Wenn man mit Hilfe eines gleichverteilten Zufallsgenerators Zufallszahlen erzeugen will die bestimmten Bedingungen genügen, kann es einfacher sein Zufallszahlen zu verwerfen die sich nicht mit einfachen Mitteln in die gewünschten Bereiche bringen lassen, als dies durch eine teure Transformation aller möglicher Zahlen zu erreichen.

Beispiel: Man kann ein Würfelereignis wie folgt implementieren:

int dice_roll(void) {
	return (int)(rand() / ((RAND_MAX + 1u) / 6)) + 1;
}

Man beachte, dass alle Ansätze welche rand() mit irgend einer Integer-Zahl multiplizieren zum Scheitern verurteilt sind da sie einen Integer-Overflow bewirken werden wenn RAND_MAX einen ähnlichen Wert wie MAX_INT hat.

Auch das Casten des Multiplikationsergebnisses nach "unsigned long" wird vermutlich nur auf 64-Bit Plattformen das Problem "lösen", denn auf 32-Bit Plattformen kann sizeof(unsigned long) == sizeof(int) sein.

Die obige Variante funktioniert hingegen auch wenn "unsigned" dasselbe ist wie "unsigned long": Denn durch die Umwandlung von "signed" nach "unsigned" vergrößert sich der erlaubte Wertebereich, so dass die Addition von RAND_MAX plus 1 danach ohne Overflow möglich selbst falls RAND_MAX == INT_MAX ist.

Um die möglicherweise teure Division zu vermeiden, kann man dies auch durch eine simplere Test-Schleife ersetzen:

static unsigned dice_shr;

void dice_init(void) {
        int mx = RAND_MAX;
        while (mx >> 1 >= 6) {
                mx >>= 1;
                ++dice_shr;
        }
}

unsigned dice_roll(void) {
        for (;;) {
		unsigned roll;
                if ((roll = rand() >> dice_shr) < 6) return roll + 1;
        }
}

Dies vermeidet zudem "long"-Arithmetik.

Allerdings macht dies natürlich nur Sinn, wenn rand() seinerseits billiger als eine Division oder Multiplikation (falls der Compiler optimiert) ist. Im obigen Fall dürfte das kaum der Fall sein. Aber wenn die Datentypen deutlich breiter als ein "int" sind, etwa bei mehrfach-genauer Arithmetik, dann vielleicht schon.
