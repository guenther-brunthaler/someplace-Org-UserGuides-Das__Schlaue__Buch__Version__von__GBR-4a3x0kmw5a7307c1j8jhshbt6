PACE:
* Acronym for "Password Authenticated Connection Establishment"
* Is based on elliptic curve cryptography
* Uses a Diffie-Hellman-like scheme, but based on EC.
* Uses low-entropy passwords of typically 6 decimal digits as a PIN.
* Is intended for electronic passports and similar authentication tokens.
* Contactless operation is aware of possible eavesdroppers or fake terminals.
* Designated successor of BAC ("Basic Access Control"), which did not provide useful security against eavesdropper.
* Intended to be secure against adversaries, both active and passive ones, who do not know the low-entropy password.
* PACE is the protocol to establish a secure communications channel between the chip card (PICC) and the (typically contactless) chip card reader terminal (PCD).
* The protocol core uses a typical DH key-exchange, requiring strong random keys from both sides; the transmitted keys are HMAC-combined with the shared known low-entropy PIN.
* Authentication of the terminal is provided by normal public key cryptography, using a two-level certificate chain: Country Verifying CA (CVCA) signing Document Verifier CA (DV) signing the PCD.
* Security concern: Eliptic Curve Cryptography is still a relatively young technique.
* Security concern: Whoever knows the private key of the DV or a CVCA can still fake or eavesdrop everything.
* How securely can the PCD obtain the secret low-entropy PIN? Likely by the same means the PICC communicates with the PDC. That is, whoever manages to get the DV's or CVCA's private key, has unrestricted power to forge or eavesdrop everything.
* In addition to the PIN which must be entered by the owner of the passport, the PICC also contains invividual cryptographic keys stored internally for fully automated authentication. As this type of authentication will also work when the PICC gets stolen, it is only provided in addition to the PIN method for low-security applications.
* It is not clear where the PIN comes from. It may be entered by the user or be read by OCR from the passport. Hopefully the first case!
* The standard does not define concrete algorithms and parameters to be used. It is only clear that some sort of ECC DH, a hash function and a MAC function will be used; likely combined with some symmetric entryption algorithm. This seems to have been a deliberate decision, allowing each country to choose its own algorithms and parameters.
* However, the use of ECC DH is dictated by the standard. Which means any weakness in ECC DH will be a single point of failure for the whole standard.
* Required interoperability with older systems could also pose a problem.
* There is no obvious reason why ECC DH has been "hardcoded" in the standard, while all the other algorithms and parameters can be choosen by each country due to its liking. (Algorithms and Parameters are described by standardized object identifiers and ASN.1 structures.)
* This creates the suspicion that ECC DH might already have been broken and is not secure. This would allow countries who know about how to exploit this fact to monitor and forge identities unrestrictedly among the participating countries.
* The fact that ECC DH was chosen over normal DH (based on the discrete log problem) and normal DH cannot even be used optionally can be interpreted in this context that normal DH might still be secure while ECC DH is not.
* Conclusion: Except for the suspicious enforcement of ECC DH for PK cryptography, PACE seems to be a secure standard.

OpenID:
* Identitäten sind URL-basiert. Zur Identitätsfeststellung muss nur eine OpenID-URL angegeben werden.
* Über die OpenID-URL erreicht man den Server eines OpenID-Providers. Dieser sitzt als Vermittler zwischen dem Inhaber der Identität und der anfragenden Stelle welche die Identität verifizieren will. Der Server des Providers erledigt dabei die ganzen technischen Aspekte der Authentifizierung.
* Typischerweise wird der Server des OpenID-Providers direkt mit dem Inhaber der Identität Kontakt aufnehmen damit dieser bestätigt dass die Feststellung der Identität auch mit seinem Einvernehmen geschieht. Der Ablauf sieht daher typischerweise so aus, dass der Anwender sich etwa mittels OpenID an einer fremden Website anmelden will. Diese delegiert nun die Identitätsfeststellung an den OpenID-Server des Inhabers, und dieser interagiert mit dem Inhaber zur Abwicklung der Feststellung.
* Ein Vorteil von OpenID ist dass jeder der sich einen OpenID-Server installiert auch sein eigener OpenID-Provider werden kann.
* Ein selbstimplementierter OpenID-Dienst kann beliebig sichere Methoden zur Feststellung der Identität implementieren - und vor allem braucht man keinerlei Passworte etc. jemals aus der Hand in die Obhut eines fremden Service-Providers zu geben.
* Die Sicherheit des Identitätsfeststellungsprozesses von OpenID kann daher beliebig hoch gewählt werden; allerdings ist die effektive Sicherheit des Verfahrens natürlich nur so sicher wie die gewählten Parameter des OpenID-Protokolls mit denen der Informationsaustausch zwischen OpenID-Server und dem externen Abfrager der Identität abgesichert wird.
* Ein OpenID-Provider kann dem Anfragenden - optional - neben der Identitätsfeststellung auch bis zu neun vordefinierte Informationen wie Name, e-Mail-Adresse des Inhabers etc. zukommen lassen. Dadurch können sich Registrationen drastisch vereinfachen; in vielen Fällen decken diese Informationen alles ab was man ansonsten in einem Web-Formular zur Account-Registration angeben müsste. Dieser Vorgang nennt sich "OpenID Simple Registration" und ist ein optionales Feature von OpenID, das die Zustimmung des Inhabers erfordert.
* Das ebenfalls die Zustimmung des Inhabers voraussetzende und neuere "OpenID Attribute Exchange"-Protokoll ist eine Weiterentwicklung des oben erwähnten "OpenID Simple Registration"-Protokolls, bei den der Server des Anfragers und der OpenID-Server einander mitteilen welche Informationen sie gerne hätten bzw. bereit stellen, so dass nur diese Daten ausgetauscht werden. Außerdem gibt es hier (vermutlich) keine Beschränkung mehr auf neun vordefinierte Datenfelder.
* Es gibt einen OpenID 2.0 Standard (seit 2007) der von einigen Websites exklusiv unterstützt wird. Andere Sites unterstützen nur den Vorgänger-Standard. Wiederum andere beides. Wenn man selbst sein eigener OpenID-Provider werden will, muss man daher entweder beide Protokolle unterstützen, oder kann nicht OpenID mit allen Service-Providern zusammen verwenden.
* Das größte praktische Problem von OpenID ist der Umstand, dass zwar viele große Websites OpenID zur Identifikation unterstützen. Aber zumeist sind diese Websites zugleich auch OpenID-Provider, und unterstützen dann nur ihre eigenen OpenID-Logins. Das macht das ganze System irgendwie für den Endandwender sinnlos da man sich dann ja erst recht wieder bei diesem Provider auf normale Weise anmelden muss. Und somit erst recht wieder Benutzername und Passwort braucht, obwohl der Sinn von OpenID eigentlich wäre dies abzuschaffen.
* Auch wenn OpenID daher in der Praxis nur geringen Nutzen für den Anwender großer kommerzieller Dienste hat, kann es intern für diese Dienste durchaus Sinn machen. Denn dann wird OpenID als Single-Sign-On für alle Dienste dieses Anbieters durch den Kunden "missbraucht". Das erspart dem Kunden zwar nichts, ist für ihn aber auch nicht aufwändiger als ein konventionelles Login. Der Dienst-Provider hingegen erspart sich Aufwand für den Datenabgleich, falls er mehrere Systeme parallel betreibt deren Passwort-Datenbanken er ohne OpenID synchronisieren müsste. So muss er nur alle Dienste OpenID-fähig machen, und installiert nur einen einzelnen OpenID-Dienst der die Accounts und Passworte tatsächlich verwaltet. In gewisser Weise wird OpenID daher in diesem Szenario funktional wie Kerberos verwendet, nur mit technisch völlig anderen Protokollen und auf eine Weise die "web-freundlicher" ist und im Gegensatz zu Kerberos beim Anwender der Dienste keine über den Web-Browser hinaus gehende installierte Software erfordert.
* Doch auch wenn große Websites OpenID typischerweise nur für Site-internes "Single Sign-On" missbrauchen, bleibt OpenID dennoch eine interessante Option zum Einsatz im eigenen Netzwerk bzw. für die Implementation anderer Web-Services, die nicht so restriktiv sind und externe OpenID-Server zulassen.
* Es gibt einige wenige Beispiele von Diensten, die auch fremde OpenID-Provider erlauben. Facebook etwa erlaubt beliebige OpenID-Provider. Freilich ist das Wort "Datenschutz" im Zusammenhang mit Facebook wohl eher eine traurige Farce. Aber immerhin.
* Andere Websites erlauben OpenID-URLs von ausgewählten Fremdanbietern. Google etwa akzeptiert Yahoo! OpenIDs für die Anmeldung. Diese Situation ist zwar geringfügig besser als als dass jeder die Verwendung seines eigenen OpenID-Providers erzwingt. Aber wirklich sinnvoll bzw. sicher sind nur OpenID-Provider die man selbst betreibt - d. h. wenn eine Website jeden OpenID-Provider akzeptiert.
* Wenn ein Website-Provider wahllos fremde OpenID-Provider akzeptiert, kann er allerdings in Konflikt mit nationalen Bestimmungen zum Datenschutz geraten die ein gewisses Schutzniveau vorschreiben. Denn in diesem Fall kann der Website-Provider nicht für die Sicherheit des eigentlichen Authentifizierungsvorganges bürgen, da er ihn ja nicht selbst durchführt sondern dies an den unbekannten OpenID-Provider delegiert. Falls letzterer kompromittiert wird, können daher unberechtigte Personen Zugriff auf die vertraulichen Daten des Account-Inhabers erlangen. Genau für solche Daten sehen manche Staaten aber besondere Sorgfaltspflichten des Website-Betreibers vor; dass er ein gewisses Schutzniveau garantieren müsse. Das ist aber unmöglich solange er dazu einem unbekannten OpenID-Provider vertrauen muss.

SRP:
* Das "Secure Remote Password"-Protocol erlaubt es, dass Client und Server einander gegenseitig verifizieren, ohne dass dazu der Vergleich von Hashes, Zertifikaten oder Fingerprints nötig sind.
* Statt dessen wird dies alles durch ein vom Client gewähltes Passwort ersetzt, und eine davon abgeleitete Datei muss am Server hinterlegt werden.
* Die alternative SSH-Implementation LSH unterstützt SRP und enthält auch ein Utility mit dem man die abgeleitete Datei (dort "Password Verifier" genannt) erzeugen kann, die man am SSH-Server hinterlegen muss.
