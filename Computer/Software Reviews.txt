00000fakeappname-1.0/nosection/nodistro/nodate: Format of THIS file: "package1-version1/section1/distro1/nodate1 package2-version2/section2/distro2/nodate2 {group1}{group2}...{group N}: Arbitrary description in as many sentences as desired." The group-tags are optional and allow to assign every package to as many logical groups as desired. This is intended to help locating related packages. Assigning the same identifier to multiple packages creates logical groups. For instance, {text-editor} might be assigned to all text editor packages, console-based ones also get tagged with {text-terminal IO}, while X11 GUI-based ones might be tagged with {Qt}. Spaces are allowed within group names, but curly braces are not. The "-version"-part is optional. The "-nodate"-part is optional. If it is present, it shall specify the date this version of the package has been reviewed or the description has been updated based on this version. The date format must be YYYY-MM-DD. There is special support for Git repositories. In this case, "nodistro" is replaced by "git", "00000fakeappname" is replaced by the last directory component of the Git URL (minus the ".git"-suffix, if any), 1.0" is replaced by the output of "git describe --tags" (if this does not work due to missing tags, manually add a tag named "0" to the initial commit and retry) with all slashes and spaces replaced by underscores, compressing runs of underscores into single underscores and removing any leading or trailing underscores, "nosection" is replaced by the URL-encoded Git URL (including the ".git"-suffix, if any).
000package-__version/__section/debian {backup}: sum of installed file sizes of package / sum including most important dependent libraries which might not always be installed ("incl." informal description of additional libraries).
0verkill/games-action/gentoo {game}: ASCII-Grafik Deathmatch-Shooter. Bringt Server und Bot mit. Jedoch: Server bindet an alle Ports; keine Einschränkung vorgesehen.
2048-qt-0.1.6-2+b1/games/debian {game}: Ein Tretris-artiges Logikrätsel, jedoch ohne zeitliche Beschränkung oder Hektik. Auf einem quadratischen Spielfeld werden Zahlen angezeigt, welche Potenzen von 2 sind. Man kann bei jedem Zug das Spielfeld in eine der 4 Haupt-Richtungen kippen, und die Zahlen rutschen an die entsprechende Kante. Wenn dabei zwei gleiche Zahlen an einander stoßen, verschwinden beide und werden durch eine neue Zahl mit ihrer Summe ersetzt. So werden die Felder wieder geleert, so ähnlich wie wenn man beim Tetris eine Reihe abbaut. Nach jedem Zug kommen aber zufällige Zahlen am Rand hinzu, so dass man mit dem Abbauen der Zahlen nicht zu lange warten darf, denn wenn kein Zug mehr möglich ist hat man verloren. Da durch die Summenbildung immer höhere Potenzen von 2 am Spielfeld entstehen können, ist es das Ziel des Spiels eine höchstmögliche Summe auf einem der Felder zu erzielen. Das theoretische Ziel ist das Erreichen der namensgebenden Summe 2048, die man praktisch aber nie erreichen wird können (behaupte ich einmal). Es gibt dieses Spiel auch als Text-Variante im Terminal, dies ist jedoch eine grafische Variante mit grafischen Animationen im hübschen Qt-Look. Ein simples Spiel, das aber trotzdem irgendwie süchtig machen kann. Nicht ganz so stark wie Tetris, dafür aber auch bedeutend weniger stressig und eine Partie dauert auch nicht länger als wenige Minuten.
3dfb/x11-misc/gentoo: Minimalistischer 3D-Filemanager mit knallig-primitiver Grafik.
3dfm/x11-misc/gentoo {file manager}{GUI}{X11}: Etwas besser aussehender 3D-Dateimanager, der alle Objekte im selben Verzeichnis ringförmig anordnet.
3proxy-0.5.3k/net-proxy/gentoo: Ein Proxy-Server mit 1,8 MB Installationsumfang. Genauer gesagt sind es mehrerer Proxy-Server in einem Paket: Ein HTTP/HTTPS-Proxy, ein FTP Proxy, ein SOCKS4/4.5/5 Proxy, ein POP3-Proxy, ein TCP Port Forwarder, ein UDP Port Forwarder, ein DNS Proxy (caching name resolver), ein Web-Server als Admin-Interface. Die Konfigurationsdatei ist eigentlich nur ein Script welche admin-Befehle enthält, die man auch über ein Console-Interface an die Proxvies schicken könnte. Die Beschreibung der Konfigurationsdatei ist übersichtlich klein in Anbetracht der vielen Features. Er ist nicht als Ersatz für Squid gedacht da er nicht cached, aber er fungiert eher als Application-Level-Firewall und Forwarder für seine diversen Protokolle. Allerdings kann man 75 % der tollen Features vermutlich mit socat eben so gut abdecken; daher ist fraglich ob dieses Paket nicht Overkill ist.
4pane-5.0-2/x11/debian {file manager}{GTK+}: Ein mittels wxWidgets/GTK+ in C++ implementierter Dateimanager mit, wie der Name schon sagt, (normalerweise) 4 Fensterbereichen. Genauer gesagt sind es wahlweise ein ("Explorer"-Manier) oder zwei ("Commander"-Manier) Teilfenster, neben oder über einander angeordnet, welche jeweils ein anderes Verzeichnis darstellen können. Jedes Teilfenster ist zwingend in einen linken und rechten Teil unterteilt. Der linke zeigt immer den Verzeichnisbaum an, und der rechte immer eine Dateiliste. Ein Highlight dieses Programms ist dass es Hard-Links erzeugen kann, und anders als beim pcmanfm lassen sich auch die Benutzergruppen-Zugehörigkeit von ausgewählten Einträgen ändern. Etwas quälend ist allerdings die träge Reaktion auf Zieh-Aktionen mit dem Mauszeiger, auch wenn es zum Glück ein visuelles Feedback gibt so dass man wenigstens mitbekommt wenn das Programm nicht auf die Mausaktionen reagiert wie es sollte. Es gibt keine verschiedenen Anzeigetypen für die Dateiliste wie in anderen Dateimanagern, sondern nur die einer detaillierten Liste mit Spalten welche ausschließlich vertikal gescrollt wird. Die Spalten sind von links nach rechts: Mini-Icon (nicht ausblendbar), Dateiname (nicht ausblendbar, immer der vollständige Name samt Dateierweiterung), Dateierweiterung (zusätzlich zu der im Dateinamen, welche nicht etwa ausgeblendet wird), Größe (mit dynamischen Einheiten wie "132B", "424,5M"), Datum/Zeit (JJJJ-MM-TT HH:MM), Zugriffsrechte (wie von "ls -l"), Besitzer, Gruppe, Symlink-Ziel (leer bei nicht-Symlinks). Bis auf die ersten beiden Spalten können alle anderen nach Belieben ein- oder ausgeblendet werden. Man kann die Dateiliste auch wie zu erwarten durch einen Klick auf den Spaltenkopf nach dieser Spalte auf- oder absteigend sortieren. Man kann auch auswählen ob Locale-basiert sortiert werden soll (oder, wie es scheint, lexikografisch nach Codepoint) und es gibt sogar eine Art "Version-Sort" wo Dezimalzahlen an Ende des Namens numerisch anstatt lexikografisch sortiert werden. Auch die Breite der Spalten kann geändert werden. Völlig unverständlich hingegen, warum jedoch nicht die Reihenfolge der Spalten änderbar ist! Immerhin kann man optional jede zweite Zeile anders einfärben, so dass die Übersicht auch bei kleiner Schriftart und breitem Fenster gewahrt bleibt. Weiters seltsam: Obwohl es ohnehin zwingend einen Dateibaum in der linken Hälfte der Teilfenster gibt, werden nichts desto trotz dennoch alle Verzeichnisse wie üblich auch in der Dateiliste angezeigt. Weiters werden Verzeichnisse in der Liste immer vor nicht-Dateien angezeigt, obwohl beide Gruppen ansonsten jede für sich den ausgewählten Sortierkriterien gemäß anordnen. Eine Besonderheit ist die Adresszeile, welche immer den vollständigen Pfadnamen der zuletzt selektierten Datei enthält - und nicht nur den Pfadnamen des dargestellten Verzeichnisses. Da dies ein editierbares Textfeld ist, ist es einfach so das Verzeichnis zu wechseln, oder Teile des Pfadnamens zu selektieren und in die Zwischenablage zu kopieren. Das Programm benutzt einen "Papierkorb", den man auch nicht abschalten kann. Immerhin kann man die Tasten redefinieren, so dass der Papierkorb dann zumindest nicht von der "Del"-Taste benutzt wird. In den Menüs gibt es sogar 3 Löschoptionen: "Normales" Löschen (in den Papierkorb), Löschen mit Umgehung des Papierkorbs, und "dauerhaftes Löschen". Letzteres bedeutet, dass die Datei sofort gelöscht wird - denn das Programm bietet ansonsten für fast alle Aktionen ein "Undo" an - daher werden zerstörende Änderungen wie Löschen normalerweise intern verzögert. Was dieses "Undo" genau bedeutet, etwa beim Überschreiben, ist mir noch unklar. Allerdings ist das Undo per Voreinstellung auf exzessiv erscheinende 10.000 Schritte konfiguriert, die man sogar bis auf 100.000 erhöhen kann. Es scheint dem Programm mit dieser irre erscheinenden Idee also zumindest ernst zu sein. Es gibt einen Menüpunkt zum Exportieren sowie Importieren der aktuellen Programm-Settings. Sehr nett um die eigenen Anpassungen auf andere Maschinen und Benutzeraccounts zu replizieren. Es handelt sich dabei sogar um harmlose INI-Dateien, nicht etwa um benutzerunfreundlichen XML-Schrott. Optional lässt sich eine Kommandozeile zuschalten welche immer unten im Fenster eingeblendet wird, Genauer gesagt handelt es sich um ein kleines Terminalfenster mit variabel einstellbarer Höhe, welches auch mehrere Zeilen anzeigen kann. Überdies ist es scrollbar. Eine Commandline-History (Cursor hoch/runter) ist eingebaut, aber scheinbar keine Tab-Completion. Auch funktioniert Job-Control scheinbar nicht. Fraglich daher wie ernsthaft man damit arbeiten kann. Das Programm gibt sich viel Mühe damit, benutzerdefinierte Werkzeuge einrichten zu können, die man dann auf selektierte Dateien oder Verzeichnisse anwenden kann. Es gibt eine aktivierbare Vorschaufunktion (nicht nur für Bilder sondern auch für diverse andere Dateitypen wie etwa Textdateien), welche ungewohnt funktioniert indem sie die Vorschau nicht im Icon anzeigt sondern nur in einer Ballon-Hilfe wenn man den Mauscursor über die Datei hält. Wie auch der pcmanfm hat 4pane die nützliche Fähigkeit, die Liste filtern zu können so dass sie beispielsweise nur Dateien mit einer bestimmten Endung anzeigt. Man kann hier auch endlich einstellen, dass keine Ordner in der Dateiliste angezeigt werden sollen - was mir sehr sinnvoll scheint. Obwohl - in der Baumanzeige sind die Ordner immer nur nach Namen sortiert. Während die in der Listenanzeige immer nach einer der Spalten sortiert sind. Etwas ärgerlich ist dass es nur einen Satz Spalteneinstellungen gibt, obwohl horizontale und vertikale Anordnung der Teilfenster völlig andere Fensterbreiten zur Folge haben und man dann jedes Mal erneut manuell die Spaltebreiten anpassen muss. Weiters gibt es keine Funktion allen Teilfenstern gleiche Breite oder Höhe zu geben. Man muss die Fensterteilung manuell vornehmen, so dass es kaum gelingt sie pixelgenau gleich breit oder hoch zu machen. Und anders als beim Krusader wird die aktuelle Breite einer Fensterhälfte während des Änderns auch nicht als Prozentwert angezeigt. Es können beliebig viele Tabs erzeugt werden, die auch einfach umbenannt werden können (standardmäßig haben sie die eher wertlosen Namen "Page 1", "Page 2" usw. und sind nicht etwa automatisch nach ihrem Directory benannt). Man hat sich scheinbar auch viel Mühe bei der Implementierung des Einhängens/Aushängens von Geräten gemacht. Es gibt dazu mehrere Methoden zur Auswahl, wie udev, mtab oder "Supermount". Man kann auch wählen ob Geräte automatisch eingehängt werden soll, oder welche bzw. welche nicht. Leider kann man dem Programm offenbar nicht austreiben zumindest alle 250 Sekunden auf neue Laufwerke zu scannen (per Default sogar alle paar Sekunden). Das klingt in Summe nach viel unnötiger Systembelastung, vor allem wenn der Dateimanager ständig läuft. Man kann festlegen ob das Anzeigen versteckter Daten standardmäßig erfolgen soll; umschalten kann man es jederzeit. Lesezeichen gibt es auch. Es gibt ein eigenes Menü für den Umgang mit gepackten Archiven, sowie ein virtuelles Dateisystem welches den Inhalt des Archivs wie eine Unterverzeichnis-Struktur anzeigt. Der übliche "Öffnen mit..."-Menüpunkt ist vorhanden und sogar mächtig aber unnötig kompliziert, da immer ein separates Dialogfenster geöffnet wird. Eine schnelle Auswahl der häufigst genutzten Applikationen zum Öffnen fehlt. Es bleibt ein gemischter Eindruck: Teils sehr mächtig, teils aber sehr eingeschränkt in den Anpassungsmöglichkeiten (etwa die unveränderbare Spaltenreihenfolge). Allgemein scheint dieser Dateimanager darauf ausgerichtet zu sein, in einem möglichst großen Fenster mit eher kleiner Schrift zu arbeiten. Zweifellos ist er gut geeignet zum Umgang mit Dateien welche lange Namen haben. Wenn man alle ausblendbaren Spalten ausblendet, sieht er ähnlich wie die Listenansicht von pcmanfm aus, hat dabei aber immer noch den Vorteil alternierender Zeilen-Einfärbungen. Und vor allem scrollt er immer noch vertikal, und nicht etwa schwachsinnig horizontal wie der pcmanfm in dieser Darstellungsart! Aufgrund seiner wxWidgets-Wurzeln ist das Programm nicht sonderlich ressourceneffizient - es braucht zwischen 2- und 3-fach so viel RAM wie der pcmanfm, und schlägt sogar noch den bereits ziemlich fetten Krusader (wenn auch nicht mehr um viel). Für minimalistische Systeme mit wenig RAM daher vermutlich nur bedingt sinnvoll. Auf "normalen" Desktop-Geräten aber sicherlich kein Problem.
KNOPPIX_V8.1-2017-09-05-DE.iso.xz/live-system/knoppix {linux distribution}: Ein Linux 4.12 basiertes Live-DVD Dateisystemabbild für x86 PCs. Läuft im RAM und benötigt keinen Schreibzugriff. Kann einen PXE-Server für das Booten anderer Rechner direkt über das Netzwerk (etwa Diskless Clients) starten. Enthält einen Installer um einen bootfähigen USB-Stick mit demselben Nutzinhalt wie die DVD zu erzeugen. Enthält auch einen Installer, um ein Linux-System auf eine Festplatte zu installieren. Dies funktionierte bei mir im Test allerdings nicht, er meckerte ständig dass er keine "geeignete" Festplatte finden könnte und zuwenig Swap vorhanden wäre, obwohl beides in der geforderten Größe vorhanden war. Jedoch las ich, dass eine solche Installation ohnehin kein Knoppix-System installiert hätte, sondern ein "mehr-oder-weniger normales" Debian-System ("entpacktes Knoppix"), bei dem man in der Praxis aber jede Menge Ärger mit Updates und Paketquellen habe. Es wurde empfohlen, die Finger von dieser Option zu lassen, außer das System soll nur kurzfristig existieren und braucht daher nicht aktualisiert zu werden. Die Oberfläche dieser Knoppix-Version basiert auf LXDE. Dennoch sind viele KDE-Programme enthalten, etwa Kmail und der KDE-Kalender. Ebenso GNOME-Programme. Natürlich auch LibreOffice, Firefox, Chromium, Konqueror, Thunderbird, Claws Mail und ein buntes Sammelsurium weiterer mehr oder auch weniger nützlicher Programme. Einige Highlights: TeXmaker/Kile, Evolution Mail, Okular, Zeiterfassung, Blender, Dia, GIMP, Inkscape, Scribus, xfig, OpenSCAD (schlankes 3D CAD-Programm mit Split-View Quelltext und Render-Darstellung mit steuerbarer Ansicht), FreeCAD (supertoll + -fett), GwenView, XSane, Mumble, Ekiga-Softphon, Linphone, Bitcoin Wallet, Ktorrent, Wireshark, PuTTY, TOR-Proxy und TOR-Browser, PcManFM, Midnight Commander, Dolphin, Krusader, Homebank, Amarok, Audacity, Cheese, Kino, Kdenlive, OpenShot, ffmpeg GUI, StopMotion, mehrere Mediaplayer inklusive SMplayer und VLC, Me TV, Ebook Speaker, Disc Ripper und Brennprogramme, KeePassX, Kleopatra PGP/GPG GUI, Desktop Recorder, WINE, ClamAV, DOSBOX MS-DOS PC Emulator, etliche Spiele (nicht nur Rätsel- sondern auch ein paar Ballerspiele und FreeCiv), Wecker, Taschenrechner, Kwrite, Leafpad, Okteta Hex-Editor. Dazu auch beliebte Commandline-Tools wie htop, screen, ImageMagick, nmap, encfs. Server-Dienste: SSH, apache2, PHP 7.0, Squid, OwnCloud Sync Client, spamassassin, bluetooth, CUPS, Wi-Fi Hotspot, OpeniSCSI, NFS, MySQL, xrdp, timidity, tftp, NTP, OpenVPN, SAMBA, gpm, avahi. Admin-Tools: LVM2, kexec, mdadm, rsync, debootstrap. Es fällt auf, dass viele Werkzeuge zur Software-Entwicklung enthalten sind: Die wichtigsten Compiler (C, C++, JAVA), gdb, Python 2+3, Perl/Tk 5.26, TCL/Tk 8.6, Debian build-essential, git, CVS, SQLite3, HSQL, Autotools, JRE, JDK, ANT, phpMyAdmin, Android Debug Bridge, kompletter Kernel Source Code, DKMS, sogar die Eclipse-IDE (allerdings nur deren Core-Komponenten die für alles externe Build-Tools verwenden die man dazu einrichten muss). Weiters Editoren (gVIM, Emacs, BlueFish HTML/PHP Editor, Geany, Qt4/5 Designer), DDD, Valgrind, Umbrello UML Modeler. Leider hat Knoppix Probleme unter dem VNC-Server von KVM zu laufen; der virtuelle Mauszeiger stimmt nicht mit dem realen überein und man klickt ständig daneben. Die SDL-Console von KVM funktioniert allerdings problemlos. Ein grundsätzlicher Vorteil von Knoppix - für deutschsprachige Benutzer - ist, dass per Vorgabe alles auf Deutsch eingestellt ist, inklusive Tastaturbelegung. Ein Problem hat Knoppix allerdings mit der Pesistenz der Daten. Die Live-DVD unterstützt dies überhaupt nicht. Man muss Knoppix erst auf einen USB-Stick installieren, wo man dann ein zusätzliches Overlay für die zu sichernden Anpassungen bzw. Benutzerdaten anlegen kann. Hierfür wird ein 8 GB USB-Stick empfohlen.
Panotools-Script-0.260.0/dev-perl/gentoo: Diverse Tools für Panormabilder. Die wichtigste Funktion (für mich): Kann von Hugin erzeugte Panorama-TIFF-Dateien in QtVR .mov Dateien umwandeln, und auch wieder retour in die Gegenrichtung.
XML-XSH2-2.1.6-r1/app-editors/gentoo: Eine XML/HTML Editing Shell. Irgendwie witzig: Das (in Perl geschriebene) Programm verhält sich ähnlich wie eine UNIX-Shell, und man kann in den (aus Dateien oder URLs) geladenen XML/HTML-Dokumenten navigieren wie im Dateisystem. Knoten des DOM-Baumes können dabei auch modifiziert oder komplett neu erstellt werden. Kann auch mehrere Dokumente gleichzeitig laden. Unterstützt auch die Validierung anhand einer DTD. Nachteil: Das Dokument muss während der Bearbeitung komplett im Speicher gehalten werden, und ist dabei vermutlich auch noch als notorisch speicher-ineffiziente Perl-Datenstrukturen abgelegt. Andererseits sollte das nur bei extrem großen Eingabedateien ein Problem sein.
abduco-0.1-2/utils/raspbian {terminal multiplexer}: Terminal multiplexer. It seems to be very similar to dtach, but is about 50 % larger. I cannot see any clear advantage over dtach, except maybe that abduco may be newer and more actively maintained. On the other hand, as of 2024 abduco is only available under Rasbian but not yet under Debian. While dtach is already available for both. A possible explanation for this might be Debian bug entry #771102 where the dtach author claims the abduco author has illegally copied significant parts of the dtach code, because the free licences of both programs are conflicting.
abe/games-arcade/gentoo {game}: Ugly, childish graphics platform game
abiword-2.4.6/app-office/gentoo: Durchaus brauchbares Textverarbeitungsprogramm mit allen wesentlichen Features, aber ohne den Overhead der großen Office-Pakete. Kann auch das OpenDocument-Format lesen und schreiben - jedoch kommt es beim Import/Export unweigerlich zu Formatierungsverlusten gegenüber OpenOffice, da Abiword natürlich nicht alle Features von OOo hat. Für sich allein genommen ist Abiword aber eine für nahezu alle Zwecke vollkommen ausreichende Textverarbeitung. Beherrscht auch PDF-Export und -Import. Abiword beherrscht auch eine simple Serienbrief-Funktion, welche allerdings von der Kommandozeile aus ausgeführt werden muss und die einzusetzenden Feldinhalte aus einer CSV-Datei liest. Sehr script-freundlich! Leider unterstützt es Abiword nicht, anklickbare (externe oder dokument-interne) Hyperlinks in erzeugten PDF-Dateien unterzubringen.
accessx/x11-misc/gentoo: Allows to edit various keyboard typing rates, but not more. Especially not editing the keymap.
adanaxisgpl-1.2.5.dfsg.1-6/games/devuan {game}: Ein 4D-Shooter. Bringt ein tolles Tutorial mit welches alles ganz einfach erklärt, und in dem man vor Weltraum-Hintergründen (eigentlich nur vereinzelte Bilder irgendwelcher Nebel und Galaxien und viel schwarz dazwischen) auf wokenähnliche Gebilde ballert. In einem schönen PDF ist es noch einmal in Detail erläutert. Es half nichts. Ich habe *keine Ahnung* wie das Zielen funktioniert. Noch dazu waren die Ziele immer winzig klein, so dass man die komischen 3 Kugeln welche sozusagen das 4D Kimme-und-Korn darstellen sollen kaum erkennen konnte. Sicher ein ganz ein tolles Spiel, aber da ich trotz aller Anleitung weder die Steuerung noch das Zielen begriff, war es für mich leider nur in fader Dreck. Aber wenigstens hat es eine ganz stimmige Sound-Untermalung. Und Leute welche sich gerne das Gehirn zersprageln wollen um herauszufinden wie Spiel tatsächlich zu spielen geht, könnten eine Menge Freude damit haben.
afflib-tools-3.7.19-1/utils/raspbian: Kommandozeilen-Utilities für den Umgang mit dem "Advanced Forensic Format" ("AFF"). Dieses Format erlaubt es, sowohl den Inhalt als auch forensische Metadaten eines zu analysierenden Datenträgers in (optional komprimierten) AFF-Dateien zu speichern. Diese werden auch kryptografisch signiert werden um nachträgliche Manipulationen zu erkennen. Die Signaturen verwenden Zertifikate und Private Keys in X.509 Format, wie auch OpenSSL sie verwendet. Die Utilities unterstützen sowohl RAW-Datenträger-Abbilder als auch mehrere Abbild-Formate von System-Emulatoren wie VMware. Die mitgespeicherten Metadaten umfassen unter anderem separate SHA-1 und MD5 Hashes, Archivformat-Information, beschädigte Sektoren, Archiv-UUID. Jedes AFF-Archiv enthält neben den diversen benannten Metadaten-Einträgen immer nur ein einziges Datenträger-Abbild. Die forensischen Daten eines Datenträgers können entweder in einer einzigen AFF-Datei gespeichert werden, oder als Directory *.afd welches mehrere zusammengehörige (automatisch nummerierte) AFF-Dateien "file_000.aff", "file_001.aff" usw. enthält. (Damit könnte man z. B. Archive größer als 4 GiB auf FAT-Dateisystemen ablegen.) Es handelt sich bei AFF also um ein digital signiertes Multivolume-Archivformat das geeignet ist auch sehr große binäre Dateien als Archiv-Einträge zu speichern. "affcat" extrahiert Dateien oder Teile (Pages, Sektoren oder Byte-Bereiche) von Dateien aus einem AFF-Archiv. Weiters kann es die vorhandenen Archiv-Einträge auflisten. Pages sind logische Verwaltungseinheiten innerhalb von AFF-Einträgen und per Default 16 MiB groß. Die Kompression erfolgt immer nur für einzelne Pages. "affcompare" vergleicht zwei AFF-Archive mit optionaler Unterstützung vom Amazon S3 als Ablageort. Es kann auch rekursiv Verzeichnisse mit AFF-Dateien vergleichen. "affconvert" konvertiert zwischen komprimiertem AFF- und unkomprimiertem RAW-Format (simple binäre Blockgerät-Abbilddatei). Wählbare Komprimierungstärke. Neben dem Default-Algorithmus kann auch die bessere jedoch langsamere LZMA-Komprimierung ausgewählt werden. "affcopy" kopiert den Inhalt einer AFF-Datei in eine andere. Kopierte Einträge können dabei optional neu komprimiert werden können, normalerweise für stärkere Kompression. Man kann sich aussuchen ob bereits bestehende Einträge überschrieben werden sollen, oder nur fehlende Einträge in die Zieldatei kopiert werden sollen. Beim Kopiervorgang werden alle Hashes und etwaige Signaturen verglichen, und die Zieldatei kann optional neu signiert werden. "affcrypto" ver- oder entschlüsselt Einträge von AFF-Archiven außer jene welche selbst Signaturen darstellen. Es kann zwischen symmetrischer und asymmetrischer Verschlüsselung gewählt werden. Vermutlich basiert dies alles auf den Algorithmen von libopenssl. Interessanter Weise kann man die verwendeten Algorithmen zwar anzeigen lassen, nicht jedoch festlegen. "affdiskprint" gibt eine XML-Datei mit SHA-1 und SHA-256 Hashes über die einzelnen Datenblöcke in einem AFF-Archiv aus. Es kann diese Ausgabe auch mit einem Archiv vergleichen. Die Dateblöcke scheinen meist 64 KiB groß zu sein, einige sind jedoch auch 128 KiB groß. Es ist unklar ob sich diese Hashes auf die AFF-Datei selbst beziehen oder nur auf das enthaltene Datenträger-Abbild. Ich vermute, letzteres. "affinfo" zeigt allgemeine Angaben wie UUID und Inhalts-Hashes einer AFF-Datei an. Kann auch die Prüfsummen verifizieren und gefundene Abweichungen anzeigen. Ebenso kann eine Liste der Archiveinträge der Ausgabe hinzu gefügt werden. "affix" repariert ein korrumpiertes AFF-Archiv. Vermutlich indem Einträge mit fehlerhaften Prüfsummen entfernt werden, und fehlende erforderliche Metadaten neu erstellt werden. "affrecover" kann einzelne beschädigte "Pages" in AFF-Archiven mittels nicht näher erläuterter "Parity Bits" wiederherstellen. Es bleibt unklar wie umfangreich die Fehlkorrektur-Fähigkeiten dieser Parity Bits sind. Angeblich kann dazu eine "Parity Page" irgendwie von "affsign" erzeugt werden. Demzufolge könnte exakt eine einzige beschädige Page im Archiv repariert werden. "affsegment" kann benannte AFF-Einträge, "segments" genannt, neu erstellen, anzeigen oder ausgeben. Segmente welche Dateisystem-Abbilder oder Signaturen darstellen werden mit anderen Utilities als diesem manipuliert. "affsign" signiert bestehende AFF-Dateien neu oder erstmals. Weiters kann es auf nicht näher erläuterte Weise (immer?) eine Parity Page für "affrecover" erzeugen. "affstats" zeigt diverse Statistiken über AFF-Dateien an. Diese werden aus Metadaten entnommen falls vorhanden, oder andernfalls neu berechnet. "affuse" mountet AFF-Dateien oder Multi-Volumes als FUSE-basiertes Pseudodateisystem, wo das im Archiv enthaltene Datenträger-Abbild als (vermutlich nur read-only-) Pseudodatei zur Verfügung steht. Man kann damit auch wenn die einzelnen AFF-Dateien nur Teile der Abbild-Dateien speichern dennoch auf die komplette Abbilddatei zugreifen. "affverify" verifiziert alle Hashes und Signaturen in AFF-Dateien. "affxml" gibt ähnlich wie "affinfo" Inhaltsinformationen eines AFF-Archivs aus, jedoch im XML-Format um die Ausgabe einfacher maschinell weiter verarbeiten zu können. Die Ausgabe kann optional auf bestimmte benannte Einträge beschränkt werden.
afl-1.57b/app-forensics/gentoo: Ein Fuzzer, der auf spezielle Features von gcc-4.8+ oder LLVM zurück greift, um den Code fürs Fuzzing zu instrumentieren. Dieser Fuzzer basiert darauf zu erkennen ob durch neue Eingaben neue Codepfade im Programm durchlaufen werden, und erkennt die möglichen Eingaben dadurch von selbst. Man erspart sich dadurch viel Aufwand bei der Definition der möglichen Eingabedaten, was man bei den meisten anderen Fuzzern nötig ist. In Kombination mit der "-fsanitze=address"-Option der oben genannten C-Compiler (oder dem noch mächtigeren aber auch langsameren valgrind) können so viele Speicher- und Addressfehler in einem Programm gefunden werden, die man normalerweise nie entdecken würde.
afterstep-2.2.2-r1/x11-wm/gentoo {window manager}{GUI}{X11}: Replaces personal GTK+ settings files without asking. Also it stuffs loads of fat icons over the client windows contents by default.
afuse-0.4.1-1/utils/debian {FUSE}: Ein FUSE-basierter Automounter. Man definiert dabei beim Mounten einfach andere Kommandos, die zum Mounten und Unmounten des automatisch zu mountenden "eigentlichen" Dateisystems verwendet werden sollen. Sobald man auf den Inhalt des Mount-Points zugreift, wird das darunter liegende Dateisystem tatsächlich gemountet falls dies noch nicht der Fall ist. Umgekehrt kann das darunter liegende Dateisystem nach einer gewissen Zeit der Nichtbenutzung auch wieder automatisch ungemountet werden. Nützlich primär für Netzwerk-Dateisysteme, aber auch für selten benutzte lokale Dateisysteme welche man um Ressourcen zu sparen nicht andauernd gemountet lassen möchte.
agg-2.5/x11-libs/gentoo {graphics drawing}: Cross-Platform C++ Library für Anti-Aliased 2D-Grafikoperationen. Unterstützt auch Sub-Pixel Auflösung. Setzt stark auf C++ Templates. Mächtig, effizient, aber auch komplex und eher nicht so toll dokumentiert, was mehr Aufwand bei der Einarbeitung erfordert. Ansonsten sehr ähnlich zu x11-libs/cairo. Leider steht es unter der GPL und nicht unter der LGPL, was den Einsatz auf OpenSource-Projekte beschränkt. Das erklärt vermutlich auch die geringe Verbreitung trotz guter Leistung. Wer hofft dass AGG anders als Cairo vielleicht auf Integer-Berechnungen basieren könnte und auf Geräten ohne FPU daher schneller wäre, irrt. Wegen der Template-Typen merkt man das zwar nicht eben so deutlich, aber auch AGG benutzt intern primär Fließkomma-Arithmetik. Dies lässt sich aber vermutlich auch wegen der Subpixel-Auflösung kaum vermeiden.
aha-0.5-1/utils/debian: Erzeugt HTML-Quelltext aus Text welcher ANSI-Terminal-Sequenzen für Farbsteuerzeichen enthält. Man kann damit beispielsweise die Ausgabe von "colordiff" in HTML umwandeln. Oder aufgezeichnete typescripts nach HTML wandeln.
airstrike-0.99+1.0pre6a-8/games/devuan {game}: auf einem einzelnen Bildschirm tut sich recht viel: Kanonen ballern, Hindernisse fliegen herum, und man steuert eines von zwei winzigen Flugzeugen welche das andere abballern soll. Alles ohne Scrollen am selben Bildschirm! Ich wurde mit der Steuerung irgendwie nicht warm. Vielleicht hätte mehr Übung geholfen, aber das Spiel faszinierte mich dazu nicht genug. Ca. 2,5 MB Installationsumfang.
akregator/kde-base/gentoo: So ähnlich wie ein USENET Newreader, aber für RSS Feeds. Allerdings verwaltet dieses Programm für die meisten Nachrichten nur die Headlines und bestenfalls den Anfang des Textinhaltes. Zum detaillierteren Ansehen wird entweder ein externer Web-Browser gestartet, oder mit dem Konqueror in einem neuen Tab gelesen. Ein nettes Programm. Nachteil: Immer wenn man einen Link mit dem externen Browser öffnet, schaltet sich das Fenster um.
alarm-clock-1.2.5-1.2/utils/debian {reminder}: Wäre im Prinzip nett, wenn es denn nur fehlerfrei funktionieren würde. Das Problem: Sobald man den Wecker zum Traybar-Icon minimiert hat und wieder öffnen möchte, erscheint nur ein komplett leeres Fenster mit grauem Hintergrund. Es ist unklar ob dies Auswirkungen auf die Funktion bestehender Alarme hat, auch kann man neue ohne dieses Fenster hinzu fügen. Ab das Bearbeiten bestehender Alarme ist so nicht möglich. Ein Beenden und Neustarten der Applikation behebt die Probleme; die Alarme bleiben erhalten. Bis zum nächsten Minimieren. Vermutlich nur ein lächerlicher Bug, aber bis er behoben wird bleibt die Applikation praktisch unbenutzbar.
alarm-clock-applet-0.3.3-1/gnome/debian {reminder}: Wecker-Applikation, welche sich automatisch im Traybar andockt. Man kann beliebig viele Alarme in einem Listenfeld erstellen. Die Alarmzeit kann eingestellt werden, jedoch kein Datum - es gilt immer der aktuelle Tag für einen einmaligen Alarm. Alternativ kann man in einer Liste der Wochentage diejenigen selektieren, an denen der Alarm wiederholend erfolgen soll. Erledigte Alarme werden nicht aus der Liste gelöscht sondern nur deaktiviert. Man kann sie jederzeit wieder reaktivieren - oder löschen. Alles was man zu einem Alarm eingeben kann, ist ein einzeiliger Text. Dabei kann entweder ein Alarmton abgespielt werden oder ein benutzerdefinierter Befehl ausgeführt werden. Zwar wird auch eine Sprechblase angezeigt, doch verschwindet diese nach einigen Sekunden. Da es keine einfache Möglichkeit gibt, einen Dialog anzuzeigen den man erst bestätigen muss, ist es möglich einen Alarm zu übersehen wenn man nicht gerade beim Gerät war. Der einzige Hinweise auf den vergangenen Alarm ist dann die Farbe des Wecker-Symbols welche sich (leider nicht besonders auffällig) ändert. Der Wecker besitzt auch einen "Stoppuhr"-Modus, wo man statt einer Alarm-Zeit die Dauer des Countdowns angibt.
alienblaster-1.1.0-7/games/debian {game}: A 2D downwards scroller shoot'em up. Nice enough on faster processors, but the Raspberry Pi is too slow for scrolling smoothly even in a smaller window.
alltray-0.71b-1+b2/x11/devuan {desktop panel}: Erlaubt es, dass auch Programme welche überhaupt nicht dafür geschrieben wurden, sich in den Traybar zu docken können als hätten sie entsprechenden Support. Das ist vor allem sinnvoll für Programme die ständig laufen müssen, von denen man aber nicht will dass sie die Taskleiste ständig mit einem Eintrag "verseuchen". De facto minimiert alltray also ein Fenster in den Traybar anstatt in die Taskleiste. Hängt leider von einigen fetten GTK-Libraries ab und benötigt auch noch den gconf-service. Besonders ressourcensparend dürfte es daher wohl eher nicht sein. Auf der anderen Seite ist die Chance hoch dass ohnehin bereits eine andere Anwendung dieselben GTK-Libraries benutzt, und sie daher mitbenutzt werden können.
alsamixergui-0.9.0rc2-1-10+b1/sound/debian {audio}{GUI}{X11}: Ein grafisches Mixer-GUI für ALSA. Mit FLTK implementiert. Vermutlich ressourcenschonender als qasmixer, jedoch auch hässlicher. Nachteil: Es werden keine numerischen Werte der Slider-Positionen angezeigt. Außerdem bietet der Mixer eine Integration in den Traybar. Bei 47 MB RAM-Verbrauch ist es allerdings vermutlich nicht die beste Idee, das Programm längerfristig im Traybar zu belassen.
amor/kde-base/gentoo: Ought-to-be funny/cute creature for the KDE desktop. Unfortunataly, it does not do much. At least on my desktop, it constantly falls off the edge of some toolbars and dies. But even while alive, it does not do much, let alone something exceptionally cute or funny. IMHO, a totally unnecessary waste of resources, not worth the installation.
ansible-2.7.7+dfsg-1/admin/debian {configuration management}: Ein in Python3 implementiertes System zum Definieren, verteilen und anwenden von Software-Konfiguration. Gehört mittlerweile Red Hat. Ansible selbst läuft nur auf einem Server. Die Clients werden mittels SSH oder RDP angesteuert und "Playbooks" (Ansible-Konfigurationsdateien bestehend aus je einem Python-Script und einer YAML-Datei) werden dorthin repliziert und ausgeführt. Dadurch ist auf den Client-Rechnern keine spezielle Client-Software für Ansible vonnöten, außer natürlich ein SSH/RDP-Client und eine Python-Installation. Es gibt eine große Community mit vielen fertigen Playbooks - doch vermutlich nur für systemd-Systeme geeignet. Ein Python-API ermöglicht die Entwicklung eigener Scripts. Nachteil: Kein Reporting enthalten, und SSH ist langsamer als andere Lösungen mit separaten Client-Agenten.
antlr-2.7.7+dfsg-7/devel/debian {parser/lexer-generator}{code-generator}: Antlr ist ein Parser-Generator. Über *diese* Version schweigen wir einmal lieber vornehm, denn die ganzen Beispiele auf der Webseite funktionieren erst ab Version 3. In jener ist die Grammatik-Deklaration im Großen und Ganzen sehr ähnlich dem was man von yacc oder bison kennt, nur dass als Ergebnis JAVA-Quelltexte erzeugt werden. (C++ geht angeblich auch irgendwie.) Mir ist etwas unklar warum so viele Leute von antrl so besonders begeistert zu sein scheinen. Ich konnte auf den ersten Blick keine herausragenden Vorteile gegenüber den unzähligen anderen Parser-Generatoren erkennen. Zumal das Teil in JAVA geschrieben ist und entsprechend "gemütlich" startet. Da überzeugt mich devel/lemon schon wesentlich mehr!
apcalc-2.12.4.4-3/math/debian {calculator}{text-terminal IO}: Original unter dem Namen "calc" bekannt (auch das Executable heißt so), handelt es sich um einen Textmodus-Taschenrechner mit beliebig einstellbarer Genauigkeit - genau wie "bc". Ein Vorteil von calc gegenüber bc ist es jedoch, dass calc mit rationaler statt nur mehrfachgenauer Arithmetik arbeitet. Auf diese Weise kann es auch mit "unendlichen Brüchen" oftmals exakt rechnen, für die jedwede Rechengenauigkeit nicht groß genug wäre wenn sie als Fließkommazahl dargestellen würde. Gegenüber bc hat er mehr vordefinierte Funktionen und eine eingebaue Hilfe sowie readline-Support von Haus aus. Weitere Unterschiede gegenüber bc sind Matrixbefehle, die Unterstützung komplexer Zahlen und Listen/Arrays. Genau wie bc kann calc benutzerdefinierte Funktionen in einer C-ähnlichen Syntax interpretieren. Dafür ist calc aber 8-10 mal so groß (rund 4 MB) wie bc und somit sogar größer als das CAS-System yacas das weitaus mehr kann.
app-arch/brotli-1.1.0/gentoo {runtime utility library}{compression}: Ein für HTML und HTTP optimierter Kompressor. Wird von allen großen Browsern unterstützt. Arbeitet ähnlich wie gzip, jedoch mit einem zusätzlichen fix vordefinierten Dictionary, welches gebräuchliche Worte aus Webseiten enthält. Außerdem algorithmische Detail-Verbesserungen gegenüber gzip. Daher vergleichbar schnell wie gzip, kann aber sehr kleine Dateien oft besser komprimieren.
apt-file-3.1.4/admin/debian: Ein super-nützliches Administrationswerkzeug. Erlaubt es ähnlich wie mit "dpkg" nach Dateien zu suchen um herauszufinden in welchen Paketen sie enthalten sind, oder den Inhalt von Paketen aufzulisten. Jedoch geschieht dies nicht nur für tatsächlich installierte Pakete, sondern auch für noch nicht installierte! Man kann daher wenn einem ein Hilfsprogramm oder sonstige benötigte Datei fehlt ermitteln, welches Paket man dazu installieren müsste. Dazu muss allerdings ähnlich wie bei "apt-get update" eine große Datenbank (35 MB per Stand 2017-08) heruntergeladen werden welche die erforderlichen Informationen enthält.
aptfs-2 {FUSE}: 0.13.1-1/utils/debian: Ein Pseudeodateisystem, welches hinter den Kulissen automatisch "apt-get source" aufruft um die Quelltexte von Debian-Paketen herunter zu laden und zu entpacken so dass man sie bauen kann ohne das Kommando manuell aufzurufen. Weiters entfernt es die entpackten Verzeichnisse später wieder, so dass man sich auch dies ersparen kann. Wohl nur dann sinnvoll wenn man sehr häufig .deb-Pakete selbst erzeugt. Für normale User daher eher sinnlos.
archivemount-0.8.7-1/utils/debian {FUSE}{compression}: Ein weiteres FUSE-Dateisystem, welches Archive mounten kann als wären sie eine Ordnerstruktur mit Dateien. Es unterstützt die folgenden Archivformate: Mehrere Varianten von "tar" bzw. "pax" (darunter alle relevanten), mehrere Varianten von "cpio"-Archiven, ISO-9660 Abbild-Dateien (mit und ohne RockRidge Erweiterungen), ZIP-Datien, zwei Arten von "shar"-Archiven. Aufgrund der nur geringen Überscheidung scheint es eine gute Ergänzung zu utils/avfs zu sein.
archlinux-wallpaper 1.4-2/community/archlinux: Hintergrundbilder für den Desktop mit Arch Linux Log. Problem: Mit wenigen Ausnahmen sind sie alle schlecht, und selbst die Ausnahmen sind nichtssagend. Die Bilder bestehen alle nicht aus Fotos, und die meisten bestehen nur aus gekachelt wiederholten simplen Mustern, welche durch irgendwelche Postprocessing-Filter "verbessert" wurden. So etwa der "Analog TV"-Effekt. Wow... Außerdem sind die meisten Bilder auch noch Gedithert... als hätte man kein 24-Bit Echtfarben-Display sondern nur 16-Bit Hi-Color. Oder gar nur 256 Farben? Sieht jedenfalls eher schwach aus. Ein wertloses Paket, außer man besitzt tatsächlich überhaupt keine eigenen, besseren Hintergrundbilder.
ark-4: 4.14.2-2+deb8u1/utils/devuan: Der native Archiv-Manager der KDE-Oberfläche. Unterstützt alle wichtigen Formate für gepackte Archive. Taugt meiner Meinung nach nichts, da er trotz hübscher Qt-basierter Oberfläche viel zu umständlich zu bedienen ist. Einige grundlegenden Funktionen die man sich im Umgang mit Archiven erwartet scheinen sogar komplett zu fehlen (oder sind so "gut versteckt" dass ich sie nicht fand).
armagetronad-0.2.8.3.4-1/games/devuan {game}: Nettes TRON-Spiel in 3D. Alleine oder gegen andere Spieler. Auch nicht besonders groß. Allerdings doch etwas geistlos nach längerem Spielen.
arx-libertatis-1.1.2/games-rpg/gentoo {game}: Ein scheinbar wirklich nett gemachtes Role-Playing-Game, wo man in First-Person Manier durch die Gegend adventured. Benötigt die (kostenpflichtig oder illegal erhältlichen) originalen Level-Dateien des kommerziellen Spiels "Arx Fatalis": Es wäre alles wunderbar... wenn dieses Drecksspiel nicht (2015-05) in paar Sekunden bis maximal wenige Minuten nach dem Start des eigentlichen Spiels mit einem illegalen Speicherzugriff verrecken würde. Empfehlung: In einem Jahr oder so noch einmal ausprobieren.
asciidoc-8.5.3/app-text/gentoo {text-formatting}: Ein Tool, das aus reinen Text-Dokumenten eine Vielzahl anderer "wohlformatierter" Dokumentformate erzeugen kann. Dazu wird möglichst "natürlich" und nicht-intrusiv wirkende Syntax as Markup verwendet. Asciidoc ist ein direkter Konkurrent zum "ReStructuredText" ("reST") von Python (dev-python/docutils), und ist selbst ebenso wie dieses in Python implementiert. Es ist schwer einen deutlichen Vor- und Nachteil des einen oder anderen Systems auszumachen; beide haben Vor- und Nachteile. Asciidoc hat etwas störende Syntax-Elemente, wie dass man unterstrichene Überschriften direkt ohne Leerzeilen an Absätze "kleben" muss, und es verwendet teilweise seltsame Zeichen wie Tilden als Unterstreichungszeichen. Diese Dinge sind be reST besser, aber dafür hat reST teils sehr eigentümliche Syntax für Dinge wie Hyperlinks und verwendet auch unschöne Dinge wie doppelte Back-Quotes, Underscores am Ende von Tokens. Dafür hat es eine recht ansprechende Syntax für Tabellen. Asciidoc erlaubt es dafür bei Tabellen mehr Parameter anzugeben, wie etwa Breite in % usw. reST ist primär dafür gedacht ein einziges Textdokument (oder sogar nur einen einzelnen Docstring) als Dokumenten-Einheit zu haben, während Asciidoc auch Befehle zum inkludieren andere Quelldateien, bedingte Interpretation usw. mitbringt. Allgemein habe ich den Eindruck, dass Asciidoc um einiges mächtiger ist, mehr Ausgabeformate und Plugins (etwa für Notendruck) unterstützt, und mehr nach "normalem Text" aussieht als reST wenn man diese Features auch nützt. Bei simplerem Markup macht hingegen reST einen besseren Eindruck. Ein komplettes Buch würde ich daher eher mit Asciidoc schreiben, eine kürzere Dokumentation oder ein Wiki eher mit reST. Auch die Lernkurve ist nicht zu unterschätzen - Asciidoc ist ein komplexes Tool mit entsprechend langer Anleitung; die Anleitung zur reST-Syntax ist zwar auch nicht gerade klein, aber doch um einiges kürzer. Mein Vorschlag: reST verwenden wo man die zusätzlichen Features von Asciidoc nicht braucht. Was die Leserlichkeit bei den "simplen" Features angeht, ist Asciidoc bei Hyperlinks besser und reST bei Tabellen, Absätzen und Überschriften. Am unschönsten sind die teils spartanisch wirkenden Regeln bezüglich der Verwendung von Leerzeilen welche einem Asciidoc auferlegt, während bei reST die seltsam positionierten Underscores, Backquotes und Mehrfach-quotes den Würgereflex herauf beschwören. Allerdings sind das Dinge welche mich auch an Python stören; Leute die in Python entwickeln sind so einen Anblick vermutlich bereits gewohnt und entsprechend abgestumpft.
asciidoc-dblatex-8.6.9-5/text/raspbian: Zusätzliche Abhängigkeiten um PDF-Dokumente mit asciidoc erzeugen zu können. Wird verwendet sobald "a2x -f pdf" aufgerufen wird. Dies ist das "empfohlene" Backend für diesen Zweck. Es benötigt aber ca. 80 MB zusätzliche Abhängigkeiten da dblatex mitinstalliert wird, welches wiederum eine LaTeX-Installation als Abhängigkeit mitschleppt. Außerdem sind die erzeugten PDF-Dokumente zumindest per Default größer als die mit asciidoc-fop erzeugten, da der Titel auf eine separate Seite gedruckt wird und Autor/Revisions-Info auf eine weitere separate. Dann erst folgt der eigentliche Dokumentinhalt. Vermutlich kann man das irgendwie deaktivieren, aber per Default ist es so.
asciidoc-fop-8.6.9-5/text/raspbian: Zusätzliche Abhängigkeiten um PDF-Dokumente mit asciidoc erzeugen zu können. Wird verwendet sobald "a2x --fop" aufgerufen wird. Erzeugt per Default schlankere PDF-Dokumente als asciidoc-dblatex, die der HTML-Version ähnlicher sehen weil Titel und Revisionsinfo mit dem Beginn des Dokumenteninhalts auf der ersten Seite zusammengefasst sind.
asciidoctor-1.5.4-2/ruby/debian: Es ist etwas unklar wie sich dieses Paket von "asciidoc" unterscheidet, scheint es doch exakt dasselbe zu tun - und einigen Behauptungen nach besser als das Original. Ein Problem ist allerdings das zugehörige Dokumentationspaket - das taugt rein gar nichts. Es ist im wesentlichen eine API-Beschreibung für Entwickler von Plugins, aber erklärt weder die ASCIIDOC-Auszeichnungssprache selbst noch die Verwendung des Tools. Auch die man-Page des Tools selbst ist nur kurz. Außerdem kann das originale asciidoc eine Kurzhilfe der Sprache direkt im Terminal anzeigen - auch dies fehlt Asciidoctor. Wenn man sich daher schon asciidoc wegen asciidoctor nicht installieren sollte, dann wenigstens dessen deutlich ausführlichere Anleitung! Die größten Unterschiede sind dass asciidoctor in Ruby implementiert ist und asciidoc in Python. Letzeres verwenden viele Projekte, Ruby ist eher ein Exot. Mit asciidoc kann man sich daher zumindest unter Umständen die Installation der Ruby Runtime ersparen wenn sie sonst niemand braucht. Eventuell hat asciidoc weniger Qualitätsmängel und arbeitet zuverlässiger. Zumindest gewann ich diesen Eindruck in Web-Recherchen. Ansonsten sind beide Pakete mehr oder weniger identisch.
asciidoctor-doc-1.5.4-2/doc/debian: Wertlos für Anwender von "asciidoctor". Nur API-Infos.
asciio-1.02.71-1/optional/debian: Ein in Perl verfasster und durch zahlreiche Perl-Modul-Pakete als Abhängigkeiten leider vergleichsweise fett gewordener (zusammen 1,5 MB Installationsumfang) auf GTK+ basierender grafischer ASCII-Art Editor. Obwohl es ein grafischer Editor ist, arbeitet man auf einer Zeichenzellen-Matrix, und es werden auch ausschließlich textbasierte Grafiken angezeigt. Diese kann man aber mit der Maus verschieben, resizen, etc. - eigentlich sehr komfortabel. Man kann auch Pfeile hinzu fügen (nur rechtwinkelig geknickte allerdings), die welche Boxen verbinden und an vordefinierten Einschnapp-Punkten (oben, unten, links und rechts - jeweils genau in der Mitte) am Rand der Box einrasten können. Diese Verbinder bleiben auch verbunden wenn man die Box später verschiebt. Es gibt zudem auch noch gerade Pfeile in 45-Grad-Schritten, welche jedoch nicht als Verbinder in Boxen einrasten sondern als unabhängige Objekte agieren. Boxen können optional in einen oberen Teil (Titel) und einen unteren Teil (mehrzeilige Beschreibung) unterteit werden, und können sich optional automatisch an den Platzbedarf des Textinhalts verkleinern. Die Boxen selbst können entweder mittels der üblichen Ersatz-Zeichen dargestellt werden, oder ausschließlich mittels Punkten, oder ausschließlich mittels Sternen. Bei den Verbindern gibt es noch mehr Optionen, welche Zeichen zur Darstellung verwendet werden können. Noch nie war es einfacher, Box-Diagramme als ASCII-Art zu erstellen und mit Text zu befüllen und mit einander mittels Pfeilen zu verbinden! Neben rechteckigen Boxen gibt es auch welche mit abgerundeten Ecken oder reiner Text ohne Umwandung. Des weiteren gibt es etliche vordefinierte ASCII-Art Cliparts ("Stencils"), die sich als Objekte einbinden lassen wie Internet-Wolke, Papierblatt-Symbol, Haus, Computer etc. Man kann das Ergebnis seiner Bemühungen auch als neuen Stencil speichern, jedoch wird dabei nur das Ergebnis gespeichert und alle enthaltenen Verbinder etc. gehen als Spezialbedeutung verloren. Man kann das Ergebnis seiner Bemühungen entweder als natives Dokumentenformat von asciio speichern, was im wesentlichen ein komprimierter serialisierter Perl-Quelltext ist. Oder man speichert es als ASCII-Datei ab. Wobei "ASCII" nicht wörtlich zu nehmen ist, es wird offenbar beliebiger UTF-8 Text unterstützt. Ein großes Problem ist dass der Export als ASCII-Art eine Einbahn-Straße ist: asciio kann nur sein eigenes Spezialformat wieder laden; es gibt keinen Konverter welcher vorhandene ASCII-Dateien in dieses Format konvertieren kann. Allenfalls kann man bestehende ASCII-Art als Stencil laden, aber die lässt sich dann nicht mehr weiter editieren sondern agiert als starres Block-Objekt. Technisch gesehen sind Stencils nichts weiter als normale asciio-Textboxen ohne Rand, die ihrerseits ASCII-Art als (manuell) editierbaren Textinhalt enthalten. Weiters scheint immer LATIN1 als Ausgabezeichensatz verwendet zu werden, auch wenn innerhalb der Textboxen UTF-8 Text eingegeben werden kann. Somit ist man de facto auf das LATIN1-Subset von UNICODE bei der Texteingabe beschränkt.
asciiquarium 1.1-4/community/archlinux: Eine Bildschirmschoner-ähnliches Aquarium-Animation. Allerdings aus farbiger ASCII-Grafik bestehend, und auf der Konsole bzw. im Terminal-Fenster wiedergegeben. Sehr lustig! Und mit 53 KB Installationsumfang auch ziemlich winzig. Das liegt wohl auch daran, dass es sich nur um ein simples Perl-Script handelt.
aspell-de/app-dicts/gentoo: German dictionaries for aspell.
aspell-en/app-dicts/gentoo: English dictionaries for aspell.
aspell/app-text/gentoo: GNU Aspell is the standard spelling checker for the GNU software system, intended to replace ispell. Also used by KDE3. Has some technical advantages over ispell such as honoring the locale settings and better handling of multiple dictionaries at the same time. It also directly supports UTF-8. Interactive and batch usage. Supports spell checking and correction as well as converting a word to a SOUNDEX-like normalized form. Aspell's command line tools are just front ends for a library which can also be directly linked to applications, enabling spell-checking support for them. The older Ispell, in contrary, could only be acessed by other applications through a pipe. Aspell is also the successor to Pspell which has been intended to be a portable spell checker.
at-3.1.13-r1/sys-process/gentoo {service manager}: Features the "at" command, allowing batch execution of a command either at a specified time, or as soon as possible when the system is idle or the system load drops below a specified maximum. In contrary to "cron", "at" is intended to be used for delayed one-time jobs. It is also suitable for continuously operating jobs which run at highly irregular intervals and prefer to schedule their next intended invocation themselves. "at" also conserves most of the invoking user's current environment variables, something which "cron" normally does not. "at" jobs are normally run from a dedicated daemon "atd", although a backwards-compatible script "atrun" is also provided which allows "at" queue runs to be scheduled by "cron". But it is not advisible to use that mode of operation, because it required atrun to be executed every minute, where "atd" will sleep until the next event is scheduled, or once every hour in case an "at" instance failed to contact the daemon of a newly enqueues job. I must say that I had a very negative opinion about "atd" in the past: I thought "atd" would check for new jobs every minute (like with "atrun", just executed by the "atd" daemon), so why not use "cron" for that anyway? Also, I use fcron rather than vixie-cron, and fcron does not wake up every minute unless a job required this, but rather calculates the time to sleep until the next scheduled event. In a code review of "at", however, I found out that my negative bias towards "atd" was actually unjustified: The 60-second poll interval only applies if "atrun" is run as a "cron" job; "atd" itself only wakes up once an hour if no jobs have been scheduled. And even then, it only "stat"s the directory where new "at" job files will be placed by "at", and immediately goes back to sleep unless the directory has been changed since the last time "atd" has checked. This means, when "at" is not actually used, "atd" will not make the disk spin around unnecessarily by getting a directory of its job directory listing every minute, but will rather just read-access a single inode every hour, which has a good chance of being cached in RAM on an idle system. This means, that the impact of running "atd" (especially in relation to power management and spinning down the disk when idle) is actually very low. The code size for "atd" is about 23 KiB and thus also rather neglectible in terms of allocated system resources. I can therefore no longer object against running "atd" as part of a standard installation, even on an otherwise rather resource-restricted system. Also, "at" is a well-known standard command, partly even standardized by POSIX. Scripts which use its services can be expected to work on other systems too. Finally, "atd" has the capability to inform the ouptput of the executed command by mail, but this only occurs if there is actually any output generated by the command, and it can also be disabled by using a command line switch.
at-3.1.23-1/admin/debian {service manager}: "at" queues jobs for the "atd" daemon which runs them once at individually scheduled times. While this functionality overlaps with that of "crond", historically "crond" did not support jobs for regular users, but "atd" did. On medium-aged or modern systems, "crond" does support user crontabs and can always be used instead of "at". In addition, "atd" can run jobs scheduled using the "batch" command at the next possible opportunity rather than at a specific time, provided the system load is not too high. "atd" therefore also acts as a general purpose batch-queueing system. Unfortunately, this batching feature does not work well with modern multi-core CPUs because there is just a single queue for jobs scheduled with the "batch" command. It would be better if there was one such queue per CPU core, but this is not the case. Therefore, "batch" is no longer appropriate for modern-day systems. "batch", "at" and "atd" are well-known tools with a well-known user interface which can be used from scripts that run on various systems. Also, "at" preserves the user's current environment variables when running the delayed commands; something "cron jobs" normally don't do. But most importantly, the disadvantage that it polls its database every minute is just an unfortunate implementation detail. Generally, "at" is intended for single-time invocations, where "crontab" is intended for repeated tasks. On the other hand, "at" jobs can re-schedule themselves resulting in periodic execution, while "crontab" jobs can remove themselves after execution, resulting in one-time execution. In addition, "sleep" and "nohup" can be combined in order to execute a job at a later time without requiring "at" for that purpose. Bottom line: "at"/"atd" is not really required or useful on modern systems. The only good reason to install them is existing scripts which already use those commands.
aterm-1.0.1-r1/x11-terms/gentoo {terminal emulator}{GUI}{X11}: Ein ziemlich kleiner Terminal-Emulator für X11 - keine 500 KB Installationsumfang. Scheint als eine schlankere Version des rxvt gedacht zu sein. Kommt aus der AfterStep-Ecke. Keinerlei Menüs, Tabs oder sonstwas besonderes erkennbar - da muss man wohl erst langmächtig die Doku studieren. Beim originalen xterm ist dies aber auch nicht besser. Und immerhin kommt aterm bereits mit schwarzem Hintergrund als Default daher. Auch aterm prahlt damit dass es als xterm-Replacement gedacht ist und weitaus weniger Speicher benötigt als dieses. Es beherrscht keine Tabs, aber dafür sinnlose Spielereien wie Transparenz und Hintergrundbild. Genau wie xterm kann man Custom-Farben nicht einfach als RGB-Werte angeben, sondern nur aus einer kleinen Liste vordefinierter Farbnamen wählen.
atlantik/kde-base/gentoo: Ein schmuckloses netzwerkbasiertes Multiplayer Monopoly-Spiel.
atril-1.8.0/app-text/gentoo {document viewer}{PDF}: Der Standard-Dokumentenbetrachter des Mate DTE. Es beherrscht die Dokumentformate PDF, PostScript, EPS, DJVU, DVI und XPS. Insgesamt eine recht bescheidene Auswahl, da das KDE-Gegenstück Okular deutlich mehr Dateiformate beherrscht. In der Praxis wird Atril daher wohl meist als PDF-Betrachter benutzt werden. Er bietet aber auch in dieser Funktion keinerlei Bearbeitungsfunktionen, während Okular zumindest Kommentierfunktionen bereit stellt. Sehr wohl beherrscht Atril aber genau so wie Okular das Ausfüllen von PDF-Formularen.
audacious-3.5-2/sound/devuan {audio}{music}: Audacious ist ein GTK-basierter Music-Player der mit vergleichsweise bescheidenen Bibliotheks-Abhängigkeiten. Wird bereits mit etlichen mehr oder weniger nützlichen Plugins ausgeliefert und kann alles was man so erwarten würde. Unterstützt auch C64 "SID"-Dateien und Amiga "SoundTracker"-Dateien genau so wie die üblichen mp3-, aac-, etc. -Dateien. Die Installation ist mit ca 9 MB Umfang zwar nicht besonders schlank (obwohl noch tolerabel), aber der Download ist erstaunlicher Weise bedeutend kleiner (ca. 2 MB). Hat auch keine Probleme mit einer großen Musiksammlung, die erstaunlich rasch eingelesen wird und danach durchsucht werden kann. Die Suchergennisse werden sogar ungewöhnlich innovativ in verschiedenen Granularitäten gleichzeitig angeboten, etwa alle Alben eines Künstlers, einzelne Alben, einzelne Songs. Das Programm macht auch auf den ersten Blick einen übersichtlichen und bedienungsfreundlichen Eindruck. Auf den zweiten Blicks hat es jedoch einige Eigentümlichkeiten. So kann man nicht per Doppelklick Songs aus der Musiksammlung in die aktuelle Playliste übernehmen sondern muss dazu einen Button drücken. Außerdem fehlt eine herkömmliche Ansicht die nach Künstlern oder Alben gruppiert ist - nur die flache Liste aller Titel ist abseits der Suche vorhanden. Auch die zuvor erwähnte hohe Geschwindigkeit beim Einlesen der Musiksammlung findet seine Erklärung darin dass das Programm keinerlei Datenbanken zu benutzen scheint, sondern alles immer komplett in den RAM lädt. Meine "Musiksammlung" erwies sich beispielsweise abgespeichert als Textdatei mit 10 MB Größe. Das ist natürlich schneller als zigtausende Songs in eine Datenbank einzutragen. Aber es kostet auch mehr RAM. Dies erwies sich auch als das größte Problem: Mit ca. 30.000 Titeln in der Musiksammlung belegte das Programm 970 MB virtuellen Speicher und 745 MB RAM. Für mich ist das ein Ausschlusskriterium! Selbst das nicht gerade schlanke Clementine belegte "nur" 300 MB virtuellen Speicher und 90 MB RAM. Der VLC Player belegt mit 145 MB virtuellem Speicher und 80 MB RAM noch weniger. (All diese Player waren beim Vergleich jeweils mit einer Medien-Bibliothek ähnlichem Umfangs ausgestattet.)
audacity-1.3.5/media-sound/gentoo {audio}: WxWidgets-basierter Multitrack-Audioeditor. Hat den größten allgemeinen Funktionsumfang von den verbreiteten freien Audio-Editoren. Unterstützt die wichtigsten Sound-Formate und Sound-Server. Gute Zoom-Funktionen und verschiedene Zeitformate. Unterstützt LADSPA-Plugins. Kann leider nicht direkt aus Audiodateien abspielen sondern muss diese erst "laden".
augeas-tools-1.11.0-3/admin/debian: Eine Suite von Konfigurations-Editoren. Vermutlich in LISP erstellt, oder zumindest von einem LISP Fan, der Erweiterungssprache für "Lenses" nach die *sehr* LISP-artig aussieht. Dennoch ein schlankes Paket - nur 1,5 MB inklusive Dokumentationspaket. Das Paket ist im wesentlichen eine Sammlung von Parsern (die erwähnten "Lenses") für viele verschiedene prominente Konfigurationsdateien in /etc. Aktuell (Stand: 2021-02) sind 440 solche Lenses enthalten. Diese Lenses können den Inhalt der unterstützten Konfigurationsdateien in eine Baumstruktur ähnlich dem DOM einlesen und auch wieder aus der Baumstruktur zurück ins ursprüngliche Format wandeln. Weiters enthält die Suite eine interaktive Shell, welche beim Start alle diese unterstützten Konfigurationsdateien parst (sowei sie vorhanden sind) und dann innerhalb der Shell ähnlich wie ein Dateisystem mit Directories (für die Pfade bis zu den Konfigurationsdateien und falls Vorhanden den Sections innerhalb der Konfigurationsdateien) und Pseudo-Dateien (für die einzelnen Settings der Konfigurationsdateien) darstellt. Man kann sich innerhalb dieses Pseudo-Dateisystems bewegen, Settings anzeigen lassen, ändern, umbenennen, verschieben, löschen etc. Kommentare der früheren Konfigurationsdateien bleiben dabei erhalten und werden ebenfalls als Settings dargestellt. Ebenso bleibt die Reihenfolge der Einträge erhalten. Wo es mehrere Einträge im selben Setting gibt werden diese als Array aus nummerierten Settings dargestellt. Man kann daher die Settings unabhängig vom konkreten Format der Konfigurationsdateien in Augeas bearbeiten, und am Ende mit einem Kommando speichern - wodurch die betroffenen Konfigurationsdateien neu geschrieben werden. Natürlich funktioniert das ganze auch non-interaktiv - ein Script kann so gezielt bestimmte Settings in einer Konfigurationsdatei ändern, ohne diese selbst parsen zu müssen oder auch nur ihr genaues Format zu kennen. Weiters kann Augeas die einen beliebigen Teilbaum seines Pseudo-Dateisystems als XML-Datei exportieren, und ebenso wieder re-importieren. Dadurch kann man auch mit allen Werkzeugen die zur XML-Manipulation verfügbar sind die Änderungen der Settings durchführen, one sich mit dem Format der Augeas-Shell befassen zu müssen (welches aber ohnehin sehr XML-nahe aufgebaut ist, zumindest logisch). Neben den erwähnten vielen Dateien in /etc kennt Augeas aber noch jede Menge weiter Dateiformate wie etwa Yaml, die auch außerhalb von /etc immer wieder zu finden sind. Ebenso werden einige Dateiformate wie LDIF und CSV unterstützt, die überhaupt keine Konfigurationsdateien sondern eher Datenbank-Bestandteile sind. Auch ein Subset von POSIX-Shell Scripten welche nur Variablen setzen und daher oft als Konfigurationsdateien "missbraucht" werden wird unterstützt. Mit der Angabe von etwas mehr Optionen kann Augeas dann auch solche Dateien laden, manipulieren und speichern. Das bedeutet folglich aber auch, dass man damit Settings zwischen verschiedenen Konfigurationsdatei-Formaten hin- und her wandeln könnte, wenn man das will. Etwa von YAML zu JSON oder INI. Nicht dass dies sehr sinnvoll wäre... Und wenn ein Format noch nicht von Augeas unterstützt wird, kann man sich seine eigene "Lense" schreiben. Vorausgesetzt man hat keine Angst vor LISP/Scheme. Insgesamt ein tolles Paket für Admins die mit XML "auf Du und Du" sind. Ansonsten zwar sehr toll, aber für Einzelbenutzer wohl eher nutzlos. Allerdings könnte es sehr nützlich beim Inventarisieren und vergleichen von Settings zwischen verschiedenen Maschinen und/oder Accounts sein.
augeas-tools-1.8.0-1+deb9u1/admin/devuan: Augeas ist ein Framework zur normierten Bearbeitung von Config-Dateien. In erster Linie ist es dabei ein Konfigurations-Editor. Man erstellt zunächst eine "Lense" bzw. ein Schema, welches in einer "ML"-ähnlichen funktionalen Sprache den Aufbau irgend einer Konfigurationsdatei wie etwa /etc/hosts beschreibt. Natürlich gibt es auch bereits viele fertige Lenses für die Konfigurationsdateien bekannter Programme wie etwa OpenSSH. Danach kann man dann das Kommandozeilenprogramm "augtool" verwenden (oder dasselbe programmgesteuert über verschiedene APIs erledigen) um den aktuellen Inhalt einer Konfigurationsdatei anhand einer Lense zu parsen und zu laden. Dann kann man die Config-Settings auf eine normierte Art ansehen, erzeugen oder ändern, und das Ergebnis dann in die originale Config-Datei zurück sichern. Kommentare aus den Konfigurationsdateien werden dabei in nummerierte Kommentar-Einträge umgewandelt, wobei gar nicht erst versucht wird ein Kommentar einem bestimmten Setting zuzuordnen. Statt dessen bleibt einfach die ursprüngliche Reihenfolge von Kommentaren und normalen Config-Settings erhalten. Das gilt selbst bei der XML-Darstellung, welche dasselbe als eine Abfolge von "node"-Elementen darstellt und Kommentare einfach als eigenständige Kommentar-Nodes repräsentiert.Augeas unterstützt auch mehrfache Schlüssel in derselben Config-Datei, diese werden dann einfach durchnummeriert. Zum bearbeiten/begutachten ist "augtool" ähnlich wie ein Commandline ftp-Client aufgebaut, d. h. er hat eine interaktive Shell wo man diverse Kommandos wie "get", "ls", "match", "cp", "rm" eingeben kann. Dies lässt sich sicherlich auch irgendwie aus einem Shell-Script heraus nutzen. Augeas virtualisiert somit Konigurationsdateien in ein einheitliches Format welches man immer mit denselben Methoden untersuchen oder manipulieren kann, während sich am physischen Format nichts ändert. Augeas funktioniert, ist mir rund 17 MB Installationsumfang (falls man die Dokumentation mit installiert) aber relativ fett, und löst vor allem keine Probleme: Man muss nach wie vor wissen was die Config-Einträge bedeuten, oder an welcher Stelle man neue hinzu fügen soll. Augeas nimmt einem nur das Laden und Speichern der Config-Datei ab, und erleichtert einem das Auffinden und Ändern von Settings durch einheitliche Befehle. Davon abgesehen erscheint es relativ sinnlos und reiner Selbstzweck zu sein.
autofs-5.0.6-r3/net-fs/gentoo: Kernel-basierter Automounter. Mit anderen Worten, er mountet entsprechend konfigurierte Dateisysteme automatisch sobald man auf deren Mount-Verzeichnisse zugreift. Das erforderliche Kernel-Modul ist ab Kernel 2.6.16 standardmäßig enthalten; für ältere Kernels sind Patches im Installationsumfang enthalten. autofs kann nicht nur lokale Dateisysteme mounten, sondern zumindest auch die Netzwerkdateisysteme CIFS/SAMBA und NFS. Zu bedenken ist dass so ein Automounter zu unerwünschten Mount-Vorgängen führen, wenn Tools wie find oder updatedb die Festplatte durchsuchen. Ein anderes Nachteil ist dass der autofs-Daemon für jeden konfigurierten Mount-Point einen eigenen Thread startet. Das kann die Verwendung von autofs ressourcenmäßig teuer machen wenn man sehr viele Mount-Points dafür konfiguriert. Die Mount-Definitionen für autofs werden zwar primär in einem Konfigurationsfile festgelegt; es ist aber auch möglich von dort aus auf einen LDAP-Server weiter zu verweisen von dem die eigentlichen Einträge bezogen werden. Weiters erfordert das Anpassen des Konfigurationsfiles Administrator-Rechte; autofs ist daher nicht dazu geeignet benutzerspezifische FUSE-Dateisysteme bei Bedarf zu mounten (zumindest nicht ohne Mitarbeit des Administrators).
autogen-5.9/sys-devel/gentoo: AutoGen creates text files from templates using external definitions. Sort of M4 for poor ones. Has *nothing* to do with GNU Autotools.
avant-window-navigator-0.3.2.1/gnome-extra/gentoo {desktop panel}: Ein Panel mit zahlreichen Features, dessen Sinn allerdings insofern etwas fragwürdig ist als es sich um eine Unterstützungs-Anwendung für den GNOME-Desktop handelt. Und dieser bietet doch eigentlich selbst alles? Nun, vielleicht bietet AWN noch mehr. Wie auch immer, ohne GNOME oder zumindest Compiz/Fusion startet das Ding nicht einmal. Zusammen mit dem "gnome-extra/avant-window-navigator-extras-0.3.2.2"-Paket das scheinbar viele nützliche Applets enthält alles in allem gute 10 MB Installationsumfang. Außerdem benötigt es auch noch mehrere Python-Pakete als Abhängigkeiten. Daher offenbar nicht gerade für minimale Desktops gedacht!
avfs-1.0.3-1/utils/debian {FUSE}{compression}: Ein FUSE-basiertes (ließ sich früher auch über den CODA-Kerneltreiber einsetzen, doch leider nicht mehr bei aktuellen Kerneln) virtuelles Dateisystem, das komprimierte Dateien, Archive und andere nicht-Verzeichnis-Objekte als Unterverzeichnisse darstellen kann, in welche man "hinein gehen" kann. Es beherrscht etliche zahlreiche Archivformate oder Netzwerkzugriffsmethoden: "Floppy disks" (FAT image files?), tar, gzip, zip, bzip2, ar and rar, ftp sessions, HTTP (einzelne Datei), RSH/rcp, SSH/scp, abgespeicherte rekursive Directory-Listings. Viele dieser Möglichkeiten unterstützt es dabei leider nur in nur-leserbarer Form. Neben den mitgelieferten Plugin-Treibern für genannten Archivformate und Protokolle kann es auch Gebrauch von installierten VFS-Plugins des Midnight Commanders machen. Das könnte praktisch sein wenn man für diesen selbst eines geschrieben hat, da es deutlich einfacher geht (normale Shell-Scripte reichen für simple Dateisysteme bereits zur Implementierung aus) als gleich einen richtigen Treiber für FUSE zu schreiben. Ein praktischer Nachteil von avfs (den man aber nicht dem Programm speziell anlasten kann sondern eher dem Umstand dass es ein Dateisystem ist) ist dass man es erst mounten muss bevor man es benutzen kann. Allerdings kann man vermutlich net-fs/autofs verwenden um dies zu automatisieren. Außerdem muss man das Dateisystem nicht pro Archiv mounten, sondern nur einmal pro Benutzer. Dazu ruft man einfach "mountavfs" auf und in $HOME/.avfs wird ein Overlay des gesamten Wurzeldateisystems gemountet. In diesem Overlay gibt es nun für jede Archivdatei einen zusätzlichen versteckten virtuellen Ordner, welcher denselben Namen mit "#" am Ende hat, und den Inhalt der Archivdatei repräsentiert. So gibt "cat test.zip#/README.txt" den Inhalt von "README.txt" aus dem Archiv "test.zip" aus. Es hätte grundsätzlich auch WebDAV-Support, aber zumindest unter Debian funktioniert dies nicht und war 2017 deaktiviert. 2023 war er wieder verfügbar, jedoch schaffte ich es nicht damit auf einen WebDAV-Server zuzugreifen. Aber selbst wenn es funktioniert hätte - es wäre nur read-only gewesen. HTTP funktioniert zwar, aber man kann damit nur einzelne Dateien herunterladen wenn man ihren kompletten Pfad kennt. So etwas wie ein Directory-Listing wo man HTTP-Hyperlinks folgen kann gibt es nicht. Somit beschränkt sich der praktische Nutzen im wesentlichen auf lokale Archive. Eventuell vielleicht noch für ftp sinnvoll, aber wer nutzt das denn heute noch? Und für SSH gibt es bessere Lösungen wie sshfs. Der Praxiswert der Netzwerk-Fähigkeiten von avfs ist daher eher gering. Potenziell interessant ist der "#volatile"-Handler, der einem ein sehr primitives Memory-only Dateisystem bietet. Also etwas ähnliches wie tmpfs, jedoch ohne dass man dazu besondere Rechte brauchen würde (außer natürlich Schreibzugriff auf /dev/fuse). Das kann interessant sein wenn alles read-only gemountet ist und kein tmpfs verfügbar ist und man keine Admin-Rechte hat. Leider unterstützt #volatile offensichtlich nicht alle Spezial-Dateioperationen und stürzt dann ab. Aber als simple Dateiablage und zum Editieren von Textdateien sollte es reichen.
avidemux-2.6.7/media-video/gentoo {video-editor}: Ein in C++ geschriebener primitiver nicht-linearer Video Editor mit Hauptaugenmerk auf Konvertierung und Digitalfilterung. Kann entweder GTK oder Qt als GUI-Toolkit verwenden, ist jedoch auch von der Kommandozeile aus benutzbar. Verwendet kein spezielles Framwork, hat aber Code von anderen Projekten wie FFmpeg, Mplayer, Transcode und Avisynth gestohlen. Unterstützt OCR-Erkennung von Bitmap-Untertiteln. Besitzt ein Virtual-Dub-ähnliches Filtersystem, das auf der Basis von JavaScript-Makros angesteuert werden kann. Als Nachteil mögen die etwas eingeschränkten Ausgabe-Formate erscheinen; alles für die Praxis relevante ist allerdings dabei. Avidemux wird wegen seiner JavaScript-basierten Filtermöglichkeiten vor allem für Konvertierungsaufgaben genutzt. Es ist für Cutting (etwa herausschneiden von Werbeblöcken), Splitting, Filtering und andere grundlegende Editieraufgaben geeignet, aber es mangelt an höherwertigen Funktionen wie Übergangseffekten, einer Timeline, dem Arbeiten mit mehreren Videospuren samt Mischmöglichkeiten und dergleichen.
axiom-200805/sci-mathematics/gentoo {symbolic calculation}{programming language}: Ein weiteres symbolisches Rechenprogramm ählich wie maxima, allerdings komplett unterschiedlich zu benutzen. Es basiert auf einem eigenen in C geschriebenen LISP-Dialekt welcher Teil der Installation ist, besitzt Zugriff auf FORTRAN-Code und ist entsprechend flott. Jung ist es ebenfalls nicht - es wurde seit 1971 mit 300 Mannjahren Aufwand entwickelt. Jede Menge Dokumentation ist dabei. Aber trotz eines X11-GUI-Dokumentations-Browsers (uralt X11-GUI Look & Feel - *kotz*) wirkt auf den ersten Blick alles etwas umständlich. Es ist mit 100 MB fast doppelt so umfangreich wie Maxima. Das System dürfte alles in allem aber brauchbar sein. Nachteil: Obwohl Axiom sein eigenes LISP mitbringt, wird zumindest zum Bauen und möglicher Weise auch zur Laufzeit zusätzlich noch GNU Common LISP benötigt. Dieser Umstand ist in den Paketabhängigkeiten nicht definiert, aber der Ebuild versagt ohne GCL weil gegen eine GCL-Library gelinkt wird. Eine weitere "Spezialität" von Axiom ist, dass es sich nicht mit Address Space Layout Randomization verträgt. Diese muss während des Bauens und zur Laufzeit von Axiom abgeschaltet werden. Insgesamt ein etwas eigenwilliges Paket mit fast schon unverschämt zu nennenden Ansprüchen, allerdings auch sehr leistungsfähig und ungewöhnlich ausführlich dokumentiert.
babl-0.0.22/media-libs/gentoo: A dynamic, any to any, pixel format conversion library. It allows converting between different methods of storing pixels known as pixel formats that have with different bitdepths and other data representations, color models and component permutations. A vocabulary to formulate new pixel formats from existing primitives is provided as well as the framework to add new color models and data types. ANSI C, works on win32, linux and mac, 32bit and 64bit systems.
babytrans-en2ger-0.2/app-dicts/gentoo: Ein Versuch, den "Babylon Translater" von Windows in Linux nachzuprogrammieren. Verwendet die Original-Datenfiles. Der Showstopper an dieser Version: Verwendet noch GTK+ 1.2 - wer will das schon noch installieren? Man sollte sich dieses Projekt in ein paar Monaten oder Jahren aber noch einmal ansehen, da die Idee gut klingt.
ballerburg-1.2.0-3/games/debian {game}: Eine Variante des bekannten "Artillery Duel"-Spiels, wo zwei Spieler mit Kanonen auf die gegenseitigen Stellungen schießen und derjenige gewonnen hat, der dem anderen als erster ausreichend viel Schaden zufügt. In dieser Variante sind es zwei Burgen zwischen denen sich ein Berg als Hindernis befindet. Man muss wie üblich Winkel und Pulvermenge einstellen sowie den Wind beachten. Ungewöhnlich ist jedoch, dass es nicht nur eine sondern zwei Kanonen pro Burg gibt welche sich unabhängig von einander befehligen lassen. Überdies gibt es Könige im Unterschoss der Burgen, und man gewinnt erst wenn man den feindlichen König erschossen hat. Überdies gibt es noch diversen Kammern in der Burg, wo Vorräte, Munition etc. gelagert sind. Wenn die zerstört werden, hat das auch irgendwelche Auswirkungen. Gewisse Wirtschafts-Spiel Elemente sind dabei vorhanden - man kann Fördertürme erwerben, Steuern einfordern, und mit den Mitteln neue Geschütze oder Munition kaufen. Man kann dem Feind dadurch auch wirtschaftlich schaden, indem man seine Ressourcen zerstört, wodurch er sich weniger Angriffs-Material leisten kann. Das Spiel wartet sogar mit Sound auf - simpel, aber doch. Dasselbe gilt auch für die Grafik - schlicht aber sie bietet was man für so ein Spiel braucht. Leider gibt es nur die Wahl zwischen Vollbildmodus oder einem eher kleinen Fenster dassen Größe sich nicht ändern lässt. Die geringe Auflösung wird im Vollbildmodus in entsprechend grobe Pixel konvertiert. Ein Highlight des Spiels ist der Umstand, dass sowohl 2 Spieler als auch 2 Computergegner gegen einander antreten können, und natürlich Spieler gegen Computer. Ebenso sind sind nicht weniger als 7 A.I.-Algorithmen in je 4 Stärke-Stufen selektierbar - im Fall von Computer vs. Computer auch unterschiedliche, so dass man kein Endlos-Spiel ansehen muss sondern der stärkere Algorithmus in der Regel gewinnt. Die Algorithmen unterscheiden sich dabei vor allem in der Zielsetzung - etwa ob sie militärische oder wirtschaftliche Offensiven vorziehen, und welche Ziele sie dabei bevorzugt ins Auge fassen. Die Anleitung erklärt das sogar recht genau in Detail. Weiters angenehm der geringe Installationsumfang des Spiels - keine 200 kB. Der Download ist nicht einmal 75 kB groß. Mir persönlich ist das Spiel wegen dem wirtschaftlichen Aspekt zwar etwas zu nervig, aber es macht zumindest Spaß den Computergegnern zuzuschauen wie sie einander gegenseitig eliminieren. Das einzige was fehlt ist Netzwerkfähigkeit. Man kann es zu zweit nur vor dem selben Bildschirm spielen. (Wenn man Brachial-Lösungen wie VNC einmal ausklammert.)
banshee/media-sound/gentoo {audio}{music}: Audio media player for Linux. GTK and Mono based (the .NET implementation of Linux). Mostly an Amarok competitor. But only if you can tolerate the Mono framework on your box, which is design by Microsoft. Is said to have about the look and feel of an iTunes clone.
baobab-3.14.1-1/gnome/debian: Das nächste Opfer der GNOME3-Inkompatibilitäten. Früher das beste Programm zum grafischen Analysieren der Festplattenbelegung, klebt es nun am linken oberen Fensterrand, und lässt sich mit keinem Mittel dort fort bekommen - außer man benutzt GNOME3 als DTE. Nein, danke! Dann muss ich eben mit dem relativ ähnlichen Tool auskommen, welches in Krusader integriert ist, obwohl es weniger mächtig ist.
barcode 0.99-2/community/archlinux: Bibliothek und Kommandozeilenprogramm zum Erzeugen diverser (1-D) Barcode-Typen als Encapsulated Postscript (EPS) oder PCL-Druckdatei. Unterstützte Codes: EAN-8, EAN-13, UPC-A, UPC-E, ISBN-13, CODE 128-B, CODE 128-C, CODE 128-RAW, CODE-39, INTERLEAVED 2 OF 5, CODE-128, CODABAR, PLESSEY, MSI, CODE-93, CODE-11.
barrage-1.0.4-3/games/debian {game}: Ein grafisch nett gemachtes aber auch sehr hirnloses 2D Fullscreen-Spiel: Panzer oder Soldaten eilen vertikal über den Bildschirm, und man muss mit der Maus Geschütze auf sie richten und vernichten bevor sie den Bildschirmrand erreichen. Schaffen sie es doch gibt es Punkteabzüge bis man schließlich verloren hat.
bbe-0.2.2-5/editors/raspbian {hex-editing}{stream-filter}: bbe is a sed-like editor for binary files. About 30 kB download size.
bchunk-1.2.2-2/otherosfs/debian: Kann Paare aus *.bin (oder *.raw) und *.cue Dateien, welche zusammen CD-Abbild-Dateien darstellen, in einen Satz von *.iso und *.cdr oder *.wav-Dateien konvertieren. Dadurch kann man etwa eine Multisession-CDROM in die einzelnen Sessions zerlegen, die man dann mit anderen Programmen weiterverarbeiten kann.
bdelta/dev-util/gentoo {binary-diff}{deduplication}: Another binary diff and patch tool very similar to xdelta, but more efficient. When bzip2'ing an bdelta diff of a source tree tarball, it clearly beats a bzip2 recompressed xdelta diff of the same archives. It also beats bzip2'ed -U0 context diffs for diffs larger than 30 - 40 KB (bzipped), but the context diffs are still more efficient for smaller diffs. On the other hand, bdelta is still in its early stages, while xdelta already is a mature product.
bdsup2sub-4.0.0-r1/media-video/gentoo {bitmap image editor}: Ein in JAVA geschriebenes GUI-Konvertierungsprogramm zwischen verschiedenen Bitmap-basierten Untertitelformaten. Ein scheint seinen Job zwar recht gut zu erledigen, aber leider besitzt es keinerlei Support zur Umwandlung von bitmapbasierten in textbasierte Untertitel. Sprich, es kann keine .srt-Dateien aus .sub und .idx-Dateien erzeugen.
beav-1 {hex-editing}{text-terminal IO}: 1.40-18+b3/editors/debian: Console-based white on black Hex Editor. Can insert and delete bytes. Emacs-style key bindings (can be edited). Written by an Emacs fan. File is copied into a memory buffer during editing. Multiple such buffers can be used for opening multiple files at the same time. Not intended for editing block devices or files in-place. Can edit data in hexadecimal, octal, decimal, binary, ASCII, EBCDIC. Can view but not edit data as floating-point values. Insert and overtype modes. Supports both big and little endianness. Binary clipboard for cut/copy/paste/insert. Can insert files into other files or save parts of them as new files. Binary search and replace. Multiple windows. Multiple views into the same buffer. Keyboard macro record and replay. Compare memory blocks. Counted repetition of commands.
beecrypt-4.2.1/dev-libs/gentoo {security}: Eine Bibliothek für kryptografische Operationen, die angeblich besonderen Wert auf Portabilität legt. (Was fast schon ein Widerspruch zu der Tatsache ist, dass sie in C++ implementiert ist und erweiterte Features wie Namespaces, Exceptions sowie Templates benutzt.) Derzeit implementiert sie die folgenden wesentlichen Funktionen: AES, BASE-64, Blowfish, DSA, RSA, EC, DH, ElGamal, HMAC, SHA1, SHA2-224, SHA2-256, SHA2-384, SHA2-512, RIPEMD-128, RIPEMD-160, RIPEMD-256, RIPEMD-320, MD4, MD5, PKCS#1, PKCS#12, FIPS-186 CPRNG. Modes of operation: ECB, CBC, CTR. Schlüssel inklusive asymmetrischer können auch generiert werden. Digitale Signaturen können erzeugt und verifiziert werden. Weiters bietet sie eine eigene Implementation mehrfach genauer Arithmetik-Routinen - zumindest solche die für asymmetrische Verschlüsselung benötigt werden. Es darf allerdings bezweifelt werden, ob diese die Performance der libgmp erreichen. Die Library unterstützt Multithreading und OpenMP und hängt zwingend von der fetten dev-libs/icu für UNICODE-Support ab. Alles in allem scheint es eine sehr brauchbare Library zu sein, wenn man einen der unterstützten Algorithmen verwenden muss. Die Installationsgröße von 3 MB ist angesichts der Tatsache dass sie in C++ geschrieben ist gerade noch akzeptabel. openssl und gnutls sind allerdings schlanker und bieten ähnliche Funktionen. Andererseits mag die offenbar saubere C++ Basis weniger Implementationsfehler und somit weniger Sicherheitsprobleme erwarten lassen.
bfr/app-misc/gentoo: Buffers data in pipes. Not clear what its actual use is.
biew/dev-util/gentoo {hex-editing}{text-terminal IO}: Console-based Hex-editor, disassembler and text viewer. Cannot display very large files, but is suitable for examining executable files. Has special support for displaying header sections of executable formats. Supports jumping to absolute file offset or executable-format-based virtual address. Can jump to the target locations referred to by disassembled jump/branch instructions. Suspicion: Is this the same as "ht"? Or a precursor from which "ht" has been forked later?
billard-gl-1.75-17/games/debian billardgl/games-sports/gentoo {game}: Das OpenGL 3D Billiard-Spiel, welches mir bislang noch am besten gefällt. Mit deutscher Lokalisierung. Spiel, Tutorial und Hilfe zum Programm sowie den Spielregeln direkt im Programm integriert. 530 kB Download, 8 MB installiert.
bindfs-1.14.7-1/utils/raspbian {FUSE}: Ein FUSE-Dateisystem, mit welchem man die Kopie eines Verzeichnisbaum wo anders hin mounten kann, und dabei diverse Dateisystem-Attribute des Originals modifzieren kann. So kann der Zielbaum etwa Read-Only gemountet werden. Oder er kann alle Symlinks in virtuelle "echte" Dateien umwandeln. Ebenso können Ownership und Permissions verändert werden. Leider hat das Programm einen Bug bei der Option Symlinks aufzulösen welcher dann unter bestimmten Umständen (keine Leseberechtigung auf einem der Parent-Verzeichnisse) dazu führt dass man keine Zugriffsrechte auf das gemountete Verzeichnis hat.
binfmtc-0.17-2.2/utils/raspbian: Ermöglicht es über den "miscfmt"-Mechanismus des Linux-Kernels, in C geschriebene Scripte auszuführen. Diese werden jedes Mal kompiliert und in /tmp (oder einem spezifizierten Verzeichnis) als temporäre Executables ausgeführt. Ein Caching-Mechanismus ist nicht vorhgesehen. Die Scripte müssen mit einem unschönen mehrzeiligen Kommentar beginnen, um vom Kernel erkannt zu werden. Insgesamt keine besonders schöne oder gar portable Lösung.
bitstream-cyberbit-2.0/media-fonts/gentoo: UNICODE-Font mit deutschen Umlauten. Darüber hinaus besondere Stärken bei CJK-Zeichen.
blackbox-0.70.1/x11-wm/gentoo {window manager}{GUI}{X11}: Der Vorgänger von Fluxbox und noch etwas kleiner im Installationsumfang. Er hat nur 4 "Styles", welche sich schlicht durch die Hintergrundfarbe unterscheiden - Fontgröße, Verzierungen etc. ist sonst alles identisch zwischen den Styles. Obwohl schlicht sind die Styles aber durchaus brauchbar und übertreffen die meisten der Fluxbox-Styles - mit Ausnahme des etwas verhungerten Fonts. Mir gefällt der Style "blue" am besten. Die meisten Features vom Blackbox sind identisch mit Fluxbox. Besser als in Fluxbox gefällt mir dass man mit dem Mausrad Fenster shaden/unshaden kann. (Nicht dass ich diese in meinen Augen sinnfreie Funktion jemals praktisch benützen würde. Aber es ist irgendwie witzig.) Das größte Manko gegenüber Fluxbox ist der Mangel an einer "richtigen" Taskleiste. Denn obwohl im Panel ein Taskleisten-Eintrag für das aktuelle Fenster angezeigt wird, so wird auch *nur* dieser angezeigt. Man kann zwar mit Buttons oder dem Mausrad diesen Eintrag auf die restlichen Fenster durchschalten, doch sieht man nie mehr als den Eintrag des aktuellen Fensters im Panel. Somit kann man nicht mittels der Taskleiste mit einem Mausklick auf ein anderes Fenster umschalten. Auch das Umschalten mit Alt-Tab wird (zumindest in der Default-Konfiguration) nicht unterstützt. Möglicherweise ist Blackbox daher sinnvoll für sehr gering auflösende Monitore wo eine Taskleiste zu viel Platz verschlingt; für hochauflösende Monitore ist es eher ungeeignet.
bless-0.6.0-5.1/editors/debian {hex-editing}: Ganz ein toller GNOME3-basierender Hex-Editor. Für große Dateien und alles. Das vielleicht tollste: Mit MONO implementiert! Wer Microsoft-Technik inniglich liebt, sollte sich dieses Teil daher keinesfalls entgehen lassen.
blockdiag-1.4.7-1/python/debian: Erzeugt aus einer Text-Beschreibung bestimmte Arten grafischer Diagramme. In Python implementiert. Eine geringfügig schlankere Alternative (6 MB) zum Paket graphics/graphviz (9 MB), die weniger allgemein ist, dafür aber einige komplexe spezialisierte Diagrammtypen einfacher erstellen kann. Enthält die folgenden Utilities zum Erzeugen der unterschiedlichen Diagramm-Typen: blockdiag (Knotenobjekte mit Beschriftung zeigen auf beliebig viele andere Knotenobjekte - das kann graphviz genau so), seqdiag (wie die grafische Darstellung des Zeitverlaufs in Projektplanungsprogrammen), actdiag (stellt die zeitliche Abfolge von Nachrichten dar, welche verschiedene Teilnehmer einander zusenden - eine fettere Alternative zum schlanken devel/mscgen das in devel/doxygen benutzt werden kann), nwdiag (stellt ein Netzwerkdiagramm dar, welches aus mit einander verbundenen Netzwerksegmenten besteht, an denen Hosts mit IP-Adressen sowie andere Segmente hängen; außerdem kann es Protokoll-Stack-Diagramme sowie Paket-Header-Felder-Diagramme erzeugen). Die verwendete Text-Beschreibungs-Sprache ist ähnlich der von graphviz.
bluefish-2.2.6-2/web/debian {text-editor}{GUI}{X11}: Ein auf ultra-toll und hipp angepriesener HTML- & Co Editor zum Editieren von CSS, HTML, XML, PHP, Perl, Make, Python. Kann auf die Validierungs-Tools csstidy, tidy, weblint und xmllint zurück greifen soweit sie installiert sind. Durch Integration externer Tools und Filter-Kommandos für Textblöcke sowie Parser für Fehlermeldungen kann dieser Editor auch als IDE (allerdings ohne Debugger-Integration) benutzt werden. Des weiteren unterstützt er "Zen Coding", auch als "Emmet" bekannt, welches so eine Art Tab-Completion-basierte Präfix-Expansions-Makrosprache ist. Man tippt also beispielsweise eine Zen-Abkürzung für ein HTML-Konstrukt ein, und der Editor expandiert es in das volle Konstrukt. Bei näherer Betrachtung ist bluefish ein ziemlich normaler Text-Editor, nur dass ihm zahlreiche Buttons und Menüpunkte spendiert wurden die immer nach dem gleichen Prinzip funktionieren: Ein Formularfenster für irgend ein HTML- oder CSS-Konstrukt öffnet sich, man füllt es aus, und als Ergebnis wird das Konstrukt dann als HTML-Text eingefügt. Mit anderen Worten, ein formular-basierter Textgenerator. Das kann sicherlich nützlich für selten benutzte Konstrukte sein da es einem Nachschlagen erspart. Aber Blufish ist kein HTML WYSIWYG-Editor wie man vielleicht erwartet hätte. Er unterstützt einen auch nur beim Neu-Erstellen von Konstrukten - das Editieren bereits bestehender erfolgt konventionell in der Textdarstellung, genau wie man es mit jedem anderen Editor ebenfalls tun könnte. Mir missfallen des weiteren seine Installations-Abhängigkeiten - darunter systemd und zahlreiche andere "Poettering"-Dienste wie udisks2 und gvfs. Zwar muss systemd nicht tatsächlich laufen, aber allein dass es installiert werden muss ist bereits eine Zumutung. Besonders schlank ist bluefish auch nicht gerade, aber das wäre ein geringeres Problem.
bmpanel-0.9.27-r1/x11-misc/gentoo {desktop panel}: Sehr minimalistisches Panel welches Taskbar, Traybar, Workspace Pager und Uhr implementiert. Kein Applikations-Startmenü oder Launch-Buttons. Rechter Mausknopf in Taskleiste minimiert alle Fenster. Alles in einer Zeile (oberer oder unterer Rand, aber immer über die volle Breite). Arbeitet hervorragend mit Openbox zusammen und unterstützt direkt dessen dynamisch erzeugbare Workspaces. Themable: Man kopiert sich /usr/share/bmpanel nach $HOME/.fbpanel und editiert dort the "theme"-Datei welche die Konfiguration enthält. Das Executable hat nur ein Argument: Den Namen des Themes das verwendet werden soll (Default ist "native"). Gesamtinstallation unter 250 KB; das Executable selbst ist gar weniger als 60 KB groß. Hat keine Abhängigkeiten von irgend einem Toolkit, unterstützt aber vernünftig aussehende Fonts mittels libfreetype.
bochs-2.4.5/app-emulation/gentoo: Ein Software-Emulator für alte 8086 bis AMD64 PCs. Unterstützt die CPU-Emulation zwar sehr viel detailgenauer als qemu & Co, leidet aber unter einem schwächlichen Angebot emulierter Hardware. Festplatten-Images (ATA Emulation, kein AHCI bzw. SATA) können das 8,4 GB Limit nicht überschreiten, maximal 2 GB RAM werden emuliert (und auch das nur unter 64 Bit Hosts da sie offenbar als ein zusammenhängender Speicherblock alloziert werden), Cirrus VGA als höchstes aller Gefühle, dazu Floppy Disks, CD-ROM, USB (1.x), paralleler und serieller Port und irgend eine NIC. Für Windows95 Systeme ist das gerade noch ausreichend, aber die Emulation eines modernen Systems scheitert bereits an der lächerlichen Festplattengröße. Irgendwie nicht so wirklich toll. Am sinnvollsten vermutlich wenn man Windows 3.x oder Windows 95 emulieren will, da QEMU hier kläglich versagt. Aber selbst hier kann man wohl auch eben so gut DOSBOX nehmen. Ein Feature von Bochs ist zweifelsohne der eingebaute Debugger, doch der ist nur sehr simpel und kann dem gdb nicht das Wasser reichen. Allerdings gibt es eine Build-Option "gdbstub" für Bochs, und dann kann man einen GDB mit dem Bochs verbinden wie unter qemu - doch leider erst ab Version 2.6 die bei mir wegen Abhängigkeiten derzeit nicht installierbar ist. Bochs ist sehr portabel und läuft auf einer Vielzahl von Plattformen, er bietet auch ein wxWidgets-basiertes GUI (neben anderen) für die Anzeige der Video-Ausgabe/Console.
borgbackup-1.0.9-1/admin/devuan borgbackup-1.1.16-3/admin/debian {backup}{deduplication}{FUSE}: Ein Backup-Programm mit Fokus auf Deduplikation. Es bringt auch ein FUSE-basiertes Pseudodateisystem mit, mit dem man den archivierten Inhalt von Backups mounten kann als wären sie ein normales Dateisystem. Es nutzt SHA-256 zur Erkennung von Datenfehlern und Manipulationsversuchen. Keine Fehlerkorrektur. Weiters kann es zwar AES-256 zur Verschlüsselung benutzen, aber man kann das auch abschalten (etwa wenn man AES ohnehin nicht traut). Das gefällt mir. Anders als restic kann BorgBackup die zerhackten Datenblocks welche nach der Deduplizierung übrig bleiben auch noch komprimieren. Ich kann mich zumindest nicht erinnern gelesen zu haben dass restic dies ebenfalls könnte. Ein Problem könnte sein dass BorgBackup in "C/Cython" geschrieben ist - es wird daher langsamer als das in Go implementierte restic sein. Vor allem aber dazu braucht man eine installierte Python-Umgebung damit man es starten kann - das könnte in einer initramfs-Umgebung schwierig bzw. aufwändig werden. Außerdem, etwas ulkig, kann BorgBackup keine gehardlinkten Symlinks backuppen. Damit könnte ich allerdings wohl leben... Was ich leider nicht finden konnte, war ein Hinweis darauf was die Mindestgröße zerhackter Blocks für die Deduplikation ist. Es *könnte* daher sein dass BorgBackup kleinere Dateien besser deduplizieren kann als restic oder zbackup - oder auch nicht. Man muss es wohl ausprobieren. Ein definitiver Nachteil von BorgBackup ist dass die Metadaten des Backup-Archivs aus irgend einem Grund auf 8 GB beschränkt sind. Damit kann man angeblich rund 500.000 Dateien backuppen. Allerdings verrät mir "locate -S", dass allein auf meinem Desktop-System momentan 1,2 Millionen Dateien in rund 110.000 Verzeichnissen vorhanden sind (Stand 2019). D. h. das wäre bereits zu viel für BorgBackup. Zumindest wenn man alles in einem einzigen Backup-Archiv sichern wollte. BorgBackup bringt daher gute Ideen mit, scheitert aber in den meisten Fällen wohl an Limits der Implementation und ist nur für eher kleinere Datenbestände als Backup geeignet. Update 2022: Es unterstützt Hardlinks, Symlinks, FIFOs, character/block Device Nodes, Ownership, POSIX Permissions, ACLs, Timestamps mit Nanosekunden-Auflösung, sogar Entstehungszeit (bei jenen Dateisystemen die so etwas unterstützen). Darüber hinaus unterstützt es plattformabhängig auch Extended Attributes und (ausgewählte) dateisystemspezifische Dateiattribute. Unter Linux wird dies alles unterstützt. Sparseness wird nicht unterstützt. Dem zusätzlichen Platzbedarf wird nur mit der Kompression begegnet. Dennoch dürfte es ein Problem werden, ein 8 Exabyte großes Sparse File zu backuppen (etwa einen sparse Dateisystem-Container für eine VM), selbst wenn darin nur 1 Byte an Nutzdaten tatsächlich belegt sind. Es kann lokal oder Client-Server-basiert arbeiten; in letzerem Fall erfolgt die Verschlüsselung am Client. Zusätzliche Komprimierung ist ebenfalls möglich, und zwar "lz4" (sehr schnell; standardmäßig ausgewählt), "zstd" (variabel), "zlib" (schnell), "lzma" (langsam) und "none" (unkomprimiert). BorgBackup scheint ähnliche Probleme wie btrfs zu haben wenn ihm der freie Platz um Backup-Verzeichnis ausgeht: "[...] please make sure that there is always a good amount of free space on the filesystem that has your backup repository (and also on ~/.cache). A few GB should suffice for most hard-drive sized repositories [...] If Borg runs out of disk space, it tries to free as much space as it can [...] This mechanism is not bullet-proof in some circumstances. If you really run out of disk space, it can be hard or impossible to free space, because Borg needs free space to operate - even to delete backup archives." Sehr aufbauend... Weiters: "Avoid to create a mixup of users and permissions in your repository (or cache). This can easily happen if you run borg using different user accounts (e.g. your non-privileged user and root) while accessing the same repo" und "Borg does not do anything about the internal consistency of the data it backs up. It just reads and backs up each file in whatever state that file is when Borg gets to it." Andererseits gelten vergleichbare Beschränkungen auch für etliche andere Backup-Programme, wie etwa rdiff-backup. Es können beliebig viele Backups ("Archives" genannt) in einem Backup-Directory ("Repository" genannt) gespeichert werden soweit der Platz reicht (siehe oben). Um das Platz-Management zu erleichtern gibt es ein Kommando das alte Backups löschen kann. Dazu muss man aber das Backup nicht explizit benennen, sondern man kann statt dessen angeben wie viele der letzten Backup für verschiedene Intervalle behalten werden sollen: tägliche, wöchentliche und monatliche Backups. Wenn man Verschlüsselung aktiviert hat, gibt es mehrere Methoden das Passwort bereit zu stellen. Direkt eine Umgebungsvariable (unsicher), einen Dateideskriptor, oder durch die Ausführung eines Kommandos welche einer Umgebungsvariable entnommen wird und als Ergebnis die Pass Phrase zurück liefert. Binäre Schlüsseldateien werden nicht unterstützt. Bereits erstellte Backups können entweder relativ zum aktuellen Directory restored werden, oder man kann sie als FUSE-Dateisystem mounten und somit einfach auf den gesicherten Dateibestand eines bestimmten Backups zugreifen. In einem Testlauf mit Standardeinstellungen für ein 5,5 GB großes unkomprimiertes TAR-Archiv voller Quelltexte benötigte BorgBackup knapp über 2 Minuten für die Sicherung. Das Ergebnis war ein 1 GB großes Backup-Archiv. Dabei wurden ungefähr 10 % der Originaldaten durch Deduplizierung eingespart, den Rest nur durch die Default-Kompression (lz4). Zu diesen Einsparungen sei angemerkt, dass die Quelltexte im Original in Form mehrerer *.tar.gz Dateien mit einer kombinierten Gesamtlänge von knapp über 500 MB vorlagen. Oder anders formuliert, BorgBackup komprimiert mit Standardeinstellungen trotz zusätzlicher Deduplizierung nur halb so viel wie tar + gzip. BorgBackup hat ein paar Ansprüche an das Dateisystem auf welchen Backup-Repositories liegen können. Sie sollten Hardlinks unterstützt werden (sie sind zwar nicht zwingend nötig da das Programm in diesem Fall "versucht" ohne sie auszukommen, doch es bleibt offen was geschieht wenn ihm dies nicht gelingt), lange Dateinamen müssen unterstützt sein, zumindest 1000 Dateien pro Directory möglich sein, und Dateien mit mehr als 2 GiB Größe. Letzteres zwar nur für "große" Repositories, doch wird nicht erklärt was "groß" bedeutet. Auf jeden Fall scheint es, dass man besser kein VFAT-, UDF- oder Minix-Dateisystem für Repositores verwenden sollte. ExFAT funktioniert vermutlich, aber es ist unklar wie stabil. Anders als viele andere Programme geht BorgBackup mit Einheiten bei der Anzeige um: RAM wird in binären Einheiten angegeben, Massenspeicher in dezimalen Einheiten. Überdies schreibt es die Einheiten auch immer dazu, so dass man nicht raten muss. Datum wird immer in internationaler YYYY-MM-DD Schreibweise angezeigt, und Zeit immer im 24-Stunden Format. Auch daran gibt es nichts zu auszusetzen. Borg nutzt derzeit (2022) nur eine CPU. Ein Problem dürfte der RAM-Bedarf werden. Das Programm lädt sowohl einen Index aller Chunks aller Backups als auch aller Dateien (wenigstens nur vom letzten Backup) in den RAM. Je größer das Repository wird, desto größer wird beides. Bei Client-Server-Betrieb lädt zusätzlich der Server zumindest den Index aller Chunks aller Backups in den RAM. Die erwähnten Chunk- und File Indizes werden zudem in ~/.cache abgespeichert, so dass der Platzbedarf dort noch einmal gegeben ist. Wenn man FUSE zum Mounten von Backups benutzt, kommt zu all dem noch zusätzlich der Speicherbedarf aller deduplizierten kleinen Chunks in /tmp hinzu. Man kann allerdings die Ablageorte aller Temporärdateien mittels Umgebungsvariablen auf andere Verzeichnisse umlenken. Dennoch entstand bei mir der Verdacht, dass BorgBackup nicht nur relativ viele Temporärdateien benutzt, sondern vor allem auch der RAM-Bedarf ausufern könnte. Bei der Integritätsprüfung gibt es 4 Varianten: Gar keine, SHA-256, BLAKE2b oder AES/AEAD (wobei die Dokumentation nicht verrät welche AEAD-Konstruktion zum Einsatz kommt - ich vermute AES-GCM). Ob diese Varianten zur Sicherstellung der Authentizität geeignet sind, wage ich zu bezweifeln. Denn diese Maßnahmen scheinen nur auf Chunk-Ebene angesiedelt zu sein, und könnten daher Opfer von Replay-Attacks werden. Zur Erkennung unbeabsichtigter Datenkorruption sind sie hingegen sicherlich geeignet. Aber auch die Benutzung der Temporärdateien könnte ein Sicherheitsproblem darstellen, da unklar ist ob diese erst in verschlüsselter Form angelegt werden oder noch davor. Definitiv werden unverschlüsselte Inhalte in ~/.cache angelegt, daher sollte man dieses Verzeichnis definitiv mittels $BORG_CACHE_DIR in ein verschlüsseltes Temporärverzeichnis umlenken. Ebenso kann man mit $TMPDIR die Verwendung von /tmp umlenken, was aber eher als Platzgründen nötig werden könnte wird da /tmp meistens ein tmpfs ist und somit tatsächlich im RAM liegt, der durch die erwähnten Index-Dateien ohnehin schon sehr belastet wird. Es gibt Metadaten-Ressourcen-Limits welche die maximale Größe eines Backups beschränken, aber "normalerweise" sollen 10-100 Millionen Dateisystemobjekte im Backup kein Problem sein. Immerhin kann man mit "borg info" anzeigen lassen, was die aktuellen Werte und die unterstützten Maximalwerte sind. Zumindest angeblich. Ich konnte diese Angaben jedenfalls nicht aus der Ausgabe heraus lesen. Schließlich machte ich einen Testlauf mit einem bereits vorhandenen Repository von rdiff-Backup mit nicht ganz 3 Dutzend inkrementeller Backups, das meiste davon Office- und PDF-Dokumente (also in der Regel eher nicht so gut komprimierbar). Ich extrahierte alle Versionen und reproduzierte sie in BorgBackup. Jede Version enthielt so um die 85 MB in 700 Dateien, und das Übertragen einer Version nach BorgBackup dauerte rund 3,5 Minuten. Da darin jedoch auch der Rechenaufwand für das Extrahieren aus dem FUSE-Dateisystem von rdiff-backup enthalten ist, wird BorgBackup vermutlich nur rund die Hälfte der Zeit davon benötigt haben. Der Vergleich der Repository-Größen im Anschluss ergab: BorgBackup - 409 MB, rdiff-backup - 417 MB. Wobei BorgBackup hier auch den "unfairen" Vorteil hatte, das verschobene oder umbenannte Dateien nicht erneut gespeichert werden müssen. Zumindest bei Archivgrößen so um die 100 MB hat BorgBackup jedenfalls noch keine Kapazitätsprobleme. rdiff-backup ist dann etwas schlechter, aber nur wenig. Vor allem aber hat es nicht so ausufernden Ressourcenbedarf. Genauer gesagt sind mir überhaupt keine Limits bekannt, abgesehen natürlich von ausreichend Platz am Datenträger für neue Backups. Und selbst dabei bietet rdiff-backup noch den Vorteil dass das Löschen von wegen zu wenig Platz abgebrochener Backups dort immer möglich ist. BorgBackup cached auch Metadaten wie Dateigröße und Änderungsdatum aus den Backups über einen längeren Zeitraum (20 Tage per Vorgabe; anpassbar). Dies wird genutzt, um sich bei weiteren Backups welche in dieser Zeit gemacht werden das zeitaufwändige "Chunken" zu ersparen, und die gesamte Datei als Duplikat zu betrachten. Macht man nur sehr selten Backup, wird dieser Cache nicht ausreichen und sogar sinnlos sein, und jedesmal alle Dateien neu "gechunked" werden. Wegen der anschließenden Deduplikation sollte das zwar zu keinem größeren Platzbedarf führen, jedoch sehr wohl zu deutlich langsameren Backups. BorgBackup funktioniert gut solange die Datenmenge im Repository nicht zu groß wird. Es benötigt dann vor allem immer mehr RAM, hat aber auch grundsätzliche Limits die bei großen Datenträgern im Multiterabyte-Bereich leicht überschritten werden können. Es geht sorglos mit verschlüsselten Daten um, und wenn man keine Maßnahmen trifft um dies zu verhindern speichert es fröhlich geheime Daten in allgemein zugänglichen Temporärverzeichnissen wo Angreifer dann später deren Überreste erbeuten können (etwa mit diversen "undelete"- und Disk-Scraping Tools). Meine Einschätzung: Bis auf Fälle wo besonders oft Dateien umbenannt oder verschoben werden, ist es rdiff-backup in nahezu jeder Hinsicht unterlegen. Fazit: BorgBackup funktioniert gut im kleinen Maßstab. Unbrauchbar für große Datenträger. Die gepriesene Deduplizierung kann nur 10 % einsparen (ohne die zusätzliche Kompression einzurechnen). Zumindest in einem Full Backup. Bei inkrementellen Backups bringt die Deduplizierung hingegen natürlich schon einiges. Allgemein scheinen mir beide Programme annähernd ausgeglichen zu arbeiten: Das was BorgBackup bei Umbenennungen und Verschiebungen zusätzlich durch Deduplikation einsparen kann, kompensiert rdiff-backup durch die größere Platzeffizienz von Deltas. Bei kleinen Datenmengen ist BorgBackup im Vorteil (so um die 2 % geringerer Platzbedarf zumindest in meinem Test). Je größer die Datenmenge aber wird, desto mehr verschieben sich die Vorteile dabei in Richtung rdiff-backup. Allein schon weil BorgBackup mehr Ressourcen verschlingt, vor allem RAM, und daher schlecht skaliert.
bovo-4.3.1/kde-base/gentoo: Nette GOBANG-Implementation für KDE, a.k.a. "5 in einer Reihe". Verschiedene Styles, darunter auch ein "Papierzettel-Style". Frei skalierbare Fenstergröße.
bsd-mailx-8.1.2-0.20160123cvs-4/mail/devuan: Stellt ein POSIX-kompatibles "mailx"-Kommando zur Verfügung... und sonst nichts. Mit diesem mailx kann man die /var/spool/mail/-Mailbox des aktuellen Benutzers sowie in privaten Dateien gespeicherte e-Mails lesen, erstellen und bearbeiten. Das Programm wurde sogar erweitert so dass es nun direkt auf POP-Server zugreifen kann - jedoch wie es scheint ohne TLS-Support und daher dieser Tage wohl nutzlos. Für das Versenden neuer Mails ist außerdem nach wie vor ein zusätzliches "sendmail"-Programm erforderlich, selbst wenn die Mail nur an andere lokale Benutzer ergeht. Siehe dazu auch das "dma"-Paket.
bsdgames-2.17-28/games/debian {game}: Die klassische Standard-Spielesammlung von BSDs. Nur terminalbasierte Spiele. Etliche davon sind aber gar keine Spiele, sondern eher "Spielereien". Wiederum andere durchaus nützliche Hilfsprogramme. Angesichts der zahlreichen enthaltenen Programme eine durchaus vertretbare Größe: 2,5 MB Installationsumfang, Download rund 1 MB. "arithmetic": Üben der 4 Grundrechenarten. "atc": Fluglotsen-Simulation. "backgammon": Das klassische Spiel gleichen Namens. Computergegner. Mit optionalem Tutorial. "battlestar": Ein in den Tropen angesiedeltes klassisches Textadventure. "bcd": Zeigt an wie Text auf Lochkarten gedruckt würde. "boggle": Möglichst viele Worte aus einem im Spiel enthaltenen Wörterbuch unter Zeitbegrenzung in einem quadratischen Raster finden. Die Buchstaben der Worte können sich dabei beliebig in 90 Grad-Schritten "schlängeln". "bsdgames-adventure": Ein weiteres Textadventure. Das berühmte "Colossal Cave"-adventure, in dem es darum geht eine Höhle zu erforschen und Schätze in ihr zu finden. "caesar": Alias für "rot13". "canfield": Das bekannte Kartenspiel Solitaire. In reiner Textdarstellung! Man spielt hier außerdem um Geld. Wenn auch nur um virtuelles. "countmail": Zeigt die Anzahl der Mails in der lokalen UNIX-Mailbox an, und kommentiert dies "lustig". "cribbage": Ein weiteres Kartenspiel. Immerhin werden die Karten anders als beim Solitaire-Klon zumindest als ASCII-Grafik optisch dargestellt. "dab": Das klassische "Kästchen-beenden"-Spiel. Die Spieler ziehen abwechselnd je eine Linie zwischen zwei benachbarten Kreuzungspunkten auf kariertem Papier nach. Wer dabei den letzten Strich eines Rechtecks setzt, gewinnt einen Punkt und bleibt am Zug. Computergegner. "go-fish": Ein weiteres Kartenspiel, reiner Text. Angeblich irgend eine bei Kindern beliebte Variante. Es geht irgendwie darum gleichartige Karten zu sammeln. Hat aber auch einen Profi-Modus wo es deutlich schwerer wird. "gomoku": Das klassische "5 in einer Reihe"-Spiel auf einem 19x19 Raster. Alle Varianten: User oder Computer vs. Computer oder User. "hack": Eine Variante des klassischen "Rogue" bzw. "nethack". Man erforscht bzw. durchkämpft (allein, kein Netzwerk-Spielmodus) einen zufalls-generierten Dungeon aus über 20 Ebenen, der mit Monstern, Schätzen etc. gefüllt ist. Der Dungeon wird dabei als ASCII-Grafik dargestellt. Alt, aber immer noch unterhaltsam. "hangman": Das klassische "Galgen"-Spiel. Man muss die Buchstaben eines Wortes erraten bevor einem die gewährten Versuche ausgehen und man "gehängt" wird. "hunt": Ein ausschließliches Multiplayer-Spiel, wo verschiedene Spieler in einem zufalls-generierten Labyrinth gegen einander kämpfen. Funktioniert im Netzwerk, aber auch am selben Rechner wenn mehrere Spieler gleichzeitig in diesen eingeloggt sind. Es gibt keine Monster, Schätze oder Computer-Gegner, jedoch findet man Waffen um sie  gegen die anderen Spieler einsetzen zu können. Es können scheinbar beliebig viele Spieler im selben Spiel mitspielen, und überdies Teams bilden. Im Grunde ein typischer Multiplayer-Shooter, nur mit ASCII-Grafik und in 2D. "huntd": Der Server-Daemon für "hunt". Er lauscht standardmäßig auf einem fixen nicht-privilegierten UDP-Port (kann jedoch auch frei gewählt werden), und alle Spieler die im selben Labyrinth gegen einander antreten wollen müssen sich zu diesem Port verbinden können. "mille": Noch irgend so ein Kartenspiel. "monop": Das klassische "Monopoly"-Spiel. Reiner Text. Für 1-9 Spieler. "morse": Zeigt an wie Text auf im Morse-Code aussehen würde, oder decodiert solchen. "number": Schreibt Zahlen, auch sehr große, als Worte aus. Leider nur in Englisch. "phantasia": Ein klassisches Multiplayer-Rollenspiel. Mit Magie, Monstern und allem. Einziges Problem: Es gibt keinerlei grafische Darstellung, nicht einmal als ASCII-Grafik. Statt dessen muss man seine Bewegungen als Koordinaten eintippen. Stammt offenbar noch aus den Zeiten als es keine Bildschirme gab und Endlos-Druckerpapier die einzige und zudem vergleichsweise teure Ausgabemöglichkeit war. "pig": Übersetzt Text in "Schweinesprache". Nur die englische Variante. "pom": Berechnet die aktuelle Mondphase und zeigt diese an. Man kann aber auch ein bestimmtes Datum angeben. Sowohl als Text als auch als Prozentwert. "ppt": Zeigt an wie Text auf Lochstreifen gedruckt würde, oder decodiert solchen. "primes": Berechnet alle Primzahlen in einem gewählten Zahlenbereich oder ab einem bestimmten Startwert, und zeigt sie an. Optional wird auch die Differenz zur letzten Primzahl angezeigt. Ausgabe dezimal oder optional hexedezimal. Leider kann man damit keine beliebig großen Zahlen berechnen - der Zahlenbereich ist auf unter 62 Bit beschränkt. "quiz": Ein "Wissens"-Quiz. Man wählt ein Thema und der Computer stellt einem bestimmte Fragen aus einem Katalog. Weiß man die korrekte Antwort, gibt es Punkte. Für völlige Trotteln die sich den ganzen Tag lang im Fernsehen Quiz-Shows reinziehen, und dann immer noch nicht genug davon haben und es auch am Computer spielen möchten. "rain": Zeigt Regentropfen als ASCII-Grafik an, die am Terminal-Bildschirm "aufschlagen" und wieder vergehen. Simpel und völlig sinnlos, aber ich fand es irgendwie beruhigend dem "Regen" eine Weile zuzusehen. Man kann die Verzögerung zwischen den Animations-Phasen wählen. 300 ms haben sich dabei sich als geeignet erwiesen. In der Voreinstellung geschieht die Ausgabe zu schnell so dass man nichts mehr erkennen kann. "random": Kann entweder als Filter arbeiten, wo es jede Zeile des Eingabetextes mit einer gegebenen Wahrscheinlichkeit (Vorgabe: 50 %) entweder durchlässt oder verwirft. Alternativ kann es eine Zufallszahl von 0 bis zu einer gewählten Größe direkt als Return-Wert ausgeben, so dass man dies danach in einem Script verwenden kann. Ein durchaus durchdachtes Benutzungskonzept. Leider sind die erzeugten Zufallszahlen von eher mittelmäßiger Qualität: Es setzt auf den Standard-Zufallsgenerator von C, den es mit der aktuellen Uhrzeit/Datum initialisiert. Folglich keine große Entropie, und daher für sicherheitskritische Anwendungen oder statistische Auswertungen von hoher Güte völlig ungeeignet. Für normale Anwendungen sollte es aber gut genug sein. Außerdem entzieht es dem System keine Entropie, da es weder von /dev/random noch von /dev/urandom Gebrauch macht. "robots": Ein weiterer Klassiker. Anfänglich werden mehrere Roboter und der Spieler zufällig auf einem Spielfeld (ASCII-Grafik) positioniert. Der Spieler muss nun alle Roboter zerstören indem er sie dazu bringt zusammen zu stoßen bevor sie ihn berühren können. Die Roboter gehen dabei immer möglichst geradlinig auf den Spieler zu. Kann der Spieler keine Bewegungen mehr Ausführen ohne von einem Roboter berührt zu werden, kann er teleportieren. Doch das ist gefährlich weil man dabei eben so gut direkt neben einem Roboter landen könnte. "rot13": Verschiebt bzw. rotiert alle Buchstaben im Text um 13 Positionen im Alphabet. Eine extrem simple Form der Verschlüsselung. Angeblich kann man auch einen bestimmten Verschiebungswert angeben, doch bei meiner Variante wurde solche eine Angabe komplett ignoriert. "sail": Die Echtzeit-Simulation eines Seegefechts zwischen Segelschiffen. Mit Wind, Kanoneneinsatz etc. Erscheint durchaus anspruchsvoll. 2D ASCII-Grafik. Man kann damit entweder gegen den Computer oder gegen andere Spieler kämpfen. Das Programm ist Client und Server in einem. Die Kommunikation zwischen Server und Clients erfolgt dabei über eine Datei. Das funktioniert zwar für lokale Benutzer, aber in wie weit aus auch über Netzwerkfreigaben funktionieren kann sei einmal dahin gestellt. "snake": Eine unübliche Variante des Klassikers: Man steuert die Schlange nicht selbst, sondern soll nur Schätze einsammeln ohne sich von der Schlange welche vom Computer gesteuert wird berühren zu lassen. ASCII-Grafik. Ohne Hektik: Die Schlange bewegt sich nur dann um eine Bewegung, wenn man auch selber eine Taste drückt um sich zu bewegen. "tetris-bsd": Das klassische "Tetris"-Spiel. Echtzeit. Allerdings nur in S/W. Farbe ist für das Spiel allerdings auch völlig unnötig, selbst wenn man es von grafischen Implementationen her gewöhnt ist. "trek": Star-Trek Kampf-Simulation. Das ganze Spiel wird durch Texteingaben gesteuert; es handelt sich um kein Echtzeit-Spiel, sondern alles spielt sich Zug um Zug ab. Also keine Hektik. Alles findet nach klassischer BASIC-Manier damaliger Spiele auf einem Raster statt, das aus 8 x 8 Quadranten mit je 10 x 10 Sektoren besteht. Sektoren sind auch die kleinsten angezeigten Einheiten auf der Karte, de facto die Spielfelder, obwohl man sich eigentlich Fließkomma-genau bewegen kann. Die Anzeige der Karte erfolgt nicht automatisch sondern nur per Kommando, kostet aber zumindest keine Ressourcen in der Simulation. Es gibt einen Nahbereichs-Scan für den aktuellen Quadranten, einen Weitbereichs-Scan der die angrenzenden Quadranten nur grob erfasst, sowie eine Karte in der die historischen Scan-Ergebnisse vermerkt bleiben, selbst wenn man sich längst aus deren Scan-Bereich entfernt hat. Das Ziel scheint es zu sein alle klingonischen Schiffe in den Sektoren zu zerstören. Man hat dazu Phaser und Torpedos, schützt sich mit Schilden, und muss den Energiebedarf beim Warp-Flug im Auge behalten. Getarnte Klingonen-Schiffe stellen eine zusätzliche Gefahr da. Reparaturen kosten Zeit, und man hat nur begrenzte Zeit zur Erfüllung der Mission zur Verfügung. Zum Glück ist der Schwierigkeitsgrad wählbar. "wargames": Eine dümmliche Idiotie, welche nur fragt ob man ein Spiel spielen will, und dann in jedem Fall denselben bekannten Text aus dem gleichnamigen Filmklassiker ausgibt. "worm": Das klassische "Snake"-Spiel (im Gegensatz zum zuvor erwähnten). Hier steuert man die Schlange selbst, die Leckerlis fressen muss und dabei weder in ihren eigenen Schwanz laufen darf der durch das Fressen immer länger wird, als auch keine Wände oder sonstige Hindernisse wie Gegener oder Gifte berühren. Auch diese Variante ist rein zugbasiert, die Schlange bewegt sich nur wenn man eine Taste drückt. Daher auch hier kein Zwang zur Hektik. "worms": Zeig mehrere Schlangen aus verschiedenen ASCII-Zeichen an, die sich zufallsbasiert über den Bildschirm schlängeln. Genau so wenig Sinn wie "rain", aber auch irgendwie entspannend zu betrachten wenn man die richtige Geschwindigkeit wählt. Ich fand 50-100 Millisekunden eine gute Einstellung. Mit den Standardwerten ist allerdings auch dieses Programm unbrauchbar, a die Schlangen sich dann viel zu schnell bewegen. "wtf": Ein simples Nachschlageprogramm für Akronyme wie "ROTFL", die in Chats oder auch allgemein im Computerbereich geläufig sind. Ähnlich wie "dict", nur dass die Daten hier von keinem Server kommen sondern in zwei unveränderlichen mitgelieferten Listen mit zusammen rund 2000 Akronymen gesucht werden. Man kann optional aber auch eine eigene solche Liste (simple Textdatei, in jeder Zeile ein Akronym gefolgt von seiner Definition) durchsuchen lassen. "wump": Noch so ein uraltes Text-Spiel: "Fang den Wumpus". Aus dem Jahr 1973. Hirnlos bis nervig da zuviel Zufall im Spiel ist und man kaum eine Chance hat länger zu bestehen. Keine Grafik, man gibt nur Befehle ein. Grundsätzlich bewegt man sich durch ein System von symmetrisch mit einander verbundenen Räumen, und soll dabei mit Pfeil und Bogen ein Monster, den "Wumpus", erlegen. Dabei muss man sich vor Fallen und Fledermäusen hüten, sowie natürlich auch dem Monster selbst. Weitere Programme welche im Quelltext des Pakets enthalten sind, jedoch aus dem Debian-Binärpaket entfernt wurden: "banner" (Druck-Banner erzeugen), "dm" (Rechteverwaltung welche Spieler die Spiele benutzen dürfen), "factor" (faktorisiert Primzahlen - beliebig große wenn der Support für die libopenssl aktiviert wird, ansonsten nur bis zu 2 GB große), "fortune" (zeigt zufällig irgendwelche Zitate, Kurze Stories oder vermeintliche Weisheiten aus einer rund 2 MB großen Liste an).
bsdiff-4.3-21/utils/debian bsdiff/dev-util/gentoo {binary-diff}{compression}{deduplication}: Das laut Google-Angestellten beste Tool zur erzeugen binärer Patches für ausführbare Dateien, ohne spezielles Wissen über das verwendete Binärformat vorauszusetzen. Erzeugt aber auch bei Textdateien, etwa nachdem man komplette Verzeichnisbäume von verschiedenen Projektversionen mit sortierten Pfadnamen der Quelltexte in ein cpio-Archiv geschrieben hat, beeindruckend kleine Deltas. Ein Nachteil ist die Geschwindigkeit - es ist das langsamste aller diff-Tools. Und es belegt auch sehr viel RAM - ca. das 20-fache der Größe der alten Datei (von welcher das Delta zur neuen erzeugt werden soll). Das von bsdiff erzeugte Delta verwendet intern offenbar bzip2-Kompression und lässt sich nicht mehr weiter verkleinern. Eine Option zum unkomprimierten Speichern des Deltas gibt es nicht. Überhaupt hat keines der mitgelieferten Programme (bsdiff und bspatch) irgendwelche Optionen. Ruft man sie ohne Argumente auf gibt es eine einzeilige Usage-Hilfe - mehr braucht man nicht zu wissen. In Sachen Benutzungskomfort und geringstmöglichem Einlernaufwand daher schwer zu übertreffen.
btfs-2.12-1/utils/debian {FUSE}: Ein simpler Bittorrent-Client für on-demand Download von den tatsächlich benutzten Teilen eines Bittorrents. Man gibt einfach eine torrent-URL oder einen Magnet-Link als Argument an, und btfs lädt den Torrent herunter und öffnet ihn als virtuelle Read-Only Sicht (zumindest nehme ich dies an) auf die darin enthaltenen Dateien und Unterverzeichnisse. Erst sobald man auf eine der Dateien tatsächlich zugreift, wird ihr Inhalt im Hintergrund herunter geladen. Insbesondere man man so Videos ansehen, die noch gar nicht komplett herunter geladen wurden während man mit der Wiedergabe beginnt (vorausgesetzt der Download liefert die benötigten Daten mindestens so schnell wie sie abgespielt werden).
buffer-1.19-11/utils/debian: Ein Programm zum Re-blocking eines Datenstroms. Kann auch Pausen zwischen den Blocks einlegen. Leider ist die Größe eines Blocks auf 1 MiB beschränkt, somit taugt es nur für Tapes und dergleichen, aber für keine "normalen" heutigen Transfer-Größen.
bum-2.5.2-1/admin/debian {service manager}: A GTK+ based run-level editor. Ebarrisingly slow, and obviously gigantic resource overhead! No idea what for. And it does not even recognize all installed services. Forget it.
bumprace-1.5.4-3+b1/games/devuan {game}: Ein nettes "Thrust"-ähnliches "erreiche den Ausgang ohne wo dagegen zu krachen"-Spiel. Die Levels scrollen allerdings anders als im Original nicht sondern sind immer zur Gänze am Bildschirm zu sehen. Die meisten Level haben daher einen Labyrinth-artigen Character. Im wesentlichen muss man verhindern gegen Wände zu krachen, nicht ins Laserfeuer zu geraten und ähnliches. Manchmal muss man auch Teleporter nutzen. Ganz nett gemacht, aber geringe Langzeit-Motivation.
burgerspace/games-arcade/gentoo {game}: Die SDL-Konvertierung des klassichen Burgertime-Spiels. Man baut einen Burger, indem man auf den durch Leitern verbundenen Plattformen die Zutaten durch die Böden/Siebe presst. Dabei wird man von Würstchen und anderen Zutaten attackiert, die man durch die herabfallenden Zutaten erschlagen kann, oder durch Pfeffer kurzzeitig lähmen. Man muss alle Burger schnell genug fertig haben bevor einen die Jäger erwischen. Schafft man dies, kommt man ins nächte Level. Sehr nett gemacht, aber ich finde es frustrierend schwer obwohl es sehr originalgetreu optisch umgesetzt ist.
bwbasic-2.20pl2-11+b2/interpreters/devuan {programming language}: Ein schlanker BASIC-Interpreter. Download 77,4 kB. Neben dem eigentlichen Interpreter (163 kB) liegt noch ein Programm (14 kB) zum Renummerieren von BASIC-Zeilennummern bei (das allerdings eher witzlos ist da es nicht in der Lage ist vorhandene Verweise auf Zeilennummern mit anzupassen). Die man-Page erläutert wider Erwarten die gesamte Sprache - sogar mit separater Schnellübersicht. Eigentlich vorbildlich, vor allem bei der geringen Download-Größe! Zu allem Überfluss sind auch noch 170 kB an Beispiel-Programmen enthalten, die wichtige Konzepte verdeutlichen welche die man-Page nicht ausführlich genug erläutert. (Im 77 kB-Download sind tatsächlich fast 400 kB Dateien enthalten. Das nennt man effektive Kompression!) Weiters kann man mit dem Interpreter nicht nur bereits fertige Programme als Scripte ausführen, sondern erhält sogar eine Interaktive Shell, wo man in klassischer Manier seine Programm eingeben und editieren kann. Commandline-History hat sie zwar keine, aber die kann man trotzdem bekommen wenn man wenn man rlwrap installiert und bwbasic mit diesem aufruft. Mit dem EDIT Kommando kann das aktuelle Programm auch mit jedem externen Editor bearbeitet werden. Die BASIC-Shell reicht überdies all ihr fremden Befehlen an die UNIX-Shell durch, so dass man auch die üblichen Shell-Befehle aus der BASIC-Shell heraus nutzen kann ohne diese verlassen zu müssen. Das BASIC selbst hat auf den ersten Blick alle Befehle des "klassischen" BASICs, von nicht-portablen Elementen wie PEEK & POKE einmal abgesehen. Zeilennummern sind optional, und man kann statt dessen auch Labels (Name gefolgt von Doppelpunkt) als Sprungziele angeben. Doppelpunkte separieren aber auch mehrere Statements pro Zeile; es ist etwas unklar wie dies von Labels unterschieden wird, funktioniert jedoch. Überdies stehen zusätzlich "strukturierte" Varianten der Kontrollstrukturen zur Verfügung (IF/ELSE/ELSEIF/END IF, SELECT/CASE, DO/WHILE/LOOP, ...), und es gibt neben GOSUB auch DEF FN, FUNCTION und SUB (vermutlich ähnlich wie in QBASIC/VB). Dateizugriff mit den üblichen BASIC-Befehlen dafür ist gegeben, inklusive "record"-befehlen (FIELD, RSET, LSET, GET #) und auch PRINT USING. ON ERROR und ON ... GOTO fehlt ebenfalls nicht. An Datentypen gibt es DBL, INT, SNG, STR. Mit dem SYSTEM-Befehl kann man aus dem BASIC-Programm heraus externe Befehle ausführen. Alles in allen ein sehr komplettes BASIC, das alles für die Verarbeitung von Dateien bietet. Allerdings hat es keinerlei Multimedia-Befehle eingebaut, und bestenfalls LINE INPUT mit Prompt-Möglichkeit könnte man als so etwas ähnliches betrachten. Etwas seltsam ist dass bei Variablennamen Groß/Kleinschreibung signifikant ist, sonst aber bei nichts (inklusive Labels). Mir fiel auch auf dass man die Tokens durch Leerzeichen trennen muss, "Zusammenkleben" wie in damals üblich wird nicht unterstützt. Fürs Debugging gibt es tracing mit TRON/TROFF. Mehrdimensionale Arrays inklusive OPTION BASE werden unterstützt, nicht jedoch MAT-Befehle. Es scheint nur DIM, aber kein REDIM zu geben. Mit CHAIN können andere BASIC-Programme als Overlays geladen werden, die mittels COMMON Variablen auch Werte austauschen können. LOAD, SAVE und MERGE gibt es auch. Fazit: Ein guter Funktionsumfang für die kleine Größe; es enthält alles was man von einem klassischen BASIC erwartet und sogar noch einiges darüber hinaus. Für minimalistische Systeme durchaus eine ernsthafte Alternative zu C, Python, Perl. Außerdem am meisten kompatibel zu klassischen BASIC-Dialekten.
bzflag/games-action/gentoo {game}: Panzer gegen Panzer. Simple aber saubere 3D-Grafik. Besonderheit ist dass das Spiel und seine Regeln besonders ausbalanciert wurden, damit man keine Schwächen des Spiels ausnutzen kann um unfaire Vorteile zu erwerben. Dafür gibt es eine Unzahl bekannter taktischer Tricks und Strategien, die man erlernen kann um dennoch besser als andere zu sein. Kein hirnloses Ballerspiel, aber es kommt durchaus spannende Action auf. Nur im Multiplayer-Modus sinnvoll, obwohl es "Bots" gibt und man zum üben auf einen eigenen lokalen Server mit Bots starten kann. Besonders interessant sind die Team-Missionen. Es gibt im Internet eine große Fan-Gemeinde mit zahlreichen Game-Servern. Auch für die LAN-Party gut geeignet. Einzig die Schlichtkeit der Grafik mag ein negativer Punkt sein. Aber dadurch können auch schwächere Rechner ohne tolle 3D Karte das Spiel noch spielen.
cairo-clock-0.3.3/x11-misc/gentoo: Funktioniert nur mit einem Compositing Window Manager, bei einem normalen Fenstermanager terminierte es sofort beim Start mit einer entsprechenden Fehlermeldung.
caja-1.8.1/mate-base/gentoo {file manager}{GTK+}: Der Standard-Dateimanager des Mate DTE. Scheint irgendwie ein Zwischending aus dem LXDE-Dateimanager PcManFM und dem Xfce-Dateimanager Thunar zu sein. Wenn man davon absieht dass die Buttons und Symbolleisten anders angeordnet sind, fand ich auf Anhieb keinerlei Unterschiede zum PcManFM-Dateimanager. Ein paar Kleinigkeiten fielen mir dann doch auf: PcManFM zeigt Dateigrößen in SI-Einheiten an, also KiB, MiB usw. - Potenzen von 1024. Caja scheint hingegen alles in dezimalen KB, MB etc. anzuzeigen - Potenzen von 1000 - und ich fand keine Option dies zu ändern (während der PcManFM sehr wohl eine Option hat um die Größen genau wie der Caja anzuzeigen). "Recht" haben beide Dateimanager, da "1 KB" gemäß SI-Einheitensystem tatsächlich 1000 Bytes sind, aber viele "traditionell verhaftete" Menschen glauben nach wie vor dass 1 KB = 1024 Bytes wäre. Diese könnten sich an den dezimalen Einheiten beim Caja stören. Andererseits haben "normale" Menschen noch nie verstanden warum ein KB etwas anderes als 1000 Bytes sein sollten; diese werden Caja lieben. Beide Dateimanager beherrschen Tabs und auch eine optionale 2-Fensterhälften-Ansicht nach dem Vorbild des klassischen "Norton Commanders". Der PCManFM bietet mehr Ansichtsmodi und mehr Varianten in der Art der Sortierung, der Caja kann dafür im Listenmodus die Spalten freier konfigurieren und etwa den Besitzer und die Zugriffsrechte einblenden, was der PcManFM noch nie konnte. Beide Dateimanager beherrschen die Benutzung des Papierkorbs, die man aber auch umgehen kann. Beide Dateimanager sind zu dumm, die Benutzung oder Umgehung des Papierkorbs durch einen vorgegebenen Schwellenwert automatisch von der Dateigröße abhängig machen zu können. Etwas seltsam ist dass es in Caja keine Möglichkeit zu geben scheint, ein Terminalfenster für das aktuelle Verzeichnis zu öffnen. Insgesamt scheint die Bilanz sehr ausgeglichen; beide Dateimanager sind annähernd gleich mächtig und unterscheiden sich in den wesentlichen Funktionen kaum. Da PcManFM aber um einiges schlanker ist als Caja (ca. Faktor 5), besteht wenig Anreiz Caja abseits von Gnome als eigenständigen Dateimanager zu verwenden, da man mit PcManFM sozusagen dasselbe bei geringerem Ressourcenverbrauch erhält.
calcoo-1.3.18-3.1/utils/debian {calculator}{GTK+}: Ein Taschenrechner mit sofortiger Ausführung a la xcalc, der jedoch etwas komfortabler zu benutzen ist. So hat er eigene Buttons um den Text aus dem Anzeigefenster von/zum Zwischenablage zu kopieren. Er hat neben der Zahl in der Anzeige noch 3 weitere Register die angezeigt werden und zwischen denen man die Zahl in der Anzeige austauschen kann. Diese Register dienen im optionalen RPN-Mode wohl auch als Stack. Wirkt alles in allem übersichtlich obgleich man über die genauerer Funktion einiger Tasten rätseln mag. Verwendet jedoch Bitmaps für die meisten Tastenaufschriften, was das Programm schlecht skalierbar für verschiedene Displaygrößen macht. Alles in allem macht es zwar keinen direkt schlechten Eindruck, wirkt aber entbehrlich und ähnlich altbacken wie xcalc.
calibre-0.8.8/app-text/gentoo {document viewer}{PDF}: Konvertiert zwischen verschiedenen e-Book Formaten. Eingabeformate: CBZ, CBR, CBC, CHM, EPUB, FB2, HTML, HTMLZ, LIT, LRF, MOBI, ODT, PDF, PRC, PDB, PML, RB, RTF, SNB, TCR, TXT, TXTZ. Ausgabeformate: EPUB, FB2, OEB, LIT, LRF, MOBI, HTMLZ, PDB, PML, RB, PDF, RTF, SNB, TCR, TXT, TXTZ. Kann die eBooks auch anzeigen - inklusive Tabellen, CSS, Lesezeichen, Verweisen. Der Calibre eBook-Viewer kann auch unabhängig von der Hauptapplikation aufgerufen werden; in diesem Fall ist es auch möglich eBooks zu lesen ohne sie der Calibre-Bibliothek hinzu zu fügen. Der eingebaute PDF-Viewer unterstützt sogar Text-Reflow in PDF-Dateien - die meisten PDF "Standard"-Viewer können dies nicht. Metadaten können (als separat gespeichertes Overlay) editiert oder auch automatisch aus dem Internet abgeglichen werden. Bibliotheksverwaltung mit mächtiger Such- und Filtersprache, deren Ausdrücke textuell eingegeben oder automatisch durch Button-Klicks im Kategorie-Browser generiert werden können. Neben vordefinierten Kategorien wie "Author", "ISBN", "Schlagworte" usw. können auch beliebige zusätzliche benutzerdefinierte Kategorien angelegt werden. Unterkategorien beliebiger Tiefe werden unterstützt. Innerhalb der Kategorien können die Einträge (wie etwa Schlagwörter) auch beliebig hierarchisch angeordnet werden; allerdings muss dies für jede Kategorie erst freigeschaltet werden: Vorgabemäßig verwenden die Einträge innerhalb jeder Kategorie einen flachen Namensraum. Kann News-Artikel herunterladen und in eBooks konvertieren. Synchronisation mit eBook-Lesegeräten. Internet-Serverfunktion zum Fernzugriff auf die private Buchsammlung. In Python geschrieben und einige Features können durch eigene Python-Scripts erweitert werden (etwa zum angepassten Download von News-Websites falls die eingebauten Methoden nicht reichen). Die größte Verwaltungseinheit von calibre ist die "Library", es können deren beliebig viele angelegt werden. Innerhalb jeder Library gibt es eine Datenbank für Metadaten und eine starre Ordnerstruktur in welcher die eigentlichen Bücher liegen. Die Metadaten liegen immer repliziert vor: Einerseits in der Library-Datenbank, andererseits als Kopie in einer eigenen Metadatendatei für jede Buch-Datei. Das erlaubt es, die Library-Datenbank im Falle einer Beschädigung komplett zu regenerieren, sowie die Metadaten einzelner Bücher isoliert zu sichern oder auf fremde Systeme zu übertragen. Außer bei der Konvertierung von Formaten scheint Calibre Metadaten-Änderungen niemals in den Original-Dateien durchzuführen, sondern immer nur in den Metadaten-Dateien. Einzig erkennbarer Nachteil von Calibre ist die mit rund 30 MB Installationsumfang nicht gerade kleine Installation und der Umstand dass das Paket aus zahllosen Einzelkomponenten besteht welche nur durch Python-Scripte "zusammen gehalten" werden, was der Stabilität des Gesamtsystems natürlich nicht gerade erhöht.
caph-1.1/games-puzzle/gentoo {game}: Angeblich ein scheinbar interessantes Physik-Puzzle, bei dem man diverse physikalische Hindernisse überwinden muss. Doch leider: Diese Version erzeugt nur ein versautes Bild im X11-Fenster. Offensichtlich noch einfach zu buggy. Eventuell irgendwann später mit einer deutlich höheren Versionsnummer noch einmal versuchen.
cardpeek-0.8.4-1+b3/utils/devuan: Hilfsprogramm zum Auslesen von Daten aus einer Smartcard. Erfordert einen bereits installierten Smartcard-Leser samt entsprechenden Treibern und Hintergrunddienst.
catfish-4.16.0-1/utils/debian: Ein Programm für die Dateisuche in GNOME3-Optik. Zum Glück wenigstens ohne die gräßlichen Client-Side Decorations leider vieler GNOME3-Programme. (Genauer gesagt: Man kann sich das in einem Konfigurations-Dialog aussuchen. Per Default ist es jedoch netter Weise deaktiviert.) In Python-3 geschrieben.  Mehrsprachig, darunter Deutsch. Das Programm kann sowohl nach Dateinamen als auch Dateiinhalten suchen. Es führt eine rekursive Suche in einem Verzeichnisbaum aus; das Startverzeichnis dafür kann man auswählen. Per Default ist immer das $HOME-Verzeichnis eingestellt. Die Bedienung ist ansonsten einfach: Es gibt ein Textfeld, und was man dort eingibt wird gesucht. Dieselbe Suche kann allerdings auch aus der Kommandozeile aus initiiert werden. Man kann weiters eine Liste von (absoluten) Verzeichnis-Pfaden konfigurieren, die bei der Suche grundsätzlich ausgelassen werden sollen. Ein paar wie "/dev" sind sogar schon vorkonfiguriert. Catfish scheint mit mlocate zusammen zu arbeiten, und benutzt dessen Datenbank mit. Man könnte also meinen, es ist nichts als ein Front End für "locate" das die Ergebnisse zusätzlich nach einem bestimmten Startverzeichnis filtern kann. Doch dass dem so nicht sein kann, bemerkt man an der langen Dauer der Suche. Entweder sucht catfish neben den Suchtreffern aus dem mlocate-Suchindex noch weitere Dateien, oder es verarbeitet den Suchindex so uneffizient dass es um ein Vielfaches länger dauert mit catfish dasselbe wie mit locate zu finden. Die Volltextsuche nach Inhalt ist natürlich etwas das locate nicht beherrscht - aber wenn man bedenkt wie langsam catfish bereits beim Suchen von Dateinamen ist, könnte die Volltextsuche zu befürchtender Weise völlig unbrauchbar langsam sein. Kurzum: Hübsch und nett, aber unbrauchbar langsam, zumindest verglichen mit dem "locate" aus der Command Line. Nur für völlig unbedarfte User deren Dateimanager nicht ohnehin bereits eine derartige Suchfunktion eingebaut hat - aber vermutlich flotter, oder zumindest auch nicht langsamer.
caveexpress-2.5.1-1/games/debian {game}: Ein hübsch gemachtes 2D-Plattformspiel in (zumindest: so getestet) Full-HD Auflösung. Es erinnert ein wenig an Lemmings, obwohl man es hier nur eine Figur steuert. Aber auch diese muss viele verschiedene Manöver beherrschen um die Levels meistern zu können, was durch ein Tutorial erklärt wird. Die Grafik ist zumindest bei Full-HD gut und detailreich, die Software-Sprites sind groß genug dass man sich nicht die Augen verderben muss da man keine winzigen Figuren steuert.
cavezofphear/games-arcade/gentoo {game}: Boulder-Dash im Character-Mode!
cbrpager-0.9.20/app-misc/gentoo: Ein eher simples Programm zum Anzeigen von Comic-Book Dateien (.cbr, .cbz usw.). Ist mit rund 315 KiB Installationsumfang war ziemlich leichtgewichtig und kann auch alles wichtige (außer einem Vollbildmodus), leidet aber darunter dass die "großen" Viewer Evince, Calibre und Okular ebenfalls Comic-Book Dateien anzeigen können. Dadurch wird dieses Programm relativ sinnlos, wenn einer der beiden anderen Viewer installiert ist.
ccdiff-0.32-1/devel/raspbian {text-diff}: Ein in Perl geschriebenes farbiges Character-"diff"-Tool für Texte. Es arbeitet weitgehend wie das normale "diff", hebt aber auch Unterschiede innerhalb der Zeilen farblich hervor. Leider wurde das Tool von einem Idioten geschrieben, der sich nicht vorstellen konnte dass irgend jemand helle Schrift auf dunklem Hintergrund in einem Terminal verwenden könnte. Die vom Programm verwendeten Farben eignen sich nur für Terminals die dunkle Schrift auf weißem Hintergrund verwenden.
cdrkit-doc-9: 1.1.11-3/doc/debian: Debian hat das berühmte "cdrtools"-Paket aufgrund von Lizenzstreitigkeiten geforkt und auf verschiedene Pakete mit völlig anderen Namen aufgeteilt. Dieses Paket enthält als Empfehlungen die Namen der Pakete, in welchen man die geforkten Pedants der klassischen cdrtools ("cdrecord" im Fork in "wodim" umbenannt, "cdda2wav" in "icedax" und "mkisofs" in "genisoimage") zum CD-Brennen, -rippen und ISO-Image-Generieren unter Debian finden kann. "cdrkit" ist dabei der Name welcher Debian dem Fork gegeben hat, allerdings heißt kein einziges Paket tatsächlich so - es handelt sich nur um einen Suite-Namen.
cellwriter-1.3.5-1/gnome/devuan {input without physical keyboard}: Eine GUI On-Screen Handschrifterkennung und (umschaltbar) On-Screen-Tastatur. Genau das was man braucht wenn keine Tastatur vorhanden ist oder nicht mehr funktioniert. Lässt sich optional auch an die Bildschirmränder andocken. Das Programm zeigt auch ein Icon im Systembereich der Taskleiste an, mit dem man das Fenster per Mausklick schnell ein- und ausblenden kann. Leider hat die On-Screen-Tastatur nur ein englisches Layout. Die Handschrifterkennung selbst ist aber trainierbar und unterstützt scheinbar beliebige Zeichen. Allerdings gibt es eine "Kontexterkennung" welche Fehlerkennungen minimiert, und diese funktioniert nur bei Englisch. xkeycaps kann daher für deutsche Texte besser als Tastaturersatz geeignet sein. Ein Vorteil von cellwriter gegenüber xkeycaps ist jedoch, dass man keine speziellen Optionen beim Start eines Terminalprogramms angeben muss, damit es Eingaben der virtuellen Tastatur akzeptiert. Cellwriter hat sich zudem auch als "Heilmittel" für das gelegentlich zumindest unter X11/Fluxbox auftretende Problem heraus gestellt, dass gelegentlich kein Fenster mehr den Tastaturfokus annimmt, und man daher nichts mehr eintippen kann. Das Tippen eines einzigen Zeichens mit Cellwriter in ein Terminal-Fenster behob das Problem jedenfalls wieder.
cfengine-2.2.10/net-misc/gentoo: Ein Applikationsframework zum Verwalten der Konfiguration vieler Rechner. Besteht aus einer deklarativen Beschreibungssprache für den gewünschten Ist-Zustand, der für unterschiedliche Gruppen von Rechnern oder auch Einzelrechner abweichend parametrisiert werden kann sowie einem Tool welches die Beschreibungssprache interpretiert und umsetzt. Es gibt auch diverse optionale Dienste zum Verteilen von Updates der Deklarationsdateien. Das Interpreter-Tool kann entweder manuell, per cron oder mit einem mitgelieferten Dienst periodisch gestartet werden. Soweit alles schön und gut. Das Problem: Die Deklarationssprache ist sehr auf ganz bestimmte Aufgaben ausgelegt, wie das Anlegen von Symlinks und modifizieren von Textdateien. Es ist zwar möglich benutzerdefinierte Shell-Scripts aufzurufen, diese fühlen sich aber wie "Bürger zweiter Klasse" an. Die Anleitung bejubelt die unglaublichen Fähigkeiten des Tools; mir schienen es aber eher "implemented as needed"-Features zu sein die willkürlich ausgewählt scheinen und das ganze macht keinen sehr orthogonalen Eindruck. Außerdem hatte ich nicht den Eindruck dass hier etwas großartiges geschaffen wurde, sondern dass man mit ein paar wohlgeplanten Perl-Scripts dasselbe ebenso wenn nicht noch besser implementieren könnte.
cfv-1.18.1/app-arch/gentoo: Erstellt und Vergleicht CRC-Prüfsummen im .cfv-Format.
cgdb-0.6.5/dev-util/gentoo {text-terminal IO}: Ein ncurses-basiertes "GUI" für den GDB - in der Konsole. Da das gdb ohnehin schon von Haus aus ein simples konsolenbasiertes GUI namens gdbtui mitbringt, fragt man sich ernsthaft wozu cgdb nütze sein soll. Wenigstens ist der Download mit 800 KB nicht lange, und wenn man ihn startet kann er zumindest Syntax-Highlighting mit den Farben der Konsole. Angeblich macht er auch weniger Zicken als gdbtui was die Handhabung des GUI angeht. Allerdings vorab gleiche eine gefährliche Drohung: "The UI is modeled on the classic Unix text editor, vi. Those familiar with vi should feel right at home using CGDB." Schluck. Und tatsächlich, irgendwie kann ich keinen rechten Vorteil an cgdb gegenüber gdbtui erkennen. OK, es ist ein wenig bunter und versaut das Display weniger leicht. Und es gibt vi-getreu verschiedene Modi in denen man sich befinden kann - in einem davon kann man etwa Breakpoints mit einer einzigen Taste setzen. Allerdings frage ich mich ob das wirklich einen separaten Debugger wert ist! Meiner Ansicht nach ist cgdb einfach nur etwas für vi-Verliebte, denen das gdbtui "zu normal" ist. OK, die Suche im cgdb wird vermutlich besser funktionieren als das "search" in der gdb-Konsole. Sonst ist für mich aber kein rechter Mehrwert zu erkennen.
checkinstall-1.6.2+git20170426.d24a630-2~bpo10+1/admin/debian {installation}: Software installation monitor and uninstallation information provider. Provides the utilities "installwatch" and "checkinstall". "installwatch" runs a command like "make install" under supervision (using a ".so"-preloading injecting monitor hooks into file/directory creation OS library functions) and provides a log what has been done. This log can be used as a basis for later uninstalling the files just installed. "checkinstall" goes one step further and creates a binary package in ".deb" (Debian), ".rpm" (Red Hat) or ".tgz"-format (Slackware) from the collected information. The latter tool is more powerful, but also has a ton of options which need to be considered. Like all utilities based on ".so"-preloading, these utilities will not work if the installation command invokes statically-linked binaries or ones which disregard ".so" injection, such as SUID binaries. Luckily, this is rarely the case with installation utilities.
chef-13.8.7-4/ruby/debian {configuration management}: In Ruby implementiertes System, das nicht nur einen Server braucht sondern auch noch Clients auf allen betreuten Systemen. Zusätzlich gibt es noch "Chef Workstation"-Dienste, wo Administratoren sich einloggen und das System damit steuern. Überdies überschreibt es schon mal manuell bearbeitete Konfigurationdateien. Clients gibt es für Windows und Linux; der Server erfordert Linux. Die Konfiguration wird in einer Ruby-basiertem Domain-Specific Language definiert. Idiotische allgemeine Namen wie "Chef", "Supermarkt" und scheinbar auch "Steak" für diverse Komponenten des Gesamtsystems erschweren das Googeln nach Lösungen. Es gibt aber ähnlich wie bei Ansible eine erkleckliche Menge bereits fertiger Playbooks.
chezdav-2.2-3/net/debian: Ein theoretisch sehr nettes Utility: Gibt den Inhalt eines beliebigen Verzeichnisses mittels WebDAV frei, so dass z. B. ein Web-Browser übers Netzwerk auf die Dateien im Verzeichnis zugreifen kann. Optional kann man noch ein Passwort vergeben, welches beim Ansurfen der freigegebenen Webseite abgefragt wird damit nur Berechtigte dort hinein gelassen werden. Die Passwortübermittung sollte danke htdigest zwar sicher genug sein, doch die eigentliche Datenübertragung scheint nicht verschlüsselt zu erfolgen. Jeder mit einem Packet-Sniffer kann die übertragenen Daten daher mitkopieren, obwohl er das Passwort nicht kennt. Daher nur im sicheren LAN zu empfehlen - und dann kann man auf das Passwort eigentlich gleich verzichten. Trotzdem grundsätzlich nett. Doch leider gibt es in der Praxis Probleme: Zum einen funktioniert das Programm nur mit einem bereits laufenden avahi-daemon - den müsste man also zusätzlich installieren. Und dann will es sich auch noch unbedingt an einen IPv6-Port verbinden um seine mDNS-Broadcasts für ZeroConf los zu lassen - was aber zwangsweise scheitert, wenn man den IPv6-Support mangels Bedarf deaktiviert hat.
chezscheme-9.5+dfsg-6/lisp/debian {programming language}: Eine vollwertige Scheme-installation. Übererfüllt den kompletten R6RS Standard. Nur 2 MB Installationsumfang - und noch einmal so viel für die optionale und ausführliche Dokumentation. Enthält einen inkrementellen Native-Code Compiler für derzeit (Stand 2021) x86 (32 und 64 Bit), PowerPC, SPARC, ARMv6. Nach Eigendarstellung ist er "reliable" und "high performance". Einem Benchmark von Dritten zufolge erzeugte der Compiler auf SPARC eines den schnellsten Executables für Scheme, der Interpreter hingegen war unter den langsamsten auf i386. Ist als Drop-In Replacement für "Petite Chez Scheme" gedacht, welches ein fast identisches System ist, allerdings mit einem (allerdings angeblich ebenfalls sehr schnellen) Interpreter anstatt einem nativen Compiler. Eine signifikante Einschränkung des Interpreters ist dabei, dass ein "Foreign Function Interface" (FFI) nur für den Compiler zur Verfügung steht. Anders als die meisten LISP- und FORTH-Systeme, aber ähnlich wie die meisten anderen Scheme-Systeme benutzt auch Chez keine dubiosen und potenziell gefährlichen Speicherabbild-Dateien, sondern baut sich seine Datenstrukturen im Arbeitsspeicher bei jedem Start neu auf. Obgleich es ein Compiler ist, bringt Chez sehr wohl auch eine REPL command line (samt History-Editierfunktionen und Tab-Completion) mit und man kann auch Scripte damit ausführen, welche dann temporär im Speicher kompiliert werden. Obgleich Chez nicht versucht das gesamte POSIX-API zur Verfügung zu stellen, gibt es doch alle wichtigen E/A-Möglichkeiten daraus wie wie Dateideskriptoren, Symlinks, Zugriffsrechte, Directory-Zugriff, Netzwerk-Sockets, Multithreading, Multiprocessing, Pipes, String-Formatierung, benutzerdefinierte zusätzliche "ports" usw. Außerdem arbeitet Chez gut mit slib zusammen, einer portablen Sammlung aus Scheme-Quelltexten die sich aus mehreren Scheme-Implementationen heraus nutzen lassen. Chez ist auch dazu gedacht mit C-Programmen zu interagieren; es gibt APIs zum Aufruf in beide Richtungen. Überdies ist ein Foreign-Function-Interface integriert, mit dem man viele Funktionen aus shared-libraries auch ohne C "glue code" direkt aufrufen können dürfte. Der weiter oben erwähnte "petite"-Interpreter liegt übrigens zumindest unter Debian gleich ebenfalls im selben Paket bei. Es handelt sich dabei um ein 300 kB großes Executable, welches zudem nur von Standard-Paketen anhängt. Allerdings benötigte er zum Starten ein zusätzliches binäres "boot"-File, angeblich als Bytecode vorkompilierte Scheme-Befehle. Insgesamt ist ein chroot-Jail welcher alles enthält um "petite" zu starten 5,3 MB groß - das meiste davon belegen. Darin enthalten dürften zudem auch bereits die Routinen für beliebig große Integer-Berechnungen sowie Rationale Zahlen sein, denn beides ist verfügbar obwohl keine libgmp im chroot Jail vorhanden ist. Alles in allem ein sehr guter erster Eindruck. Bedenken löste einzig die Copyright-Meldung aus, welche besagt dass es sich um ein bei CISCO entwickeltes Projekt handelt. Wie klug der Einsatz für sicherheitskritische Anwendungen sei, ist daher zweifelhaft. Hinzu kommt, dass Chez nicht direkt aus dem Quellcode gebaut werden kann, sondern auch dazu die erwähnten zusätzlichen "boot"-Dateien benötigt, welche diverse mitgelieferte Scheme-Quelltexte als Bestandteile von Compiler und Interpreter in bereits vorkompilierter Form enthalten müssen. Daher werden diese in binärer Form der Quelltext-Distribution beigelegt. Mit dem so erzeugten Compiler kann man die Scheme-Quelltexte danach zwar erneut kompilieren und vergleichen ob sie identisch mit den beiliegenden "boot"-Dateien sind. Jedoch gibt es keine Sicherheit, dass der Compiler durch das Wirken der mitgelieferten Boot-Dateien nicht schon längst mit einer Hintertür versehen wurde, welche er dann auch in die neu erzeugten Boot-Dateien mit einbaut obwohl sie nirgends im Quelltext zu sehen sind. Wenn dann auch noch CISCO im die Finger im Spiel hat, kann das bei paranoider Denkweise durchaus Ängste herauf beschwören. Andererseits, selbst CISCO korrumpiert und verdirbt vielleicht doch nicht alles woran sie beteiligt sind.
chicken-bin-4.13.0-1/lisp/debian chicken 4.10.0-1/community/archlinux chicken-1.89/dev-scheme/gentoo {programming language}: Ein native-Code Scheme-Compiler ("csc") und -interpreter ("csi"). Beherrscht mit wenigen Ausnahmen den gesamten R5RS-Standard (Makros funktionieren z. B. komplett anders) mit etlichen Erweiterungen sowie einzelnen Anleihen von R6RS (z. B. Block-Kommentare - sehr nützlich zum Starten von Scheme-Scripten aus Shell-Scripten heraus). Obwohl es mittlerweile bereits R7RS gibt, bleibt R5RS die nach wie vor am weitesten verbreitete Variante; so gesehen ist es nicht so schlimm und sogar besser für die Portabilität. Das Paket steht unter der BSD-Lizenz, also sehr wenig restriktiv für eine Verwendung selbst in kommerziellen Anwendungen. Dieses Hauptpaket hat mit den binary Executables hat zudem eine sehr nette und umfangreiche Dokumentation dabei, mit der man zur Not auch alleine über die Runden kommt. Unter anderen ist der komplette R5RS-Standard darin enthalten. Chicken erzeugt aus SCHEME-Quelltexten temporäre ANSI-C Quelltexte, und kompiliert diese danach gleich weiter in ausführbare Dateien. (Will man die C-Quelltexte jedoch begutachten, kann man den internen Scheme-zu-C Compiler "chicken" auch manuell aufrufen.) Dieser Umweg über C-Quelltexte erlaubt natürlich auch besonders einfaches Zusammen-Linken mit anderen C-Übersetzungseinheiten. Überdies bedeutet es, dass Chicken ohne Änderung auf allen Hardware-Plattformen funktioniert welche einen funktionierenden C-Compiler bereit stellen - was de facto alle Plattformen sind die auch nur irgend eine praktische Relevanz aufweisen. Der erzeugte Code funktioniert überdies auf dem interessanten Konzept, durch konsequente Ausnutzung des "Continuation Passing Style" in C den C-Stack als Heap zu benutzen - die Garbage Collection bereinigt daher den C-Stack anstatt wie sonst üblich den Heap. Chicken nützt zudem einen "Copying"-GC, der keine unsauberen Annahmen über die Low-Level-Details des C-Stacks wie dessen Frame-Aufbau benötigt, und entsprechend portabel bleibt. Als Konsequenz ist ein CALL/CC (anders als etwa in GNU Guile) nicht aufwändiger als ein normaler Funktionsaufruf in C, und auch die in Scheme vorgeschriebenen Tail-Recursions stellen kein Problem dar. Leider unterstützt Chicken nicht den vollen "Numeric Tower" von Scheme, d. h. Ganzzahlen welche in Berechnungen zu groß werden, werden in Fließkommazahlen statt mehrfachgenauer Ganzzahlen konvertiert. Allerdings kann die fehlende Funktionalität bei Bedarf mittels der externen "numbers"-Erweiterung ergänzt werden; sie ist lediglich nicht im Standard-Lieferumfang enthalten. Wenn man den relativ großen Installationsumfang der Laufzeitbibliothek von über 6 MB betrachtet, ist Chicken eine relativ fette Installation unter den schlankeren Sprach-Installationen. 3,6 MB Download und 22 MB installiert. Man vergleiche dies mit Lua, das mit 270 KB auskommt. (In beiden Fällen wurden die normalen C-Runtime-Libraries nicht eingerechnet.) Für kleine Stand-Alone Anwendungen daher ein wenig überfettet. Außer es gibt deren viele, was den Umfang der Shared Library dann irgendwann wieder amortisieren würde. Immerhin sind die eigentlichen erzeugten native Executables relativ klein - ca. 30 kB für ein kleines Testprogramm aus wenigen Zeilen (nach "strip -s"). Und auch der fetten Laufzeitbibliothek muss man zumindest zugute halten, dass nichts unnötiges drin zu sein scheint - nur Support-Code für tatsächlich sinnvolle Features vom Scheme. Zudem relativiert sich die Größe der Laufzeitbibliothek auch dadurch, dass sie abseits der üblichen C-Runtime-Bibliotheken keinerlei zusätzliche Abhängigkeiten hat. Anders als etwa bei "Chez" wird auch keine zusätzliche "Boot"-Datei mit präkompilierten Supportfunktionen zusätzlich benötigt. Ein von mir eingerichteter chroot-Jail der alles enthielt was ein Chicken-Executable zum Laufen benötigt, war (im installierten Zustand und nicht etwa als Archiv komprimiert) knapp über 9 MB groß. Das ist immer (gerade) noch akzeptabel, wenn man vergleicht dass aktuelle initrd-Images - gepackt - oft bereits größer als 20 MB sind. Wenn Platz allerdings grundsätzlich keine Rolle spielt, kann man eben so gut gleich eine volle Scheme-Implementierung wie racket/lisp/debian nehmen die den aktuellen Sprachstandard ohne Abstriche unterstützt (welche allerdings auch eine deutlich größere Installation ist). Es gibt zudem eine große Sammlung von Third-Party-Bibliotheken und Software-Modulen speziell für Chicken, welche "Eggs" genannt werden.
chkrootkit-0.49/app-forensics/gentoo: Ein Tool, welches man von einem CRON-job aus periodisch startet um das System auf Anzeichen von Rootkits zu untersuchen. Leider ist dieses Tool *schweinelangsam* und rattert gute 20 Minuten lang auf der Platte herum, wobei es maximalen I/O generiert so dass alles andere derweil steht oder nur krötenlangsam funktioniert. Daher ist es nervig und teuer dieses Tool zu verwenden, insbesondere in Fälle wo die Wahrscheinlickeit Opfer eines Rootkits zu werden ohnehin gering ist. Für gefährdete Systeme empfiehlt es sich vermutlich aber dennoch.
chm2pdf/app-text/gentoo {PDF}: Converts Microsoft .chm files into .pdf files. Contains dev-libs/chmlib as a dependency, which in turn contains several tools for extracting the contents of .chm files or serve them as HTML via HTTP to a web browser. Quite useful for reading Microsoft-infested documention on a POSIXoid workstation.
chocolate-doom-3.0.0-4+deb10u1/games/debian chocolate-doom-3.0.1-1/games/raspbian {game}: Eine weitere Game-Engine, die Doom abspielen kann. Anders als sein ansonsten weiter entwickelterer Fork crispy-doom kann chocolate-doom nicht nur Doom, Doom2 und Heretic-Leveldateien abspielen, sondern in älteren Debian-Versionen zusätzlich ebenso die von Hexen. Ab Debian-12 "bookworm" unterstützt aber auch crispy-doom Hexen. Es gibt dann keinen Grund mehr chocolate-doom zu installieren. Denn es kann es nur die Original-Grafikauflösungen benutzen, bzw. diese für die aktuelle Bildschirmauflösung hochskalieren. Weiters kann es nicht mehr als die 256 VGA-Farben darstellen. Das Ergebnis ist eine Grafik die - anders als bei der crispy-doom- oder doomsday-engine - so potthässlich pixelig aussieht dass man sich beinahe erbrechen möchte. Dafür ist der Download aber klein (nur rund 1 MB) und enthält game-engines für Doom, Doom2, Hexen und Heretic. Die Grafik ist anders als bei der doomsday-engine flüssig und komplett originalgetreu - leider *zu* originalgetreu was die klotzig-kotzige Pixelgrafik mit nur 256 Farben angeht. Alles andere ist aber gut gelöst: Problemlose anpassbare Tastatur- und Maussteuerung, Musik mit Adlib- oder MIDI-Emulation (klingt mit timidity und dessen Soundfonts hervorragend, doch selbst Adlib klingt nicht schlecht). Empfehlung: Zum Spielen von Hexen unter Debian benutzen. Für Doom, Doom2 und Heretic besser crispy-doom benutzen, das (trotz gleicher Auflösung dennoch) grafisch wesentlich besser aussieht. Auf Maschinen mit sehr schneller Grafikkarte (und nur dort) statt dessen die doomsday-engine für alle Varianten (Doom, Hexen, ...) von Spielen benutzen.
chromium-8.0.552.237/www-client/gentoo {www-browser}{GUI}{X11}: Ein optisch auf den ersten Blick dem neuen Internet Explorer sehr ähnlich wirkender schick aussehender Browser, der besonders Standard-konform ist und eine der schnellsten JavaScript-Implementierungen überhaupt bietet. Das User-Interface wurde gegenüber den Firefox drastisch abgespeckt; so gibt es nur mehr die allernötigsten Buttons. Bookmarks und History gibt es weder als Sidebar noch als Menü, sondern sie sind auf jedem neuen Tab zu finden. Die Bookmarks wurden simplifiziert: Sie enthalten nun weder eine Beschreibung noch Schlüsselwörter; nur noch URL und Menütitel. Der Location-Bar kann allerdings ähnlich wie beim Firefox sowohl die History als auch Bookmark-Titel als auch Bookmark-URL durchsuchen. Dadurch kann man den Bookmark-Titel für Schlüsselwörter mißbrauchen. Dann fehlt allerdings ein sinnvoller Titel für das Menü. Chromium ist die OpenSource-Basis für den Google-Browser "Chrome"; allerdings wurden eine Menge der Spitzel-Features vom Chrome entfernt bzw. entschärft. Dennoch wird man mit den Standard-Einstellungen bis ins Mark ausspioniert, indem etwa jede Fehleingabe an einen Server zur "Korrektur" versendet wird; von derartigen "serverbasierten Hilfsfunktionen" gibt es zahlreiche. Die man alle deaktivieren kann. Nur dass es in der Standardeinstellung nicht getan wurde. Chromium gilt als "schlank" und "schnell". Schlank ist allerdings relativ: mit ca. 50 MB Installationsumfang ist er zwar in der Tat etwas kleiner als der Firefox mit seinen 80 MB, aber immer noch in einer vergleichbaren Größenordnung. Was die Geschwindigkeit angeht startet er zwar schneller, danach konnte ich aber keinen Unterschied mehr bemerken. Nun, mag sein dass es stimmt. Aber der Unterschied ist jedenfalls nicht augenfällig. Und im Vergleich zum "Konqueror" von KDE oder gar zum "Dillo"-Browser etwa ist der Chromium genau wie der Firefox immer noch ein fettes Monster. Chromium unterstützt Themes und Add-Ons ebenso wie der Firefox; allerdings gibt es nahezu keine verfügbaren. Zumindest keine sinnvollen. Oder fast nicht: Einen Werbeblocker gibt es. Aber es gibt weder einen Image-Blocker, noch einen Popup-Blocker, noch einen Script-Blocker, noch einen Flash-Blocker. Diese Dinge kann man zwar teilweise im Browser selbst konfigurieren, dann aber nur umständlich auf globaler Liste mit einer händisch zu editierenden Ausnahmeliste. Aber keinesfalls kann man diese Blocker mit einem Mausklick schnell ein- und ausschalten wie es sinnvoll wäre. Natürlich mag es sein dass all diese Add-Ons eines Tages verfügbar sein werden. Derzeit ist es aber noch nicht soweit, und der Chromium daher nicht sinnvoll für Leute wie mich nutzbar, welche auf diese Add-Ons des Firefox keinesfalls verzichten wollen. Fazit: Der Browser wirkt durchaus brauchbar und weniger überladen als der Firefox. Doch leider sind einige wichtige Add-Ons (noch?) nicht für Chromium verfügbar und machen ihn daher praktisch uninteressant; insbesondere für Anwender die ur eine geringe Bandbreite zur Verfügung haben und daher auf diverse Blocker angewiesen sind, um im heutigen flash- und Werbebanner-verseuchten Internet zurecht zu kommen ohne dass alles kriechend langsam wird.
chromium-bsu-0.9.15.1/games-action/gentoo {game}: Ein vertikal scrollendes, sehr hübsch gemachtes 2D-Ballerspiel, welches wahlweise in einem Fenster oder in Fullscreen-Moduls laufen kann. Die Schiffe sind (allerdings auch wegen der nicht übergroßen nativen Auflösung welche für Fullscreen scheinbar anti-aliased hochgerechnet wird) groß und gut zu sehen, und durch die abgefeuerten Schüsse entstehen jede Menge verspielter Lichteffekte.
cinelerra-20120707/media-video/gentoo {video-editor}: Ein in C++ geschriebener nur unter Linux lauffähiger nicht-linearer Video Editor. Was die Kernfunktionen betrifft mächtiger und professioneller als als alle anderen NLEs, jedoch eigenwillig in der Bedienung und stürzt meiner Erfahrung nach sehr gerne ab. Das Programm ist für seine hohe Signalverarbeitungsqualität bekannt; Audio wird mit 64 Bit Genauigkeit verarbeitet; Video entweder als YUVA oder RGBA mit Floating-Point oder 16-Bit Integers je nach Komponente. Außerdem arbeitet es Auflösungs- und Framerate-unabhängig. Ein Nachteil von Cinelerra ist dass es nur 1:1 Seitenverhältnisse direkt unterstützt; Video-Material mit anderem Seitenverhältnis muss konvertiert oder in verzerrter Form bearbeitet werden. Cinelerra enthält anders als die meisten anderen NLEs auch eine Compositing-Engine mit der Color-Keying und Matting durchführbar sind. Cinelerra gilt als Hardcore-Tool nur für hartgesottene Freaks und professionelle Anwender, über das sich kein normaler User drüber traut. Cinelerra-GG Infinity, Cinelerra HV und Cinelerra CV sind 2022 auf den Plätzen 9, 12 und 13 der beliebtesten Editoren (auf slant.co).
claws-mail-3.17.8-1+b1/mail/debian: Ein E-Mail-Programm. Ein MUA (Mail User Agent). Eine GUI-Applikation. Gleiche Zielsetzung wie Mozilla Thunderbird (TB), jedoch weniger mächtig in vielen Details. So bietet es etwa keinerlei Support zum Verfassen von HTML-Mails. Anzeigen kann es solche Mails hingegen, wenn auch nur in Text umgewandelt. Allerdings ist die Leistungsfähigkeit der eingebauten Umwandlung zu bezweifeln. Allein schon weil man den Dillo Webbrowser mittes Plug-In dazu verwenden kann, den Inhalt einer HTML-Mail anzuzeigen was darauf hinweist dass dies besser sein dürfte. Claws Mail is ein Fork bzw. Nachfolger von Sylpheed Claws, was man auch daran erkennt dass das Kürzel SC in etlichen internen Mail-Headern vorkommt. Claws kennt Offline-Betrieb ebenso wie das teilweise Herunterladen von Mails - ein sehr wichtiges Feature zum Reduzieren von Datenverbrauch angesichts zahlreicher Spam-Mails. Dabei kann man allerdings nicht wie beim TB einstellen dass "nur die Kopfzeilen" herunter geladen werden sollen, sondern in ganzen KiB und daher mindestens 1 KiB. Auch die Option Mails niemals oder erst nach einer gewissen Anzahl von Tagen vom Server zu löschen existiert, alternativ zum sofortigen Löschen nach dem Herunterladen. Aus unverständlichen Gründen scheint diese Vorhaltefrist jedoch auf ein Jahr beschränkt zu sein, was in vielen Anwendungsfällen viel zu kurz ist. Das Programm bietet auch Adressbücher, und anders als bei TB sind diese als XML-Datei gespeichert und daher relativ leicht extern verarbeitbar. PGP-Support ist ebenfalls eingebaut bzw. als mitgeliefertes Plugin enthalten. Ebenso Rechtschreibprüfung - man kann sogar zwei Wörterbücher zugleich aktivieren, ein primäres und ein sekundäres. Filter sind ebenfalls vorhanden, allerdings wird dabei unerklärlicher Weise zwischen solchen unterschieden die beim Abrufen von Mails ausgeführt werden, und andern die man manuell aufrufen kann bzw. automatisch sobald ein Ordner betreten wird. Vorlagen für neue Mails sind vorhanden, ebenso lassen sich eigene "Signatur"-Texte festlegen. Dies sowohl global als auch pro Account übersteuerbar. Ein potenziell interessantes Plugin dient dazu, neue Mails von einem eigenen Perl-Programm untersuchen zu lassen. Das kann "procmail" und ähnliche Lösungen ersparen. A pro pos - auch ein Plugin für ClamAV ist vorhanden, umd Mails damit auf Malware scannen zu lassen. Ebenso gibt es mehrere Plugins für Spam-Erkennung. Eines etwa verwendet Spamassassin, bogofilter ist ein anderes. Dies Plugins benötigen aber extern installierte und konfigurierte zusätzliche Programme. Eingebaut hingegen ist der "bsfilter"-Spamfilter, der tatsächlich auch sehr gut funktioniert. Einziges Problem: Es ist ein Ruby-Script, und schweinelangsam. Man merkt dass allerdings nur beim ersten Anlegen eines neuen Accounts wenn hunderte oder tausende Mails abgerufen und danach stundenlang gefiltert werden... Beliebig viele Accounts werden von Claws ebenfalls unterstützt. Es Backend-Format für die Datenspeicherung benutzt Claws normalerweise offenbar das "MH"-Format. Dies ist allerdings *nicht* mit dem "maildir"-Programm zu verwechseln, wo jede Mail als separate Datei gespeichert wird. Statt dessen scheinen die Mails per Default in SDBM-artigen Datenbanken abgelegt zu werden. Es existiert jedoch ein Plugin, damit Claws auch das "mailbox"-Datenformat unterstützt wie der TB es verwendet und wo alle Mails im selben Ordner als eine einzelne große Textdatei gespeichert werden (welche dann ab und zu "gepackt" werden muss um als gelöscht markierte Mails daraus zu entfernen). Ich vermute dass das Claws-Format für den Einsatz auf Flash-Medien ähnlich schonend wie das "mbox"-Format und ressourcenschonender als "maildir" sein wird, allerdings mit einem etwas höheren Platzbedarf da das SDBM-Format ebenfalls seitenbasiert arbeitet und daher interne Fragmentation unvermeidlich ist. Dafür werden alllerdings die "Pack"-Vorgänge von "mbox" eingespart wo sämtliche Daten neu geschrieben werden müssen. Auf die Anzahl der Schreibvorgänge bezogen ist Claws daher vermutlich sogar schonender. Der größte Vorteil von Claws gegenüber TB ist der deutlich geringere RAM-Verbrauch. Gerade bei kleiner dimensionierten Rechnern wie Raspberry-Pi Modellen mit 1 GiB oder sogar nur 512 MiB RAM wird man mit Claws wesentlich besser über die Runden kommen - und das ohne dabei all zu viel an Komfort aufgeben zu müssen. Während Claws in einigen Details wie der Tab-Completion von e-Mail Adressen sogar komfortabler ist.
clementine-1.3.1+git276-g3485bbe43+dfsg-1/sound/devuan {audio}{music}: Ein Qt-basiertender mehr-oder-weniger Nachbau von Amarok, der allerdings deutlich schlanker als das Original ist - und vor allem ist es frei von dessen KDE-Abhängigkeiten. Zwar bietet Clementine nicht alle Funktionen von Amarok, aber genug um es sehr ähnlich zu machen. Clementine ist eine gute Wahl für Leute die Amarok schätzten, jedoch kein KDE verwenden, und mit den überschaubaren Abstrichen leben können die Clementine macht. Das Programm bietet in erster Linie eine Medien-Bibliothek, die auch mit sehr vielen Songs klarkommt da sie intern eine SQLite-Datenbank zur Verwaltung benutzt. Aus dieser Bibliothek können dann Songs ins Playlists übernommen werden, oder "intelligente" Playlists welche automatisch Songs aus der Bibliothek holen. Etwa der "dynamische Zufallsmix", "häufig gespielte", "hoch bewertete", "neu hinzu gefügte" und so weiter. Weiters erfasst das Programm wie oft man einen Titel abgespielt hat und ob man ihn komplett abgespielt oder vorher abgebrochen hat. Daraus kann es einen Score berechnen wie beliebt dieser Titel für den Benutzer ist, und man kann dies dann als Auswahlkriterium bei der Suche nach Titeln machen. Manuelle Bewertung von Songs ist zusätzlich möglich. Weiters kann man sehr schnelle Suche von Songs anhand von Teilen des Namens oder anderer Metadata-Feldern durchführen. Clementine kann auch diverse Internet-Radiostationen "empfangen", und Songs mit portablen Geräten synchronisieren. Eine Album-Cover-Verwaltung ist ebenso enthalten, wie das Downloaden von Internet-Infos über Musiker oder zum Ergänzen von fehlenden Metadaten oder Album-Covers. Es gibt auch eine anpassbare Listenansicht, wo normalerweise alle Interpreten nach Anfangsbuchstaben gruppiert sind, und deren Albums und schließlich einzelne Songs zum Aufklappen. Damit ist es beispielsweise einfach, alle Songs eines Albums in der Originalreihenfolge in die Playlist zu übernehmen. Des weiteren kann man auch nach Lyrics suchen lassen. Leider funktioniert das Downloaden von Album-Covern und Lyrics meiner Erfahrung nach bei Clementine sehr viel schlechter als bei Amarok bzw. ist die Erfolgsquote geringer. Möglicherweise ist das aber auch nur ein Konfigurationsproblem. Auch ist das Programms schon seit langem (Stand: 2018 und Vorjahre) buggy und hängt sich beim Beenden zumindest unter dem Fluxbox-Fenstermanager reproduzierbar auf, so dass es als Hintergrundprozess ohne sichtbares Fenster funktionslos weiter existiert bis man es "killt".
clex-4.6.patch8-1/misc/raspbian {file manager}{text-terminal IO}: ncurses-based Norton-Commander-style file manager for the text console. Except that only one of the two panels is visible. Both panels can be switched. The invisible panel serves as the destination. Directories can also be bookmarked. Commands are not executed internally, but the file manager rather constructs normal commands like "cp", "mv", "rm", "less" on a built-in command line at the bottom of the screen. The constructed commands can still be edited before finally executing them with the Enter key. There is a history for both visited directories and executed command lines. Offline help is provided. A very lean program (around 400 kB total, including help text). The executable is just about 100 kB and does not depend on any libraries except the C runtime and ncurses. The terminal is split into a large upper area showing the current directory, and a shell command line in a smaller area (but still more than a single line like in mc) below it. A "midnight commander" for the (very) poor. Well suited for minimal console-based rescue systems and initramfs environments.
clif-0.93-9.1/interpreters/devuan: In C-Interpreter. Klingt ja fein. Dann jedoch muss man lesen: [...] Clif [...] is a proper subset of C language. This subset contains all key constructions of C language except [...] structures, unions and pointers [...] Clif contains the program flow control statements "for" "while" and "if" but does not contain the "switch" and "do while" specifications [...]. Noch dazu scheint es, dass clif nur die K&R Syntax für Funktionsdeklarationen beherrscht, also ohne Prototypen. Kurzum, unbrauchbar für alles außer lächerliche Spielereien.
clipit-1.4.2-1/misc/devuan {clipboard manager}{GTK+}: In C geschriebener und in GTK+ implementierter schlanker Clipboard-Manager. Der Hauptzweck solcher Manager ist es, dass der Clipboard-Inhalt nicht verloren geht wenn das Programm welches das Clipboard zuletzt befüllte geschlossen wird. Der Inhalt der primären Maus-Auswahl geht zwar sehr wohl verloren wenn ein Fenster geschlossen wird, jedoch kann man deren Inhalt dann immer noch aus dem Verlauf des Clipboard-Managers zurückholen (vorausgesetzt er wurde konfiguriert die primary selection als Datenquelle für den Verlauf zu nutzen). clipit kann eine Historie der Clipboard-Einträge in eine History-Datei sichern, fragt jedoch vorbildlicher Weise beim ersten Start, ob man dies tatsächlich will, da es gemeingefährlich ist falls man Passwörter und dergleichen übers Clipboard zu kopieren pflegt. Das Programm stellt ein Traybar-Icon zur Steuerung zur Verfügung, wo man alle Einstellungen in einem GUI vornehmen kann. Insbesondere kann man dort auch Tasten-Hotkeys vergeben (bzw. entfernen). Egal ob der Verlauf in eine Datei gesichert wird oder nur im RAM gehalten wird, kann man eine Liste beliebiger RegExes definieren, die von der Aufnahme in den Verlauf ausgenommen werden. Es können "Aktionen" definiert werden, welche definierbare externe Kommandos mit dem aktuellen Text in der Zwischenablage aufrufen. clipit kann zusätzlich auch noch als Kommandozeilen-Befehl dazu verwendet werden, Text welcher von der Standard-Eingabe gelesen oder als Aufrufparameter des Programm-Executables angegeben wurde ins Clipboard zu kopieren. Ebenso kann wahlweise der Inhalt des Clipboards oder der primären Selektion auf die Standard-Ausgabe geschrieben werden - ähnlich wie xclip. Leider lässt sich diese Funktionalität nicht dazu benutzen, aus einer Aktion heraus den Inhalt des aktuellen Clipboard-Eintrags zu ändern. Genauer gesagt scheint das Schreiben des Clipboard-Inhalt überhaupt nicht zu funktionieren. Seltsam. Scheint ein Bug in dieser Version sein. Man kann sich aussuchen, ob clipit nur das Clipboard oder auch die primäre Selektion verwenden soll, sowie ob es beides synchronisieren soll. Für den Verlauf kann man noch konfigurieren, ob die Auswahl eines Eintrags diesen nicht nur ins Clipboard kopiert, sondern auch gleich einfügt (man spart sich also ein nachfolgendes Ctrl-V). Die maximale Größe und einige Anzeige-Attribute des Verlaufs können konfiguriert werden. Es gibt einen Modus, der nur Texte welche eine URL enthalten in den Verlauf aufnehmen (ins Clipboard gelangen auch andere Texte beim Kopieren, nicht jedoch in den Verlauf). Weiters hat das Programm einen "Offline-Modus", in welchem die Aufnahme von Einträgen in den Verlauf grundsätzlich unterbunden wird. Vermutlich ist dies dazu gedacht, Passworte die man wissentlich übers Clipboard kopiert von einer Aufnahme in den Verlauf abzuhalten. Und es merkt sich diese Einstellung auch über Neustarts hinweg. Somit kann man den Verlauf permanent abschalten, wenn man dieses Feature nicht wünscht oder sogar gemeingefährlich findet. Ein Nachteil des Offline-Modus ist jedoch, dass damit die primäre Maus-Selektion verloren geht wenn ein Fenster geschlossen bzw. die Selektion aufgehoben wird. Im Normalmodus wird die Maus-Selektion im Verlauf gespeichert und beim Einfügen mit dem mittleren Mausknopf wird der zuletzt hinzu gefügte Verlaufs-Eintrag automatisch verwendet wenn keine echte Selektion mehr existiert. Als Kompromiss kann man mit der RegEx "." alle möglichen Texte von der Aufnahme in den Verlauf ausnehmen. Dabei bleiben die Selektionen und die Zwischenablege erhalten, wenn ein Fenster geschlossen wird. Der Verlauf selbst kann einerseits in einem eigenen Dialog angezeigt werden, als auch direkt im Menü des Traybar-Icons (dann allerdings nur ein Subset begrenzter Länge des Gesamtverlaufs, wobei man die Länge von beidem separat festlegen kann). Weiters bietet der Verlaufs-Dialog inkrementelle Filterung bei der Suche. Es gibt einen Menüpunkt zum Beenden von clipit. Es gibt Optionen zum Festlegen einer Anzahl von "statischen" Einträgen die getrennt im Kontextmenü des Traybar-Icons angezeigt werden; zu diesem Zweck gibt es im Verlauf eine Funktion zum Editieren der Einträge, bei denen man einen Eintrag auch als "statisch" festlegen kann. Clipit ist ein Fork von parcellite, der interessanter Weise aber weniger zu können scheint als das Original (vermutlich wurde dieses später noch weiter entwickelt). clipit legt seine Settings als Dateien in XDG-konformen Verzeichnissen ab und verwendet keine D-Bus Dienste. Ressourcenbedarf: 40 MB virtuell, 21 MB echter RAM (RSS). Wenn es bereits im Offline-Modus und mit deaktivierten Tastenkürzeln gestartet wurde, belegte es nur 15 MB RAM. Leider moniert ein Bug-Report, dass das Programm 4-5 mal pro Sekunde den Prozessor aufweckt. Das verbraucht unnötig Strom, vor allem wenn ein Rechner ständig oder vom Akku läuft. Man sollte es daher bei längerem Nicht-Gebrauch beenden. Insgesamt macht das Programm aber einen sehr guten Eindruck und lässt keine Wünsche offen. Außerdem ist das Programm leider buggy, indem es nach einiger Zeit oder unter unbekannten Umständen die Exclusion-Liste zu löschen scheint, so dass danach erst recht wieder alle Einträge in den Verlauf aufgenommen werden. Das eliminiert (Stand: Debian 8) den Hauptvorteil gegenüber parcellite wieder.
clisp-2.49/lang/netbsd {programming language}: Beliebte Common-LISP Implementation, die zwar nur Bytecode erzeugt, aber dafür den vollen Standard abdeckt und auch nicht groß ist (8 MB Download, 35 MB installiert). Ein großer Vorteil gegenüber zahlreichen anderen LISP-Implementationen besteht darin, dass es kein bereits installiertes anderes LISP zur Installation benötigt - nur ein C-Compiler ist erforderlich. Clisp war bei einer Umfrage von 2008 die zweitbeliebteste LISP-Implementation. Jahrelang war ich davon überzeugt, dass die Lizenz ein großes Problem darstellen würde: "Das Programm steht unter der GPL und hat nur eine Ausnahme für damit erzeugte LISP-Programme definiert welche nichts als die minimalen Standard-Libraries nutzen. Wer auf irgendwelche der anderen integrierten Libraries zugreift, die teils GPL-lizensiert sind, handelt sich den GPL-Virus ein und muss seine Applikation dann ebenfalls unter die GPL stellen. Das ist anders als beim GCC und ist untragbar wenn man mit der Sprache sowohl privat als auch für eine Firma arbeiten will." Erst 2022 ging ich der Frage in FAQ von clisp näher nach und fand heraus, dass man sich den GPL-Virus weder dann durch clisp einhandelt wenn man ClosedSource-LISP-Quelltexte noch daraus kompilierte *.fasl-Dateien an zahlende Kunden weitergibt. Sondern nur wenn man ein eigene Programm (statisch oder dynamisch) gegen das clisp-Executable linkt. Und selbst dann gibt es noch eine Möglichkeit die GPL zu vermeiden, indem man statt dessen über einen Socket mit dem clisp-Executable kommuniziert anstatt direkte Funktionsaufrufe zu tätigen. Dass man sich hingegen mit der Verwendung von GPL-lizensierten Erweiterungs-Bibliotheken wie libreadline den GPL-Virus einhandelt, ist nicht clisp-spezifisches sondern trifft für jede Sprachimplementierung zu. Clisp selbst verwendet die GPL da es sowohl die libreadline als auch die libgmp verwendet, die beide GPL-lizensiert sind. Die oben erwähnten Ausnahmen von der GPL für damit kompilierte oder interpretierte Programme entsprechen ziemlich denselben die der GCC (welcher ebenfall sie libgmp verwendet) ebenfalls hat. Clisp lässt sich daher praktisch genau so problemlos und umfangreich wie der GCC verwenden, bei dem die Lizenz auch noch nie ein Problem dabei war. Die Startmeldung von clisp enthält einen riesigen 7-armigen Leuchter als ASCII-Grafik, und die Namen der Entwickler machen alle einen sehr jüdischen Eindruck. Die Kombination von beidem macht den Einsatz von clisp poltisch heikel, da manche Kunden in bestimmten Ländern den Eindruck gewinnen könnten dass diese Implementation nicht politisch neutral sei sondern bestimmte Weltanschauungen verherrlicht welche sie ablehnen.
cmake-3.25.1-1/devel/raspbian {software build system}: Ein in C++ implementiertes Meta-Buildsystem. Das bedeutet, es erzeugt nur Projektdateien für andere Build-Systeme, kann aus eigener Kraft heraus aber gar nichts selbst bauen. Es unterstützt als Ziel-Buildsysteme mehrere OpenSource-IDEs sowie Makefiles und Ninja. Die erzeugten Makefiles rufen allerdings intern cmake als Hilfswerkzeug auf, anders als bei den GNU Autotools mus CMake daher fürs Bauen der Projekte immer ebenfalls installiert sein. Wenn Ninja ohnehin installiert ist, sollte man es als Backend vorziehen da es effizienter arbeitet. Die CMake-Dokumentation ist eingebaut und kann mit "$ cmake --help-full | less" angezeigt werden.
cockpit-188-1/admin/raspbian: Ein Web-Panel für systemd-basierte Systeme. Stellt ein hübsches und zeitgemäß aussehendes Web 2.0 GUI im Browser zur Verfügung, wo man alle möglichen systemd-Settings die man eben so gut auch im Terminal anzeigen kann dann eben im Browser sieht. Es kann auch hübsche Diagramme zeichnen, nicht unähnlich dem KDE/GNOME "Systemmonitor". Es ist auch ein ziemlich schlankes System und braucht nicht einmal einen externen Webserver. Sogar ein Terminal wird im Browser laufend emuliert! Alles sehr gut und schön. Mein einziges Problem ist dass ich keinerlei Vorteile gegenüber der traditionellen Bedienung des Systems erkennen kann. Cockpit sieht zwar schicker aus, zeigt aber nur ein Subset der tatsächlich vorhandenen Parameter an. Die relevantesten allerdings schon. Trotzdem, irgendwie sinnlos. Wohl nur für Commandline-Hasser zu gebrauchen, die auf diese Weise dann doch ihren Server ein bisschen konfigurieren können.
coda-6.9.5/net-fs/gentoo: Ein replizierendes Netzwerk-Dateisystem mit offline-Fähigkeit und Tools zur späteren Resynchronisation sowie Konfliktauflösung. Im Grunde sehr toll. Jedoch: Alles seit Jahren in sehr alpha-mäßigem Entwicklungszustand; flog 2012 wegen Integer Overflows und anderer Probleme aus dem offiziellen Portage-Tree. Ich schloß mich dem an - was nützt das tollste Dateisystem, wenn es unzuverlässig arbeitet? Davon abgesehen kann man mit Unison einen ähnlichen Effekt wie die Offline-Fähigkeiten von Coda erreichen, und das ganz ohne die Mithilfe des Dateisystems. Und wenn ich wirklich ein Netzwerk-Dateisystem will, habe ich noch davfs2, wdfs, NFS und glusterfs installiert. Außerdem versaut Coda frech das Wurzeldateisystem mit einem /coda-Eintrag; eine Seuche die es von afs geerbt hat.
codeblocks-16.01+dfsg-2+b1/devel/devuan {development_environment}{GUI}{X11}: Code::Blocks ist eine supertolle Crossplattform-IDE für C/C++, die einfach alles bietet. Debugger-Integration, Symbol-Browsing, Code Folding, Keyword Completion. Mit wxWidgets geschrieben, es gibt Versionen für Windows und Linux und vermutlich auch Mac. Unterstützt Projekte mit mehreren Build-Targets und Abhängigkeiten zwischen diesen. Pre- und Post-Build Aktionen sind ebenfalls möglich. Unendlich viele Optionen zum Einstellen; erinnert sehr an Visual Studio. Ist offenbar auch als Alternative für dieses gedacht, da es VS-Projektdateien zumindest importieren kann. Der Symbolbrowser stellt alle Projektsymbole in einer mehrstufigen Ansicht ausreichend übersichtlich dar. Das Kontextmenü im Editor, gestattet es alle Referenzen eines Symbols zu finden, dessen Deklaration oder Implementation. Allerdings scheint diese Funktionalität nicht mit dem Symbol-Browser integriert zu sein, denn es sucht jedesmal alle Quelltext-Dateien durch. Da die Suche dabei aber relativ schnell erfolgt, beschränkt sich die Dauer auf die reine Lesedauer der Dateien und beträgt daher nur einige Sekunden. Dennoch wäre es schneller hierzu einen Index zu verwenden. Die oben genannte Version hat einen Bug, der bei der 32-Bit-Version die meisten Icons im Symbol-Browser als schwarz gefüllte S/W-Grafik anzeigt, während der Symbolbrowser in der 64-Bit-Version überhaupt nicht funktioniert. Weiters wird der Linker mit einer falschen Reihenfolge der Objektdateien aufgerufen, was den GNU-Linker zwar nicht stört, andere Linker aber möglicherweise sehr wohl. Die IDE besitzt ein eigenes Build-System, basierend auf XML-basierten Projektdateien. Es unterstützt weder Autotools noch CMake, und auch die früher vorhandene Möglichkeit ein Makefile zu erzeugen scheint mittlerweile verschwunden zu sein. Es gibt allerdings separate externe Projekte wie insbesondere "cbp2make", welche Code::Blocks-Projektdateien in "richtige" Makefiles umwandeln können. Aber leider sind die erzeugten Makefiles nicht portabel da sie die Reihenfolge der Argumente bei Linker-Aufruf nicht korrekt berechnen sondern irgendwie aus der Reihenfolge der Source-Files im Projekt abzuleiten scheinen. Offensichtlich besteht hier dasselbe Problem wie auch beim IDE-internen Build - siehe oben. Auf der anderen Seite funktionieren die Makefiles aber zumindest unter Linux und Windows mit dem GCC. Dennoch, die Linker-Reihenfolge manuell festlegen zu müssen (wenn man portable Makefiles wünscht) ist eine ziemliche Zumutung, denn wozu braucht man dann eigentlich noch eine IDE? Wenn man sich mit solchen Details herum ärgern will, kann man das Makefile eben so gut auch gleich selbst schreiben.
codelite-2.6.0.4189/dev-util/gentoo {development_environment}{GUI}{X11}: A very powerful IDE which has it all: Symbol browser, debugger integration, multiple configuration support, inter-project dependencies, can import from Microsoft Visual Studio, can make use of existing UNIX Makefiles, auto-generates Makefiles for building, uses text files for storing configuration. The only drawbacks are: It cannot generate or update existing Makefiles from Cmake or Automake, generated config files need manual tuning sometimes to avoid absolute filenames or repeated options, there seems to be no other way to set the font size for all project templates than to batch-edit dozens of configuration files manually. On the plus side, the generated Makefiles are very simple and straightforward and don't require any GNU extensions. Codelite might be a good idea for the initial development of non-trivial applications and libraries before they reach the point where Automake/Autoconf support becomes mandatory. In other words, it is useful for initial rapid prototyping, but its built-in project support becomes rather useless once the project has switches to Autotools. Nevertheless, it may be still a nice editor and debugger. Due to its built-in project-wide symbol browser and CSCOPE support it is also useful for code-reviews.
command-not-found-0.2.38-1/admin/devuan: Ein vor allem für Anfänger sehr nützliches Paket. Das Paket integriert sich zumindest in die Bash und wird aktiv wird sobald ein nicht installiertes Programm durch den Benutzer aufgerufen wird. Denn wird dem Benutzer eine Fehlermeldung gezeigt welches Paket er installieren müsste, um das nicht gefundene Programm aufrufen zu können. Falls es in keinem Paket einen direkten Treffer gibt, wird eine Ähnlichkeits-Suche nach einem ähnlich klingenden Programm durchgeführt. Auch dieses Paket hat ähnlich wie "apt-file" das Problem, dass erst ein Suchindex aufgebaut werden muss damit es funktionieren kann. Als Basis des Suchindexes müssen zudem detaillierte Paketinformationen aller angebotenen Pakete herunter geladen werden. Genauer gesagt verwendet command-not-found intern apt-file, so dass alle Nachteile von apt-file bezüglich der übertragenen Datenmenge für die zusätzlich benötigten Paketinformationen auch hier schlagend werden. Ein weiterer Nachteil von command-not-found ist, dass jede Fehleingabe eines nicht existierenden Programmnamens automatisch die Ähnlichkeitssuche auslöst, welche eine unnötige Wartezeit bis zu mehreren Sekunden bewirken kann, falls man sich nur vertippt hat und gar kein zusätzliches Paket installieren will.
concalc-0.9.2-2/math/debian {calculator}{text-terminal IO}: Der in C++ geschriebene kleine Bruder des GUI-Taschenrechners Extcalc. Bequem und kann auch Programmargumente als Ausdrücke auswerten. Beherrscht auch die üblichen mathematischen Funktionen wie sin(), ln() usw. Kann sogar numerisch Differenzieren und Integrieren. Beherrscht auch C-ähnliches Scripting ähnlich wie "bc" oder "calc". Kurz: keine 170 KB Installationsumfang. Showstopper jedoch: Scheint intern nur mit stinknormalen Fließkommazahlen zu arbeiten. Daher Genauigkeit und Wertebereich auf die eines "double" beschränkt. Unbrauchbar für gehobene Ansprüche - außer vielleicht für Ingenieure und Messwertverarbeitung.
conky-1.9.0-r3/app-admin/gentoo: Ein Tool zum Anzeigen von Betriebsparametern ähnlich wie htop, jedoch in einem grafischen Fenster und nicht interaktiv. Fenster bedeutet dabei nicht notwendiger Weise ein normales Fenster, obwohl auch das unterstützt wird. Sondern Conky kann seine Ausgabe auch direkt auf den Desktop-Hintergrund rendern, oder als ein "Dock"-Fenster (vermutlich für WindowsMaker), "Panel" (?) und noch ein paar andere Modi. Unklar ist ob damit auch Fenster erzeugt werden können die im System-Traybar angezeigt werden. Was genau im Fenster angezeigt wird ist relativ frei konfigurierbar und kann auch durch eigene Scripte erweitert werden. Conky's Konfigurationsdatei ist ein Lua-Script, und es können auch eigene Lua-Scripte verwendet werden die zur Laufzeit Berechnungen anstellen. Ein Nachteil von Conky ist seine relative Fettheit: Selbst der simpelst denkbare Graph, der nur ein konstantes Zeichen anzeigt, verbrät schon 21 MB virtuellen Speicher und 12 MB residenten RAM. Der RAM-Bedarf wird zwar kaum höher wenn der Graph komplexer wird; der virtuelle Speicherbedarf verfielfacht sich aber sehr wohl. Es gibt zwar sicherlich noch fettere Programme als conky, aber schlank ist definitiv anders.
connman-1.36-2.2+deb11u1/net/debian: Ein NetworkManager für Arme. Verspricht ebenfalls alles ganz unglaublich toll zu können, und benötigt dazu ebenfalls einen ständig laufenden Daemon. Allein schon aus diesem Grund nichts für mich! Aber vielleicht interessant für Leute die ein "Internet-Icon" haben wollen, die jedoch eine schlankere Lösung als den echten NetworkManager haben wollen. Zumindest behauptet conmann, "mit so wenigen Ressourcen wie möglich" auszukommen. Jedenfalls kann der connman zumindest Ethernet, VPN und Wi-Fi verwalten. Mit BlueZ und oFono angeblich auch Bluetooth und Mobilfunkmodems.  Überdies kann er ans DNS-Cache bzw. -proxy fungieren. Er integriert sich auch mit dem systemd und scheint Gebrauch von D-Bus zu machen. Tatsächlich startet er 2 Prozesse welche je 5 MB RAM belegen, zusammen also 10 MB. Das ist zwar nicht sehr fett, aber auch nicht gerade schlank. Dazu startet er dann auch noch den wpa_supplicant, auch wenn man noch keinerlei Wi-Fi eingerichtet hat. Damit sind es dann schon 15 MB RAM. Er scheint auch Bonjour, also ZeroConf zu unterstützen, und ebenso UPNP. Er bringt ein halbwegs benutzerfreundlich wirkendes CLI mit. Ebenso kann man einen weiteren "Agenten" installieren, der das Wi-Fi-Passwort vom Benutzer abfragt. Insgesamt macht das ganze zwar einen halbwegs brauchbaren Eindruck. Aber ebenso vernebelt er einem dem Blick was tatsächlich vorgeht und wirkt mich ähnlich unnötig wie der echte NetworkManager. "Internet Icon" bringt er zudem gar keines mit.
console-data-???/???/debian: Ein eigentlich überflüssiges Paket, da eine deutsche Locale auf der Konsole auch ohne dieses Paket erzielbar ist. Jedoch gibt es zumindest unter Raspbian das Problem, dass die deutsche Tastaturbelegung, obgleich installiert, nicht automatisch durch die init-Scripte aktiviert wird, wenn das Paket console-data nicht ebenfalls installiert ist.
construo/games-puzzle/gentoo {game}: Man konstruiert Wireframe-Objekte in einem Editor, und diese werden dann per Knopfdruck simulierten Kräften ausgesetzt und von diesen zerstört oder auch nicht. Zwar irgendwie interessant, aber kein Spiel das irgend ein Ziel hätte. Erinnert irgendwie an "Bridge Builder", nur ohne die Brücke und ohne den Zug... ;-)
copyfs-1.0.1-5/utils/debian {version control}{FUSE}: Ein lustiges FUSE-Dateisystem, welches vor jeder Änderung einer Datei eine interne Kopie der Datei erstellt. Optimal für Leute welche zu faul sind ein Versionskontrollsystem zu benutzen, die aber trotzdem Angst haben ihre früheren Änderungen zu verlieren. Leider ist copyfs sehr primitiv und legt einfach nummerierte Dateien in seinem Metadatenverzeichnis an, sowie zusätzliche Metadaten-Dateien (in Textform), ohne irgend etwas zur Eindämmung der Datenmenge zu tun. Es erstellt nur volle Kopien der Dateien, und benutzt kein diff oder dergleichen um die Datenmenge zu reduzieren. Für große Datenmengen wäre es daher zu ineffizient. Außerdem hat es offenkundig Probleme mit der Synchronisation - mehr als einmal beim Testen erhielt ich Meldungen von Editor, dass die Datei am Datenträger neuer sei als die gerade editierte. Und auch von copyfs selbst kamen regelmäßig Warnungen. Jedoch hatte offensichtlich keine der Meldungen negative Auswirkungen, es schien trotzdem alles korrekt zu funktionieren. Im Grunde also ein brauchbares Tool, das nur durch den ineffizenten Umgang mit dem Platzbedarf fragwürdig erscheint. oriFS wäre eine deutlich effizientere, aber auch komplexere Alternative.
coq/sci-mathematics/gentoo: Dies ist kein automatisches Beweis-System wie man bei oberflächlicher Betrachtung der Beschreibung vielleicht glauben können mag, sondern nur ein Framework mit dem man OCaml-Programme erstellen kann die dann Beweise durchführen. Daher sicher ein sinnvolles Tool für Experten auf dem Gebiet, aber nichts was für einen Endanwender direkt interessant wäre der nur irgend einen vermuteten mathematischen Sachverhalt bewiesen haben möchte.
cpipe-3.0.1-1/utils/debian: cpipe kann wozu "buffer" unfähig ist: Einen Datenstrom in beliebige große Blocks zerlegen und nach jedem Block eine optionale Pause einlegen. Genauer gesagt kann man die Geschwindigkeit in KiB/s beschränken. Es kann während des Transfers optional auch die aktuelle Geschwindigkeit sowie die bislang übertragene Datenmenge anzeigen. Andererseits, mit wget kann man die Rate einfacher limitieren wenn am anderen Recher ein Web-Server verfügbar ist.
cpufreqd-2.4.2-2/admin/debian: Ein reichlich sinnloses Programm, dessen einzige Existenzberechtigung darin zu bestehen scheint, dass es in Ausnahmesituationen (wie Überhitzung oder wenn der Ladestand der Batterie eine bestimmte Grenze unterschreitet) profilgesteuert automatisch die Konfiguration der aktuellen Powersave "Governors" ändern kann. Allerdings kann man das genau so gut mit der Hand machen. Die eigentlichen Governors brauchen diesen Daemon nicht, um zu funktionieren.
cpuinfo-0.0~git20220617.082deff-1/science/raspbian: Stellt das "cpu-info" Utility zur Verfügung, welches einem nur die allergrundlegendsten Informationen über die CPU und das Chipset anzeigt. Diese sind sogar noch weniger als das was /proc/cpuinfo ausgibt, da z. B. die CPU-features nicht angezeigt werden. Etwas weniger freundlich formuliert, wertloser Müll, könnte man meinen. Doch halt! Es bringt auch 2 weitere Utilities mit: "cache-info" zeigt die Größe und Art der CPU-Caches an, und "isa-info" zeigt die zuvor vermissten Details über das Instruction Set an.
cramfs/sys-fs/gentoo: On-disk-structures are specific to MMU-page size and endianness. Also gid truncation, no DOLM and other issues. Limited maximum file size. Only for very small ROM filesystems, squashfs is quite better for larger ones.
crispy-doom-5.10.0-1/games/raspbian {game}: Eine Game-Engine für Doom, Doom 2 und Heretic. Ab Debian-12 "bookworm" wird auch "Hexen" unterstützt. Weiters unterstützt es die alten "Classic" Doom-Levels, welche der "DOOM 3: BFG"-Edition als Zusatz-Gimmicks beigepackt wurden. Weiters alle Versionen der Levels von "John Romero's Episode 5: Sigil for Ultimate Doom". Nahezu alle Varianten und Mods dieser Spiele werden unterstützt. Es handelt sich um einen Fork von "chocolate doom", der Unterstützung für höchste Bildschirmauflösungen, mehrere Bildschirm-Seitenverhältnisse, mehr FPS und andere Vorteile (etwa auch Maus + "WASD"-Steuerung anstatt nur Cursortasten wie im Original, viele Optionen zum Anpassen von Rendering und Einfärben diverser Spiel-Elemente) mitbringt. Allerdings darf man nicht glauben dass deswegen die Grafik eine höhere Auflösung als das Original hätte - sie wird lediglich primitiv klötzchen-hochskaliert. Zwar erlaubt crispy-doom eine Auflösung von 640x400 anstatt der Original-Auflösung von 320x200. Aber da die Texturen auf die Original-Auflösung abgestimmt sind, schaut das Ergebnis trotzdem nicht viel anders aus. Daher stammt auch der Name, er bezieht sich darauf dass man hier die Pixel noch scharf sieht anstatt dass ein Versuch unternommen wurde sie unscharf zu machen. Sehr originalgetreu. Auch kompatibel zu den Save-Games der Originalspiele. Die Levels der Doom 1 Shareware-Variante werden direkt (bzw. via Abhängigkeits-Paket) mitgeliefert, die Copyright-geschützten Original-Leveldateien kann man allerdings, so vorhanden, dazu installieren und dann ebenfalls benutzen. Keine Performance-Probleme, allerdings besteht eine gewisse Gefahr dass einem von den schnell bewegten groben Klötzchen-Pixel in der hochskalierten Original-Auflösung übel wird oder man nach einiger Zeit zumindest Kopfschmerzen davon bekommt.
criticalmass/games-arcade/gentoo {game}: Witziges Galaga-ähnliches Ballerspiel mit reletiv großen Grafikobjekten, netten Farbübergängen im Hintergrund - aber *sauschwer*. Erst wenn man eine "kritische Masse" an Waffen, Extras etc. erreicht hat, besteht auch nur die geringste Chance weiterzukommen. Gefällt mir; leider derzeit nur für 32-Bit.
cryfs-0.9.10-2/utils/debian {FUSE}: Ein Dateisystem, welche (von ihm selbst zuvor) verschlüsselte Dateien in einem Verzeichnisbaum in einem FUSE-gemounteten virtuellen Verzeichnisbaum so darstellt, als wären sie unverschlüsselt. Crypfs ist somit ein direkter Konkurrent von EncFS, der unter einigen bekannten Sicherheitslücken leidet. Crypfs trumpft im Vergleich dazu gleich schon einmal mit starken unterstützten Ciphers auf: AES, TWOFISH, SERPENT und MARS - alle wahlweise mit 128 oder 256 Bit Schlüsselstärke, und entweder mit GCM pder CFB als Chaining-Modus. Vor allem die Verfügbarkeit des starken SERPENT (und nicht nur das lautstark von der NSA lautstark als sicher gepriesene AES) ist sehr erfreulich. Der CFB-Modus ist zwar sogar noch unsicherer als das ohnehin schon von Problemen gequälte CBC, aber solange der als halbwegs sicher geltende GCM zur Verfügung steht ist das egal. Cryfs wirbt damit die verschlüsselten Dateien in die Cloud zu legen - mit CFB eine sehr schlechte Idee, aber GCM sollte auch hier sicher sein. Derzeit (2017) ist das Projekt aber noch sehr neu und die Entwickler selbst bezeichnen es noch nicht als stabil. Außerdem ist noch nicht alles implementiert, konkret die Integritätsprüfung - dadurch werden "Replay-Attacken" früherer Block-Inhalte durch den Cloud-Provider möglich. Ich würde es derzeit daher nicht verwenden wollen. Aber ein interessantes Projekt, das man im Auge behalten sollte. Außerdem ist sich der Autor der Schwachstellen bezüglich Replay-Attacken von CBC offenbar durchaus bewusst, denn er klagt auf der Webseite über entsprechende Mängel von EncFS. Es ist daher zu hoffen, dass er dieselben Fehler nicht selbst machen oder zumindest noch beheben wird. Außerdem speichert cryfs zwar einzelne verschlüsselte Dateien, aber es gibt keine 1:1-Korrespondenz zwischen den virtuellen entschlüsselten Dateien und den verschlüsselten. Cryfs zerhackt Dateien und Verzeichnisse offenbar selbst zuerst in intern genutzte Blocks und verwaltet diese danach in einer Baumstruktur, und nur die Knoten und Blätter des Baumes tauchen als verschlüsselte Dateien am realen Datenträger auf. Ein eigentlich sehr guter und auch für die "Cloud" geeigneter Ansatz, sobald die Integritätsprüfung einmal zuverlässig funktionieren sollte. Die Default-Blockgröße sind 32 KiB, was mir viel zu groß erschien. Doch die kleinste Blockgröße mit der sich überhaupt ein Dateisystem anlegen lässt sind 256 Bytes. Allerdings hängt es sich dann rasch mit einer Fehlermeldung auf. Das blieb auch so als ich die Blockgröße bis zu 1024 Byte erhöhte - das ist die Default-Blockgröße von EncFS. Als ich den Default von 32 KiB akzeptierte, funktionierte es dann. Nach den Anlegen des verschlüsselten Verzeichnisses befinden sich lauter Dateien darin welche alle exakt die angegebene Blockgröße groß sind. Jede dieser Dateien ist offensichtlich anhand eines Hashwertes benannt, und zwar Hexadezimal. Damit nicht zu viele Einträge im selben Verzeichnis liegen, sind diese Dateien alle in Unterverzeichnisse verteilt deren Namen aus 3 Hex-Ziffern besteht und offenbar die ersten 3 Hex-Nybbles des Hashes vorweg nehmen (sie werden im Dateinamen nicht wiederholt). Bis auf diesen sehr einheitlichen Aufbau gibt es nur eine einzige Datei mit einem festen Namen im selben Verzeichnis in dem die ganzen Unterverzeichnisse liegen, und das ist die Konfigurationsdatei von cryfs. Sie ist binär und enthält bis auf ein paar wenige Strings nur nichtssagende Bytewerte - vermutlich IVs, Salts etc. Grundsätzlich scheint alles zu funktionieren, jedoch ist die große Blockgröße unpraktisch beim Remote-Zugriff, da diese Blöcke (nehme ich einmal an) immer zur Gänze übertragen werden müssen. Selbst wenn die Daten der Dateien innerhalb der Blöcke effizient gespeichert sein sollten und mehrere kleine Dateien im selben Block abgelegt sein mögen (was ich einmal hoffen will), wäre der Datenübertragungs-Overhead für einen Remote-Zugriff (etwa via WebDAV gemountet) wegen der Blockgröße in Summe sicherlich enorm. Das Dateisystem ist zudem relativ lahm. Allerdings hatte ich auch SERPENT-256-GCM für meinen Test verwendet, und das braucht sicherlich einige Rechenleistung. Grundsätzlich funktionierte es aber. Was ich nun noch in Erfahrung bringen müsste ist woher das Programm seine Zufallszahlen bezieht, und ob es diese nur bei der Generierung des Dateisystems oder auch permanent während der Arbeit braucht. Negativ fiel mir auf dass crypfs per Default bei jedem Aufruf einen Internet-Server kontaktiert um auf Updates oder Sicherheitswarnungen zu prüfen. Man kann dies zwar durch das exportieren einer Umgebungsvariable verhindern, aber das könnte man leicht vergessen und dann "telefoniert crypfs nach Hause". Zwar ist angesichts des OpenSource-Charakters des Programms zu hoffen dass es auch wirklich nur das behauptete tut. Aber es geht trotzdem verdammt noch Mal niemanden etwas an wann ich ein verschlüsseltes Dateisystem mounte und unter welcher IP-Adresse ich währenddessen erreichbar bin! Außerdem scheint das Dateisystem häufig in Troubles zu geraten und funktioniert dann nicht mehr sondern gibt lediglich die Meldung "Transport endpoint is not connected" an (obwohl der FUSE-Daemon des Programms nach wie vor läuft). Im Log sah ich darauf hin, dass Hard Links scheinbar noch nicht implementiert sind. Versucht man trotzdem einen anzulegen, hängt sich das Dateisystem mit der genannten Fehlermeldung auf. Es wird in solchen Fällen auch rasch korrupt, und die letzten geänderten Dateien sind dann kaputt bzw. geben nur noch Lesefehler beim Zugriff aus und lassen sich scheinbar auch nicht mehr löschen. Da es auch kein fsck-Utility für cryfs gibt, dürfte die einzige Option in so einem Fall sein ein neues Dateisystem anzulegen, und alle Dateien welche man aus dem alten noch lesen kann ins neue zu kopieren, und das alte dann zu löschen. Kurzum, so unreif wie das ganze nach wie vor ist, ist es nicht lustig damit zu arbeiten. Es bleibt daher vielversprechend, aber solange nicht einmal alle grundlegenden Dateisystemoperationen unterstützt werden und zum Absturz des Dateisystems führen, kann man damit praktisch nicht arbeiten. Oder nur unter sehr kontrollierten Bedingungen, wie von einen Script ausgewählte Dateien hinein kopieren zu lassen.
cssc-1.4.0-6/vcs/debian {version control}: Eine mehr oder weniger originalgetreue Re-implementierung des in POSIX standardisierten SCCS ("Source Code Control System"). Es handelt sich dabei um ein Versionskontrollsystem für Textdateien, die ähnlich primitiv wie RCS ist, jedoch sogar noch primitiver und zugleich umständlicher. Dennoch dürfte SCCS bei kommerziellen UNIXen sehr verbreitet sein, wohl auch da es dort meist vorinstalliert mit kommt und überdies schon sehr lange existiert. Grundsätzlich arbeitet SCCS so, dass es ähnlich wie RCS nur einzelne Dateien versioniert. Für jede Arbeitsdatei gibt es eine Metadatendatei mit zugehöriger Historie und Deltas, die standardmäßig in einem SCCS-Unterverzeichnis desselben Unterverzeichnisses gespeichert sein müssen in dem sich die jeweilige zugehörige Quelltextdatei befindet. (Dies kann man mit Optionen aber temporär übersteuern.) Wenn man Dateien auscheckt um damit arbeiten zu können, bevölkert SCCS das Arbeitsverzeichnis mit zahlreichen zusätzlichen Metadaten-Dateien, die teilweise sehr ulkige Dateinamen haben. Außerdem legt es für jede unter Versionskontrolle gestellte Datei ein Backup an, welche wie der Originalname benannt ist nur mit einem Beistrich als erstes Zeichen. Immerhin entfernt es die meisten dieser seltsamen Dateien wieder sobald man eine Datei nach dem Bearbeiten eincheckt. Das Dateiformat der SCCS-Metdaten-Dateien scheint gewisse Ähnlichkeiten mit denen des bekannten kommerziellen Versionskontrollsystem "Bitkeeper" zu haben. Oder letzeres strebte auch nur eine gewisse Grund-Kompatibilität mit dem damals wohl kommerziell noch sehr wichtigen SCCS an. Das Format selbst ist primär ein Textformat, jedoch enthält es an zahlreichen Stellen CHR$(1)-ASCII-Steuerzeichen ([Ctrl]-[a]) welche die verschiedenen internen Datenbereiche von einander trennt. Nur weil es sich um ein Textformat handelt, darf man davon aber keinesfalls Leserlichkeit erwarten. Es sieht eher so ähnlich aus wie TROFF-Dateien, mit lauter 1- oder zwei Buchstabenkürzel die irgendwas bedeuten. Eine RCS-Kontrolldatei ist da sehr viel verständlicher, auch wenn sie im Grunde ähnliche Informationen speichert. SCCS hat ein Datumsproblem da es Jahreszahlen nur 2-stellig zu speichern scheint. CSSC ist zwar Year-2000 compliant, und "teilweise" auch Year-2038-compliant. Was das im Detail bedeutet konnte ich noch nicht ermitteln. Aber die Bezeichnung "CSSC" steht für "Compatibly Stupid Source Control", und das trifft angeblich auch aud die Jahreszahlen-Unterstützung zu, was vermutlich nichts all zu gutes bedeuten kann. Auch der 2. Satz in der Einleitung empfiehlt bereits, CSSC nicht für neue Projekte zu benutzen. Statt dessen werden RCS und CVS empfohlen. Grundsätzlich scheint CSSC daher vor allem historisch interessant zu sein, oder wenn man von berufs wegen gezwungen ist mit bereits vorhandenen Quelltexten unter SCCS-Kontrolle zu arbeiten. Das eigentlich einzig halbwegs Positive was mir an SCCS auffiel, war dass es sich mehr als andere VCS um UNIX-spezifische Details wie Benutzer- und Gruppenberechtigung kümmert, und diese auch in seine internen Berechtigungen einbezieht. Etwa was Datei-Sperren betrifft. Ob das auch irgendwelche praktischen Auswirkungen haben kann sei dahin gestellt, da es sich um keine SUID-Programme handelt die irgendwelche Benutzerbeschränkungen durchsetzen könnten.
ctorrent-3.2-r1/net-p2p/gentoo: Commandline-client for Bittorrent. Can also create .torrent files. Works quite well for normal tracker-based torrents, but unfortunately it does not support trackerless torrents which use the Kademlia protocol.
ctwm-3.7-4+b1/x11/debian {window manager}{GUI}{X11}: Eine irgendwie aufgepeppte Version des twm. Sieht optisch aber auf den ersten Blick ziemlich identisch aus. Möglicherweise punktet er auch durch sinnvollere Default-Einstellungen. Vermutlich hat er zudem irgendwelche Zusatzfunktionen - diese springen einem dann allerdings nicht sofort ins Auge. NetBSD zieht ihn jedenfalls dem originalen twm vor. Doch beide bleiben eine Zumutung.
cuneiform-1.1.0+dfsg-5/non-free/graphics/devuan {OCR}: Cuneiform ist deutlich schneller als Tesseract, die Texterkennung jedoch etwas schlechter. Das größte Problem ist aber dass dieses Programm Probleme hat Text in Tabellenform bzw. das Layout von Textspalten allgemein korrekt zu erkennen und in der Ausgabe als sinnvoll weiterverarbeitbarem Text zu präsentieren.
cunit-2.1-r1/dev-util/gentoo: Ein Unit-Testing Framework für C. Man verfasst im wesentlichen Callbacks für die Test-Cases, und das Framework ruft diese dann auf und sammelt die Ergebnisse. Dabei kann man die Tests auswählen, es gibt Curses und Commandline-GUIs. Auf der anderen Seite bietet cunit eine größere Menge an Makros und Funktionen, mit denen man assert()-ähnliche Tests durchführen kann deren Erfolg das Framework auswertet. Klingt alles soweit nicht schlecht, aber leider arbeitet alles mit globalen Variablen und macht mir keinen sonderlich flexiblen Eindruck. So bieten die meisten Callbacks etwa keine Möglichkeit Argumente zu übergeben, so dass man erneut auf globale Variable angewiesen ist. Die grundsätzliche Strukturierung ist 3-stufig: Test Cases werden in Test Suites gruppiert, und diese wiederum können in einem globalen Test Kontext aktiver Tests zusammengefasst werden. Die Ausgabe kann entweder durch die GUIs erfolgen, oder in ein XML-File. Mich stört an cunit die Inflexibilität und intensive Verwendung globaler Variablen; bis auf die GUIs nimmt einem das Framework kaum Arbeit ab und nervt eher im Gegenteil mit administrativen Funktionen die man ständig aufrufen muss.
cutemaze-1.1.1/games-puzzle/gentoo {game}: Ein Irrgartenspiel wo man als Maus mehrere Kästestücke finden muss (oder als Pinguin mehrere Fische). Man sieht einen Ausschnitt des Irrgartens von oben, und hinterlässt Spuren die einem helfen bereits abgeschrittene Wege zu erkennen. Die Grafik ist simpel. Das Highlight des Spiels ist die automatische Generierung der Irrgärten, wobei mehrere Algorithmen zur Verfügung stehen. Leider ist nirgends erklärt wodurch sie sich unterscheiden, obwohl die erzeugten Irrgärten durchaus "irgendwie anders" aussehen. Man kann auch Breite und Höhe des Irrgartens festlegen und die Ansicht zoomen - doch häufig reicht der maximale Zoom nicht aus den ganzen Irrgarten auf den Bildschirm zu bringen. Ein Problem ist, dass man überhaupt keine Ahnung hat wo sich die gesuchten Käsestückchen befinden, wenn sie nicht zufällig am Bildschirm sichtbar sind. Aber immerhin gibt es eine "Hint"-Funktion wo einem dann ein Pfeil in die Richtung zum (vermutlich nächsten) Käsestück weist. Etwas nervig ist auch die zu langsame Tastaturwiederholung, so dass man sich bei größeren Irrgärten den Finger wund tippt. Ein etwas dümmliches Spiel, aber mit 400 KB gerade noch annehmbar klein. Außerdem läuft es wohl selbst auf den lahmsten Rechnern.
cvs2svn-2.4.0-2/vcs/debian {version control}: Ein Python verfasster Konverter, der CVS-Repositories (einmalig, nicht inkrementell) nach Subversion, Bazaar-NG und Git konvertieren kann. Angeblich zuverlässiger und weniger fehlerträchtig als git-cvs; daher vorzuziehen außer wenn inkrementelle Konvertierung vonnöten ist.
d1x-rebirth-0.58.1-1+b1/non-free/games/debian {game}: Siehe d2x-rebirth - praktisch dasselbe für die erste Ausgabe des Originalspiels. Nicht minder gut. Jedoch deutlich geringerer Installationsumfang (12 MB) der (unfreien und separat zu besorgenden) Level-Dateien. Daher eine bessere Wahl als der Nachfolger, wenn beim Speicherplatz für die Installation der Level-Dateien gespart werden soll.
d2x-rebirth-0.58.1-1.1/non-free/games/debian d2x-rebirth-0.57.1/games-action/gentoo {game}: OpenSource-Version des bekannten Amiga/PC-Spiels "Descent 2". Leider ist nur das Programm selbst OpenSource; zum Spielen benötigt man eine Kopie der Grafik/Level-Originaldateien (260 MB) des proprietären Spiels. Nichts desto weniger ist es eine bestens gelungene Version des Originals welche denselben Spießspaß bietet. Zum Inhalt: Man steuert ein Raumschiff, welches auf einem ausgehöhlten Asteroiden in einem 3D-Höhlensystem herumfliegt. Dabei wird man von allen Arten von Robotschiffen angegriffen, muss Schlüssel sammeln um zugehörige Schlösser aufsperren zu können sowie Waffen finden um sich verteidigen zu können. Ultimates Ziel jedes Levels ist es, den Zentralreaktor der Station in die Luft zu jagen und dann durch einen Tunnel zu entkommen bevor der Asteroid explodiert. Durch das Retten von verschleppten Raumfahrern kann man Extrapunkte Sammeln. Die Levels selbst, die Steuerung und selbst die Karte sind echtes 3D - kein 2D mit zusätzlicher Höhenkomponente wie in vielen anderen Pseudo-"3D"-Spielen. Die 3D-Karte war so ziemlich einer der letzten Versuche in 3D-Spielen, ein in 2D-Spielen übliches Automapping zur Verfügung zu stellen bevor man dies wegen der Unübersichtlichkeit aufgab. Durch die freie 3D-Steuerung ist es in diesem Spiel mitunter eine Herausforderung sich räumlich zu orientieren und eine korrekte Vorstellung von "oben" und "unten" zu behalten. Ein geniales Spiel, auch wenn die Grafik sicher nicht mehr zeitgemäß ist. Aber das mindert nicht merklich den Spielspaß.
dante/net-proxy/gentoo: SOCKS Proxy Server und Client. Als Client kann es auch zusammen mit anderen Proxy-Servern verwendet finden, etwa mit ssh mit local "dynamic" application-level port forwarding oder mit squid. Besserer Support für DNS-Auflösung über den Proxy als bei net-proxy/tsocks.
dar-2.3.8/app-backup/gentoo {backup}: Disk Archiver. Speichert das Backup eines Dateisystems in einer Datei wobei ein Index der Dateien für den Direktzugriff beim späteren Restore extra hinzugefügt wird. Die Ausgabedatei kann in der Maximallänge beschränkt werden; in diesem Fall werden mehrere Segmente (typischerweise auf mehrere Datenträger verteilt) erstellt. Feature: Für das Erstellen eines Inkrementellen Backups ist kein Zugriff auf die vorherigen Backups vonnöten, falls eine Kopie des letzen Indexes lokal verfügbar ist. Entsprechend können die inkrementellen Backups über beliebig viele Datenträger fortgesetzt werden. Weiters speichern inkrementelle Backups auch die Information, wenn Dateien gegenüber dem letzten Backup gelöscht wurden! So bleiben beim Restore eines bestimmten Backups keine zu diesem Zeitpunkt eigentlich bereits gelöschten Dateien übrig die in den inkrementellen Backups davor aber noch enthalten sind. Die Backup-Dateien können auch komprimiert und mit GPG verschlüsselt werden; weiters ist es möglich sie auf einem Fileserver auszulagern. Das Programm unterstützt auch Hard Links, POSIX-ACLs und alles was in Extended Attributes des Dateisystems gespeichert werden kann. Da die Dateien in Backup-Dateien gespeichert werden und nicht direkt im Dateisystem, gibt es auch keine Probleme mit lokal nicht vorhandenen Benutzer-IDs oder -Rechten. Die Suite enthält auch ein Tool zum Kopieren der unbeschädigten Teile einer nicht komplett lesbaren Datei.
darktable-4.2.1-4/graphics/debian darktable-1.6.4/media-gfx/gentoo: Ein Metadaten-Editor und Organisationsprogramm für Bilder. Es kann auch Effekte auf Bilder anwenden. Eine besonderheit von Darktable ist, dass es die Effekte normalerweise nur live anwendet, und die Originalbilder nie antastet. Statt dessen kann es die Änderungen in einer internen Datenbank oder in Form von XMP-"Sidecar"-Dateien speichern. Als besonders leistungsfähig erweist sich das Programm beim zuweisen von Schlagworten, wo ganze Bäume definiert werden können. Ebenso können nicht nur einzelne Schlagworte einem Bild zugewiesen werden, sondern ganze Unterbäume. All dies ist so aufgebaut, dass es auch bei sehr umfangreichen Schlagwort-Katalogen funktioniert. Ebenso gibt es mächtige Filter zum Selektieren auch großer Mengen an Bildern, auf welche dann gewählte Effekte (oder Schlagworte) zugewiesen werden. Es handelt sich meiner Ansicht nach um die bislang überzeugendste Lösung, wenn es darum geht Bilder zu beschlagworten oder anhand komplexer Filterkriterien zu selektieren. Es beherrscht auch "professionelle" Funktionen wie den Umgang mit HDR- und RAW-Dateien. Allerdings ist das Programm auch ziemlich komplex und erfordert eine gewisse Einarbeitungszeit. Die folgenden Bildformate kann es exportieren: AVIF (Kanaltiefen 8, 10 und 12 Bit), JPEG (8 Bit Kanaltiefe), JPEG 2000 (nur lossless, 12 Bit Kanaltiefe), JPEG XL (Kanaltiefen 8, 10, 12 und 16 Bit sowie 32 Bit Fließkomma), OpenEXR (Farbtiefe 16 und 32 Bit Fließkomma, Kompression: unkomprimiert, RLE, ZIPS, ZIP, PIZ, PXR24, B44, DWAA, DWAB), PDF (Farbtiefe 8 und 16 Bit, Kompression: unkomprimiert, Deflate), PFM, PNG (Farbtiefe 8 oder 16 Bit), PPM (16 Bit Kanaltiefe), TIFF, XCF.
dash/app-shells/gentoo: DASH is a direct descendant of the NetBSD version of ash (the Almquist SHell) and is POSIX compliant. Very similar to the shell built into BusyBox. Minimalistic. Good standard compliance with only a few enhancements over the original sh, such as "local". Best choice for writing scripts which will run on most UNIX installations unaltered (either using bash, dash or BusyBox' ash).
dasher-4.11/app-accessibility/gentoo {input without physical keyboard}: Dasher ist ein Programm zur Texteingabe mittels Kontextauswahl von vorgeschlagenen Zeichen über ein Koordinateneingabegerät wie die Maus. Dabei wird einem abhängig vom bisher eingegebenen Text eine Auswahl möglicher weitere Zeichen vorgeschlagen, über welche man den Mauszeiger bewegen muss. Dadurch kommt man zur Auswahl der nächsten Zeichen. Die Zeichen werden nicht einfach wie Buttons dargestellt, sondern als Rechtecke verschiedener Farbe und verschiedener Größe. Offenbar bestimmt die Textwahrscheinlichkeit des nächsten Zeichens die Anfangsgröße jedes Rechtecks, aber man man kann auch kleine Rechtecke durch Anvisieren zoomen und dann auswählen. Jedes Zeichen das einem anderen folgt wird dabei als verschachteltes Rechteck in einer alternierenden Farbe (Graugrün oder gedecktes Türkis) angezeigt. Jedoch gibt es auch Rechtecke mit Spezialfunktionen: Gelb wechselt zu Großbuchstaben, rot zu Ziffern, weiß zu Leezeichen, grün zu Sonderzeichen. Daneben gibt es noch weitere Farben um zu verhindern dass benachbarte Kästchen in derselben Farbe angezeigt werden. Das System erweckt einen sehr innovativen Eindruck, jedoch dauert die Texteingabe damit für wenig Geübte ewig weil das Zoomen und Scrollen seine Zeit dauert. Außerdem findet man das gesuchte Zeichen nicht immer sofort, sondern muss dazu erst zoomend durch die Gegend scrollen. Mag sein dass dies nur eine Frage der Übung ist. Das System wirkt zwar intuitiv verständlich, aber macht einen sehr ressourcenbelastenden Eindruck da während der Eingabe ständig alles im Eingabefenster automatisch gezoomt oder verschoben wird, damit die nächsten Zeichen groß genug werden um mit dem Mauszeiger treffen zu können: Der ganze Prozess geschieht nur durch Bewegen der Maus; man klickt während der eigentlichen Eingabe nichts an. Statt dessen wechselt man durch Klicken irgendwo ins Fenster zwischen dem Erkennungs-Modus und dem normalen Maus-Modus mit dem man die Menüs und Buttons des Programms bedienen kann. Im oberen Bereich des Fensters ist dabei ein Textfeld eingeblendet, wo der bislang erzeugte Text zu sehen ist und in die Zwischenablage oder per Drag&Drop in andere Anwendungen gezogen werden kann. Das Programm hat ein GUI-basierte Oberfläche mit vielen Einstellungsmöglichkeiten. Außerdem werden neben Stift und Maus auch eher esoterische Eingabegeräte wie Eye-Tracker unterstützt. Man kann dann wohl auch durch reines Ansehen Text eingeben. Neben dem klassichen fensterbasierten Applikationsmodus kann man das Progamm auch in einem Fullscreen-Modus laufen lassen, oder in einem fokus-losen Modus wo jede Eingabe direkt an das Fenster geht das gerade den Fokus hat. Letzteres habe ich aber nie zu aktivieren geschafft. Ein paar Bugs hat das Programm auch - es ist nicht möglich eine Zeilenende-Zeichen einzufügen, ohne zuvor ein Leerzeichen einzugeben.
davfs2-1.4.5-r1/net-fs/gentoo {FUSE}: Erlaubt es WebDAV-gehostete Dateien als (mehr oder weniger) normales Linux-Dateisystem zu mounten. Verwendet CODA als Backend, kann aber auch FUSE verwenden. Leider ist das Design von davfs2 dergestalt dass es unmöglich ist es als normaler User einzurichten. Wohl ist es möglich dass ein normaler User ein von Administratoren vorkonfiguriertes WebDAV-"Laufwerk" mountet - aber in jedem Fall sind Administrator-Rechte zum Einrichten erforderlich. Das macht den Einsatz praktisch oftmals schwierig, obwohl das Programm allgemein ganz gut funktioniert.
davical-0.9.8.4-r1/www-apps/gentoo: Ein CalDAV und CardDAV Server. In PHP und PostgreSQL implementiert. Baut auf WebDAV auf und erdordert als Basis einen Webserver der dieses bietet. (CalDAV basiert auf iCalendar-Daten und CardDAV basiert auf vCard-Daten; beides wird via WebDAV gespeichert und synchronisiert). Browser-basierte Konfiguration. Hatte es ewig lang installiert. Nie verwendet. Musste schließlich wegen einer USE-Flag-Inkompatibilität mit PHP fliegen. Thunderbird und etliche andere Programme können als Front-End für davical dienen.
db-util-5.3.1/utils/devuan {key/value store}: Command line utilities for examining and manipulating BerkeleyDB (created by the libdb* library) databases. Most importantly, it contains the "db_dump" utility for displaying database contents.
dblatex-0.3.9-3/text/raspbian: Kann aus "DocBook" SGML/XML-Dateien LaTeX-Dateien erzeugen, aus denen wiederum PDF, DVI oder PS-Dateien erzeugt werden können. Dieses Paket erfordert texlive als Abhängigkeit, und ist entsprechend fett. Wenn man die DocBook-Dateien mit asciidoc erzeugt hat und diese nur einfach in PDF-Dateien konvertieren will, kann man diese Abhängigkeiten vermeiden indem man asciidoc-fop installiert.
dconf-editor-3.22.3-1/utils/debian: Ein sehr komfortabler Editor für dconf-Settings (das Nachfolge-System von gconf), ein Settings-System ähnlich der "Registry" von Microsoft Windows. Ein Problem habe ich persönlich mit dem sehr eigenwilligen GNOME3-Look der Applikation, aber darüber kann man hinweg sehen. Schlimmer ist, dass das Programm fürchterlich umständlich wird wenn man viele Einstellungen ansehen oder bearbeiten will. Denn jedes Setting erfordert dass man in der Baumstruktur in ein Blatt verzweigt, und dann wieder zurück zum Elternknoten um zum nächsten Setting zu gelangen. Dass das nicht irgendwie durch Tastaturkürzel zu beschleunigen sein sollte, klickt man sich dabei zum Idioten und das Auge muss ständig zwischen den verschiedenen Buttons zu diesem Zweck hin- und herwechseln. dconf-editor ist ein grafischer Ersatz für das "gsettings"-Tool auf Kommandozeilen-Ebene und als solcher optional. Allerdings erfordert das Benutzen von "gesettings" ähnlich wie das von "dbus-send" langes Einlesen in der Anleitung, und scheint auch ähnlich umständich zu benutzen zu sein. Der einzige Vorteil den ich bei dconf gegenüber der Windows Registry gelten lassen möchte, ist dass die einzelnen Schlüssel dort wenigstens eine Dokumentation enthalten. Die Kehrseite ist jedoch dass nur definierte  Schlüssel überhaupt bearbeitet werden können, und die Definition (inklusive der Dokumentation) wird aus zentral installierten (Administrator-Rechte erforderlich) XML-Dateien entnommen. Das Hinzfügen benutzerspezifischer XML-Dateien ist nur sehr umständlich über den Weg von Umgebungsvariablen möglich und nicht von Haus aus vorgesehen. Fazit: Ein umständliches System, das einem 100 x mehr Mühen beschert als simple Text-Konfiguationsdateien. Ach ja, und ich vergaß noch: Die XML-Dateien müssen auch noch von einem eigenen Compiler in ein binäres Format kompiliert werden, bevor dconf es nutzen kann. Ein typisches Machwerk aus dem Umfeld der "systemd"-Autoren. Außer GNOME- und Mate-Programmen scheint auch sonst niemand dieses Settings-System zu benutzen, welches auf mindestens 3 Installations-Pakete verteilt ist.
ddd/dev-util/gentoo: Ganz fantastisch toller Super-Debugger mit GUI. Kann nicht nur C/C++, sondern sogar Perl debuggen. Angeblich. Tatsächlich wird er offensichtlich von niemandem so recht gewartet oder unterstützt, denn die dazu erforderlichen Plug-Ins sind entweder nicht vorhanden oder funktionieren nicht. Andererseits funktioniert er für C/C++ so halbwegs brauchbar, was man vom insight-Debugger aufgrund dessen mangelhafter Stabilität nicht gerade behaupten kann. Leider benutzt ddd das Motif-Toolkit, sprich er ist häßlich bis zur Grenze des Übergebens. Und ddd ist auch nicht in der Lage UTF-8 Umlaute korrekt anzuzeigen, sondern zeigt sie fehlcodiert als Latin-1 an.
debian-handbook-8.20180830/doc/debian: Eine lange Anleitung zur Benutzung von Debian in vielen Sprachen als auf viele Seiten und Kapitel aufgeteiltes Handbuch im HTML-Format. Erläutert die meisten administrativen Tools, geht dabei allerdings meist nicht besonders in die Tiefe. Deshalb eher für normale User bis hin zu Power-Usern gedacht. Besonders interessant ist der Abschnitt über das eigene Erstellen neuer Pakete.
debian-kernel-handbook-1.0.19/doc/debian: Hilfreiche Dokumentation (nur englisch) im HTML-Format, wenn man sich ein eigenes Kernel bauen möchte. Ebenso enthält sie Hinweise zur Benutzung und Anpassung einer eigenen initramfs sowie der Installations-Hooks für Kernel-Pakete. Lesenswert für Experten.
debian-refcard-10.4/doc/debian: Enthält unzählige Versionen des grundsätzlich selben 2-seitigen PDF-Dokuments in verschiedenen Sprachen, welches die wichtigsten Systemkommandos zusammenfasst. Jede dieser Seiten im Querformat ist dabei 3-spaltig bedruckt. Nur für Debian-Anfänger nützlich - der erfahrene Superuser findet hier keinerlei Nutzen mehr.
debian-reference-en-2.76/doc/debian: Enthält zusätzlich vertiefende Informationen zum "debian-handbook", jedoch nur in einer Sprachversion (es gibt mehrere Varianten des Pakets, dieses hier ist auf englisch). Es empfiehlt sich immer dann hier nachzuschauen, wenn man mehr Details wissen möchte als im "debian-handbook" verraten wird. Teilweise überschneiden sich die Informationen zwar, doch im allgemeinen handelt es sich um keine "bessere Version" des "debian-handbook" sondern um eine Vervollständigung dessen. Als besonderes Goodie liegt dasselbe Handbuch zusätzlich als ".pdf" und ".epub"-Version vor, jeweils schön intern verlinkt. Damit ist es auc gut geeignet, in kompakter Form auf andere Geräte versandt und dort betrachtet zu werden - etwa auf eBooks, Tablets, Handys als nützliche Lektüre für Wartezeiten unterwegs.
deltup/app-portage/gentoo {binary-diff}{deduplication}: A binary-diffing intended to be used on compressed source text archives. It unpacks them internally and then uses bdelta for creation of the actual patch. The patch also includes the file names and optional also checksum information, which means the patch-file is the only filename-argument needed on the command line for later reconstruction. This is different from the "diffball"-suite which is similar, but requires to specify all the file names when applying the patches. And there is also the difference that deltup works while the corresponding tool from the diffball suite does not seem to. (Or the diffball-tool just does not understand as much archive-formats as deltup does). Another advantage of deltup over diffball is that it allows to combine multiple patches into a single output file. On the other hand, the other tools from the diffball-suite might be able to create smaller patches for *really* binary files, because they might be using better algorithms than bdelta. This claim has to be checked more thoroughly, however, because diffball only diffs small hunks where bdelta's per-hunk overhead might be an unfair disadvantage.
denu-2.3.2-r1/x11-misc/gentoo {installed applications menu editing}: A GUI editor which can edit and generate menus for fluxbox, waimea, openbox, icewm, gnome and kde. It works well even without dbus running. It allows to add menu entries from two sources: A list of installed packages (which seems to be highly Gentoo specific but maybe other package managers are supported as well) and a list of "special" menu entries like "autogenerated menu", "separator", "reconfigure" etc. Usually one starts with the "Autofill" function which adds all available packages to the edit area, automatically creating submenus based on freedesktop.org standards. After that, entries and menus can be re-ordered, removed, added or edited. The end result should be saved in a very strange but obviously space-efficient text format which reminds me of BENCODE but puts every item on an individual line. Finally the WM-specific menu files can be generated from the contents of the current editing area, but it is obviously not possible to import existing menus or export manually created items as XDG-compliant *.desktop files. Which means the multi-WM-target support is export-only. There is also a problem with the Autofill function: It works well, but replaces the contents of the work area. Which means all manual changes are lost. There does not seem to be a way to retain manual changes while still adding menu entries for newly installed applications automatically. This makes the whole tool somewhat useless, because one always wants the menu to contain the newest installed applications in addition to what has been modified manually. The XDG standard provides a solution with "include" files for this problem, but denu does not make any use of it.
detachtty-11.0.0-2/utils/debian {KVM sharing}{text-terminal IO}: Another terminal multiplexer. It is very similar to "dtach", but splits the functionality to attach ("attachtty") or detach ("detachtty") into two different utilities. Unlike detach, it can optionally record a transcript of all terminal I/O into a log file. (However, running "script" under "detach" would likely do pretty much the same.) It also has support for connecting to a remote machine via SSH. The executable sizes of either attachtty or detachtty are smaller than that of dtach, but the sum of the sizes of both programs is larger than dtach. attachtty and detachtty have little or no options, so there is less to think when using them, compared to dtach. On the other hand, dtach offers more flexibility and allows to define the key to be used for detaching from a running interactive command, while attachtty reuses existing shell job control signals like Ctrl-z. I got the overall impression, that dtach is more tuned for interactive use, while the focus of detachtty is starting non-interactive commands and only occasionally switch to them for terminal input. On the other hand, detachtty can write standard I/O and standard error to different log files, which seems to be more efficient than running "script" under dtach control.
dev-libs/libgcrypt-1.11.0-r1/gentoo {security}{runtime utility library}: Eine Alternative für OpenSSL, die von einigen Paketen (meist nur alternativ) unterstützt wird. Enthält mehr Ciphers. Konkret werden unterstützt: IDEA, 3DES, DES, CAST5, BLOWFISH, AES, TWOFISH, ARCFOUR, SERPENT, Camellia, Salsa20, GOST 28147-89, ChaCha20, SM4, ARIA. Modes: ECB, CFB, OFB, CTR, CCM, GCM, Poly1305, OCB, XTS, EAX, SIV, GCM-SIV. Asymmetrisch: RSA, DSA, Elgamal, ECDSA, ECDH, EdDSA. Hashes: SHA1, RIPE-MD-160, MD5, MD4, MD2, TIGER, HAVAL, SHA2, SHA3, SHAKE, CSHAKE, CRC-32, CRC-24, WHIRLPOOL, GOST R 34.11-94, STRIBOG, BLAKE2B, BLAKE2S, SM3. Schlüsselableitung: S2K, PBKDF2, SCRYPT. Hilfsfunktionen für: Zufallszahlen, Crypto-Berechnung via MPI, Primzahlen-Erzeugung (nur zufällig), Primzahlen-Check, Generator-Suche (nur zufällig) für gegebene Primzahl.
devuan_jessie_1.0.0_i386_CD.iso.xz/system-installer-live-system/devuan {linux distribution}: Der Installer für Devuan Linux. 32-Bit x86 ohne PAE. Basiert auf Debian-8 "Jessie". Aktualität irgendwann 2016-2017. Enthält - glaube ich - keine Installationspaket; Internet-Zugriff ist erforderlich (oder vorab manuell herunter geladene Pakete, welche dasselbe Dateisystem-Struktur wie die Paket-Repositories im Internet verwenden).
dhewm3-doom3-1.5.0+git20181221+dfsg-1/contrib/games/debian {game}: Port des Original-Spiels "Doom 3". Erfordert um gespielt werden zu können die Originaldateien des Spiels. Sehr nett gemacht, läuft auch mit INTEL Onboard-Grafikkarten immer noch flüssig. Unterstützt sowohl das Originalspiel als auch das "Resurrection of Evil" Expansion-Pack.
dia-0.97.1/app-office/gentoo: Ein GTK+-basiertes Programm zum Zeichnen aller möglicher (vektorbasierter) Diagramme wie Flussdiagramme, Schaltkreisdiagramme etc. Ein Klon von Microsoft VISIO gewissermaßen. Eine schlankere Alternative zu OpenOffice.org Draw. Sehr simpel und nicht übermäßig mächtig in den Funktionen. Aber es kann was man normalerweise braucht und bringt auch einen ganzen Haufen vorgefertigter Symbole bereit für den Einsatz mit. Vorteile gegenüber OOo Draw: Es gibt einfache Toggle-Buttons, mit denen man das Gitter- und Objekt-Einrasten deaktivieren kann. Es gibt keine speziellen "Verbinder"-Objekte; alle Objekte können wie Verbinder genutzt werden. Das ist vor allem bei Bezier-Kurven vorteilhaft, die als Verbinder genutzt werden und beliebige viele Kontrollpunkte enthalten können. Dia verfügt zudem über ein halb-automatisches, mäßig intelligentes Auto-Routing Feature, welches Verbindungslinien teils automatisch um andere Objekte herum leitet damit sich diese nicht überkreuzen. Weiters kann man bei Elementen die als Verbinder genutzt werden Offsets angeben, so dass die Verbinder die verbundenen Elemente nicht direkt berühren müssen, sondern auch nur auf sie verweisen können. Nachteile gegenüber OOo Draw: Keine so schönen wählbaren Limitierungen (glatt, symmetrisch) bei Bezierkurven. Außerdem kann dia keine neuen Klebepunkte zu Objekten hinzu fügen sondern ist auf die fixen Klebepunkte pro Objekt-Typ beschränkt. Andere Objekte enthalten keinen Support für Text-Elemente zwecks Beschriftung; d. h. man ist da facto immer gezwungen Text- und andere Elemente zu gruppieren wenn man eine Beschriftung wünscht. Gruppierte oder mehrfach selektierte Objekte können nur mehr verschoben, aber nicht mehr in der Größe verändert werden. Dies macht Maßstabsänderungen sehr problematisch da man hier alle Elemente einzeln vergrößeren muss. Was weiters fehlt, ist eine Option mit der man alle selektierten Elemente auf die gleiche, kleinste oder größte Größe aller der Objekte anpassen kann. (Das kann OOo Draw allerdings genau so wenig.) Was weiters fehlt, sind Lineal-artige Objekte um Bemessungen innerhalb der Zeichnung anzuzueigen. Überhaupt ist das Beschriften von Kanten, etwa in DAGs, problematisch und nicht direkt unterstützt. Fazit: Die Vorteile von dia gegenüber OOo Draw sind seine besseren Verbinder, die beliebig komplexe Beziers oder Polylines sein können. Allerdings sind dafür die Klebepunkte beschränkt an denen diese Verbinder andocken können. Das Auto-Routing kann bei komplexen Diagrammen ebenfalls hilfreich sein. Außerdem hat dia ein einfacher zu erlernendes User-Interface. Eventuell kann auch die größere Auswahl an vorgefertigten Objekt-Bögen mit Elementen für verschiedene Diagrammtypen ein Grund sein sich für dia zu entscheiden. In allen anderen Fällen ist man mit OOo Draw besser beraten, zumindest solange einen der wesentlich größere Installationsumfang von OOo nicht abschreckt.
dialog-1.1.20120706/dev-util/gentoo {cmdline-dialog}{text-terminal IO}: Das weitverbreitestste Tool zur (pseudo-) grafischen Interaktion mit dem Benutzer im Textmodus. Basiert auf ncurses und hat leider Probleme mit UTF-8 Texten. Es gibt auf manchen Distributionen ein ähliches jedoch weniger mächtiges Tool namens whiptail (bzw. eine UTF-8-fähige Variante davon) welches dieses Problem nicht hat. Das Hauptproblem von whiptail ist die derzeit mangelnde Verfügbarkeit unter Gentoo. Unter Debian ist die Situation allerdings umgekehrt: Dort gibt es nur whiptail und dialog ist gar nicht mehr verfügbar.
dictd-1.11.2/app-text/gentoo: Stellt einen Server für den "dict"-TCP-Service zur Verfügung, der lokal installierte app-dicts/dictd-* Wörterbücher zum Nachschlagen benutzt. Dieser Dienst kann auch so installiert werden dass er nur von localhost aus erreichbar ist, oder über (x)inetd nur bei Bedarf für einzelne Anfragen gestartet wird. Ebenfalls im Paket enthalten ist ein Commandline-Client zur Abfrage, der sowohl den zuvor erwähnten lokalen dict-Service als auch im Internet bzw im LAN gehostete andere Server abfragen kann.
dictd-gazetteer/app-dicts/gentoo: Enthält nur Postleitzahlen, Abkürzungen und Namen von US-Städten. Dort sicherlich praktisch; für den Rest der Welt vermutlich eher uninteressant.
dictd-misc/app-dicts/gentoo: Klingt zwar nichtssagend, ist tatsächlich aber ein Nachschlagewerk namens "Easton" für Bibelsprüche zu einem gegebenen Schlüsselwort. Für weltliche Zwecke nutzlos.
didiwiki-0.5-13/web/devuan {wiki}: Minimalistisches in C geschriebenes Wiki mit minimalen Abhängigkeiten. Winzig: 81,92 kB installiert. Auch der Quelltext mitsamt allen Debian-Patches ist gepackt nicht viel größer. Ressourcensparend: Knapp 2 MB virtueller Speicher und 500 kB RAM (RSS). Mit so wenigen Ressourcen begnügt sich nicht einmal der schlankeste normale Webserver (lighttpd). Selbst der "inetd" verbrät mehr. Didiwiki gehört auch zur Standard-Ausstattung von Puppy Linux, wo geringer Ressourcenbedarf sehr geschätzt wird. Die Debian-Implementation startet das Wiki so dass es nur vom eigenen Rechner aus erreichbar ist, was eine gute Idee ist da didiwiki keinerlei Zugriffbeschränkungen kennt: Keine User, keine Rechte, keine Passworte. Entsprechend einfach und komfortabel ist aber auch die Bedienung. Das Wiki legt alle Inhalte ausschließlich in *beinahe* normalen Textdateien ab: CR+LF als Zeilenschaltung sowie ein angehängtes Nullbyte am Ende jeder Datei. Keinerlei Datenbank-Support. Keine Konflikt-Auflösung. Keine Volltextsuche mit Google-artiger Suchsprache, aber immerhin eine simple Suche nach beliebigen Zeichenketten über alle Wiki-Seiten. Keine History, keine Diffs: Es wird nur die letzte Version jeder Seite aufbewahrt und überschreibt vorherige Inhalte. Da das ganze Wiki aber nur aus den beinahe-Textdateien der einzelnen Wiki-Seiten besteht, kann man diese einfach selbst mit Git & Co versionieren. Simple Operation mit nur wenigen Funktionen: "Changes" zeigt eine Liste aller vorhandenen Wikiseiten mit ihrem letzten Änderungsdatum an, "New" legt eine neue Seite an (Seitentitel und Inhalt, wobei der Titel als Dateiname verwendet wird), "Edit" bearbeitet die gerade angezeigte Seite. Ansonsten gibt es nur noch "Home" und "Help" die zu ansonsten ganz normalen Wiki-Seiten mit vordefinierten Namen springen. Mehr als diese Funktionen gibt es nicht! Weder fürs Umbennenen noch Löschen von Wiki-Seiten gibt es Funktionen. Man kann das aber leicht "von außen" tun indem man die Wiki-Dateien direkt mit der Hand umbenennt/löscht. Keine Mehrsprachigkeit (nur englische Bedienung). Aber da es ohnehin nur die genannten handvoll Funktionen gibt, braucht man auch keine großartigen Übersetzungen dafür. Einzig die Hilfe-Seite möchte man vielleicht übersetzen, aber das kann man jederzeit auch selbt tun da die Hilfeseite wie jede andere Wiki-Seite bearbeitet werden kann. In den Wiki-Seiten selbst verwendet man eine eigene sehr simple, aber Wiki-typische Markup-sprache. Kein Markdown; kann viel weniger als dieses. Aber alle wichtigen grundlegenden Markup-Funktionen werden geboten: Überschriften, Aufzählungen, Schrift kann fett, kursiv unterstrichen oder durchgestrichen werden, Trennlinien, Wiki-interne Links, externe Hyperlinks, Einbinden von extern bereit gestellten Grafikdateien (es gibt keine Funktionen zu deren Upload oder Bearbeitung), vorformatierter Text, und sogar simple nicht-verschachtelbare Tabellen. Ansonsten gibt es nur normale Absätze aus Textzeilen, die durch Leerzeilen getrennt werden müssen und vom Wiki als Fließtext interpretiert werden. Worte im Text welche aus CamelText bestehen, werden automatisch als Wiki-interne Links auf Seiten des entsprechenden Namens interpretiert. Man kann aber auch beliebigen Text als Wiki-Link definieren indem man ihn in eckige Klammern setzt. In diesem Fall kann man auch einen anderen Text als die Link-URL bzw. den Wiki-Seitennamen für die Anzeige des Links darstellen lassen. Es ist nicht erforderlich dass die Seiten bereits existieren auf welche man verlinkt. Klickt man auf solch einen "toten Link", gelangt man automatisch in den Editier-Modus für die Neuerstellung der fehlenden Wiki-Seite. Die Wiki-Dateien sind in einer flachen Struktur angelegt, es werden keine Unterverzeichnisse verwendet oder unterstützt. Entsprechend darf der Name einer Wiki-Seite auch keinen Schrägstrich enthalten. Es gibt keinerlei Metadaten- oder Konfigurations-Dateien. Das Wiki besteht einzig aus den Dateien der Wiki-Seiten in einem einzigen Unterverzeichnis. Man sollte diese Anforderung bei der Auswahl eines geeigneten Dateisystems für die Ablage des Wikis beachten. Wenn eine Linux-Distribution kein Paket für didiwiki bereit stellt, ist es einfach das Programm selbst zu bauen: Mehr als "make" und ein installierter C-Compiler werden dazu auf einem POSIX-artigen System nicht benötigt.
dietlibc-dev-0.34~cvs20160606-10/libdevel/debian: A minimalistic C runtime library for static linking. Supports cross-compiling. Does not support dynamic linking or locales. Displays warnings but supports most (except "%n") printf() conversions and other C standard-I/O functions; it is expected that the POSIX I/O functions are used instead of the "FILE *"-based functions. Provides a compiler driver wrapper "diet" which must be prepended to the actual compiler driver command, and modifies the driver to link against the static diet libc. It is unclear whether dlopen() is currently still supported or not any more. A DNS resolver daemon executable ships as part of the installation; it seems likely that DNS resolver functions of the library launch that executable as a background process. It is not known whether or under which conditions this daemon is shut down when it is no longer needed. Big problem: GPLv2 licensed! Which means it cannot be used for anything else than OpenSource projects. And even for OpenSource projects dietlibc dictates that those must also use the GPL rather than an arbitrary OpenSource license.
diffball/dev-util/gentoo {binary-diff}{deduplication}: Eine weitere Suite für binäre Diffs. Darunter auch ein Tool das Archive vor dem Diffen erst entpackt. Jedoch funktionierte letzteres Tool im Test nicht. Das binäre Diff-Tool "differ" hingegen lieferte erbärmliche Ergebnisse verglichen mit Deltup. (Kein Wunder da die Dateien gepackt waren.) Differ ist eigentlich nur ein Front-End, welches die Eingabedatei irgendwie in Prüfsummen-gehashte Häppchen zerteilt, und dann diese Häppchen von einem anderen Backend-Algorithmus diffen läßt. Hier trumpft "differ" auf, er beherrscht fast alle bekannten Formate außer xdelta (das aber ohnehin eher schwach ist). Im direkten Vergleich stellte sich dabei folgende Reihenfolge (besser nach schlechter komprimierend) heraus: "switching", "gdiff5" (non-Standard-Modifikation), "gdiff4", "bdiff", "bdelta". Fazit: Bei Quelltext-Archiven ist deltup besser weil es funktioniert - bei echten Binärdateien sollte man sich "differ" und "patcher" aber vielleicht noch genauer ansehen.
diffpdf-1.9.2/app-text/gentoo {binary-diff}{appdoc-diff}{PDF}: Ein grafisches Diff-Tool um die Unterschiede zwischen zwei PDF-Dokumenten anzuzeigen. Man kann dabei zeichenweise, wortweise oder allgemeine Unterschiede in der grafischen Darstellung der Dokumente anzeigen lassen. Die beiden PDF-Dokumente werden dabei neben einander angezeigt. Die Modi für Zeichen- und Wortunterschiede funktionieren nur mit textbasierten PDFs, aber die Option zur Anzeige der Unterschiede in der grafischen Darstellung funktioniert mit Einschränkungen auch in Bitmap-basierten Seiten in PDF-Dokumenten. Allerdings werden dabei nicht einfach die Pixeldarstellungen verglichen, sondern das Programm versucht sehr wohl Textblocks innerhalb der Bitmaps zu erkennen, damit auch vertikal verschobene Textblöcke als identischer Inhalt erkannt werden können. Leider funktioniert das nicht sehr zuverlässig, aber immerhin. Auf jeden Fall ist es trotz Verbesserungsbedarfs das bislang mächtigste Programm zum Vergleichen zweier PDFs auf OpenSource-Basis das ich kenne.
diffuse-0.4.3/dev-util/gentoo {text-diff}{no-soft-line-wrap}{text-merge}: Ein in Python geschriebenes visuelles Diff- und Merge-Tool. Besonderes Alleinstellungsmerkmal: Unterstützt nicht nur das Vergleichen bzw. Zusammenführen von 2 oder 3, sondern *beliebig* vielen Quelldateien! Geringer zusätzlicher Installationsumfang (keine 200 KB Download, 900 KB installiert) soweit Python und PyGTK bereits installiert sind. Syntax-Highlighting. UTF-8 Support. Leider kein weicher Zeilenumbruch - daher nicht für Fließtexte mit einer physischen Zeile pro logischem Absatz geeignet. Einfache Tastaturnavigation. Kann die zu vergleichenden Dateien direkt als verschiedene Dateiversionen aus SCM-Repositories von Bazaar, CVS, Darcs, Git, Mercurial, Monotone, RCS, Subversion und SVK beziehen. Kann auch automatisch alle Unterschiede zwischen den letzten eingecheckten und lokal modifizierten Versionen aller ausgecheckter Dateien zeigen. Bearbeiten der Dateien. Multi-Level Undo. Anpassbare Zeilen-Synchronisation zwischen den verschiedenen Dateien. Lokale Manipulationsmöglichkeiten von Selektionen wie Zeichensatzkonvertierung, Groß-/Kleinschreibung, Leerzeichen entfernen, sortieren. diffuse kann weiters beliebig viele derartige Diffs in verschiedenen Tabs anzeigen. Allerdings arbeitet diffuse immer nur mit einer oder mehreren einzelnen Dateien; es beherrscht kein Vergleichen kompletter Directory-Hierarchien wie kdiff3 oder kompare dies zusätzlich beherrschen.
digikam-0.8.2-r1/media-gfx/gentoo {graphics image viewer}: No lossless rotation without plugins, cannot handle .mpg or even .tif files, bloated, images need to be imported into special "album" directories.
digikam-0.9-1/media-gfx/gentoo {graphics image viewer}: Ein Foto-Organizer/Betrachter für KDE. Auch Frontend für "gphoto", das zahlreiche Digitalkameras unterstützt. RAW-Import. TIFF, JPG, BMP, PNG und JPEG-2000 Bilder (schneller als KDE-builtin) werden direkt unterstützt. Kein oder AVI/MPEG Support. Übernimmt die Kontrolle über einen Verzeichnisbaum in dem alle verwalteten Bilder in Verzeichnissen gespeichert sind. Es ist aber auch möglich von ausserhalb die Dateien zu verschieben und umzubenennen. Die Metadaten können danach wieder synchronisiert werden. Kaum Optionen in der Fotoübersicht - gerade einmal verlustfreie Rotation, und auch dies nur über KIPI-Plugins. Fotos werden nach Verzeichnis ("Album"), Datum, 5-Sterne-Bewertung oder baumförmigen Stichworten verwaltet. Einzelbilder-Bearbeitung und -Ansicht erfolgt über das Programm ShowFoto, das auch separat gestartet werden kann und Gwenview sehr ähnlich ist, aber etwas komfortabler. So hat es bei den Nachbearbeitungsfunktionen "vorher" - "nachher" Darstellungen, Histogramme und zeigt zahlreiche Metainformationen an. Metadaten können optional zusätzlich in den EXIF/IPTC-Feldern gespeichert/aktualisiert werden. Suchabfragen mit verschachtelten und/oder Ausdrücken speicherbar. Nachteile: Suchausdrücke sind in ihrer Komplexität praktisch durch die Fenstergröße begrenzt. Gespeicherte Suchausdrücke können nicht als ein Kriterium in neuen Suchabfragen verwendet werden. Probleme im Zusammenhang mit dem Mausfokus.
dillo-3.0.5-7/web/debian {www-browser}{GUI}{X11}: Ein auf der fltk-GUI-Bibliothek aufbauender minimalistischer Webbrowser. Der so ziemlich schlankeste Webbrowser unter X11. Allerdings kann er auch so gut wie nichts - insbesondere kein JavaScript, keine Frames, keine Popups. Aus demsselben Grund ist er aber auch sehr sicher, da Malware keine Ansatzpunkte findet. Da er sehr schnells startet, ist er prinzipiell auch gut als voreingestelltes Program, zum Öffnen von *.html Dateien geeignet. Allerdings kann er viele Sonderzeichen wie Pfeile nicht darstellen bzw. erscheint dann nur ein Quadrat als Platzhalter für nicht unterstützte Zeichen. Weiters stellt er bei Tabellen nur die äußeren Umrandungslinien dar, nicht aber innenliegende Gitterlinien. Und schließlich hat er die ärgerliche Angewohnheit, bei jedem Neuladen einer Webseite oder angezeigten Datei wieder zum Seitenanfang zurück zu springen. Dies ist besonders Ärgerlich wenn man Webseiten selbst erzeugt und aktualisiert, da man dann immer wieder zu der Stelle scrollen muss wo man vor dem Neuladen war und eine Änderung dort sehen möchte. Auch das selektieren vom Text zum Herauskopieren mit der Maus funktioniert nicht immer. Besonders problematisch ist das Downloaden von Dateien, da dazu wget im Hintergrund verwendet wird aber es gelingt nicht immer das Gewünschte Zielverzeichnis einzustellen. Es ist unklar ob dies ein Fehler ist oder ich lediglich nicht verstanden habe wie man das Download-Verzeichnis im Dateiauswahldialog auswählt. Auf jeden Fall ist es nicht trivial.
dillo/www-client/gentoo {www-browser}{GUI}{X11}: Very nice and minimalistic web browser, supports tabs and displaying text and images, but not much more. Quite useful for memory-constrained systems. Does not support JavaScript or Cookies at all. Whether CSS shall be honoured or images shall be loaded can be selected by simple check-boxed in a pull-down menu. Dillo is therfore one of the safest browsers available. It is also extremely lightweight and has only a minimal memory footprint compared to all the other graphical browsers. The only real trouble with Dillo is a bug that sometimes Web pages "stall" during download. Because all downloads are actually done by a background helper application, pressing the "stop" button does not really abort the download, and reloading the page just lets the background application continue its failed attempt. Only by closing the whole application the failed downloads are really aborted and can be retried.
diod-1.0.21-1/admin/devuan: Ein Userspace-Server für das Plan9 File System, der mit der Linux-Client-Implementation 9P (modprobe 9p) zusammen arbeitet. Es ist ähnlich unsicher wie NFS, aber bedeutend simpler auszurollen, da ihm ein TCP-Port an dem ein diod-Server lauscht zum Verbindungsaufbau ausreicht. KVM bietet zudem auch ein spezielles "virtio"-Transport-Protokoll für 9p.
diodon-1.0.3-1/utils/devuan {clipboard manager}{GTK+}: Ein in Vala geschriebener schlanker Clipboard-Manager. Man kann wählen ob das Programm nur das eigentliche Clipboard oder auch die primäre Maus-Selektion kontrollieren soll. Ob beides automatisch synchronisiert werden soll, lässt sich separat wählen. Auch dieses Programm hat ein GUI zur Konfiguration, so dass man sich nicht mit Konfigurationsdateien auseinander setzen muss. Es gibt nur einen einzigen Hotkey, welchen man definieren (oder deaktivieren) kann, und zwar zum Aufruf des Verlaufs. Dieser öffnet aber nicht etwa ein eigenes Dialog-Fenster mit Liste und Scrollbalken wie man glauben sollte, sondern es poppt nur dasselbe Menü auf, welches man auch mit der Maus übers Traybar-Icon erhält. Immerhin ist dieses Menü auto-scroll-fähig, wenn es schon keine Scrollbalken aufweist. Es gibt einen Menüpunkt zum Beenden von diodon. diodon benötigt einen laufenden Session-DBUS-Daemon um zu funktionieren, und speichert auch alle seine Settings mittels des dconf-Dienstes ab (welcher dazu natürlich ebenfalls gestartet wird). diodon unterstützt des weiteren ein Plug-in-System, wobei bereits das Traybar-Icon selbst solch ein Plugin ist. Ohne dieses funktioniert das Programm "unsichtbar", und das Einstellungsmenü ist nur noch über den Hotkey aufrufbar. Dumm allerdings, wenn man diesen deaktiviert hat! Da muss man dann einen dconf-Editor bemühen, um diese Settings "mit der Hand" wieder zurück zu setzen, denn irgendwelche Konfigurations-Dateien gibt es ganz im Geiste von "dconf" (bzw. der Microsoft Windows Registry) nicht. Man kann Auswählen ob der Inhalt der Zwischenablage beim Programmende gespeichert werden soll, was gut ist da es im Hinblick auf Passwörter eine schlechte Idee ist. Und er merkt sich dieses Setting sogar. Weniger schön ist jedoch, dass dieses nützliche Setting keinerlei Effekt zu haben scheint: Egal ob das Sichern der Zwischenablage ein- oder ausgeschaltet war, ich fand danach alle Einträge des Verlaufs in einer XML-Datei. Der Ressourcenbedarf von diodon sind 50 MB virtuell und 19 MB tatsächlicher RAM (RSS). Somit ist er zwar geringfügig schlanker als clipit wenn dieses voll aktiviert ist, jedoch fetter als dieses im "offline"-Mode. Und dies, obwohl clipit deutlich mehr kann. Rechnet man dann noch den erforderlichen DBUS-Daemon sowie den dconf-Dienst hinzu, wird clipit endgültig schlanker im Vergleich.
dirdiff/dev-util/gentoo dirdiff-2.1-9/utils/raspbian {dir-diff}{text-diff}{soft-wrap-at-right-margin}{text-merge}: Ein weiteres grafisches Tool a la kdiff3 zum Vergleichen von Verzeichnis-Hierarchien, welches es aber nicht wirklich mit kdiff3 aufnehmen kann. Zumindest ist es aber GTK+-basiert und benötigt daher kein Qt. Außerdem ist es eine winzige Installation, falls man "Tk" bereits installiert hat. Ein Vorteil gegenüber kdiff3 ist, dass es bis zu 5 Verzeichnisbäume zugleich mit einander vergleichen kann. Dabei kann man Dateien über simple Joker vom Vergleich aus- oder einschließen. Weiters kann man etliche der Optionen des bekannten Kommandozeilen-"diff" für den Vergleich konfigurieren. Unterschiedliche Dateien an derselben relativen Position in den Bäumen werden farblich markiert um das relative Alter anzuzeigen. Ich war anfangs verwirrt weil diese Farben nichts mit Unterschieden im Datei-Inhalt zu tun haben. Erst später begriff ich, dass standardmäßig überhaupt keine identischen Dateien angezeigt werden. Man kann dies einschalten, und diese Dateien werden dann weiß markiert. Die Aktionen zum Abgleichen kompletter Dateien sind intuitiv. Die Vergleichsanzeige zwischen Datei-Inhalten hingegen weniger. Alle unterschiedlichen Abschnitte sind unter einander dargestellt und codieren durch ihre Einfärbung auf wenig intuitive Weise, welche Änderung zu welcher Dateiversion gehört. Solange eine Zeile nur zu einer Version gehört, ist es noch einfach: Sie hat dann deren Farbe. Existiert dieselbe Zeile aber in mehreren Versionen, ist ist die Zeile in allen diesen Farben eingefärbt. Das Verwirrende daran ist, dass alle Abschnitte mit Farben bis auf die letzte Version nur eine fixe breite am linken Rand haben. Der Rest der Zeile ist hingegen mit der Farbe der letzten Version gefüllt. Weder ist eine links/rechts Anzeige vorgesehen, noch können Unterschiede auf Worte oder gar Zeichen begrenzt angezeigt werden. Obwohl das Programm keinen weichen Zeilenumbruch auf Wort-Ebene beherrscht, bricht es überlange Zeilen zumindest am letzten Zeichen weich für die Anzeige um, so dass man die Änderungen ohne Horizontalscroll dennoch grundsätzlich sieht. Dass diese Änderungen schwer zu finden sind da die Einfärbung sich nur auf die ganze umgebrochene Zeile bezieht, steht auf einem anderen Blatt. Für Fließtext daher nur schlecht geeignet. Das kann kdiff3 weitaus besser. Man kann jede der farbcodierten Zeilen markieren und alle markierten Änderungen auf einen auszuwählenden Dateibaum anwenden. Alternativ kann man einen Patch als Unified-Diff aus den gewählten Änderungen erzeugen, den man dann noch in einem Fenster überarbeiten kann bevor man ihn abspeichert. Von der etwas unübersichtlichen vertikalen Vergleichsansicht abgesehen tut das Programm aber gut seinen Job und ist auch nicht zu schwer zu verstehen. Definitiv simpler als kdiff3! Außerdem ist es eine bedeutend kleinere Installation. Überdies treffen die oben genannten Probleme mit Fließtext nur auf die eingebauten Diff/Merge für Dateien zu. Statt dessen kann man auch ein externes Programm zu diesem Zweck definieren. Aber leider ist kdiff3 das einzige Programm das ich kenne, welches Unterschiede in Fließtexten sinnvoll anzeigen kann. Und dieses kann bereits Verzeichnisbäume vergleichen, so dass man kein dirdiff mehr zusätzlich braucht. Das Programm "dirdiff" ist auch als Hilfsprogramm "tkdirdiff" im Paket "tkcvs" (zumindest unter Debian so benannt) enthalten. Allerdings fällt auf, dass die Version im "dirdiff"-Paket neuer zu sein scheint. Es handelt sich dabei vermutlich um den Hauptentwicklungszweig, während "tkvcs" mit der Übernahme neuer Revisionen hinterher hinkt. Auf der anderen Seite ist es grundsätzlich exakt dasselbe Programm. Die einzigen Unterschiede die mir auffielen waren: tkdirdiff hat Bitkeeper-Support, dirdiff nicht. Und nur dirdiff hat die Option "Show files that aren't in some dirs". Diese Option bezieht den Inhalt fehlender Unterverzeichnisse in die Anzeige ein; andernfalls wird nur das Verzeichnis selbst als fehlend dargestellt. Eine eher entbehrliche Option. Alles andere scheint identisch zu sein. Wegen dieser geringen Unterschiede empfehle ich nicht "dirdiff" zu installieren, falls "tkdiff" bzw. "tkcvs" ohnehin bereits installiert sind.
dirvish/app-backup/gentoo {backup}{deduplication}{compression}: Ein auf rsync basierendes Netzwerk-Backup-Programm, welches zunächst ein Full-Backup speichert, und inkrementelle Backups mittels Hardlinks in ein neues Verzeichnis realisiert. So brauchen nur geänderte Dateien überhaupt angelegt zu werden und kosten Platz. Ein Rotationsschema ist integriert. In Perl geschrieben.
disk-manager-1.1.1-2/admin/debian: Ein in veraltetem Python (diverse Warnings) implementierter besserer Editor für die /etc/fstab. Kann nicht einmal Wechselmedien einhängen. Unbrauchbar außer für blutige Laien die sich fürchten einen normalen Editor zum Bearbeiten der fstab zu bemühen.
ditaa/graphics/debian: Ein JAVA-typisch grausig fettes (10 MB-Download und 20 MB zusätzlich zum JRE installiert insgesamt, inklusive Zwangs-Abhängigkeiten; das eigentliche Executable ist nur 100 kB groß) JAVA-Programm, das ähnlich wie das deutlich schlankere python/python-aafigure ASCII-Art in "richtige" Grafiken umwandelt. Und in dem fetten Installationsumfang ist nicht einmal die Anleitung enthalten, die muss man sich zusätzlich online ansehen. Das Programm ist überdies schweinelangsam, genauer gesagt braucht es ewig zum Starten. Eine simple ASCII-Grafik aus 3 Textboxen benötigte mehr als 1 Minute zur Konvertierung. Immerhin war das wenigstens das Ergebnis der Konvertierung zufriedenstellend, anders als bei aafigure. Doch leider hat auch ditaa einen gravierenden Mangel: Es kann nur PNG-Dateien erzeugen (wenigstens mit Anti-Aliasing), und keine skalierbaren SVG-Vektorgrafik-Dateien! Das wiederum kann nur aafigure. Seufz. Andererseits kann man sich ohnehin nicht darauf verlassen dass alle Web-Browser SVG korrekt darstellen können. Daher sind Bitmap-Grafiken vermutlich ohnehin vernünftiger. Es gibt auch für ditaa ein text/asciidoc-Plugin, welches es erlaubt die ASCII-Art Diagramme direkt in asciidoc-Quelltexte aufzunehmen. Angesichts der langen Render-Zeit sollte man sich das aber gut überlegen: Wenn man nicht einschlafen will sollte man wohl besser nur die mit ditaa bereits vorab erzeugten PNG-Dateien aus dem asciidoc-Dokument heraus referenzieren.
dma-0.13-1+b1/mail/raspbian dma-0.11-1+b1/mail/devuan: Der "DragonFly Mail Agent" ist eine extrem schlanke "sendmail"-Implementation, welche keinen Hintergrunddienst installiert und am lokalen System erstellte Mails an die /var/spool/mail/-Mailboxen lokaler Benutzer oder an externe SMTP-Server (TLS wird dabei unterstützt) zustellen kann. Es ist jedoch nicht in der Lage, auf Port 25 (oder einem anderen) von außen  herein kommende e-Mails zu empfangen. Nur wenn man letzteres benötigt, reicht "dma" nicht aus und man muss statt dessen einen vollwertigen MTA wie "postfix" oder "exim" installieren. "dma" installiert allerdings einen Cron Job der alle 5 Minuten prüft ob Mails deren Zustellung scheiterte existieren um die Zustellung erneut zu versuchen. Dieser Fall kann jedoch nur auftreten falls Mails an externe SMTP-Server versendet werden. Solange Mail nur an lokale Benutzer versendet wird ist der Cron Job daher unnötig und kann deaktiviert werden.
dmraid/sys-fs/gentoo: Wird immer für spezifische Kernel-Version gebaut.
dnsmasq-2.72-3+deb8u2/net/devuan: Einer der schlankeren DHCP-Server. Außerdem ist er auch ein TFTP- und BOOTP-server sowie ein DNS proxy. Weiters kann DNS-Anfragen mit Namen aus lokalem Dateien wie /etc/host beantworten. Fetter als udhcpd, hat aber dafür nicht dessen fürchterlichen Bug, sondern kann gezielt nur bestimmte Interfaces bedienen. Dnsmasq ist allerdings kein vollwertiger DNS-Server, sondern kann DNS-Anfragen die er nicht anhand seinen lokalen Dateien bedienen kann nur an echte DNS-Server weiterleiten. In der Default-Installation fungiert er nur als nameserver und DHCP-Server und weiteren Funktionen sind inaktiv. Per Default bindet er an alle Interfaces, und folgt dabei der Devise man ihn konfigurieren kann nur Requests von bestimmten Interfaces tatsächlich zu bedienen. Mit anderen Worten, man soll darauf vertrauen dass dnsmasq auch tatsächlich wie erhofft arbeitet. Wem das zu gefährlich ist und dnsmasq nur an solche Interfaces binden will die auch serviciert werden sollen, kann ihn aber auch konfigurieren sich nur an eine explizite Liste von Network Interfaces zu binden, welche dann allerdings auch sämtlich vorhanden und aktiv sein müssen. Da dies eher witzlos ist weil Interfaces jederzeit manuell aktiviert oder deaktiviert werden könnten, kann man alternativ eine Ausnahme-Liste (welche auch glob-Wildcards unterstützt) von Interfaces definieren, an die er sich *nicht* binden soll. Was leider fehlt ist die Möglichkeit eine Liste von Interfaces anzugeben, an die er sich binden soll soweit sie vorhanden sind. Man kann dies aber reichlich umständich durch Negation mittels der Ausnahmeliste annähernd nachbilden.
docutils-0.8.1/dev-python/gentoo {text-formatting}: Tools zur Aufbereitung von Dokumentation aus Python-Quelltexten "docstrings". Enthält allerdings auch unabhängig davon nutzbare Tools zur Konvertierung von Dateien im "ReStructured Text"-Format. Dies ist eine Alternative zu app-text/asciidoc (siehe dort für einen Vergleich), welches dasselbe grundlegende Ziel hat: HTML-Dokumente und andere "wohlformatierte" Dokumentformate aus simplen Textdateien zu erzeugen, die spezielle aber möglichst "natürlich wirkende" Syntax als Markup benutzt.
dokuwiki-20140929b/www-apps/gentoo {wiki}: Eine in PHP vefasste Wiki-Software. Eine in dieser Sprache verfasste Software will ich aus Sicherheitsbedenken heraus nicht verwenden. Zudem scheint das Kernpaket in Debian nicht mehr enthalten zu sein. (Stand: 2018. Es gibt einige Zusatzpakete dafür, aber nicht das eigentliche Wiki)
dolphin-4.3.1-r1/kde-base/gentoo {file manager}{Qt}: Der neue Dateimanager von KDE4+. Nachdem der Konqueror gegenüber KDE-3 abgespeckt wurde so dass er nun keine Dateiverwaltungsoperationen mehr durchführen kann (nicht einmal das Auflisten von Verzeichnisinhalten ist mehr möglich), füllt Dolphin die nun dadurch entstandene Lücke in der Funktionaliät. Er beherrscht Links-Rechts-Split a la Norton Commander, aber Tab wechselt leider zwischen allen möglichen Minifenstern und nicht nur zwischen den Directory-Panes. Hat den Wahn andauernd Openoffice starten zu wollen, selbst zum Betrachten der lächerlichsten Textdateien! Dies kombiniert mit der lustigen Idee per Default jede Datei per *Einfachklick* zu öffnen macht das Programm eher zu einem lustigen Scherz als zu einem ernsthaften Dateimanager (gottlob ist dieser Schwachsinn abschaltbar). Ein großer Wurf scheint mir Dolphin jedenfalls nicht zu sein - einfach der tausendste Klon des (mir verhassten) Windows-Explorers. Ein Glück dass es den Krusader gibt. Der größte Vorteil des Dolphin ist wohl dass er ein Kernbestandteil von KDE-4 ist und entsprechend immer in der neuesten Version vorhanden sein wird.
doomsday-1.15.8-5+b1/games/debian {game}: Eine Game-Engine für Doom und Hexen (möglicherweise auch Heretic), die ein sehr Aufwändig und hübsch gemachtes Verwaltungs-GUI in höchster Auflösung besitzt. Erfordert wie üblich das Vorhandensein der Leveldateien der Original-Spiele. Ich probierte es für Hexen aus - die niedrig aufgelöste Grafik wird aufwändig hoch skaliert und sieht auch optisch so gut aus wie es nur technisch möglich ist. Doch leider hat diese Game-Engine erhebliche Performance-Probleme: Alles ruckelt und kriecht dass es keine Freude mehr ist. Unbrauchbar zumindest mit integrierter INTEL Onboard-Grafik - teurere Grafikkarten schaffen es vielleicht dennoch damit flüssig zu bleiben. Dieser Port kann auf jedenfalls performancemäßig weder mit Crispy Doom noch Quake 2 mithalten. Doch leider können diese Engines auch keine Hexen- oder Heretic-Gamelevels laden.
doublecmd-gtk-0.7.7-1/utils/raspbian {file manager}{GTK+}: Ein nahezu perfekter Klon des kommerziellen "Total Commander"-Dateimanagers, welcher unter Microsoft Windows extrem beliebt ist. Somit ist er ein direkter Herausforderer von Krusader, der dasselbe versucht, und übertrifft diesen dabei in fast allen Punkten. Dies ist die GTK+-Version des Programms. Er sieht auch gut aus und ist eine Freude zu bedienen. Bis auf eine kleine, aber zumindest mich leider extrem störende Tatsache, welche ein K.O.-Kriterium für mich darstellt: Er verbraucht ständig CPU-Zeit, auch wenn er gerade absolut überhaupt nichts zu tun hat. Die Belastung ist dabei zwar gering, auf rund 100 Sekunden Echtzeit kommt eine Sekunde verschwendete CPU-Zeit. Aber wenn man das Programm tage- und wochenlang einfach laufen ließe, summiert sich dies trotzdem. Ein echter Jammer, denn ansonsten wäre es der Dateimanager meiner Wahl. Das Programm ist zudem auf mehreren Plattformen verfügbar - nicht nur Linux, sondern auch Windows, MacOS, BSD und (kommerziellem) UNIX.
doublecmd-plugins-0.7.7-1/utils/raspbian {file manager}{GUI}{X11}{extension}: Eine Liste mit Plug-Ins für Double Commander (doublecmd-qt und doublecmd-gtk), die zudem (zumindest in der Windows-Version des Pakets) auch zum kommerziellen "Total Commander" kompatibel sein dürften. Es handelt sich bei den enthaltenen Plugins ausschließlich um solche, die mit verschiedenen Archiv-Dateiformaten umgehen können.
doublecmd-qt-0.7.7-1/utils/raspbian {file manager}{GTK+}: Dies ist die ansonsten funktionsgleiche Qt-Version des "Double Commanders", welche aber leider der GTK+ Version derzeit nicht das Wasser reichen kann. Nicht nur dass er ständig abstürzt oder sich aufhängt. sieht er auch etwas plumper aus (was wohl an den Farben liegen dürfte) und verbraucht mehr Ressourcen. Konkret ergaben sich bei einem Vergleich identischer Workloads die folgenden Werte (virtueller Speicher / RSS bzw. tatsächlicher RAM-Bedarf) für mehrere Dateimanager: krusader (211M/67M), doublecmd-gtk (185M/55M), doublecmd-qt(311M/88M), worker (86M/16M). Das Problem mit der ständigen CPU-Belastung hat diese Qt-Version exakt genau so wie die GTK+ Version.
dropbear-0.52/net-misc/gentoo: Ein sehr kleiner SSH-Server und -Client; protokollkompatibel mit anderen SSH-Implementationen. Vorteil: Sehr geringer Code-Umfang; sehr detailliert einschränkbar was man von den Features tatsächlich ins Executable compilieren will. Unterstützt auch mehr symmetrische Algorithmen und bei diesen auch größere Schlüssellängen als OpenSSH. Kann auch Multicall-Executables für die diversen Untertools erzeugen um weiteren Platz zu sparen - ähnlich wie BusyBox. Wird auch gerne mit dieser zusammen installiert. Nachteil: Zwar bietet Dropbear eine größere Auswahl bei symmetrischen Verschlüsselungsalgorithmen. Aber aus einen unerklärlichen Grund unterstützt es für die Key-Exchange-Phase nur die Diffie-Hellman OAKLEY-Gruppe 2. Das ist ein 1024 Bit Modulus. Solche Moduli gelten nicht mehr als ausreichend sicher. Die heutzutage zumindest empfehlenswerte Gruppe 14 (2048 Bit) - oder noch größere - unterstützt Dropbear jedoch nicht. Und dies, obwohl der SSH-Standard fordert dass Gruppen 2 und 14 unterstützt werden müssen. Daher sind die höheren Schlüssellängen bei dem symmetrischen Algorithmen weitgehend wertlos, denn die Sicherheit des Gesamtsystems wird immer noch durch das schwächste Glied in der Kette bestimmt. Folgerung: Solange Dropbear nicht (was sicherlich leicht möglich wäre) erweitert wird so dass es zumindest DH Group 14 unterstützt, ist es zu unsicher um für sicherheitsrelevante Umgebungen benutzt zu werden. Denn auch wenn man einen 1024-Bit Schlüssel vermutlich nicht in Echtzeit knacken wird können während die Verbindung noch besteht, kann man die Verbindung zumindest aufzeichnen und sie nach dem Knacken des Schlüssels nachträglich entschlüsseln. Es besteht daher keine realistische Gefahr für eine Man-In-The-Middle-Attacke und somit aktive Beeinflussing der SSH-Session, wohl aber dass die Vertraulichkeit der übermittelten Daten in der Session nachträglich kompromittiert werden kann.
drupal/www-apps/gentoo: CMS in PHP geschrieben. Danke. Nächster, bitte.
dsyslog-0.6.0/admin/debian: Ein weiterer system-Logger. Im Gegensatz zur syslog-ng und rsyslog benutzt er eine andere Syntax als der klassische syslogd; jedoch wird eine Example-Datei mitgeliefert welche eine typisches syslogd-Konfiguration nachbildet, und die Original-syslog-Konfigurationszeilen sind als Kommentare zum Vergleich beigelegt. Ein Nachteil dieses Loggers ist seine knappe Dokumentation, die kein zwar kein tagelanges Studium erfordert, dafür aber auch vieles nicht erklärt (vor allem welche Möglichkeiten welche die mitgelieferten Plugins im Detail bieten) das man dann im Quelltext nachschauen muss. An Log-Quellen unterstützt er UNIX Domain Stream Sockets (nur im Datagramm-Modus - was eher schwach ist), UDP, automatische "MARK"-Meldungen jede halbe Stunde sowie den dmesg-Meldungen des Kernels. Ausgeben kann er die Log-Zeilen in Dateien, als UDP-Pakete oder in MySQL-Datenbanken. Bedingte Ausgabe (pro Ausgabeziel) ist möglich anhand von exaktem Vergleich, Glob-Pattern und Regexes (nur für Felder "source" und "program"). Bedingte Ausgabe (gemeinsam für alle Ziele) bzw. ignorieren/Löschen von Log-Einträgen ist möglich anhand von Severity/Facility, Programmnamen oder anhand von Regexes (nur Message-Text) prüfen können. Großartige Spezial-Features wie die "großen" Logger sie bieten (RELP, TLS) sucht man vergebens. Das Programm basiert auf dem GLib-API und ist durch selbstentwickelte Module (neue Quellen, Ziele, globale Filter und zielspezifische Filter) erweiterbar. Zudem setzt er auf Spezialfeatures der glibc und möglicher Weise auch des GCC, womit seine Portablilität eher beschränkt sein dürfte. Sehr verbreitet scheint er auch nicht zu sein, und die Entwicklung dürfte auch tot sein da die Webseite nicht mehr vorhanden ist. Er dürfte auch nur für "typischen" Gebrauch geeignet sein, da unklar ist ob er überhaupt zu Queuing in der Lage ist um auch bei hoher Belastung keine Log-Meldungen zu verlieren ohne das System zu blockieren. Eine komplexe Queue- und Worker-Thread-Konfiguration wie rsyslog bietet er jedenfalls nicht. Ein großes Manko ist dass man das Log-Format nicht anpassen kann - außer man schreibt ein eigenes Ausgabe-Plugin dafür, wozu man zwar den vorhandene Quelltext des Standard-Moduls leicht recylen könnte - aber trotzdem. Ein Vorteil ist dass der Code sehr schlank und modular sowie auf den ersten Blick sauber zu sein scheint (komplett mit Doxygen dokumentiert). Das liegt auch daran dass das ganze Programm im wesentlichen nur vorhandene glibc- und glib-Funktionen aufruft, und wenig selbst tut. Was nicht unbedingt schlecht sein muss, da so auch weniger Fehler entstehen können.
dtach-0.9-5/misc/raspbian: {KVM sharing}{text-terminal IO}: Terminal multiplexer. It is similar to GNU "screen" and "tmux", but only provides the most basic functionality of those tools: To attach, detach or re-attach a running application to a terminal. It does not preserve the screen contents when detaching, nor does it provide any sort of scrollback-buffer. As a compensation for those shortcomings, the executable is only 18 kB in size, where tmux is about 420 kB and GNU "screen" is even a lot larger. As a consequence, "dtach" can be installed even on minimalistic systems with very constrained storage-space, where job control ist not enough but tmux would be too large. It is most likely also easier to compile manually, because it certainly has less build dependencies because of its lo-fi nature. dtach can also be used together with "dvtm", which adds the capabilty to restore the screen contents when re-attaching, and also provides (very basic) scrollback buffer capabilities. Tip: dtach can be comfortably used with the following command sequence: >>>$ mkdir -pm 700 /tmp/dtach && cd /tmp/dtach && a() { dtach -A "${1:?session_name}" -ze ^A "$SHELL" -l; } && z() { dtach -A "${1:?session_name}" -E "$SHELL" -l; } && PS1='DETACHED $ ' && a initial<<<. This starts a session "initial". [Ctrl]+[a] detaches, and the "a" command can then be used to create and attach to more sessions or to re-attach to existing ones. Use "z" instead of "a" to let job control handle detachment. This might be necessary because dtach provides no way to escape the command key if one is set.
dtc-overlay 1.4.1-1/alarm/archlinux: Ein Compiler, der aus Device-Tree Overlay Quelltextdateien (*.dts) binäre Device-Tree Overlay Dateien (*.dtb) compiliert. Ebenso kann er die Binärdateien wieder zurück in Quelltextdateien decompilieren.
duff-0.5.2-1.1/utils/raspbian {deduplication}: Kann Duplikate nur ermitteln und anzeigen, jedoch nichts selbst mit ihnen tun. Normalerweise wird vorgebliche Gleichheit nur aufgrund der Dateigröße und des SHA-1 Hashes ermittelt. Man kann jedoch auch SHA2-256, SHA2-384 und SHA2-512 wählen, oder einen Byte-für-Byte Vergleich anfordern. Letzteres leider nur alternativ und nicht zusätzlich.
duplicity-0.7.11-1/utils/devuan {backup}{deduplication}{compression}: Erstellt Backups in TAR-Archiven und lädt sie dann mit GPG verschlüsselt auf irgend einen Fileserver zur Ablage. Besonders stolz ist es auf seine native Unterstützung diverser Cloud-Anbieter, insbesondere Amazon S3 und Microsoft Azure. Nutzt rsync's simple Delta-Fähigkeiten zur Datenreduktion zwischen mehreren Versionen derselben Datei. In Python geschrieben. Beherrscht (Stand 2020-01) keine Hardlinks. Sparse Files werden nicht speziell unterstützt sondern wie normale behandelt. Außerdem gibt es ein Limit von rund 8 GB für die Metadaten jedes Backup-Archivs (Stand 2019-01), was ca. 500.000 Dateien entspricht. Größere Backups sind nicht möglich bzw. müssen vorher in kleinere zerlegt werden. Das ist unpraktisch. Außerdem benutzt duplicity SHA-1 für seine Integritätsprüfung - das ist (zumindest in Kontext von verschlüsselten Backups) keine gute Idee, da SHA-1 mittlerweile (genau wie MD4 und MD5) als "geknackt" gilt. Schließlich dürfte duplicity noch viel temporären Speicherplatz für seine Backups benötigen, konkret zumindest den doppelten Platz. Möglicherweise besteht dieses Problem aber auch nur wenn vom der PGP-Verschlüsselung Gebrauch gemacht wird. Duplicity scheint mir konzeptionell ein Abklatsch von rdiff-backup zu sein, dem man sinnlose (AES) Verschlüsselungs-Funktionen spendiert hat. Alles in allem leidet das Programm unter so vielen Einschränkungen oder unglücklichen Design-Entscheidungen, dass es wohl eher nicht zu empfehlen sein dürfte. Das Paket enthält ein Zusatzprogramm "rdiffdir", welches die Funktionalität von "rdiff" auf Verzeichnisbäume ausweitet. Auch dieses Utility unterstützt allerdings keine Hardlinks.
dustracing2d-2.1.1-1/games/debian {game}: Ein 2D-Autorennspiel, das gewisse Ähnlichkeiten mit dem Spiel "Rally Speedway" am C64 aufweist. Man steuert ein kleines Rennauto, das man nur aus der Vogelperspektive sieht und welches sich immer an selben Position am Bildschirm befindet, während die Strecke des Rennkurses 2-dimensional unter dem Auto vorbei scrollt. Die Steuerung ist simpel: Zwei Tasten links/rechts zum Steuern und zwei weitere Tasten vor/zurück zum Bremsen/Beschleunigen. Es gibt mehrere Strecken, welche frei geschaltet werden sobald man die davor geschafft hat. Dazu muss man eine bestimmte Anzahl an Runden überstehen und kein zu schlechtes Renn-Ergebnis produzieren. Überdies liegt ein Level-Editor bei um eigene Strecken erstellen zu können. Es gibt verschiedene Spielmodi. In einem fährt man allein gegen mehrere Computer-Gegner. In einem anderen fährt man zusammen mit einem 2. menschlichen Spieler auf einem Split-Screen ebenfalls gegen die Computer-Gegner. Dabei kann man den Bildschirm wahlweise horizontal oder vertikal teilen. Die Steuertasten sind konfigurierbar. Vorgabe sind die Cursortasten für den 1. und WASD für den 2. Spieler. Weiters gibt es einen Duell-Modus, wo man im Split-Screen nur gegen den anderen Spieler allein anstritt - ohne Computer-Gegner. Und schließlich kann man noch allein gegen die Zeit spielen, wie schnell man den Kurs schafft. Das Spiel unterstützt verschiedene Fullscreen-Auflösungen, darunter zumindest Full-HD. Die vertikale Synchronisation des Bildaufbaus lässt sich dabei ein- oder ausschalten. Das Spiel scrollt flüssig und macht von der Umsetzung her einen guten und modernen Eindruck. Das Spiel ist auch nicht groß - nur ca. 5 MB Download bzw. ca. 8 MB installiert.
dvb-apps-1.1.1+rev1500-1.4/video/debian linuxtv-dvb-apps-5.8/media-tv/gentoo: Enthält Kommandozeilen-Tools zum Scannen von verfügbaren DVB-TV-Sendern, diverse Debug-Tools sowie ein Tool zur Wiedergabe der gefundenen Sender. Unterstützt neben DVB-T (terrestrisches TV) auch DVB-C (Kabelfernsehen) und DVB-S (Satellit). "scan", "dvbscan": Scan for channels on your digital TV device; "czap", "szap", "tzap", "azap": Senderwahl; "gnutv": Tune, watch and stream your TV; "dvbdate": Set your clock from digital TV; "atsc_epg": Display ATSC Electronic Program Guide (next programs); "alevt": Teletext browser. Doppelt so lange wie media-tv/w_scan, benötigt dafür aber keinen installierten VLC-Player zur Wiedergabe. Ein Vorteil ist das enthaltene Tool zum Aufzeichnen und Anzeigen von Teletext (via USE-Flag). Dafür ist das Scan-Tool schlechter, da es zusätzliche Frequenzdaten benötigt, die es nicht selbst ermitteln kann (was zum Teufel tut dieses Tool dann eigentlich genau???)
dvdisaster-0.79.5-10/otherosfs/debian dvdisaster-0.70.1/app-cdr/gentoo: Erstellt Korrekturdateien (interleaved Reed-Solomon) für gebrannte CDs und DVDs oder beliebiger Einzeldateien (normaler Weise eine Abbilddatei) im einstellbaren Umfang. Die Korrekturen können entweder auf dasselbe Medium gebrannt werden (empfohlen: 30 % Overhead, mindestens 15 %), oder auf ein anderes (das nächste zu brennende) das selbst Fehlerkorrekturdaten enthält (empfohlen: 15 % Overhead). Oder die ECC-Information wird einfach als neue Datei erzeugt. So kann man z. B. eine große Archivdatei schützen indem man ihr eine von dvdisaster erstellte *.ecc Datei zur Seite legt. Unverzichtbar für Langzeitlagerung von selbstgebrannten Rohlingen! GTK+ GUI und Kommandozeile.
dvtm-0.15+40.g311a8c0-1/utils/raspbian {KVM sharing}{text-terminal IO}: Ein Versuch, im der Terminal das Gegenstück zu einem Tiling Window Manager wie "dwm" zu realisieren. Praktisch ist es ein Terminal-Multiplexer ähnlich wie "tmux", nur mit noch komischeren Tastenkombinationen. Allerdings gibt es neben nicht-überlappenden Fenstern sehr wohl auch die Möglichkeit dass nur ein Fenster davon Terminal-füllend (bis auf die Statusleiste vom dvtm) angezeigt wird. Allgemein ist eines der Fenster das "Master"-Fenster in dem man normalerweise auch arbeitet, und alle anderen Fenster werden irgendwie verkleinert am Rand angeordnet oder auch gar nicht angezeigt. Die folgenden Anordungen sind standardmäßig vorhanden: Nur Master-Fenster anzeigen, gekachtelte Fenster links, gekachelte Fenster unten, alle Fenster soweit möglich gleich groß als Gitter angeordnet. Im Quelltext kann man noch weitere Anordnungen wie eine Fibonacci-Spirale aktivieren, dazu muss das Programm aber neu kompiliert werden. Weiters kann man jedem Fenster beliebig viele numerische Tags zuweisen. Weiters kann man auswählen welche Tags gerade sichtbar sein sollen. Dann werden nur Fenster mit solchen Tags angezeigt. Damit kann man "mehrere Desktop-Seiten für Arme" simulieren. Es ist möglich über einen FIFO Text zu dvtm zu schicken der dann in der Statuszeile hinzu gefügt wird. So könnte man z. B. die Uhrzeit, CPU-Auslastung und dergleichen anzeigen lassen. Etwas schwach bzw. umständich ist der Copy-Modus: Der Scrollback-Buffer wird dabei einfach in eine Temporärdatei kopiert welche dann mit einem normalen Texteditor bearbeitet wird. Das was dieser dann abspeichert gilt als "markiert" und kann dann in eine der anderen Shells eingefügt werden. Das ist umständlich, weil man so alles wegschneiden muss außer das was einen interessiert, anstatt nur einfach letzteres zu markieren. Ganz in der Tradition vom "dwm" gibt es auch keinen Konfigurationsdatei, sondern man soll dazu die Konfiguration in einem Header-File anpassen und dann das Programm damit neu kompilieren. Zum Glück ist das aber nur bei den Tastenkombinationen nötig, die meisten anderen Einstellungen inklusive der Kommandotaste (welche man vor den eigentlichen Tastenkombinationen drücken muss, standardmäßig [Strg]+[g]) lassen sich auch via Kommandozeilen-Option einstellen. Die "Microsoft Windows"-Tasten werden nicht benutzt. Insgesamt kann man mit den Tastenkombinationen gut über die Runden kommen und braucht keine Anpassung der Belegung. Mit nur 40 kB ist das Programm auch ein sehr kleiner Download (100 kB installiert). Hängt auch nur von der C-Library und der ncurses-Library ab. Es kann von den Features her nicht mit "tmux" oder "screen" mithalten, ist aber auch nur rund 1/10 so groß. Allerdings fehlt dvtm ein wichtiges Feature, nämlich detach/reattach. Es kann zu diesem Zweck aber mit anderen Programmen wie "dtach" oder "abduco" kombiniert werden, welche wiederum nichts anderes können. Die Kombination ermöglicht es dann sowohl zu reattachen (was dvtm nicht beherrscht), als auch den Bildschirminhalt nicht zu verlieren (was dtach nicht beherrscht), und ist trotzdem immer noch ressourcensparender als tmux oder screen.
dwdiff 2.0.9-6/community/archlinux {text-diff}{word-diff}: Eine verbesserte Version von "wdiff", welche annähernd dasselbe kann, aber zusätzliche Einstellungen bietet, wie beispielsweise dass man die Zeichen welche "Worte" trennen anpassen kann. Es gibt auch Optionen um die Ausgabe komplett identisch zu der von wdiff zu formatieren. Es gibt auch eine Option, um die Ausgabe eines normalen unified "diff" in das Ausgabeformat von wdiff umzuwandeln. Dadurch kann man aus normalen Diffs Word-Diffs machen. Was das Tool leider nicht kann oder bietet, ist ein duales "Word-Patch" Tool welches Word-Diffs als Patches auf Dateien anwenden kann, um die Unterschiede anzuwenden. Das Tool ist daher eine Einbahnstraße, was die erzeugten Diffs betrifft.
dwm-6.4-1/x11/raspbian dwm-6.0-7/x11/devuan dwm-6.1-5/x11/debian {window manager}{GUI}{X11}: Ein als unglaublich klein und ressourcensparend bejubelter "tiling" Fenstermanager in der Tradition von Ratpoison & Co. Besonders stolz ist er darauf dass er kein Konfigurationsfile besitzt, und jede Anpassung im Quelltext erfolgen muss den man darauf hin neu kompiliert. Etwa weil man einen zusätzlichen Tastatur-Hotkey zum Starten einer Applikation festlegen wollte. Dwm kennt grundsätzlich 3 Modi: Tiling, "Monocycle" und "Floating". Beim Tiling ist links ein "Master"-Fensterbereich welcher die volle Höhe des Bildschirms einnimmt (von der dwm-Steuerleiste einmal abgesehen) und rechts davon sind alle anderen Fenster, welche alle dieselbe Restbreite einnehmen und vertikal gestapelt sind. Nur durch Patches kann man auch andere Tiling-Anordnungen wie etwa horizontales Stapeln ermöglichen. Normalerweise wird im "Master-Fensterbereich" nur ein einziges Fenster dargestellt, nämlich das aktuelle Haupt-Arbeitsfenster. Allerdings kann man den Master-Fensterbereich um beliebig viele zusätzliche vertikale Unterfenster ergänzen, unter denen die Höhe des Master-Fensterbereichs dann gleichmäßig aufgeteilt wird. Im "Floating"-Mode kann man die Position und Größe von Fenstern frei verändern; sobald man allerdings den Modus umschaltet sind die individuellen Fenster-Positionen alle wieder verloren. (Angeblich gibt es aber auch dafür Patches damit Fenster sich ihre letzte Floating-Position merken können.) Im "Monocycle"-Modus wird immer nur ein einziges Fenster maximiert dargestellt. Wenn man dann auch noch die Steuerleiste von dwm ausblendet, hat man eine Full-Screen Ansicht. Das Verändern von Größe/Position im Floating-Modus erfolgt nicht etwa durchs Steuerelemente am Fenster, sondern durch bestimmte Tastenkombinationen, wo man dann mit der Maus das Fenster entweder vergrößern oder verschieben kann ohne eine bestimmte Stelle im Fenster anklicken zu müssen. Neben den genannten Basismodi kann man in Tiling-Modus noch individuelle Fenster als Floating definieren. Automatisch wird dies vor allem bei Pop-Up-Dialogfenstern getan, welche einen sonst vermutlich in den Wahnsinn treiben würden da sich das optisch wahrgenommene Fensterlayout sonst jedesmal komplett ändern würde. Dwm unterstützt des weiteren "so etwas ähnliches wie 9 Workspaces", indem man jedes Fenster einer von 9 Gruppen zuordnen kann, die man dann typischerweise gleichzeitig anzeigen und dafür alle anderen Fenster verstecken kann. So schön das auch alles sein mag, der dwm bekommt ein echtes Problem wenn viele Fenster offen sind. Dann werden die Tiles abseits des Master-Tiles nämlich der Höhe nach winzig klein, und zugleich im Verhältnis zur Höhe lächerlich breit, so dass man nichts mehr in ihnen erkennen kann. Und noch dazu dauert der Aufbau der Tiles dann ewig lang, weil der dwm dazu *jedes* Fenster rendern muss. Und da alle Tiles immer komplett sichtbar sind (außer die für andere Workspaces ausgeblendeten), dauert das entsprechend lange. Weiters nervt am dwm dass er für alles Tastenkombinationen verwendet, die von vielen Anwendungen selbst benutzt werden. So werden viele Funktionen einfach mit einer Alt-Buchstabe-Kombination erreicht, die in sehr vielen Programmen für Menü-Schnellaufrufe verwendet wird. Da der Fenstermanager Vorrang hat schnappt er sich diese Tastenkombinationen dann, so dass sie in der Applikation nicht mehr wie erwartet funktionieren. Bzw. ganz andere Funktionen des Fenstermanagers auslösen. Natürlich kann man auch hier wieder alles redefinieren... im Quelltext des dwm. Halbwegs lustig ist dafür das "Startmenü" des dwm geraten: Es öffnet sich einfach eine Textzeile wo man ähnlich wie per Tab-Competion inkrementell nach vorhandenen Programmen suchen und diese Starten kann, nur dass man Tab drücken müsste. Solange man den Namen des Programms weiß ist das durchaus komfortabel. Allerdings filtert die Auswahliste nicht aufgrund von vorhandenen *.desktop-Dateien; jedes ausführbare Programme wird gefunden und vorgeschlagen, auch wenn es kein GUI-Programm ist. Dieses mehr oder weniger lustige "Startmenü" ist allerdings nicht Teil des dwm, sondern es handelt sich dabei um ein separates Paket "dmenu", welches allerdings je nach Distribution häufig als Abhängigkeit von dwm automatisch mitinstalliert wird. Weiters scheint dwm die Fähigkeit zu fehlen, im Betrieb auf einen anderen Fenstermanager umzuschalten. Solange man nicht viele zu Fenster offen hat oder sie brav auf verschiedene Workspaces/Gruppen verteilt, kann man mit dwm halbwegs angenehm arbeiten. Doch bei zu vielen Fenstern macht er bald schlapp, und auch die voreingestellten Tastenkürzel sind problematisch da sie oft mit den normalen von Applikationen kollidieren. Wirklich Sinn machen dürfte dwm daher wohl nur auf Rechnern mit extrem wenig RAM, wo sein sehr geringer Ressourcenbedarf (inclusive seines Codeumfangs) sich positiv auswirken mag: Dwm verbraucht nur rund 10 MB RAM (RSS) während er läuft. Ansonsten sollte man wohl besser zu einem seiner etwas fetteren "Konkurrenten" wie ratpoison mit ähnlicher Bedienungs-Philosphie greifen.
easyedit-1.4.6/app-editors/gentoo {text-editor}{text-terminal IO}: Simple console-based editor. Does not support UTF-8.
eclipse-3.8.1-7/devel/debian {development_environment}: Die fetteste Sau im Dorf der integrierten Cross-Plattform Entwicklungs-Umgebungen (ca. 260 MB Download für eine Standard-Installation ohne Abhängigkeiten wie JRE). Eclipse ist primär zur JAVA-Anwendungs-Entwicklung gedacht, aber es gibt auch ein vollwertiges Plugin für C/C++ Entwicklung samt Debugger-Integration und allen Extras. Es ist auch möglich C-Projekte mit Eclipse zu benutzen die auf normalen Makefiles basieren. In diesem Fall hat man die Wahl zwischen "Managed" Makefiles welche von Eclipse selbst generiert werden, oder man erstellt sie komplett selbst. Autotools-Support ist ebenfalls vorhanden. Es gibt für alle 3 Varianten integrierte Editoren zum Bearbeiten der Konfiguration welche sogar auf Spezifika der Variante eingehen. Aber nur Makefiles können automatisch "Managed" sein; Autotools-Projekte nicht. Allerdings gibt es einen integrierten Konverter, der neue Autotools/Makefile-Projekte aus bestehenden Quelltexten erzeugen kann. Leider funktioniert hierbei offensichtlich nicht alles so wie es sollte; beim Anlegen eines neuen Autotools- oder Makefile-Projektes verreckte der Wizard beispielsweise mit einer JAVA Null-Pointer-Exception, so dass beides nicht möglich war. Eclipse-Projekte benutzen in jedem Fall komplexe XML-Dateien zur Beschreibung der Projekteinstellungen und -Abhängigkeiten, gegebenenfalls zusätzlich zu den Makefiles und Autotools-Dateien. Eclipse selbst ist in JAVA implementiert und benötigt daher viele JAVA-Pakete als Abhängigkeiten. Sieht grundsätzlich nett aus und scheint auch alles zu können was man von einer IDE so erwartet. Was mich stört ist allerdings der immense RAM-Bedarf, auf einem Rechner mit 2 GB RAM (aber ohne Swap) startete es nicht einmal sondern verreckte nur mit einem Segfault. Vielleicht könnte man das irgendwie einstellen indem man die mitgelieferten Start-Scripte anpasst und die JRE mit anderen Speichereinstellungen aufruft. Aber "out of the box" funktioniert es nur mit Rechnern die Gigabytes an RAM haben. Der Start selbst dauert auch relativ lange, aber das ist bei fetten Programmen nicht ungewöhnlich. Wenn es erst einmal läuft (800 MiB virtueller Speicher und 260 MiB RAM in der x86-Version), macht es einen netten Eindruck. Eines der Dinge die mich stören tut mich eigentlich nur das Plugin-System: Dieses installiert und aktualisiert Plugins unter Umgehung des Paketmanager des Systems. Und schlimmer noch, dabei werden nicht etwa Quelltexte herunter geladen und lokal gebaut, sondern bereits fertig kompilierte Komponenten. Ich misstraue so einem System zutiefst; auf diese Weise kann man such Malware ohne Ende einhandeln. Ich zweifle nicht daran dass die Plugins digital signiert sind, aber wer sagt dass die Malware nicht bereits "ab Werk" eingebaut war? Immerhin lässt sich das automatische Update abschalten und ist im Falle von Debian auch standardmäßig inaktiv, so dass diese Gefahr nur tragend wird wenn man es einschaltet. Weiters stört mich, dass die IDE ständig Context Switches durchführt, sogar wenn alle Fenster, Projekte und "Perspektiven" geschlossen sind und einfach nur das IDE-Fenster offen ist. *Viel* Rechenzeit verschlingt Eclipse nicht in diesem Zustand, aber eine Minute CPU-Zeit kommt auf diese Weise trotzdem zusammen, wenn man es eine Stunde oder so laufen lässt. Und wenn ein Projekt offen sein sollte, wird das fürchte ich noch mehr sein. Wenn man die IDE daher permanent geöffnet lässt und nicht nur bei Bedarf startet, ist ein Mehrverbrauch an Strom (wenn auch nicht in bedeutendem Ausmaß) zu befürchten. Ich sehe nur geringe Vorteile durch die Nutzung von Eclipse für die C/C++ Entwicklung gegenüber einem klassischen Editor und Makefiles; der größte ist vermutlich das Verbergen der Komplexität beim Einrichten der Build-Infrastruktur des Projekts. Aber leider gibt es viele Projekte, die Eclipse als Editor-Komponente zum Bearbeiten oder Entwerfen ihrer Dokumente benutzen. So benötigen zahlreiche Reporting-Engines (wie etwa JasperReports) beispielsweise Eclipse, damit man Reports erstellen und bearbeiten kann. Auch "Android Studio" basiert auf Eclipse. Ob man Eclipse daher mag oder nicht, manchmal wird es einem einfach aufgedrängt.
egroupware/www-apps/gentoo: In PHP geschriebene Groupware welche Termine, Kontakte, Projekte und To-Do-Listen verwaltet. Als Clients können neben dem Web-Browser auch Kontact, Novell Evolution und MS Outlook verwendet werden. Mit SyncML können auch PDAs und SmartPhones synchronisiert werden. Kann auch mit dem N900 Smartphone synchronisiert werden, wenn man dort die Pakete syncevolution und syncevolution-frontend installiert.
eigen-2.0.5/dev-cpp/gentoo: Template-Klassen für C++ zur Matrix und Vektormanipulation. Variable Dimensionen werden unterstützt, doch konstante Dimensionen werden effizienter abgearbeitet. Zur Vermeidung von Temporärvariablen bei Zwischenausdrücken arbeiten die Klassen mit Lazy Evaluation (auf einem Kostenmodell basierend). Neben den grundlegenden Matrix/Vektorfunktionen gibt es auch Funktionen zum Extrahieren von Submatrizen, Lineare Regression und Hyperflächen-Fitting nach der Least-Squares Methode. Typen für 1, 2 und 3 Dimensionen sind bereits vordefiniert. Für schwach besetzte Matrizen gibt es ein eigenes Modul.
eix/app-portage/gentoo: A faster replacement for search. Optionally using SQLite. Does the same job, can do even more, and updating the index is *much* faster. Supports portage portage/layman overlays. It also supports displaying the USE flags for installed packages.
elinks-0.11.5/www-client/gentoo {www-browser}{text-terminal IO}: Ein netter konsolenbasierter Web-Browser ähnlich wie Lynx. Im Gegensatz zu Lynx hat er aber auch Support für Grafiken (via Framebuffer), beherrscht JavaScript, unterstützt Links-Rechts-Scroll, "tabbed" Windows, verschiedene Zeichensatz- und Farbsettings und erlaubt es vor allem die Tastaturbelegung anzupassen. Alles in allem wäre er Lynx weit überlegen - wenn er nur funktionieren würde! Denn tatsächlich hat er einen üblen Bug: Er öffnet jede Menge File Descriptors, schließt diese aber nie mehr! Oder zu spät. Effekt: Nach kurzer Zeit intensiven Surfens stürzt das Programm mit der Meldung "Out Of File Descriptors" ab. Ein dummer Bug in einem ansonsten guten Programm. Aber der Bug reicht dass elinks praktisch unbrauchbar ist.
elogv-0.7.4/app-portage/gentoo {text-terminal IO}: Ein Betrachter für die Log-Dateien welche in /var/log/portage/elog beim Emergen von Paketen angelegt werden, falls man dieses Feature aktiviert hat. Das Programm zeigt alle verfügbaren Log-Dateien in der oberen Hälfte eines ncurses-basierten bunten GUIs an; in der unteren Hälfte befindet sich ein Ausschnitt des Log-Inhaltes welcher mittels der Leertaste weitergeblättert werden kann. Man kann die Liste der Log-Dateien nach verschiedenen Kriterien filtern und sortieren. Was man allerdings nicht kann, ich das Log-File per Default bildschirmfüllend betrachten. Für einige Befehlssequenzen wurden "vi"-kompatible Kommandos gewählt.
emelfm2-0.4.1/app-misc/gentoo {file manager}{GTK+}: Nice Norton-Commander-sortof file manager with UTF-8 support. No support for multiple display pane tabs. GTK+ based with GTK+ theme support. Rather minimalistic in functionality but features everything needed in an actual file manager. Mouse / icon / keyboard operation as expected. Toggle between two pane and single pane layout. Function for recursively calculating the accumulated size of selected items. Bookmarks. Pane display filters for name, size and date (optionally apply to directories, too). Command line. "Launch shell in terminal window here" functionality. "Run as root". Simple mount manager. Keeps track of launched child processes and allows to kill them. Contains a plain text file viewer (search/print/wrap) as well as a minimalistic text editor (but still including search/replace/undo/print and optional soft line wrapping). Incremental or dialogue-based name search in directory display panels. Switch for showing hidden entries. Different Panel layout and date/size display formats. Configurable file type actions. Selectable case sensitivity for search/sort. Extensible via plug-in scripts. Graphical manager for menu, icon, plugin and keyboard shortcut customization. A problem of the current version is its automatic background queuing of copy/transfer jobs which provides little or no visual feedback when the operation has actually finished.
emerge-delta-webrsync-3.5.1-r3/app-portage/gentoo {deduplication}{compression}: Ein Tool, mit dem angeblich differenzielle Updates des Portage-Trees möglich werden. Sehr schön. Doch leider funktionierte es bei mir im mehrwöchigen Test nie: Niemals fand es auf den Servern die Updates welche es suchte, und lud dann erst recht wieder das 45 MB Vollarchiv runter. Tolles "Delta". Vielleicht liegt es daran, dass ich derzeit nur wöchentliche Updates mache, und die Server die Delta-Updates nicht so lange speichern. Einerlei - unbrauchbar. Zumindest derzeit und für mich. Aber zumindest eine nette Idee welche dahinter steckt.
enca/app-i18n/gentoo: Erkennt die Sprache und Zeichenkodierung einer Textdatei, und kann letztere in das lokale oder in ein angegebenes Format umwandeln. Leider unterstützt dieses tolle Paket die deutsche Sprache nicht...
encfs-1.9.5-1+b1/utils/debian {FUSE}: Das bislang komfortabelste verschlüsselnde Overlay-Dateisystem für nicht-privilegierte Benutzer. Man mountet dazu ein Verzeichnis welches von EncFS versschlüsselte Dateien enthält in ein virtuelles anderes Verzeichnis, wo man die entschlüsselten Dateien sieht. Es werden AES, Blowfish und CAMELLIA als Verschlüsselungsalgorithmen unterstützt, alle mit Schlüssellängen zwischen 128 und 256 Bit. Die Dateinamen im realen Verzeichnis können optional ebenfalls verschlüsselt werden, wobei man die Wahl hat zwischen einer Methode welche die Länge der originalen Dateinamen nicht verbirgt und einer welche dies zumindest einigermaßen tut. Es ist möglich "Löcher" in Dateien durchzureichen (etwa für bestimmte Datenbanken wichtig) wenn man dies wünscht. Weiters können Integritätsinformationen gespeichert werden welche Lesefehler erkennen und theoretisch auch vorsätzliche Manipulationen erkennen können. Praktisch hat EncFS aber leider viele Implementations-Schwächen, die eine ganze Reihe von Angriffen auf die verschlüsselten Daten möglich machen. Die eigentliche Verschlüsselungs ist zwar nach wie vor sicher, aber ein Angreifer der es schafft Snapshots der verschlüsselten Daten zu verschiedenen Zeitpunkten zu erstellen und diese dann mit einander zu vergleichen, kann die Verschlüsselung dadurch möglicherweise knacken. EncFS ist daher eine brauchbare Lösung als zusätzliche Verschlüsselungsebene, wenn man besser implementierte wie LUKS bereits auf der unteren Ebene nutzt. Es ist auch OK auf Wechseldatenträgern die man normalerweise niemand anderem übergibt, oder zumindest niemandem dem man nicht vertraut. Doch eine ganz schlechte Idee wäre es, EncFS in der Cloud einzusetzen - etwa auf einer WebDAV-Share. Trotz seiner Nachteile ist EncFS wegen seinem großen Komfort aber immer noch ein nützliches Dateisystem, solange man sich der Sicherheits-Einschränkungen bewusst bleibt.
enchant/app-text/gentoo: A wrapper for accessing ispell, aspell, hunspell and other spelling checker backends via a common interface. It also tries to emulate common functionality not provided by specific backends. Enchant is primarily a library to be linked to other applications rather than a command line interface, although it also ships with a rather rudimentary one. But Enchant's CLI currently is no match for Aspell's. However, this does not also apply when using Enchant's library which is a fully-fledged spell-checking solution.
engrampa-1.8.0/app-arch/gentoo {compression}: Der Standard-Manager für gepackte Archivdateien des Mate DTE. Unterstützt zumindest in seinem Auswahlmenü die folgenden Archivformate: 7-Zip (".7z"), ".ar", ".jar", selbstentpackendes ".zip", ".tar.bz2", ".tar.Z", ".tar.gz", ".tar.lrz", ".tar.lzo", ".tar", ".tar.xz", ".zip". Das Verschlüsseln und Aufteilen in Teilarchive gegenener Maximalgröße wird unterstützt soweit das Dateiformat es ermöglicht. Es ist unklar ob es möglich ist durch das Hinzufügen eigener Script-Hooks auch andere beliebige Archivformate zu unterstützen; jedoch scheint das eher nicht so zu sein (wenn überhaupt dann nur über das Erstellen einer eigenen C "Shared Library", was C-Programmierkenntnisse erfordert).
enlightenment-0.17.6/x11-wm/gentoo: Ein Desktop-Environment, welches sein eigenes GUI-Toolkit mitbringt und daher weder von GTK+ noch Qt abhängig ist. Gegenüber der Vorgängerversion "E16" glänzt er vor allem mit zusätzlichen mitgelieferten Anwendungen wie etwa einem Dateimanager. Grundsätzlich ausreichend aufwändig (auch Wunsch mit diversen OpenGL-Effekten) gemacht und sieht halbwegs OK aus. Bietet auch bereits Wayland-Unterstützung für die Zeit nach X11. Jedoch: Etwas buggy - Absturz nach wenigen Minuten Testen. Immerhin bot er darauf hin an sich selbst neu zu starten. Der Dateimanager ist zu dämlich einen Ordner anzuzeigen, wenn man keine Anzeigerechte für den Ordner darüber hat. Der Tastaturfokus hat probleme - manchmal kann man ihn mit der Maus nicht umschalten und erst Alt-Tab behebt das Problem. Außerdem nervt mich die bedienungsmäßige Ausrichtung dieser DTE an mehrere Workspaces: Ständig scrollt in eine der 4 Richtungen ein anderer Workspace vorbei. Nervig auch die Default-Fokuseinstellungen: Wenn man das Mausrad auf dem Desktop-Hintergrund betätigt scrollt sofort ein anderer Desktop herbei. Dreht man das Mausrad jedoch weiter, wirkt es sofort auf das Fenster welches sich dann zufälliger Weise genau unter der Maus befindet und tut dort etwas völlig applikationsspezifisches; also etwas anderes als zuvor. Weiters stört mich dass die "Windows"-Tasten Teil der Standard-Tastaturbelegung sind. Natürlich kann man das vermutlich alles anpassen, aber die Defaults gefallen mir nicht.
eog-2.32.1/media-gfx/gentoo {graphics image viewer}: "Eye Of GNOME" ist der Standard-Bildbetrachter (oder nur einer davon?) der GNOME-Benutzeroberfläche. Trotzdem handelt es sich nur um einen recht minimalistischen Viewer der (auch wenn er ohne GNOME und konkret von Xfce aus aufgerufen wird) fantastisch schnell startet und daher gut als Standard-Bildbetrachtungsprogramm geeignet ist. Er hängt auch nur von wenigen GNOME-Bibliotheken ab, am fettesten vermutlich gconf. Ansonsten ist es in erster Linie ein GTK-Programm. Er kann wirklich nur das nötigste, sprich Bilder anzeigen, zoomen, drehen, spiegeln. (Dies alles nur temporär ohne Veränderung des Originals.) Er kann Bilder an die Fenstergröße anpassen und hat auch einen Vollbildmodus. Im Normalmodus hat er oben eine Buttonleiste und unten eine Vorschauleiste der Bilder im Verzeichnis. Des weiteren lässt sich das Programm bzw. seine Bibliotheken auch aus anderen Programmen heraus ansteuern; das API dazu ist dokumentiert und optional kann auch Python-Support dafür kompiliert werden. Das Programm beherrscht alle wichtigen Bildformate, und etliche Features und Formate können optional beim kompilieren aktiviert werden. Mit 2,5 MiB Installationsumfang auch nicht zu fett. Ich hättes es *beinahe* zu meinem bevorzugten Standard-Bildbetrachter unter Xfce-4 auserkoren, wenn ich nicht noch einen "katastrophalen" Mangel entdeckt habe: Es gibt zwar eine Funktion zum Anpassen der Bilder an die Fenstergröße - aber die scheint nur zu große Bilder zu verkleinern, kleine aber nie zu vergrößern! Fazit: Unbrauchbar! Andere können das. Geeqie beispielsweise.
eom-1.8.0/media-gfx/gentoo {graphics image viewer}: Der Standard-Bildbetrachter des Mate DTE. Wenig spektakulär, aber angenehm zu benutzen. Am unteren Bildrand wird eine abschaltbare Vorschau der Bilder im gewählten Verzeichnis angezeigt, darüber im Hauptbereich des Fensters das aktuelle Bild. Auch die Funktionen Vollbild und Dia-Show fehlen nicht. Der Toolbar ist nicht überladen sondern bietet nur die sinnvollen Buttons weiter/zurück, hineinzoomen, hinauszoomen, 1:1-Darstellung, fensterfüllende Darstellung sowie um 90 Grad nach links oder rechts rotieren. Das rotierte Bild kann dabei auf Nachfrage auch gespeichert werden. Dabei ist unklar ob die Rotation im Falle von JPEG-Bilder als verlustfreie Operation implementiert ist. Das Programm basiert auf der gdk-pixbuf-Bibliothek, was es eigener Aussage nach dazu befähigt, auch sehr große Bilder mit geringem Speicheraufwand zu scollen und zu zoomen. Weiters besitzt das Programm angeblich ein leistungsfähiges System für Erweiterungen, von denen ich allerdings nur drei sah die bereits fix vorinstalliert waren und eigentlich nur Grundfunktionen des Programms implementierten. Ein separates Paket mit zusätzlichen Plugins scheint es noch nicht zu geben und ich würde auch nicht darauf wetten wollen dass sich das jemals ändern wird.
epdfview 0.1.8-7/community/archlinux {document viewer}{PDF}: Ein leichtgewichtiges "GTK+"-basiertes PDF- sowie XPS-Anzeigeprogramm. Beherrscht zwar nur die wesentlichen Funktionen welche man von jedem PDF-Anzeigeprogramm erwartet, ist aber für die meisten Anwendungsfälle völlig ausreichend. Es hat auch nur einen sehr geringen Installationsumfang von rund 500 KB. Ein Nachteil ist allerdings der Ressourcenverbrauch - das Programm braucht bei bestimmten PDF-Dateien wesentlich mehr RAM oder Temporärspeicher als mupdf. Das ging so weit, dass der Raspberry Pi sich bei einem Dokument gänzlich aufhängte und nur mehr auf einen Reset reagierte. Beim im Kern ähnlich schlanken, jedoch mit einem erheblich größeren Installationsumfang gestraften "mupdf" passierte so etwas hingegen nie.
epiphany-0.7.0-6/games/debian {game}: A Boulder Dash clone. Does not even look too bad, except for the somewhat strange choice of colors for the player's character. It even scrolls nicely as the player moved through the level; just like the original BD. Unfortunately, the RPi's CPU is not fast enough to handle the scrolling smoothly. Try again on a faster processor, or once hardware-acceleration for SDL 2D is available on the Raspberry Pi.
epiphany-browser-3.38.2-1+deb11u3/gnome/debian {www-browser}{GUI}{X11}: Ein GNOME3-Webbrowser. Trägt sich im Menü als "Web" ein, ganz clever. Damit man keine Ahnung hat dass sich ausgerechnet *dieser* Browser dahinter verbirgt. GNOME3-typisch gibt es nur wenige Einstellungsmöglichkeiten. Ich fand weder eine Möglichkeit Javascipt noch Grafiken zu blocken. Plugins scheint es auch keine zu geben. Wenigstens Suchmaschinen kann man einfach hinzu fügen und bearbeiten, und ein Adblocker sowie ein Pop-Up-Blocker ist ebenfalls integriert. Passwort-Verwaltung ist vorhanden. Firefox-Sync wird ebenfalls unterstützt, wobei offen bleibt ob das dann mit dem Firefox kompatibel ist oder nur zwischen Epiphany-Browsern synchronisieren kann. Schnüffel-Pseudoblocker wie "Gefährliche Inhalte blockieren" sind fix im Programm eingebaut. Zumindest in RAM-Verbrauch ist dieser Browser um einiges schlanker als der Firefox, wenn auch immer noch fett genug.
epm/app-portage/gentoo: Required for handling of RPM files under Gentoo.
esearch/app-portage/gentoo: Create a fast search index for the portage tree. Basically replaces the very slow "emerge --searchdec". Updating the index is quite slow, but using it is quite fast. Supports portage/layman overlays.
esmtp-1.2/mail-mta/gentoo: Relay-only Mail Transfer Agent (MTA) with a sendmail compatible syntax. Can also do local delivery. Caveat: Development stopped around 2009.
espeak-1.42.04/app-accessibility/gentoo {audio}: Sprachausgabe-Tool das auch von Scripts aus verwendet werden kann. Erfordert pulseaudio oder portaudio für direkte Soundausgabe. Sonst kann es nur eine Wave-Datei erzeugen, und diese kann man dann abspielen. Kann englisch und deutsch, aber in erbärmlicher Qualität. Daher wenig brauchbar in der Praxis, ausser für Geeks welche sich am unverständlichen Gestammel erfreuen und es als Ratespiel auffassen.
eterm-0.9.6-1/x11/debian {terminal emulator}{GUI}{X11}: Der Terminal-Emulator des "Enlightenment" Desktop Environments. Zwar im Grunde reichlich sinnlos wenn man ihn ohne dieses verwenden will. Jedoch bringt es das nützliche Utility "Esetroot" mit, welches, falls installiert, automatisch vom Fluxbox Wallpaper-Setter verwendet wird, so dass die dämliche Fehlermeldung unterbleibt dass das ansonsten verwendete "display" einen Fehler-Returnwert zurück gegeben hätte. Da das Paket ca. 1/2 MB groß ist, sollte man es wieder deinstallieren sobald man das Wallpaper-Problem mit Fluxbox irgendwie anders gelöst hat. Etwa mit dem xloadimage-Paket. Dieser X11 Terminal-Emulator bietet ansonsten alle möglichen Spielereien an, aber weder Font noch Palette sind via Menü editierbar. Man merkt sofort dass dieses Programm zum "Enlightenment" DTE gehören könnte: Winziger Font, dafür popelige Hintergrundbilder und zahlreiche Menüs, in denen man aber nichts sinnvolles findet. Tabs gibt es natürlich keine, denn Enlightenment frönt ja dem SDI-Paradigma. Und Tabs sind ja so etwas wie ein kleines MDI. Daher schlecht und böse.
ethtool/sys-apps/gentoo: Kann Wake-On-LAN und andere Hardware-Settings von Ethernetkarten anzeigen und ändern. Das funktioniert oft auch bei NICs die keinen WOL-Support im BIOS haben und sich dieses Setting nicht übers (echte) Abschalten hinaus merken können.
etm-3.2.27-1/utils/devuan {PIM}{reminder}: Der "Event and Task Manager" ist eine in Python3/Tk geschriebene GUI-Anwendung zum Organisieren von Kalender-Einträgen, To-Do-Listen (inklusive Tasks und zugeordnete Jobs) und Wiederholungs-Terminen. Insgesamt gibt es folgende Eintrags-Typen: "Action" zur Erfassung von Tagebuch-Einträgen und dem Notieren von Geld-Ausgaben, "Event" für Kalender-Einträge, "Occasion" mit Datum aber ohne Zeit für Geburtstage und Jahrestage, "Note" für Notizen, "Tasks" für To-Do-Listen-Einträge, "Delegated Task" der jemand anderem zugewiesen wurde, "Task Group" um Tasks zu gruppieren, "In basked" zur Vorerfassung von Einträgen die noch nachbearbeitet werden müssen, "Someday maybe" für derzeit ausgeblendete Einträge die man später einmal reaktivieren kann, "Comment" für Einträge die ignoriert aber in einer der Ansichten doch angezeigt werden, "Defaults" zum virtuellen Ausfüllen von Feldern in einem Wirkungsbereich. Diesen Einträgen kann noch eine Vielzahl von Schlüsseln zugeordnet werden, etwa um Alarme zu definieren, die Dauer des Eintrags festzulegen, Schlüssel*wörter* zu vergeben, Wiederholungsregeln festzulegen, Hyperlinks und Kommentare zuzuordnen und vieles andere mehr. Kann auch Alarme und komplexe Wiederholungen wie Ostern handhaben. Obwohl es verschiedene Kalender-Ansichten gibt, werden diese nicht zur Dateneingabe benutzt, sondern dazu wird eine kürzelreiche relativ frei-formatige Eingabesprache (basiert auf Fuzzy Parsing) verwendet. Diese ist sehr US-lastig, insbesondere was Datumsformate und Namen von Wochentagen und Monaten betrifft. Allerdings kann man alternativ zumindest auch 24h-Zeiten eingeben. Zu jedem Eintrag wird auch die Zeitzone dazu gespeichert, so dass Mischeinträge aus verschiedenen Zeitzonen kein Problem sind. Angezeigt werden alle Zeiten dabei immer in der lokalen Zeitzone, doch leider nur im 12h-Format. Vermutlich könnte dies mit einer deutschen Übersetzungsdatei gelöst werden, doch eine solche gibt es leider nicht (bzw. nur eine leere solche). Etwas seltsam ist dass die GUI-Ansichten des Kalenders keine Navigations-Buttons haben - man muss mit den Cursortasten auf andere Wochen/Monate etc. als das gerade angezeigte Intervall welchseln. Das Programm stellt auch Timer zur Erfassung von Aktivitäten oder für Countdowns zur Verfügung, die auch Einträge generieren können. Man kann Notizen erfassen und diese nach Schlüsselwort und Titel sortiert anzeigen. Man kann auch unklassifizierte Eingaben als Vorerfassung vornehmen die man erst später ansehen und in einem konkreten Eintrags-Typ zuordnen wird. Die Inhalte von Ansichten können als CSV- oder iCalendar-Dateien (.ics) exportiert werden. Aus iCalendar-Dateien können auch Einträge importiert werden. Alle Daten werden in simplen Textdateien abgespeichert, wobei die Einträge in der erwähnten Eingabesprache abgelegt werden. Wie gut das skalieren kann ist unbekannt. Das Encoding der Textdateien kann man auswählen, es scheint per Default von der Locale übernommen zu werden. Sonderzeichen und UNICODE sind daher in UTF-8 Locales kein Problem. etm kann automatisch von Git oder Mercurial Gebrauch machen, um Änderungen an den Kalender-Dateien zu versionieren und eine Änderungs-Historie im GUI anzeigen zu können. Obwohl das Programm per Default als GUI-Anwendung startet, kann man die wichtigsten Operationen auch von der Kommandozeile aus durchführen. Auf den ersten Blick macht das Programm den Eindruck einer sehr mächtigen Lösung, die vor allem bei intensiver Nutzung viel Zeit bei der Dateneingabe sparen mag. Allerdings dürfte wegen der kryptischen Kürzel in der Eingabesprache auch eine längere Lernkurve vonnöten sein wenn man alles beherrschen will (was aber für simple Nutzung nicht nötig ist). Es gibt zudem eine schöne Anleitung als eine einzelne (lange) mitgelieferte HTML-Datei. Optisch sieht die Anwendung als GUI leider Tk-typisch einigermaßen hässlich aus, obgleich es für die Verhältnisse von Tk wiederum halbwegs gut aussieht. Außerdem ist der Tk-Support im Kern der Voll-Installation von Python enthalten, so dass keinerlei Abhängigkeiten dazu kommen.
eureka-1.24-3/utils/debian {game-editor}: Ein Level- und Map-Editor für die klassischen Doom-Games (Doom und Doom 2). Hübsch gemacht, ein normales GUI-Programm mit Menüs, Buttons etc. Das Programm wenn man selbst neue Levels erstellen oder vorhandene "unfair" begutachten möchte.
evilvte-0.4.6/x11-terms/gentoo {terminal emulator}{GUI}{X11}: Mini-Terminalemulator. So minimal dass er keinerlei Konfigurationsdatei unterstützt - alle Optionen werden zur Compile-Time in einer anpassbaren Header-Datei festgelegt. Gentoo unterstützt das Verwenden einer angepassten Header-Datei zu diesem Zweck. EvilVTE unterstützt UTF-8 und basiert auf der VTE-Library. Für minimale X11-Installationen vermutlich sinnvoll; zumindest falls die VTE-Library ohnehin benötigt wird. Nachteile: Zumindest per Default ein blinkender Cursor. Das ist ineffizient für Fernwartungs-Szenarien. Ein scheinbarer Bug ist dass das Festlegen der Farben und Palette im Header-File nur teilweise funktioniert; was ich auch tat - das Shell-Prompt blieb immer schwarz.
evolvotron/x11-misc/gentoo: Plottet eine auswahl fraktaler Grafiken. Klickt man auf eine, kommt ein neuer Bildschirm mit stärker verwandten Grafiken.
exact-image-0.8.1-r1/media-gfx/gentoo {bitmap image editor}{PDF}: Enthält eine Hand voll Kommandozeilen-Tools für bestimmte Bildverarbeitungs-Anwendungen. Die Tools benutzen allgemein die "Anti-Grain-Geometry"-Bibliothek für hochwertiges Anti-Aliasing. "bardecode" erkennt und decodiert einige 2D-Barcodes: EAN, Code 128, Interleaved 2 of 5 und Code 39. "e2mtiff" erzeugt Multipage-TIFF-Dateien aus Einzeldateien. "econvert" wendet einige unterstützte Bildverarbeitungsoperatoren auf ein Eingabebild an und erzeugt ein Ausgabebild. Unterstützt werden dabei einige der Operatoren die man auch von ImageMagick her kennt, doch bei weitem nicht alle. Dafür ist econvert vermutlich schneller, und deutlich kleiner im Installationsumfang, der rund 10 MB mit allen Library-Abhängigkeiten (inklusive libc) beträgt. Konkret unterstützt werden: Scale image with bi-cubic, bi-linear or box filter, with nearest neighbour detection or data dependent triangulation; gaussian blur, convolution matrix, crop, simple deinterlace, edge detect, fast auto crop, flip vertically or horizontally, Floyd Steinberg or Riemersma dithering; change image gamma, hue, lightness, saturation, brightness, colorspace or contrast; draw a line, invert, normalize, override image DPI, rotate (Fließkomma-Winkel), resize, split image in Y-direction into n parts, draw (optionally rotated) text with specified font, fast and dirty thumbnail generation. Codecs für folgende Bildformate sind vorhanden: BMP, DCRAW (nur lesen), EPS (nur schreiben), GIF, JPEG-2000, JPEG, OPENEXR, PCX, PDF (nur schreiben), PNG, PNM, PS (nur schreiben), RAW, SVG (nur lesen), TGA, TIFF (Komprimierungen: Fax Group 3 und 4, LZW, DEFLATE/ZIP, unkomprimiert), XPM. Bestimmte JPEG-Transformationen können verlustlos ausgeführt werden. "edentify" identifiziert ähnlich wie "file" einige unterstützte Bildformate und gibt auch die Parameter (etwa Größe und Auflösung) des untersuchten Bildes aus. "empty-page" erkennt heuristisch ob ein Bild eine leer eingescannte Seite darstellt. "hocr2pdf" erzeugt aus einer XML-Datei gemäß der hOCR-DTD sowie den darin verlinkten externen Bilddateien eine durchsuchbare PDF-Datei. Anmerkung: Die XML-Datei enthält bereits den OCR-erkannten Text. Tools wie gscan2pdf, cuneiform und tesseract können hOCR-Dateien erzeugen. "optimize2bw" wandelt Grauwert oder Farbdateien in S/W-Dateien um, wobei eine Batterie bekannter Filter wie Denoise, Unsharp Mask, Threshold, Rescale zum Einsatz kommt. Die Entfernung von Halbtonrasterung wird jedoch leider nicht unterstützt.
exfat-fuse-1.3.0-1/otherosfs/debian {FUSE}: Ein FUSE-Dateisystem, welches es erlaubt das in älteren Kerneln noch nicht enthaltene EXFAT-Dateisystem dennoch zu mounten. SDXC-Speicherkarten ab 32 GB werden ab Werk immer EXFAT-formatiert ausgeliefert, daher ist dieses Dateisystem praktisch nicht unwichtig. Es ist VFAT zwar sehr ähnlich, unterstützt aber Dateien größer als 4 GiB, was für Videodateien nötig sein kann. Auch wenn neuere Kernels EXFAT-Support bereits enthalten, erlaubt es dieses Paket dennoch zusätzlich dass auch nicht-privilegierte Benutzer EXFAT-Dateisystem-Abbilder mounten können.
exim/mail-mta/gentoo: Not as secure as Postfix, but more powerful and secure enough for most tasks anyway. Although it has a monolithic design which makes it less secure than Postfix by design, it actually has a very good security record. It can deliver mail to local users as well as to the Internet, has a powerful filtering language and is considered by many as a good choice for a preinstalled system default mailer. Like most full-featured MTAs, it is intended to be used as a drop-in replacement for sendmail. exim can be configured to run on demand only via inetd/xinetd, instead of running permanently as a server process.
extremetuxracer-0.7.5-1+b1/games/debian extreme-tuxracer/games-action/gentoo {game}: Ein Pinguin gleitet auf seinem Bauch verschneite Hänge hinab und versucht dabei im Schnee herum liegende Fische einzusammeln. Gutes Testprogramm für OpenGL und Sound! Auch halbwegs (bis auf den Verzehr der Fische) "politisch korrekt" und für Kinder geeignet.
exult-1.2-18/contrib/games/debian {game}: Ein Laufzeitumgebung für Ultima 7. Und zwar für beide Teile - Part 1 "The Black Gate" (das Originalspiel) als auch Part 2 "The Serpent Isle" (ein Follow-up mit komplett unterschiedlicher Landkarte, bzw. spielt es auf einer Insel ohne Verbindung nach Britannia). Benötigt die Original-Daten des kommerziellen Spiels um auch tatsächlich zu etwas nütze zu sein. Funktioniert grundsätzlich sehr nett, auch die Maussteuerung ist gut durchdacht. Es gibt auch optionale Original-Zusatzpakete für digitalisierte Musik (Vorbis OGG Dateien) als auch für digitalisierte Sprachausgabe. Ohne diese Zusatzpakete gibt es nur Text anstatt zusätzlich (für ausgewählte Szenen) Sprache, und die Musik wird mittels MIDI erzeugt. Dabei werden drei Synthesizer-Standards unterstützt welche man sich aussuchen muss: FM-Synthese (ursprüngliche Adlib-Soundkarten, nur eher ärmlich klingender glockenartiger Sound, alles mittels FM-Synthese vom Yamaha 3812-Chip oder ähnlichem erzeugt), GM (General MIDI), GS (erweitertes GM für zusätzliche Effekte) und GS 127 (erweitertes GS welches umfangreichere Soundfonts nutzt). Unter Linux bedeutet dies, dass man entweder ein MIDI-Schnittstelle benötigt an welcher ein echter Synthesizer hängt, oder eine Soundkarte (oder Daughterboard) mit MIDI-Synthesizer-Fähigkeiten. Oder einen MIDI-Software-Synthesizer, wie "fluidsynth" und dazu passende soundfonts. Mit "fluidsynth" klang der Modus "GS" am besten. Die Musik kann sich durchaus hören lassen. Selbst die reine FM-Synthese klingt noch ausreichend nett. Die erwähnten OGG-Dateien sind übrigens nichts anderes als mit aufgezeichnete MIDI-Musik, allerdings von einem optimal dafür abgestimmten MIDI-Gerät erzeugt, so dass alles korrekt ist: Keine falsch zugeordneten Instrumente, keine fehlenden Effekte, optimal abgemischt. (Hinweis: Ich habe mit dem game-data-packager von Debian für beide Parts separate .deb-Archive erstellt, die getrennt die Daten der erforderlichen Spielwelten enthalten. Ebenso habe ich die oben erwähnten Zusatzpakete für digitalisierte Musik als auch für digitalisierte Sprache sowie alle PDF-Anleitungen, Clue-Books und Karten-PDFs beigelegt welche ich nur auftreiben konnte. Kurzum, es ist alles enthalten was das Herz begehrt.) Nur ist die Grafik nach heutigen Maßstäben doch sehr klobig bzw. pixelig. Weiters nimmt sie nur einen kleinen Teil des Bildschirms ein, da die Auflösung der Grafiken statisch ist und für heute veraltete Hardware konzipiert. Zwar gibt es die Möglichkeit die Grafik zu skalieren, jedoch nur um den Faktor 2 was bei einem großen Bildschirm immer noch viel zu klein ist. Besser ist da schon die Vollbildsteuerung - dabei wird das Bild auf den ganzen Bildschirm skaliert so dass nun alles groß genug ist. Die Auflösung der Grafik ändert sich dadurch aber nicht. Immerhin gibt es viele verschiedene Skalierungs-Modi (von denen mir "Super2xSai" am besten gefiel), so dass die Grafik zwar klobig bleibt aber nicht mehr all zu störend pixelig. Weiters nervt die ruckelige Bewegung der gesteuerten Charaktere, die zudem nur wenige Bewegungsphasen besitzen. Wobei es weniger ruckelt als die Bewegung immer nur in Sprüngen von der Größe einer Kachel (vermutlich 8 x 8 Pixel) möglich ist, aus denen die gesamte Spielwelt zusammen gesetzt ist. Bei starker Vergrößerung werden daher auch diese Sprünge bei der Bewegung immer größer, was einem wie Ruckeln vorkommt ohne tatsächlich eines zu sein. Das ist ein unangenehmer Kontrast zu modernen Spielen wo flüssige Bewegungen erwartet werden. Ansonsten ist es ein richtiges Ultima wie es leibt und lebt, und erfordert daher sehr viel Geduld um sich in die elendslangen Anleitungen einzulesen und die ganze Zaubersprüche, Tränke etc. auswendig zu lernen. Oder man muss ständig nachblättern, was auch nicht viel besser ist. Noch dazu muss man sich ständig mit NPCs unterhalten und längliche Texte lesen um Hinweise auf Rätsel zu erhalten die man lösen muss. Kein Spiel für Leute mit begrenzter Zeit oder Geduld. Toll jedoch wenn man von beidem ausreichend hat und dabei keine all zu hohen Ansprüche an die Grafik, obgleich diese vor 25 Jahren noch als hipp galt. Es handelt sich übrigens um eine Pseudo-3D-Grafik, wo man alles exakt von oben sieht und alle aufrecht stehenden Figuren um exakt 45 Grad geneigt sind. In Zeiten wo man wirklichkeitsgetreue 3D-Grafik gewöhnt ist, doch ein gewisser Rückschritt. Immerhin ist es liebevoll ausgestaltete Pixelgrafik und keine Symbolgrafik wie damals vor Ultima 6. Als Bonus enthält die exult Spiele-Engine eine Option, eine pixelgetreue Karte der gesamten Spielwelt abzuspeichern. Man kann dabei sogar zwischen 3 Modi wählen in wie weit Häuser "aufdeckt" sein sollen oder man das Dach sehen möchte. Die Karte der gesamten Spielwelt wird dabei in Form von 12 x 12 Kacheln aus je 2048 x 2048 Pixeln als .pcx-Dateien abgespeichert. Um diese Einzelbilder als Gesamtkarte darzustellen braucht man einen geeigneten Tile-Viewer, der nicht Bestandteil von exult ist.
exult-studio-1.2-18/contrib/games/debian {game}{game-editor}: Ein GTK+ basierter Editor für Ultima 7. Ich fand allerdings nicht heraus wie man die Weltkarte damit editieren oder ansehen kann. Zwar wurden alle Spielwelt-Kacheln angezeigt aus denen sie besteht, aber im Editor in völlig falscher Reihenfolge angeordnet. Überhaupt ist die Bedienung des Programms ein großes Mysterium - man muss wohl im Internet nähere Infos suchen wie das ganze zu benutzen gedacht ist. Grundsätzlich besteht die Welt aus 12 x 122 Welt-Kacheln, von denen jede wiederum aus kleineren Mini-Kacheln zusammen gesetzt zu sein scheint. Die Welt selbst besteht aus - zumindest - 3 Höhenebenen. Dadurch werden Häuser "aufgeklappt" wenn man um Spiel hinein geht, bzw. nicht wenn man auf eine Leiter steht. Diese Höhenebenen sind aber offenbar nichts weiter als überlagernde Welt-Kacheln. Die Mini-Kacheln haben alle eine identische Größe (ich vermute 8 x 8 Pixel) und können im Editor scheinbar irgendwie bearbeitet werden, indem er dazu ein externes Malprogramm aufruft. Allerdings schaffte ich auch das nicht zum Funktionieren zu bringen. Interagierende Gegenstände und NPCs werden als "Shapes" dargestellt. Shapes und Weltkacheln können animiert sein, indem verschiedene Bewegungsphasen als Verbund von Kacheln kombiniert werden. Den Shapes kann man dabei auch jede Menge Eigenschaften (Check-Boxen) und Attribute (Zahleneingabefelder) im Editor zuordnen und. Alles ein wenig mysteriös in der Bedienung, aber grundsätzlich dürfte man mit wohl alles editieren oder sogar ein eigenes Spiel erstellen können - vermutlich aber nur wenn man dafür eiserne Nerven hat.
ezquake-2.2+git20150324-1/games/debian {game}: Ein QuakeWorld client. Benötigt die Original-Dateien von Quake. Es scheint sich dabei um eine reine Online-Gaming Angelegenheit zu handeln - als ich es offline startete, tat es nichts. Auf jeden Fall ist dieses Paket nicht erforderlich (und möglicherweise gänzlich nutzlos) wenn man Quake nur offline als Single-Player Mission spielen möchte.
fake-hwclock 0.3-1/alarm/archlinux: Very primitive service which saves the current system time on shutdown and restores it on startup. It includes an optional timer service which saves the system time every 15 minutes, which might be helpful if the system crashes unexpectedly.
fakechroot-2.19-3.2/utils/debian {installation}: Arbeitet ähnlich wie "chroot", jedoch nur scheinbar und kann daher auch von unprivilegierten Benutzern aufgerufen werden. Tatsächlich bleibt alles wie es ist, doch das aufgerufene Programm "lebt" in der Illusion ein anderes Verzeichnis wäre das Wurzeldateisystem. "fakechroot" ändert allerdings nicht die vom Programm wahrgenommenen Besitzer der Dateien. Dazu kann man "fakeroot" verwenden, siehe dort für Näheres. (Die dort erwähnten Grenzen der Illusion für das aufgerufene Kommando treffen ebenso für "fakechroot" zu.)
fakeroot-1.23-1/utils/debian {installation}: Ein Utility welches ähnlich wie "sudo" und "su -c" ein anderes Kommando als einem anderen Benutzer ausführt, in diesem Fall immer als "root". Allerdings führt "fakeroot" das Kommando nicht wirklich, sondern nur scheinbar als "root" aus. Es scheint dem ausgeführten Kommando so als würden alle Dateien welche tatsächlich dem unprivilegierten Benutzer gehören welcher "fakeroot" aufgerufen hat scheinbar "root" gehören. Das gilt auch für alle Dateien welche das Kommando selbst anlegt - tatsächlich gehören diese aber dem unprivilegierten Benutzer der das Kommando via "fakeroot" aufrief. "fakeroot" ist unter Debian sehr nützlich um als völlig unprivilegierter Benutzer Binärpakete bauen zu können, ohne dass die erzeugten Pakete falsche Berechtigungen enthalten. Was "fakeroot" aber nicht ändert, sind die von aufgerufenen Programm wahrgenommenen absoluten Verzeichnispfade. Siehe "fakechroot" um auch dieses Problem bei Bedard zu beheben. "fakeroot" arbeitet mittels dem DL_PRELOAD-mechanismus, und funktioniert daher nur für solche Aufgerufenen Kommandos welch den dynamischen Linker verwenden und nicht gegen solche Manipulationen abgesichert sind. Daher lassen sich weder statisch gelinkte noch SUID-Executables auf diese Weise täuschen.
falkon-3.1.0+dfsg1-11/web/debian {www-browser}{GUI}{X11}: Kann JavaScript, Bookmarks, Passwortverwaltung und sogar Flash. Verwendet Plugins von denen zahlreiche bereits vorinstalliert sind. Etwa einen Adblocker oder eines zum Ausfüllen von Formularen anhand einiger fix definierter Felder (Name, Adresse usw). Zumindest ein Teil der Plugins scheint in Python verfasst zu sein, was üble Ahnungen bezüglich des Overheads aufkommen lässt. Einen Scriptblocker gibt es zumindest als Python-Plugin. Einen Grafikblocker fand ich überhaupt nicht. Als Installation ist der Falkon klein und schlank. Der RAM-Bedarf zur Laufzeit ist aber ähnlich wie beim Firefox, tatsächlich sogar größer. Schlank ist jedenfalls anders. Der so ziemlich einzige Vorteil gegenüber den Firefox scheint mir zu sein dass man einfach eigene Suchmaschinen-Einträge hinzufügen kann.
fbautostart-2.718281828-1/misc/debian: Der Fluxbox-Fenstermanager beherrscht von sich aus kein XDG-konformes Autostarten von registrierten Applikationen. Dieses Paket liefert ein Tool mit, welches zu diesem Zweck in der Startup-Datei von Fluxbox aufgerufen werden kann um diese Funktionalität nachzurüsten.
fbida-2.08/media-gfx/gentoo {graphics image viewer}: Ein Bildbetrachter ("ida") primär für die Framebuffer-Konsole. Funktioniert zwar auch unter X11, aber da gibt es hübschere ("originaler X11-Look") Bildbetrachter. "Reines X11" ohne irgendwelchen großen Toolkits (nur motif), sprich keine Abhängigkeiten von großen Bibliotheken. Neben der eigentlichen Bildanzeige der Bilder in einem Verzeichnis beherrscht es (zumindest unter X11) auch noch ein paar (nicht permanente) Editier-Funktionen wie Gammakorrektur, Weichzeichner, Kantenerkennung, Rotation usw. Nervig ist dass es beim Bildwechsel ständig die Fenstergröße ans Bild anpasst. Einen Vollbildmodus gibt es auch nicht - zumindest nicht im Menü. Die einzige wirkliche Existenzberechtigung dieses Pakets ist es, dass es eine modifizierte Version des "exiftran"-Tools mit installiert, welche vom "geeqie"-Bildbetrachter benötigt wird wenn man dessen "eingebaute" Features zur verlustlosen JPEG-Rotation verwenden will. Dazu reicht es aber auch das Paket ohne "X" USE-flag zu bauen, womit man den minderwertigen Bildbetrachter genau so los wird wie seine Abhängigkeit vom motif-Toolkit.
fbpanel-7.0-3/x11/debian {desktop panel}: Ein Plugin-basiertes Desktop-Panel das alle Stückerln spielt: Eigenes Startmenü mit Icons (unabhängig vom WM; wird beim Neustart automatisch aktualisiert, verwendet freedesktop.org Standards, man kann auch eigene Einträge hinzu fügen; sieht am zweitbesten der Startmenüs aller separat installierbaren Panels aus - nach xfce4-panel), Applikations-Launch-Buttons (Tool-Tips und Icon möglich), Taskbar mit Kontexmenü, Workspace-Pager, Anzeigen für Memory, CPU und Netzwerkauslastung, Traybar und Uhr (anpassbares Datums/Zeitformat; kann außerdem sogar einen navigierbaren Kalender einblenden). Weitere enthaltene Plugins für Lautstärke und Batterie-Ladestand. Auch die Anzeige der Ausgabe eigener Kommandos ist möglich. Anordnung an allen Bildschirmrändern möglich; der Anteil an der Länge des Randes ist einstellbar (Pixel, Prozent oder nach Platzbedarf des Inhalts). Automatisches Ausblenden ist möglich. Mehrere Instanzen des Panels können gleichzeitig laufen, wenn verschiedenen Konfigurationsdateien dafür benutzt werden. Erstaunlich: Trotz der einfachen Text-Konfigurationsdatei ist ein grafisches Konfigurationstool eingebaut dass über die Kommandozeile aufgerufen werden kann. Aber leider funktioniert davon nur ein kleiner Teil (die allgemeinen Settings; die Plugins lassen sich offenbar noch nicht bearbeiten obwohl es Buttons dafür gibt). Nachteil: Es ist eine GTK+ Applikation, und daher von den fetten GTK+ Libararies abhängig. Arbeitet gut mit Openbox, Fluxbox und deren dynamisch hinzufügbaren und entfernbaren Workspaces zusammen. Leider beherrscht die Taskbar-Komponente nicht das Gruppieren von Fenstern sondern zeigt jedes Fenster einzeln an. Das ist vor allem im Zusammenspiel mit Fluxbox ärgerlich, wo man "getabbte" Fenster auch gerne als einzelnen Taskbar-Eintrag sehen würde. Deshalb empfiehlt sich hier ein Mischbetrieb wo Fluxbox den Taskbar stellt und fbpanel einen zusätzlichen Launchbar. So klein der Installationsumfang (500 kB sowie 190 kB an Download; nur ein einziges Paket ohne weitere applikations-spezifische Abhängigkeiten) auch ist und so fein dieses Panel allgemein funktioniert - ressourcenschonend ist es nicht: Mit 55 MB RAM übertrifft es den Ressourcenverbrauch des xfce4-panels bei weitem, obwohl dieses noch hübscher, komfortabler und leistungsfähiger ist. Einzig Plugins bringt fbpanel mehr an eingebauten mit.
fbreader-0.12.10/app-text/gentoo: e-Book Reader für UNIX, Windows und diverse PDAs/Smartphones. Verwendet unter Linux wahlweise GTK+ oder Qt4. In C++ geschrieben. Es gibt sogar irgend einen Linux-basierten eBook-Reader, auf dem fbreader die Primär-Applikation zum e-Book-Anzeigen darstellt. Das dankt fbreader sicher auch seiner hohen Portabilität und seinem akzeptablen Installationsumfang (6 MiB in der GTK+ Version, 7 MiB in der Qt4-Version). Unterstützte Formate: epub, fb2, plucker, Mobipocket (ohne DRM), Palmdoc (Aportis Doc), trc (Psion Text), Plaintext. Limitierte Unterstützung von html, rtf, Open E-Book (oeb), OpenReader und Microsoft chm. Kann diese Formate auch direkt aus tar-, zip-, gzip- und bzip2-Archiven heraus lesen. (Leider gilt dies nicht für die Android-Version von fbreader welche neben eBook-Formaten nur unkomprimierte Textdateien lesen kann.) Insbesondere kann er auch index.html-Dateien welche sich zusammen mit relativ davon referenzierten Dateien in einer .tar.bz2-Datei befinden anzeigen - Calibre beherrscht dies nicht (nur zip-gepackte Dateien). Da .tar.bz2-Dateien aber als eine Einheit komprimiert werden, kann das .tar.bz2-Format besser komprimiert werden. Allerdings muss es komplett im Speicher entpackt werden, so dass für extrem umfangreiche Dokumente .zip doch wieder das bessere Format ist. Allerdings beherrscht FBReader nicht das Extrahieren von Metadaten-Informationen aus gegebenfalls vorhandenen .opf-Dateien aus solchen Archiven (allerdings sind diese Metadaten-Dateien auch nur im EPUB-Standard spezifiziert). Das ist problematisch weil in den Metadaten auch das Text-Encoding des Dateinamens festgehalten ist, der dann oft im falschen Encoding als Titel angzeigt wird. Weder FBReader noch Calibre unterstützen Dateien welche vom "zip"-Tool mit bzip2-Kompression erzeugt wurden. FBReader beherrscht Textsuche. Vollbildmodus. Bibliothek welche Liste der installierten Bücher anzeigt. Die Bibliothek enthält nur Verweise auf die Bücher und erstellt keine Kopien der Originale; man muss daher selbst dafür sorgen dass die Originale vorhanden bleiben. Hat keine normalen Menüstrukturen, sondern ist ganz auf Icon-Bedienung auf einem PDA ausgelegt. Dies macht es etwas ungewohnt in der Bedienung am PC, stellt aber kein ernsthaftes Komfort-Defizit dar. Die Anzeige kann in 90 Grad-Schritten rotiert werden. Beliebig viele Schlagwörter können jedem Buch zugeordnet werden, die Schlagwörter können dabei in beliebig tiefen Hierarchien organisiert werden. Das Paket hat nur vergleichsweise wenige Abhängigkeiten, ca. 0,5 MB kommen noch für dev-libs/fribidi und dev-libs/liblinebreak hinzu um UNICODE-konform arbeiten zu können. Es macht eher wenig wenig Sinn FBRreader und Calibre zugleich zu installieren - Calibre kann (bis auf die Unterstütung einiger zusätzlicher exotischer Formate) um nichts weniger als fbreader, nur ist es wesentlich fetter. Andererseits startet fbreader wesentlich schneller was ihn als Default-Verknüpfung für das Dateiformat-Anzeigeprogramm der unterstützten Dateitypen komfortabler macht. FBReader ist aufgrund des geringenen Funktionsumfangs auch deutlich einfacher zu bedienen und zu erlernen als Calibre. Da es kaum etwas zu konfigurieren gibt hält ist auch der Konfigurationsaufwand deutlich geringer als bei Calibre. Ein Nachteil von FBReader ist, dass jedes betrachtete eBook automatisch in die FBreader-Bibliothek aufgenommen wird. Da dabei automatisch etwaig bereits vorhandene Metadaten übernommen werden, besteht so die Gefahr die manuell gepflegte Bibliothek durch temporäre Dateien zu "verschmutzen", die gar nicht langfristig zur Verfügung stehen. Der Calbre eBook-Viewer kann im Gegensatz dazu sehr wohl eine einzelne Datei unabhängig von der eigentlichen Calibre-Library öffnen. Außerdem hat FBReader die Unsitte, ohne Fehlermeldung eine andere Datei anzuzeigen als die welche man ihm in der Kommandozeile angegeben hat, falls er das Format letzterer nicht beherrscht. In diesem Fall zeigt er entweder eine Datei gleichen Basisnamens aber anderer Datei-Erweiterung an falls er deren Format besser beherrscht, oder er ignoriert die angegebene Datei überhaupt und zeigt statt dessen die zuletzt benutzte Datei aus der Library an.
fdupes-1:2.2.1-1/utils/raspbian {deduplication}: Kann Duplikate von Dateien in Verzeichnisbäumen anhand ihres Inhalts erkennen und anzeigen, so wie optional auch löschen (natürlich wird jeweils eines der Exemplare dabei übrig gelassen). Es ist effizient und sicher: Zunächst wird nur aufgrund der Dateigröße verglichen, dabei gleiche per MD5-Hash, und dabei immer noch gleiche durch Vergleich Byte für Byte. Also keine Gefahr für Hash Collisions. Nachteil ist dass dieses Programm keine Option hat, Dateien durch Hardlinks oder Symlinks zu ersetzen. Dateiattribute wie Owner oder Permissions werden beim Suchen von Duplikaten ebenfalls ignoriert.
featherpad-1.6.1-1/editors/raspbian {text-editor}{Qt}: Ein vergleichweise leichtgewichtiger Texteditor, basierend auf Qt. Es ist ähnlich wie L3afpad und besitzt alle dessen Funktionen, allerdings ohne dessen nervigen Bugs bei der Display-Aktualisierung. Es hat einige zusätzliche Funktionen gegenüber L3afpad, wie RegEx Search/Replace, Syntax-Highlighting, Auto-Indentation, mehrere Encodings (UTF-8, UTF-16, LATIN1), Tabs (can be detached into individual separate windows), Spell Checking (via hunspell), optional vertical bar after specied column (e.g. column 80), optional trailing space removal, optional show whitepaces, optionally ensure last line has a newline, user-redefinable keyboard shortcuts, insert date/time (with customizable format), Auto-Bracket (inserts and highlights matching bracket- and quote characters), Conversions (upper case, lower case, titlecase), sort (ascending or descending) contents of selected line range. Diesen Vorteilen stehen ein paar Nachteile gegenüber: Um ca. 63 % erhöhter RAM-Verbrauch für denselben bearbeiteten Text, etwas längere Startdauer, hässlichere Icons ("Material Design"). Wegen der immensen Vorteile, insbesondere Tab-Support, empfehle ich diesen Editor für Rechner mit genug RAM (1 GiB sollte reichen).
feh-2.5/media-gfx/gentoo {graphics image viewer}: Ein minimalistischer Bildbetrachter ohne Toolbars (nur ein Kontextmenü hat er), der nur auf X11 aufbaut und weder ein GTK noch Qt oder sonst ein Toolkit als Abhängigkeit hat. Das Programm ist ganz auf Tastatur- und Commandline-Bedienung ausgerichtet und nur knapp über 0,5 MiB groß. Es startet auch wirklich sofort und ohne merkliche Verzögerung. Trotzdem hängt es erstaunlicher Weise von nicht weniger als 40 DLLs ab, aber offenkundig keine fetten. Eine Spezialität des Programmes ist dass es optional mit curl-Support gebaut werden kann, womit man dann auch Bilder aus http/ftp-URLs heraus "direkt" anzeigen kann. Eigene Tastenkürzel können umfangreich definiert werden ("natürlich" per Konfigurationsdatei und nicht etwa per Dialog), ebenso kann man eigene Scripte aufrufen (etwa um Bildbearbeitungsfunktionen extern zu realsieren). Grundsätzlich hat das Programm 3 Anzeige-Modi: Einzelnes Bild, Thumbnail-Ansicht, Dia-Show oder mehrere Bilder auf einmal anzeigen. Es hat einige zuschaltbare Overlay-Informationen wie Dateiname, EXIF-Daten usw. Verlustfreie Rotation wird unterstützt wenn die libjptran verfügbar ist. Die einzige Hilfe neben dem bescheidenen Kontextmenü: Die "man"-page. Ein typisches "UNIX-Programm": Kann viel, aber man muss stundenlang die Anleitung studieren. Daher wohl nur für Spezialanwendungen sinnvoll, wie aus Scripten heraus Bilder anzeigen. Ich habe diesen Bedarf nicht, weil dazu gibt es noch simplere Image-Viewer wie xv. Irgendwie ist feh zu mächtig um noch simpel genannt zu werden, aber gleichzeitig zu unkomfortabel nach modernen Maßstäben um noch zeitgemäß genannt werden zu können.
fetchmail-6.3.21/net-mail/gentoo: Lädt e-Mails von POP3 oder IMAP-Servern herunter und leitet sie an einen lokalen Mail-Transfer-Agent (wie sendmail) zur Zustellung weiter, welches die Mails dann ins Postfach zustellt. Fetchmail kann die Mails aber statt dessen auch an procmail oder maildrop übergeben; das erstpart die Installation eines vollwertigen MTAs wenn die Mails einfach nur an die lokale Mailbox des Benutzers zugestellt werden sollen. Fetchmail unterstützt alle möglichen Server-Protokolle und auch SSL/TLS-verschlüsselten Serverzugriff. Es kann einen oder mehrere Accounts abrufen, neue Mails nach dem Lesen von dort löschen oder auf den Servern belassen. Weiters kann es auch als Daemon gestartet werden, um die Accounts in regelmäßigen Intervallen abzufragen. Vordergründig scheint es problematisch zu sein dass man die Passwörter für die diversen Accounts unverschlüsselt im Konfigurationsfile des Programms ablegen muss. Aber letztendlich wäre jede Verschlüsselung wirkungslos, da das Programm ja irgendwo auf die Klartextpasswörter zugreifen können muss. Man muss daher in diesem Fall auf die UNIX-Zugriffsrechte vertrauen.
ffmpeg-2.2.14/media-video/gentoo: Tools und Libraries für Wiedergabe, Aufnahme und Konvertierung von Audio-/Video. Konkurrent von media-video/libav. Siehe Eintrag zu letzterem für die Unterschiede zwischen beiden Paketen.
fhist-1.18-2/devel/devuan {version control}{text-diff}{text-merge}: Ein sehr minimalistisches Versionskontrollsystem (fhist), das auch einen Ersatz für diff (fcomp) und patch (fmerge) mitbringt. Relativ schlank: 237 kB Download, 490 kB installiert, hängt nur von der libc ab. Leider hat es üble Einschränkungen, so kann es etwa keine Unterverzeichnisse verwalten (jedes Repository speichert nur verschiedene Dateien aus demselben Quellverzeichnis), und ein Quelldateiname darf maximal 12 Zeichen lang sein... im Grunde ist fhist nur ein besserer Wrapper um die Tools fcomp und fmerge, welche Deltas zwischen Dateien erzeugen und anwenden können. fhist kennt aber weder Branches noch Tags; es speichert einfach nur alle Revisionen einer Datei und einen optionalen Kommentar pro Revision. So gesehen bieten CVS und sogar RCS mehr Features. Jedoch ein wesentlicher Unterschied, dass fcomp und fmerge ihre Deltas in binärer Form speichern. Darüber hinaus verwenden sie auch noch einen besonderen minimal-Difference-Algorithmus, der zwar deutlich langsamer als ein "diff" ist, jedoch wesentlich kleinere Deltas erzeugt. Ein Nebeneffekt ist dabei, dass fcomp und fmerge in gewissem Umfang auch mit binären Dateien arbeiten können, wo jedes Byte dann als "Zeile" interpretiert wird. Leider mit einer ärgerlichen Einschränkung: Die Dateien dürfen keine binären Null-Bytes enthalten. Zwar ist dies grundsätzlich auch erlaubt, doch die Null-Bytes werden dabei verstümmelt. Konkret wird jedes 0x00-Byte in ein 0x80-Byte umgewandelt. (Sollte im Original kein 0x80 vorkommen, lässt sich diese Verstümmelung daher wieder rückgängig machen.) Sinnvoll dürfte vor allem das fcomp-Tool sein wenn man es statt "diff" für größere Text-Diffs benutzt, wo ein möglichst kleines Ergebnis-Diff gewünscht wird, das immer noch in textueller Form präsentiert werden soll. fcomp verwendet ein vollkommen eigenes Textformat zur Anzeige der Unterschiede. Das Default-Format ist eine Abart von konventionellen "Context"-Diffs, und zeigt die Unterschiede als Textblöcke mit einer Überschrift wie "INSERT", DELETE" oder "REPLACE" ... "WITH" an. Alternativ kennt es ein 2. Format, das einem Unified-Diff recht ähnlich sieht. Außerdem gibt es noch ein 3. Format, das wie das erste ist, nur dass ausschließlich übereinstimmende Zeilenblöcke (mit "MATCH" betitelt) ausgegeben werden. Man hat auch gut Kontrolle darüber, wie viele Kontext-Zeilen angezeigt werden sollen, oder ob zu kurze unveränderte Zeilenblocks mit den benachbarten geänderten zu einem einzigen geänderten Block zusammengefasst werden sollen. Es gibt eine Option um mehrere Leerzeichen als eines anzusehen (und solche am Zeilenende komlett zu ignorieren). Ebenso lassen sich Unterschiede in Groß-/Kleinschrift ignorieren. Oder leere Zeilen. Beide Formate sehen eigentlich übersichtlicher und leichter verständlich aus als das was "diff" ausgibt. Aber es sind eben Non-Standard-Formate die kein anderes Tool unterstützt. Weiters kann fcomp eine "Edit-List" ausgeben, welche mit simplen ein-buchstaben-Kommando pro Zeile eine Datei in die andere tranformieren kann. Problem: Nur wenn beide Dateien bereits vorhanden sind... fcomp kann wahlweise im Textmodus oder Binärmodus betrieben werden. Anders als bei diff und patch arbeiten fcomp und fmerge nicht zusammen. fcomp ist nur ein Ersatz für diff, während fmerge ein eigenständiges 3-way Merge-Tool ist. Es erwartet sich ein gemeinsames Basis-File sowie 2 geänderte Files als Eingabe, und kombiniert dann in seiner Ausgabe die Änderungen beider Dateien gegenüber der Basis. Etwas anderes kann es nicht tun. Konflikte werden durch Marker in der Ausgabe gekennzeichnet, aber nicht für Lösch-Konflikte. Diese muss man sich separat mit einer eigenen Option anzeigen lassen welche die Löschungen und deren Zeilennummern anzeigt, und diese dann manuell wieder in die gemergedte Datei zurück kopieren wenn sie nicht gelöscht werden hätten sollen. Was fmerge nicht direkt kann, ist einfach ein Delta zu erstellen oder Anwenden. fhist bietet Keyword-Expansion, und zwar für die Versionsnummer, Datum, Benutzername und Dateinname. Allerdings wird dies nur beim Extrahieren getan, und auch dann nur wenn man eine spezielle Option angibt. Ähnlich wie bei RCS und CVS werden die expandierten Keywords aber nicht vor dem Einchecken entfernt, sondern - wenn vorhanden - mitgespeichert. Sie werden lediglich beim Extrahieren ersetzt, wenn man die Option nutzt. Größter Nachteil des Pakets: Entweder gibt es einen üblen Bug oder die Rechenzeit steigt bei Binär-Diffs ins Unendliche, denn ich schaffte es bei einem harmlosen File von keinen 2 kB Größe nicht, ein binäres Diff zu erhalten obwohl das Text-Diff sofort da war. Statt dessen rechnete fcomp und hörte einfach nicht damit auf. Ein anderes Problem von geringerer Tragweite ist, dass zwar nicht das Paket selbst, aber eine zum Bauen des Pakets benötigte Library mindestens ein Linux Kernel 2.6.35 benötigt - und dies nur wegen der Textumwandlung irgendwelcher bescheuerter "errno"-Fehlermeldungen. Daraus folgt aber vor allem, dass das Paket nicht sehr portabel sein dürfte. Etwas eigenwillig ist auch dass alle Optionen lange Namen haben, teils Underscores verwenden, und nur mit einem Dash eingeleitet werden. Allerdings akzeptieren die Programme es auch wenn man 2 Dashes macht, und überdies kann man die meisten Optionen abkürzen bis hinunter zu einem Buchstaben, Underscores werden ignoriert, und zwischen Groß-/Kleinschreibung wird auch nicht unterschieden. Somit kann man ohnehin wie gewohnt arbeiten, nur in der man-Page wundert man sich zunächst einmal was das für seltsame Optionen sind.
fifteenapplet/kde-base/gentoo {game}: That boring old 15-piece "arrange the numbered tiles in ascending numeric order"-kindof puzzle. Nothing to complain about the actual implementation into the desktop toolbar - but the game still sucks. Also it's screen area is ridiculously tiny due to the fact that it is integrated into the KDE toolbar. Get rid of it, there are better casual games around for KDE.
figlet-2.2.5-2/text/raspbian: Erzeugt "banner"-Texte aus ASCII-Zeichen die für die Ausgabe am Monitor (anstatt für den Drucker) geeignet sind. Die dargestellten Zeichen sind dabei Outlines, d. h. mit ASCII-Linien umrandete Hohlräume. Unterstützt auch Umlaute, wenn diese als LATIN1 umgewandelt wurden. Die erzeugten Texte eignen sich gut für /etc/issue oder /etc/motd sowie (verschwenderische) e-Mail-Signaturen. Die Texte können auch mehrzeilig sein; das Programm bricht dann automatisch gemäß der konfigurierten Zeilenbreite um. Banner-Text kann linksbündig, rechtsbündig oder zentriert ausgegeben werden. Zusätzlicher Banner-Fonts können installiert werden.
fish-2.1.1/app-shells/gentoo: Eine nette "exotische" Shell. Zum Verfassen von Scripten kann man sie wegen ihrer Non-Standard Syntax vergessen, aber für die interaktive Nutung ist sie interessant. Zunächst einmal kennt sie nicht nur Tab-Completion, sondern macht auch Vorschläge während des Tippens wie man sie vom Smartphone her kennt. Diese kann man aber getrost ignorieren wenn sie unpassend sind; wozu man nichts spezielles tun muss. Variablen werden immer innerhalb desselben Wortes expandiert, man braucht also nie Hochkommas um eine Variable schreiben die als ein Argument verwendet wird. Allerdings können Variablen auch Arrays speichern, die dann als mehrere Argumente eingesetzt werden. Nur in diesem Fall muss man Hochkommas schreiben um dies zu Unterdrücken. Die Shell bringt eine komfortablere Hilfe mit, die optional auch den Webbrowser startet. Sowie viele man-Pages für die einzelnen Funktionen. Dadurch ist die Shell noch fetter als die Bash, allerdings nur was den Installationsumfang angeht. Die eigentliche Shell ist - angeblich - schlanker und speichereffizienter. Ein interessantes Feature ist dass sie niemals eine Subshell verwendet, auch bei der Verwendung von Pipes nicht. Daher kann ein Fish-Script das Ergebnis einer Pipe in Variablen speichern, auf welche die äußere Ebene vor der Pipe Zugriff hat. Interessant sind auch (optional verwendbare) "Universale Variablen", die allen laufenden Shell-Instanzen (desselben Nutzers) automatisch und sofort zur Verfügung stehen. Ebenso kann man Shell-Funktionen "autoloaden" lassen, bei denen dann Änderungen in der Datei ebenfalls sofort allen laufenden Shell-Instanzen zugute kommen. Mehrfache Dereferenzierung mit $ ist möglich. Es gibt "**" als pfadübergreifendes Joker-Symbol. Viele Sonderzeichen der Bash fallen weg und werden statt dessen als ausgeschriebenes Befehlswort in Form einer Kommando-Substitution verendet. Die grundlegenden Expansions gibt es aber größtenteils unverändert, ebenso Redirection, Pipes und Job Control. Nett ist auch die Multiline-Edit-Funktion, wo man bei mehrzeiligen Ausdrücken ählich wie in einem Editor nicht nur vor- und zurück, sondern auch hoch und runter fahren kann. Einrückung im Fall von Kontrollstrukturen wird dabei automatisch vorgenommen. Außerdem ist die Shell farbenfroh und syntax-highlightet die Eingaben automatisch entsprechend der Fish-Syntax. Weiters ist ein eingebauter Debugger für Scripte vorhanden. Bei der Anzeige des aktuellen Verzeichnisses im Prompt sowie bei überlangen Tab-Completions kürzt Fish auch den Pfad, entweder durch Auslassungszeichen oder indem es nur den ersten Buchstaben von weiter vorn liegender Pfadkomponenten anzeigt. Das einzig gewöhnungsbedürftige an Fish ist dass es beim Expandieren von Jokern Groß- und Kleinbuchstaben immer direkt hinter einander sortiert; vermutlich liegt das aber an der Locale. Die Shell verfügt über viele eingebaute Befehle, die üblicherweise eleganter zu benutzen sind als in "normalen" Shells. Als interaktive Shell ist Fish durchaus interessant, eventuell die Bash abzulösen.
fish-3.6.0-2+rpi1/shells/raspbian: Diese Version stürzt bereits beim Start mit einem Segfault ab.
flam3 3.0.1-4/community/archlinux: Ein Programm zum Erzeugen von Flammen als Einzelbilder oder Animationen. Leider kann es nicht in Echtzeit Flammen anzeigen, sondern muss diese erst berechnen und als Bilddateien oder Videos rendern. Noch dazu stellt es genau genommen eine Programmiersprache für fraktale Grafiken, wie auch Flammen welche sind dar, wo Parameter-Sets als XML-Dateien aufbereitet werden müssen - hört sich fürchterlich umständlich an. Also leider kein Bildschirmschoner dem man einfach nur beim Züngeln der Flammen beobachten kann, sondern ein "ernsthaftes" Programm zur Animation von Flammen mit entsprechendem Einarbeitsungsaufwand. Mit knapp 2 MB Installationsumfang ist es zudem auch relativ umfangreich für ein Programm, welches eigentlich nur eine einzige Funktion beherrscht.
flightgear-0.9.9/games-simulation/gentoo {game}: Netter Flugsimulator. Funktioniert aber nicht mit bestimmten OpenAL-Versionen.
flowblade-2.6-3/video/debian {video-editor}: Flowblade ist ein leichtgewichtiger aber mächtiger nicht-linearer Video-Editor. Flowblade ist 2022 auf Platz 3 der beliebtesten nichtlinearen Video-Editoren (auf slant.co). 2022 ist der RAM-Bedarf direkt nach dem Start 200 MB RAM. Ich fand das Arbeiten umständlich. Erstens einmal stören einen die vielen Audio- und Videospuren die man nicht abschalten kann wenn man nur jeweils eine davon braucht, was bei simplen Projekten häufig der Fall ist. Weiters ist das frame-exakte Herauskopieren von Abschnitten eines längeren Clips und Zusammenfügen solcher Extrakte in der Timeline mühselig. Wenn man die Länge der Extrakte nachträglich ändert, entstehen Lücken oder Überlappungen in der Timeline die ich nicht einfach zu korrigieren vermochte. Es geht, ist jedoch arbeitsintensiv. Vorteile des Programms sind 2022: Relativ leichgewichtig, deutlich stabiler als openshot und pitivi. Nachteile 2022: Keine fortgeschrittenen Effekte wie Bildstabilisierung oder komplexe Übergänge. Das GUI benötigt eine relativ hohe Display-Auflösung; nicht für kleine Displays geeignet. GPU-Rendering ist nicht sehr stabil und funktioniert nur mit bestimmten Hardware/Treiber-Kombinationen absturzfrei.
fltk-1.1.7-r2/x11-libs/gentoo: Lightweight GUI Toolkit with optional OpenGL support. X11 and Windows. Fully C++ based. Features a graphical GUI Designer called FLUID which edits UI descriptions saved as *.fl text files and can generate C++ source files from this. Short snippets for event-handling code can be directly embedded via FLUID; external callback functions from other source files can be specified for longer event-handling code. Can be statically linked; libraries try to minimize link dependencies. Weak abstraction - you have to deal with pixel coordinates all the time. On the other hand, if the GUI-designer is used for creating the UI elements, it will handle the coordinates. Uses static variables to keep track of several state variables. Only supports the GUI-aspects of an application, and not also something like printing, network or database access. FLTK does not use event tables or message maps; events must be handled like in the "good old Win16" ;-) times, i. e. there is a single event handler function for a widget which is usually a large "case" statement. There are no layout managers as such; however windows contents can selectively be resized proportionally.
fluidsynth-1.1.6-r1/media-sound/gentoo {audio}{music}: Ein Software-MIDI-Synthesizer, der als Backend für die Ausgabe von MIDI-Noten dient. Dies geschieht (glaube ich) transparent durch das Sequencer-Interface von ALSA, so dass kein implementations-spezifischer Support seitens der Applikation notwendig ist, welche die MIDI-Musik abspielen lassen will. FluidSynth unterstützt bzw. basiert auf Sound-Fonts in Standard-Formaten von denen viele (auch freie) verfügbar sind. Leider ist kein einziger Sound Font über Portage erhältlich; wohl aus Lizenzgründen. Man muss daher Sound-Fonts manuell herunterladen und lokal installieren. Ein Vorteil von FluidSynth ist dass es eine zugehörige Qt-Applikation namens QSynth gibt, mit welcher man viele der Konfigurations-Optionen in einem GUI Einstellen kann. Allerdings kann man sowihl FluidSynth als aoch Timidity durch ein virtuelles MIDI-Keyboard einer Dritt-App ansteuern, so dass qsynth keinen überwältigenden Vorteil gegenüber Timidity schafft. Es scheint mir allerdings, dass FluidSynth von der Benutzerbasis her beliebter ist, und auch bessere/mehr Effektfilter bieten soll. Grundsätzlich tun aber beide Programme ihren Job, und auch die Qualität ist vergleichbar gut.
fluxbox-1.3.2/x11-wm/gentoo {window manager}{GUI}{X11}{WM Dock}: Ein Fenstermanager mit knapp 4 MB Installationsumfang, der keines der "großen" Toolkits als Abhängigkeit hat. Ca. 16 MB RAM-Bedarf. Fluxbox ist eine Weiterentwicklung von blackbox aber immer noch sehr leichtgewichtig. Er beherrscht die für Usability wichtigen Enhanced Windows Manager Hints. Er ist ein Konkurrent zu jwm und auf LiveCDs sehr beliebt. Fluxbox kann im laufenden Betrieb auf einen anderen WM wechsel, indem man das Fluxbox-Kommando (dafür gibt es einen eigenen Menüpunkt) "Restart" mit dem anderem WM als Argument ausführt. Fluxbox bietet im Gegensatz zu einigen anderen leichtgewichtigen WM's zwar immerhin ein Panel, aber dieses enthält kein Applikations-Startmenü sondern nur die Uhrzeit, Buttons zum Umschalten der Arbeitsfläche und die Taskleiste. Fluxbox kann des weiteren mittels eines "Slit" genannten Bereichs als Dock für Dock Apps gemäß dem Standard des "Window Maker"-Fenstermanagers (Paket "wmaker") dienen. Der Slit selbst kann entlang aller Bildschirmränder zentriert oder an die eine Ecke grenzend angeordnet werden. Dock Apps erkennen den Slit selbst und starten automatisch dort, die relative Reihenfolge der Apps im Slit lässt sich jedoch dauerhaft abspeichern. Ein Applikations-Startmenü ist nur über das Kontextmenü des Desktop-Hintergrundes zu bekommen, wozu man aber einen freien Platz braucht um den Desktophintergrund überhaupt erst einmal erreichen zu können. Normalerweise hält man sich dazu neben dem Panel etwas Platz frei, so dass das Panel nicht über die ganze Breite des Bildschirms geht. Alternativ kann man sich die Mausbelegung ändern. Dadurch gelang es mir, mit dem mittleren Mausknopf über dem Toolbar oder Desktop ebenfalls das Startmenü zu bekommen. Fluxbox kann sein Applikations-Startmenü nicht direkt aus *.desktop Dateien erzeugen; der Menüinhalt wird aus einer Textdatei gelesen. Es wird ein Menügenerator-Script mitgeliefert welches diese Datei aus aus *.desktop Dateien generieren kann, aber das Ergebnis ist nicht sonderlich überzeugend da jede Menge Einträge warum auch immer nicht gefunden werden. Es ist besser man verwendet dazu einen externen Generator x11-misc/menumaker. Die Maus- und Tastatursteuerung von Fluxbox kann relativ detailliert über eine weitere Textdatei angepasst werden. Auch globale Tastenkürzel zum Start bestimmter Applikationen und Mehrtasten-Sequenzen a la Emacs sind damit realisierbar. Wenn man den Desktop-Hintergrund mit dem mittleren Mausbutton anklickt, bekommt man ähnlich wie bei openbox ein Menü zum wechseln der Arbeitsflächen, und man kann damit auch welche hinzufügen oder löschen. Dieses Menü hat Untermenüs für die einzelnen Arbeitsflächen, in denen die einzelnen Fenster aufgeführt sind. Da dieses Menü mehrspaltig wird falls erforderlich, lassen sich zumindest einige hundert Fenster pro Arbeitsfläche ansteuern obwohl es keinen Scrollbalken gibt was für die Praxis ausreichen sein sollte. Allerdings richtet sich die Breite der Menüspalten nach dem längsten Fenstertitel, wodurch dann im schlimmmsten Fall nur noch eine Spalte am Bildschirm dargestellt wird. Wenn mehr Fenster offen sind als Platz in diesem mehrspaltigen Auswahlmenü-Fenster Platz finden, wird dieses einfach breiter als der Bildschirm, und man muss das ganze Menüfenster verschieben um den am Bildschirm sichtbaren Ausschnitt des Fensters zu verändern. Umschalten der Fenster mittels Alt-Tab wird unterstützt, allerdings gibt es keine Anzeige welches dabei das nächste Fenster sein wird - die Umschaltung erfolgt einfach und man muss sehen wohin sie einen trägt. Mit dem Mausrad lassen sich sowohl die Arbeitsflächen umschalten, die Fenster über das Panel durchschalten, aber nicht Fenster am Titelbalken Shaden/Unshaden wie in Blackbox. Fluxbox liefert einen ganzen Haufen "Styles" mit, welche sich zwar nur über Farbe, Font, Fensterverzierung und bestenfalls Hintergrundmuster unterscheiden. Aber dadurch dass man die Styles einfach aus einem Kontextmenü auswählen kann, kann der Anwender sie leicht umschalten ohne dazu Konfigurationsdateien editieren zu müssen. Die meisten der Styles sind allerdings unbrauchbar, da sie entweder winzige Fonts oder kaum unterscheidbare Farbkombinationen für Vorder- und Hintergrundfarbe der Menütexte verwenden. Bei weiteren Styles mangelt es daran dass das optische Unterschied zwischen dem aktiven und den restlichen Fenstern oder deren Einträgen in der Taskleiste zu gering oder überhaupt nicht vorhanden ist. Hier eine Auflistung der Styles die ich noch am brauchbarsten fand (nach Gefallen gereiht, bestes zuerst): bloe, arch, zimek_green, zimek_bisque, ostrich, green_tea. Die folgenden Styles sind auch noch OK wenngleich sie der optische Unterschied zwischem aktivem und inaktivem Fenster etwas zu gering ist (keine Bewertung durch die Reihenfolge): bora_black, bora_blue, bora_green, zimek_darkblue. Dabei ist wichtig zu wissen dass es nicht reicht einfach nur ein anderes Theme aus dem Menü auszuwählen - man muss danach Fluxbox unbedingt auch neu starten (etwa mittels des Menüpunkts "Restart"), da sonst üblicherweise einige Farben des neuen Styles nicht korrekt umgestellt werden. Ein besonderes Feature von fluxbox besteht darin, den Balken mit dem Fenstertitel mit dem mittleren Mausknopf in ein anderes Fenster ziehen zu können. Dann teilt sich im Zielfenster der Fenstertitel-Balken und wird zu zwei Karteireiter-Umschaltflächen. Der originale Inhalt des Zielfensters und der Inhalt des Herkunftsfensters werden hingegen zu umschaltbaren Registerkarten des nunmehr kombinierten Zielfensters. Wenn man mehr Fenster ins Zielfenster zieht, werden es entsprechend mehr Karteireiter. Ebenso kann man einen Karteireiter aus dem Fenster auf den Desktop-Hintergrund ziehen um wieder ein eigenständiges Fenster daraus zu machen. Ein extrem nützliches wirklich Killer-Feature!
focuswriter-1.2.0/app-text/gentoo: Ein "Textverarbeitungsprogramm", das weniger kann als jeder normale bessere Texteditor. Angeblich kann es auch RTF-Dateien editieren - davon konnte ich in dieser Version allerdings nichts bemerken. Wenigstens hat er auch mit 1 MB großen Textdateien keine Performance-Probleme. Irgendwie beschleicht mich der Eindruck, dass hier jemand aus ein paar Qt-Grundelementen schnell mal eine Applikation im Qt-Designer zusammengeklickt hat. Der besondere Anspruch das Programmes liegt darin, nur den Text anzuzeigen und alle anderen störenden GUI-Elemente im Normalbetrieb zu verstecken. Das tut er auch, nur kann das Programm eben nahezu nichts. Immerhin beherrscht es wenigstens Tabs. Vielleicht in einer späteren Version mal wieder ansehen - es sieht zumindest nett aus (wie allerdings so ziemlich jedes andere Qt-Programm auch.)
fontforge 20150824-1/extra/archlinux: Ein sehr mächtiger Editor für Outline Fonts, der auch zur Anzeige aller Zeichen im Font "missbraucht" werden kann. Mit rund 8 MB Installationsumfang (plus ein paar kleinere Bibliotheken) auch nicht gerade schlank.
fontforge/media-gfx/gentoo: Outline Font Editor. Can also create and edit Hints. The well-known URW++ fonts have been edited with it. Supports TrueType, PostScript, OpenType and SVG fonts.
fontypython-0.4.2.3/media-gfx/gentoo: Ein in Python für Qt4 geschriebener simpler Font-Viewer. 1 MB installationsumfang. Im Unterschied zu anderen Programmen wählt man hier die Verzeichnisse aus in dem die Font-Dateien liegen. Das Programm zeigt dann für jede gefundene Font-Datei im Verzeichnis einen beliebig definierbaren Beispieltext an. So kann man schneller als bei anderen Programmen wo man immer nur einen Font zur selben Zeit sieht alle Fonts in einem Verzeichnis gemeinsam kontrollieren. Und man sieht auch die Unterschiede zwischen den Darstellungen des Beispielsatzes sofort.
foobillardplus-3.43~svn170+dfsg-6/games/debian {game}: Eine grafisch sogar noch besser gemachte 3D Billiard-Simulation als billard-gl, welches bereits ausgezeichnet ist. Auch sehr ähnlich wie "billard-gl". Ebenfalls deutsche Lokalisierung, Tutorial und Schnellhilfe direkt im Programm integriert. Eine ausführlichere Hilfe wird im Browser angezeigt (jedoch kein Online-Zugriff erforderlich). Ein sehr schönes Programm, das alles was billard-gl bereits gut macht noch ein kleines bisschen besser zu machen scheint. Dazu hübschere Hintergrund Grafik: Man befindet sich in einem gemütlichen Zimmer mit Tischen, Couchen usw. und ein prasselndes Feuer brennt im Kamin. Diese Zusatz-Scherze haben allerdings ihren Preis ohne direkt etwas zum Spiel beizutragen: 22 MB Download, 28 MB installiert. Die Steuerung von billard-gl erschien mir überdies etwas intuitiver, obgleich man wegen der umfangreichen Anleitung sicherlich mit beiden Programmen zurecht kommen wird.
fop-doc-1: 2.1-6/doc/debian: Wertlos für Anwender von "fop" die aufs Web verwiesen werden. Nur API-Infos. Diese verbrät dafür aber grausige 80 MB Platz.
forensics-colorize-1.1-5/utils/raspbian: Enthält zwei Kommmandozeilenprogramme: "filecompare" vergleicht zwei Dateien welche typischerweise Dateisystem-Abbild-Dateien sind und erzeugt eine Bitmap geänderter Bereiche daraus. "colorize" konvertiert diese Bitmap in eine Windows *.bmp Grafikdatei, welche die geänderten Bereiche dann farbig als 2-dimensionales Bild darstellt. Der Dateivergleich erfolgt primitiv blockweise mit festlegbarer und fixer Blockgröße. Die *.bmp Datei wird mit einer fixen Auflösung von 1 Pixel pro Block erzeugt. Will man größere Klötzchen sehen, muss man die Ausgabedatei mit einem separaten Programm wie etwa "convert" skalieren. Man kann lediglich die Breite der Grafik in Pixel festlegen, die Höhe ergibt sich aus der Gesamtblock-Anzahl. Ein primitives Programm, doch es tut seinen simplen Job.
fox-1.6.40/x11-libs/gentoo: In C++ geschriebenes LGPL GUI-Toolkit für X11 UNIX/Linux und MS Windows, aber derzeit nicht für MacOS. Bindings für Python und Ruby verfügbar. 50 MB Installationsumfang inklusive Dokumentation, Header-Files und Libraries. Zeichnet seine GUI-Elemente in Windows95-Optik selbst. Im Vergleich zu FLTK hat es bessere C++ Integration, mehr GUI-Elemente und auch Layout-Manager; dafür fehlt allerdings ein GUI-Designer und es ist komplexer. Verwendet C++ Exceptions um Fehler zu signalisieren. Reentrant und Support für Pipes, Sockets und Mutexes. GUI-Elemente sind an Variablen gebunden und ändern (vermutlich durch Überladen des Zuweisungsoperators) automatisch den angezeigten Wert. Eine Registry kann "Recently-Used"-Einträge; angepasste Dialog-Settings etc. auch über die aktuelle Sitzung hinaus speichern. MDI und SDI-Funktionalität. Ballon-Hilfe. Floating Toolbars. Layout-Managery inklusive Matrix-Layout - allerdings scheint die ROWSPAN- und COLSPAN-Fähigkeit von GTK+ zu fehlen. Grafikfunktionen für Bildschirm und PostScript-Druckerausgabe. FOX konkurriert im wesentlichen mit Qt, welches FOX in allen Einzelpunkten übertreffen dürfte und überdies einen GUI-Designer und eine IDE (Kdevelop oder Qt-Creator) bietet. Allerdings ist die Zukunft von Qt (Stand: 2011) alles andere als gesichert, und außerdem mag FOX dann vorzuziehen sein wenn man alle Quelltexte selbst und dabei möglichst prägnant schreiben will ohne dass einem Codegeneratoren, Wizards oder XML-Files mit GUI-Beschreibungen ständig dazwischen pfuschen oder in die Quere kommen. Kurzum, man hat unter FOX mehr Kontrolle über den Gesamtquelltext der eigenen Applikation. Unter Qt kann man dafür aber mit weniger Arbeit zum Ziel kommen, es deckt auch andere Bereiche als GUI-Programmierung ab, und es sieht besser aus. Doch dafür hat man mit Qt das Problem der unsicheren Zukunft.
fp-ide-3.2.0+dfsg-12/devel/debian {development_environment}{text-terminal IO}: Eine text-mode Benutzeroberfläche im Stil der klassischen "Turbo PASCAL"-Oberfläche aus den frühen 90er Jahren. Benutzt denselben PASCAL-Dialekt wie "fpc", hat jedoch den Compiler und Linker direkt eingebaut und benötigt daher keinen separat installierten fpc. Man kann die Programme direkt von Editor-Puffer in den Speicher kompilieren und gleich dort laufen lassen, ohne dass dazu ein separates Executable abgespeichert werden müsste. Auch ein Debugger ist in die IDE integriert, und sogar ein Symbol-Browser (der allerdings erst nach erfolgreichem Linken die gewünschten Informationen liefern kann). Ein Meilenstein im Komfort wenn man auch mit einem schwachen Rechner blitzschnelle Edit-Compile-Run-Zyklen durchlaufen will, ohne das dazu ständig Unmengen an Temporärdateien angelegt werden müssen.
fpart-1.5.1-1/misc/raspbian: Teilt den Inhalt von Verzeichnisbäumen in gleich große Teile auf. Dazu liest es entweder den Inhalt von Verzeichnisbäumen, oder eine vom Benutzer erzeugte Liste die pro Zeile eine Bytegröße und einen Pfadnamen enthält. Das Programm tastet die eigentlichen Dateien nicht an sondern erzeugt nur eine Liste aus Tripeln (Bag-Number, Byte-Size, Pathname). Die Größe als Kriterium der Aufteilung muss angegeben werden, und kann entweder eine Anzahl an Einträgen oder eine Gesamt-Bytegröße pro "Bag" sein. Die Ausgabe ist zwar annähernd aber nicht strikt pro Bag sortiert, konkret können "Reste" des vorigen Bags noch in den Ausgaben des nächsten Bags vorkommen. Doch mit "sort" lässt sich dies einfach lösen. Man kann mit fpart z. B. einfach einen großen Dateibaum auf mehrere Datenträger gleicher Größe aufteilen, welche dadurch möglichst voll gefüllt werden. Dazu kopiert man alle Pfadnamen mit derselben Bag-Nummer auf denselbe Datenträger. Später können die Inhalte all dieser Datenträger wieder in ein einelnes Dateisystem zusammen kopiert werden, und stellen dann eine Replik des früheren Originals dar.
fpc-3.2.0+dfsg-12/devel/debian fpc/dev-lang/gentoo: Free PASCAL compiler. Der beste freie PASCAL-Compiler den ich 2009-2021 für Linux finden konnte. Schneller Code. Außerdem kleine Executables dank intelligentem Linking. Überdies ist der PASCAL-Dialekt sehr modern mit Objekten usw. Es beherrscht im wesentlichen den gesamten Sprachumfang des kommerziellen BORLAND PASCAL, sowie möglicherweise noch zusätzliche Erweiterungen. Allerdings: Wer will schon in PASCAL programmieren? Dennoch - bei Bedarf vermutlich eine gute Wahl. "Vermutlich"? Nun, ich habe keine einzige Zeile damit programmiert als er installiert war... aber die Reviews waren recht gut. Auf jeden Fall war es besser als GNUPascal.
free-bangla-font-0.2/media-fonts/gentoo: Hat keine deutschen Umlaute. Wohl für indische oder ähnliche Sprachen. Vergessen.
freecad-0.14.3702+dfsg-3/science/devuan {3D}{CAD}: Das ultra-supergute 3D CAD Programm. 85 MB Download. In Python mit (so vermute ich aus den Abhängigkeiten) Plugin-Modulen in C++ geschrieben. Qt-basierte Benutzeroberfläche. Für Linux, Windows und MacOS verfügbar. Beispiele sind kaum bzw. nur mühsam im Netz zu finden (Stand 2018-01). Die Debian-Version liefert nicht einmal alle Beispiele mit die im Git-Repository des Projekts zu finden sind, obwohl es im GUI Links gibt um sie zu öffnen - welche entsprechend versagen. Als ich die Dateien manuell herunterlud und öffnen wollte, stürzte FreeCAD bei einem der ohnehin nur Handvoll an Beispielen reproduzierbar ab. Mag ja sein dass FreeCAD ganz toll ist, aber irgendwie vermisst man beim ersten Start all die gewohnten Werkzeuge die man aus 2D-CAD-Programmen wie LibreCAD kennt. Auch interaktives Drehen des 3D-Modells ist scheinbar nicht möglich, man kann die 3D-Projektion scheinbar nur in 2D verschieben und zoomen. Selbst das minimalistische und wesentlich schlankere OpenSCAD bietet diese Möglichkeit. Allerdings fand sich nach längerem Herumprobieren in einem Kontextmenü doch noch eine Möglichkeit den Navigationsmodus umzuschalten, damit man die Anzeige auch rotieren kann. Warum dies nicht die Voreinstellung ist, bleibt rätselhaft. Auch die vermissten vielen Buttons anderer CAD-Programme tauchten nach längerer Suche auf, scheinbar existieren sie nur in bestimmten Workspace-Presets die man erst einmal laden muss, und man findet sie daher nicht auf Anhieb. Eine dieser Ansichten verhält sich sogar wie ein Webbrowser bzw. ist einer. Das Programm scheint auch einen speziellen Modus für 2D Modelle zu haben, in dem freies 3D-Drehen der Ansicht grundsätzlich nicht zur Verfügung steht. Der Ersteindruck des Programms ist negativ, aber vermutlich benötigt das Programm einfach nur eine längere Einarbeitungszeit da es anders organisiert ist als man das von einem CAD-Programm erwartet. Die Beispiele zeugen zumindest davon, dass es sehr wohl möglich ist auch komplexe 3D-Modelle damit zu erstellen. Auch wenn sie optisch etwas primitiv und plump aussehen, aber vielleicht liegt das nur an Render-Voreinstellungen die auf flüssiges Arbeiten auf Kosten schönen Aussehens optimiert sind. Tatsächlich finden sich nach erneut längerer Suche auch Popup- und Kontext-Menü-Einträge wo man zwischen verschiedenen Render-Modi auswählen kann, inklusive Drahtgitter und Eckpunktewolken-Ansicht. Davon abgesehen ist ein "Eigenschafts"-Fenster am linken Rand allgegenwärtig, wo man alle möglichen Objektattribute exakt numerisch einstellen kann. Die hierarchische Struktur von Objekten wird in einem Fenster darüber angezeigt, das als aufklappbare Baumstruktur organisiert ist und mit der man auch das aktuell ausgewählte Objekte wechseln kann. Das Programm erlaubt es auch einige Renderer externer Programme zu benutzen, und kann Objekte aus anderen Programmen in sein Modell einbinden. Darunter etwa OpenSCAD, PovRay (eine 3D Szenenbeschreibungssprache und Renderer) und LuxRender (ein OpenSource Raytracing-basierter reiner Renderer mit HDR- und OpenCL-Support der Wellenlängen anstatt des üblichen RGB-Farbraums verwendet). Scheinbar kein Blender. Die Anleitung wird nicht mitgeliefert, aber es gibt (neben einer Web-Version) eine downloadbare 10+ MB große 200+ seitige Anleitung im EPUB-Format. Eine PDF-Version gibt es ebenfalls.
freedroidrpg-0.15.1/games-rpg/gentoo {game}: Ein 3D-Klon das klassischen Paradroid-Spiels. Man übernimmt Roboter, um danach mächtigere Roboter zu übernehmen - oder versucht sich durchzuballern. Grafisch aufwändig gemacht, da ein 200 MB Download.
freedv-1.4.3~1gdc71a1c-1+b1/hamradio/debian: Dieses Paket enthält den "Codec 2", einen Sprach-Codec der Für noch größere Komprimierung soll man den "Codec 2" benutzen der Sprache noch mit niedrigsten Bitraten von 0,7 - 3,2 kpbs in ausreichender Qualität komprimieren kann. Doch leider ist dieser Codec monolithisch in einer GUI-Applikation eingebaut, welche zwar tolle Buttons bietet jedoch offenbar nur für Amateurfunk-Geräte benutzbar ist. Auf jeden Fall lässt sich damit offenbar nicht ein Voice-Chat via Internet realisieren, oder auch nur der Inhalt einer Datei aufnehmen / wiedergeben. Es scheint rein auf die Bedürfnisse von Amateurfunk ausgelegt zu sein.
freefilesync-12.0-2+rpi1/utils/raspbian {dirtree sync}: Grafische Software zur bi-direktionalen (optional auch nur unidirektional) Verzeichnis-Synchronisierung. In C++ mit wxWidgets verfasst. Es funktioniert (zumindest) unter Windows, MacOS und Linux, wobei die Windows-Version die Features vorgibt bzw. beschneidet. So ignoriert der Namensvergleich standardmäßig Groß-/Kleinschreibung, gibt es keine RegEx-Unterstützung oder Character Ranges, Hardlinks werden nicht unterstützt (bzw. wie separate Dateien behandelt). Wenn man die Unterscheidung Groß-/Kleinschreibung aktiviert (was nur manuell in der Konfigurationsdatei möglich ist aber für strikt POSIX-konforme Dateisysteme unbedingt getan werden sollte), führt das Auftreten unterschiedlicher Groß-/Kleinschreibungen in den beiden Dateibäumen zuerst zu einem Konflikt; bei späteren Synchronisierungen scheint es dann aber zu funktionieren. Zugriffsrechte, ACLs oder gar EAs werden ebenso ignoriert und nicht synchronisiert wie dateisystemspezifische Attribute (verschlüsselt, komprimiert). Eine Ausnahme ist das "Executable"-Attribut, welches zumindest mitkopiert wird (beim Vergleich wird es aber ignoriert). Auch wird nur die Änderungszeit synchronisiert. Bestimmte Sonderzeichen welche unter Linux (anders als unter Windows) in Dateinamen erlaubt sind dürften das Programm verwirren, oder lassen sich zumindest nicht in Filteraudrücken verwenden. Was Permissions angeht, lässt sich das Kopieren dieser zwar einschalten, erfordert dann aber angeblich Administrator-Rechte. Tatsächlich funktionierte es auch ohne diese teilweise, aber unvollständig: Eine Datei mit Mode 642 wurde z. B. als Mode 640 kopiert. Unabhängig davon kopiert diese Option die Permissions nur falls eine Kopier-Aktion stattfindet; beim Vergleichen wird ein Unterschied der Permissions trotzdem ignoriert. Sehr nett hingegen ist die Hilfsfunktion für das mehrfache Umbenennen selektierter Dateien. Dabei werden allen variierenden Abschnitten zwischen den Namen nummerierte Platzhalter zugewiesen, die man dann im Ersatztext verwenden kann. Im GUI erstellte Settings-Profile lassen sich danach auch aus der Kommandozeile heraus aufrufen. (Dabei können die Basis-Verzeichnisse aus dem Profil auch übersteuert werden.) Einige Funktionen sind nur der kostenpflichtigen "Spendenversion" des Programms vorbehalten. Solche Funktionen werden in der Beschreibung hier ignoriert. Bedienungsanleitung gibt es nur auf der Webseite; dort lässt sie sich allerdings alternativ auch als nur eine einzige Webseite darstellen welche man dann herunterladen kann. Für den Dateivergleich gibt es drei auswählbare Varianten: Datum und Größe, Datei-Inhalt oder nur Dateigröße. Symlinks werden standardmäßig komplett ignoriert, es kann aber auch wahlweise der Inhalt der Link-Ziele verglichen werden, oder die Pfadangaben der Link-Ziele. Für ungenaue Zeitangaben lässt sich ein Zeitfenster HH:MM einstellen, so dass Zeiten im Fenster als identisch angesehen werden. Das ist nützlich für Unterschiede zwischen Sommer- und Winterzeit ignoriert werden, wenn ein Dateisystem Lokalzeit anstatt UTC für Dateien speichert. Dateien und Ordner können anhand von DOS-artigen Wildcards (diese repräsentieren Zeichen: null oder mehr, exakt eines, eines oder mehr) inkludiert und exkludiert werden. Die Suchausdrücke können dabei entweder relativ zur Wurzel des Dateibaums (mit führenden Pfadseparator-Zeichen; Schrägstrich und Gegenschrägstrich werden dabei als synonym betrachtet) oder relativ (ohne solches) zum aktuell durchsuchten Unterverzeichnis sein. Weiters kann das Suchergebnis auch auf einen Größenbereich und Datumsbereich eingeschränkt werden. Normalerweise werden Suchbedingungen sowohl auf Ordner als auch Dateien angewendet. Durch Anhängen eines Doppelpunkts beschränkt man ihn auf Dateien, durch das Anhängen eines Pfadseparators auf Verzeichnisnamen. Die nachfolgend erläuterten Einstellungen lassen sich im GUI *nicht* einstellen sondern nur manuell in der (Per-User) globalen XML-Konfigurationsdatei. Während des Vergleichs und/oder Abgleichs legt das Programm per Vorgabe Lock-Files in jedem Wurzelverzeichnis der Synchronisation an die es danach wieder löscht. Dies lässt sich abschalten, verhindert wenn eingeschaltet aber Datenkorruption wenn mehrere FFS-Instanzen auf dasselbe Remote-Verzeichnis zugreifen und ist daher eine gute Idee. Weiters kann das Programm mit reduzierter CPU-Priorität ("nice") arbeiten. Es gibt eine eigene Option für das Ignorieren einer Zeitdifferenz von exakt einer Sekunde, welche standardmäßig aktiv ist, weil FAT-Dateisysteme die Zeit nur auf 2 Sekunden genau speichern können. Schließlich lassen sich kopierte Dateien nach dem Kopieren automatisch vergleichen. Das ist vor allem bei unzuverlässigen Netzwerkverbindungen sinnvoll, verdoppelt aber auch die Übertragungszeit. Es lassen sich externe Anwendungen definieren, welche dann mit Platzhaltern für die Pfadangaben aufgerufen werden. So lässt sich z. B. ein visuelles Tool für den Vergleich des Inhalts zweier Textdateien definieren. So sieht man dann nicht nur dass zwei Dateien sich unterscheiden, sondern auch wie. Das Vergleichen erfolgt dabei grundsätzlich in einer separaten Phase vor dem Abgleichen. Es gibt 4 Varianten des Abgleichens: Bidirektional (Änderungen in beide Richtungen replizieren), Unidirektional (für reine Backups), Update (Backups ohne Löschungen) und Custom (auswählbare Features). Es ist ein zusätzliches Programm RealTimeSync enthalten welches ein abgespeichertes Profil im Batchbetrieb anwendet, sobald Änderungen in einem der Dateibäume erkannt werden. Weiters können Profile auch als Batch Jobs gespeichert werden, die dann von z. B. einem cron Job aus aufgerufen werden können. Das Programm kann optional (außer für bidirektionalen Abgleich; dafür zwingend) eine Datenbank verwenden welche Metadaten aller Dateien zum Zeitpunkt des letzten Abgleichs speichert. Dadurch können Verschiebungen automatisch erkannt werden, was sonst nicht möglich wäre (leider funktioniert dies nur bei Dateisystemen wo Dateien eine persistente ID haben; konkret funktioniert es weder mit FAT noch SFTP/FTP). Außerdem können für Löschungen und Konflikte in einigen Situationen intelligentere Entscheidungen automatische getroffen werden. Diese Datenbank mit dem Namen ".sync.ffs_db" wird immer in den Wurzelordnern der zu Synchronisierenden Verzeichnisbäube gespeichert. Der Name lässt sich nicht ändern. Neben erreichbaren Verzeichnissen aus dem lokalen Dateisystem gibt es Unterstützung für FTP (normal oder via TLS), SFTP (Passwort, Private Key File oder SSH-Agent) und Google Drive. Wenn Dateien gelöscht oder ersetzt werden, können die Originale optional in den Papierkorb verschoben werden, oder in einem Verzeichnis als versionierte Dateienamen in einem festzulegenden Archiv-Ordner. Dabei wird den Dateinamen ein Timestamp hinzu gefügt. Man kann die Anzahl der Versionen optional auf die letzten x Tage (plus optional minimale und maximale Anzahl der Versionen) begrenzen, oder auf eine maximale Anzahl neuester Versionen. Beim Synchronisieren werden Log-Dateien angelegt. Sie werden standardmäßig nach einer einstellbaren Anzahl an Tagen automatisch gelöscht. Unison ist ein Linux-freundlicheres Synchronisationsprogramm mit weniger Einschränkungen als FreeFileSync ("FFS"). Allerdings ist es in OCaml verfasst und quält Benutzer mit einem Versions-Horror (jeder Node muss exakt dieselbe Programm-Revision verwenden, oder eine Remote-Synchronisation wird verweigert) was FFS nicht tut. Außerdem muss bei Unison am Remote-Server unbedingt eine Unison-Instanz installiert sein, während FFS auch "dumme" Protokolle wie FTP und SFTP unterstützt wo kein FFS am Remote-Server installiert sein muss.
freefont-ttf-20090104/media-fonts/gentoo: UNICODE-Font mit deutschen Umlauten. Stammt vom "Free UCS Outline Fonts Project".
freemind/app-misc/gentoo: Netter 2-dimensionaler Folding-Editor zur Erfassung von Ideen. Man gibt die Texte in Sprechblasen ein; diese können Unter-Sprechblasen aufklappen. Vermutlich hilfreich bei Brainstorming-Sessions. Cross-Platform JAVA-Anwendung.
freepv-0.3.0-r3/media-gfx/gentoo {graphics image viewer}: Ein Betrachter für Panorama-Bilder. Beherrscht diverse verbreitete Dateiformate für solche Bilder. Am wichtigsten ist dass er QtVR .mov-Dateien abspielen kann, wie dev-perl/Panotools-Script sie aus von media-gfx/hugin erstellten Dateien konvertieren kann. Mit der Toolchain dieser drei Progamme lassen sich daher in Echtzeit schwenkbare 360°-Panoramen erzeugen und wiedergeben.
freesweep/games-puzzle/gentoo {game}{text-terminal IO}: Ein simpler Minesweeper-Clone für die Textkonsole. Breite, Höhe und Minendichte können frei festgelegt werden, soweit das Ergebnis noch auf den Bildschirm passt. Ncurses-basiert. Kann wahlweise mit ASCII-Zeichen oder erweiterten Liniengrafik-Symbolen arbeiten. Ebenso werden optional Farben unterstützt.
fribidi-0.19.2-r1/dev-libs/gentoo: Implementation des Standard-UNICODE-Algorithmus zum Erkennen der Textausgaberichtung von bidirektionalem Text. Interpretiert dazu auch Steuerzeichen wie U+200E LEFT-TO-RIGHT MARK. Wird benötigt wenn man selbst UNICODE-konforme Textausgabe implementieren will statt dafür vorgefertigte Widgets zu benutzen.
fsgateway-0.1.1-5/utils/debian {FUSE}{DOTNET}: Ein leider in MONO inplementiertes und daher für jeden anständigen Linux-User inakzeptables FUSE-Dateisystem, welches eine Sicht auf den Inhalt einer XML-Datei sowie der folgenden Datenbanken als Dateisysteme als virtuellen Dateisystem-Baum mounten kann: PostgreSQL, MySQL, SQlite, Microsoft SQLServer (natürlich...), Sugar Datastore. Weiters kann es einen existierenden Verzeichnisbaum anders strukturiert in Form von "Tags" darstellen - was auch immer das genau bedeuten mag. Wegen der erfodelichen MONO-Runtime (ca. 17 MB) belegt die Installation in Summe rund 20 MB Platz, falls man MONO nicht bereits installiert hat.
fspanel-0.8_beta1-r2/x11-misc/gentoo {desktop panel}: Minimalistic panel which provides two arrow buttons for switching the workspace (unexpected: stops at first or last workspace and does not wrap around), a task bar of running applications (icon followed by window name), and a simple text clock using HH:MM format. Nothing else. No pager, start menu or application launch buttons. Does not even support a configuration file: Hardcoded configuration which can only be changed by recompiling. Looks OK to me, if a task bar is all that is missing (e. g. in "OpenBox"). Is known to have problems with maximized windows which have been fixed in a fork known as "hpanel". As of 2014-03 it is no longer in the Portage tree.
fsv/x11-misc/gentoo: Zeigt alle Dateien und Ordner grafisch an, indem es lässig in 3D zum im Browser ausgewählten Objekt scrollt.
funnyboat/games-arcade/gentoo {game}: Harmlosere Variante von "Wavy Navy", aber leider nur in winzigem Fenster. Für diese Einschränkung aber eine sehr hübsche Grafik und auch durchaus unterhaltsam.
fuse-convmvfs-0.2.6-2+b2/utils/debian {FUSE}: Erlaubt es ein virtuelles Overlay über ein existierendes Dateisystem zu stülpen welches dessen Dateinamen konvertiert. Typischerweise ist so etwas nützlich wenn die Dateien auf einem Datenträger mit anderen Zeichensätzen oder Codierungen erstellt wurde als die welche man lokal verwendet. Wenn eine MS-DOS Floppy etwa Dateinamen mit Codepage 437 erstellt hat und man diese Floppy unter Linux auf einem UTF-8 System gemountet hat, kann dieses Dateisystem die enthaltenen Umlaute richtig anzeigen obwohl sie in einem völlig anderen Zeichensatz gespeichert sind.
fuse-posixovl-1.2.20120215+gitf5bfe35-1/misc/debian {FUSE}: Dies ist ein Overlay-Dateisystem, mit dem man einem "dummen" Dateisystem wie FAT UNIX-typische Eigenschaften wie lange Dateinamen, Symlinks, Permissions, Owner/Group und dergleichen "spendieren" kann, obwohl das dumme Dateisystem nichts davon beherrscht. Dies wird dadurch implementiert indem versteckte zusätzliche Dateien mit Metadaten am dummen Dateisystem abgelegt werden, welche die von Dateisystem selbst nicht unterstützten Metadaten speichern. Leider ist die Anleitung dürftig. Aber mit dem folgenden Befehl "/sbin/mount.posixovl -S fat fat_posix -- -o default_permissions" schaffte ich es eine zuvor mittels fusefat ins Verzeichnis ./fat gemountete  VFAT-Imagedatei als ./fat_posix mittels fuse-posixoverl zu mounten. Ich konnte dann tatsächlich Symlinks anlegen, die im darunter liegenden FAT-Dateisystem dann als versteckte Datei aufschienen. Allerdings ignorierte er dafür meine "chmod"-Befehle. Ich blicke da noch nicht ganz durch. Aber Hauptsache Symlinks funktioneren damit auf VFAT!
fuse2fs-1.43.4-2/admin/debian {FUSE}: Erlaubt es, ext2/ext3/ext4-Dateisysteme als FUSE-Dateisysteme zu mounten. Scheint auch aus dem Umfeld der Original-Autoren dieser Dateisysteme zu stammen, was eine gute Qualität erhoffen lässt. Und es funktioniert auch super. Leider *zu* super: Während andere FUSE-Dateisysteme die Zugriffsrechte normalerweise ignorieren oder zumindest eine Option bieten ob sie diese beachten sollen oder nicht, respektiert fuse2fs *immer* die Zugriffsrechte. Jeder normale User kann daher jedes Disk-Image auf denen das entsprechende Dateisystem enthalten ist mounten. Aber alle Dateien die z. B. root gehören, kann er normalerweise nur lesen (wenn überhaupt). Um auch selbst Dateien ändern zu können, muss er daher im gerade laufenden System über dieselben UIDs/GIDs verfügen wie er sie damals auf jenem System hatte wo er die Dateien in die Image-Datei kopierte. Oder die Permissions müssen so liberal gesetzt sein dass "other" jeder Zugriff gewährt wird. Während letzteres natürlich immer möglich ist, setzt es entsprechende Vorbereitung voraus. Man kann daher in der Realität admin/fuse2fs meist nur solche Image-Dateien schreibend benutzen, die explizit für den Zweck vorbereitet wurden von beliebigen Usern bearbeitet zu werden. Das mindert den Nutzen dieses Tools erheblich, denn es wäre ja gerade interessant als nicht-privilegierter User Image-Dateien bearbeiten zu können. So schafft dieses Tool nur eine idiotische Pseudo-Sicherheit die es in den meisten Fällen unbrauchbar macht. "Pseudo"-deshalb, weil man ja totzdem händisch das Image manipulieren kann um seine Zugriffsrechte vor dem Mounten so zu ändern dass man auf alles zugreifen kann. Es ist nur zusätzliche Mühe, sonst nichts. Völlig idiotisch! Daher kaum ein Praxiswert für dieses Tool, am ehesten noch die Chance für den Administrator um dubiose Image-Dateien erst einmal damit zu mounten und zu untersuchen bevor man das Kernel darauf zugreifen lässt. Allerdings sollte ein fsck dafür auch ausreichen. Ein verbleibendes Anwendungs-Szenario ist die Emulation von pro-Directory Quotas. In diesem Fall mountet man ein ext-Filesystem innerhalb eines (am besten sparse) Image Files bestimmter Größe, womit man innerhalb des Mount points dann nicht irrtümlich mehr Platz belegen kann als es der Größe des Image Files entspricht.
fusedav-0.2-3.1/web/raspbian {FUSE}: Ein FUSE-basiertes Dateisystem welches es erlauben würde, den Inhalt eines WebDAV-Servers lokal als Netzwerkdateisystem zu mounten. Von Lennart Poettering geschrieben. Das merkt man gleich daran dass es nicht funktioniert; einfach nichts tut. Es gibt Personen die Fehler in Quelltext gefunden und an Poettering gemeldet haben, aber dieser antwortet nicht darauf. Kurzum, in dieser Version unbrauchbar, und es scheint auch nicht mehr weiter entwickelt zu werden. Außerdem erinnern wir uns: Poettering ist der Typ, dem wir neben GNOME (das war ja noch OK) "wundervolle Dienste" wie udisks, PolicyKit und ConsoleKit und vor allem systemd zu "verdanken" haben. Und der empfiehlt Software nur auf spezielle Features des Linux-Kernels auszurichten und sich um Portabilität nicht zu scheren. Dass so jemandes Code nach ein paar Jahren nicht mehr kompilierbar ist, sollte einen daher nicht verwundern.
fuseext2-0.4-1.2/misc/debian {FUSE}: Ein FUSE-Dateisystem zum Mounten von ext2-Dateisystemen - insbesondere aus Abbild-Dateien. Leider ist es derzeit noch so sehr "Beta" (stand 2023) und die Option zum Schreiben ist noch "experimentell", so dass ich die Frage stellt wie sicher Daten in diesem Dateisystem sind. Einmal fror mir das ext2-Dateisystem komplett ein, bloß weil ich ein "df -h ." gemacht hatte.
fusefat-0.1a-3/misc/debian {FUSE}: Ein FUSE-Dateisystem zum Mounten von VFAT-Dateisystemen - insbesondere aus Abbild-Dateien. Leider ist es derzeit noch so sehr "Beta" (stand 2023) und die Option zum Schreiben ist noch "experimentell", so dass ich die Frage stellt wie sicher Daten in diesem Dateisystem sind. Beim Test hat es allerdings gut funktioniert. Die Dokumentation ist dürftig. Aber mit dem Befehl "fusefat -o rw+ -o umask=22 -o uid=`id -u` -o gid=`id -g` fat.img fat" schaffte ich es eine VFAT-Abbild-Datei "fat.img" mit sinnvollen erhaltenen Berechtigungen ins Verzeichnis ./fat zu mounten. Wenn man Symlinks und dergleichen verwenden will, kann man das ganze dann noch mit fuse-posixovl als 2. Schicht mounten.
fuseiso-20070708-3.2+b1/admin/debian {FUSE}: Ein FUSE-Dateisystem, das ISO-9660-Dateisysteme als nicht privilegierter User mounten kann (vorausgesetzt dieser hat dennoch Zugriff auf das entsprechende Blockgerät oder eine Dateisystem-Abbilddatei eines solchen), inklusive dessen Erweiterungen wie Joliet, RockRidge und zisofs. Weiters unterstützt es die CD-ROM Abbilder welche die Programme CloneCD (*.IMG) und "Alcohol 120 %" (*.MDF) erstellt haben da diese identisch mit dem ebenfalls unterstützten *.BIN-Abbildformat sind. Was fuseiso allerdings leider nicht unterstützt sind ebenfalls häufig anzutreffenden *.CUE Dateien.
fuseiso9660-0.3-1.3/misc/debian {FUSE}: Scheint nur orginale ISO-9660 CD-ROM Abbilddateien ohne Erweiterungen wie Joliet oder RockRidge mounten zu können. So gesehen kann ich keinen Grund erkennen dieses Dateisystem anstatt fuseiso zu installieren. Möglicherweise ist es performanter wenn man von einem physischen Disc-Laufwerk liest, da es zahlreiche Tuning-Parameter anbietet und zudem per Default mit asynchronem Datenträgerzugriff arbeitet.
fusesmb-0.8.7-1.4/utils/debian {FUSE}: Erlaubt es auch nicht-privilegierten Benutzern, Netzwerkdateisysteme über SAMBA/SMB/CIFS-Shares zu mounten obwohl der Administrator ihnen keine eingerichtet hat.
fvwm-2.5.18-r1/x11-wm/gentoo {window manager}{GUI}{X11}: Overloaded somewhat uglyfied version of IceWM.
gajim-0.14.4-r1/net-im/gentoo {chat}: Ein netter in Python geschriebener Instant-Messenger für das XMPP-Protocol (früher "Jabber" genannt). Bin recht zufrieden damit und es scheint einen besseren Security-Track Record zu haben als der wesentlich bekanntere Pidgin. Es unterstützt keine anderem IM-Protokolle direkt, allerdings implementieren viele Server mittels sogenannter "Transports" Brückenfunktionalität zu anderen IM-Protokollen. Unter Linux bietet gajim auch TLS/GPG-Support mit End-zu-End Verschlüsselung.
galculator-2.1.4-1.2/math/raspbian galculator/math/debian {calculator}{GTK+}: Der RAM-Speicher-Sparer unter den vollwertigen Taschenrechnern (die also mehr bieten und besser aussehen als xcalc). Ein GTK+-basiertes Taschenrechnerprogramm, das eigentlich alles bietet was man von so einem Programm erwartet. Es sieht hübsch aus - graue gerundete Tasten, lindgrünes "Display", schwarze große Ziffern. Farben und Schriftarten lassen sich aber in der Konfiguration anpassen. Es hat drei Modi - simpler Taschenrecher, wissenschaftlicher Taschenrechner und "Papiermodus", wo man Ausdrücke in ein Eingabefeld eintippt, und eine History der Ausdrücke und Ergbnisse wird als (alternierend eingefärbte) Liste angezeigt. (Das war einmal - nun hat die Liste nur noch einheitlich weißen Hintergrund. Wie Papier eben.) Im simplen und wissenschaftlichen Modus kann man zwischen 3 Eingabeformen wählen: normale algebraische Button-Eingabe (die meisten Buttons können auch über Tastatureingaben gedrückt werden), umgekehrte polnische Notation oder "Formeleingabe" mittels eines editierbaren Textfeldes. Bei letzterer ist es etwas ärgerlich dass keine Autocompletion-Funktion im Textfeld zur Verfügung steht, man muss Funktionsaufrufe wie sqrt() komplett eintippen. Aber natürlich kann man statt dessen einen anderen Eingabemodus wählen wenn einen dies zu sehr stört. Funktionen im simplen Modus: Grundrechenarten, Vorzeichenwechsel, Klammern, Prozent, Quadratwurzel, Speicher setzen, Speicher abrufen, zu Speicher addieren. Dabei gibt es beliebig viele Speicher - wenn man eine der Speichertasten drückt, klappt ein Auswahlfeld auf wo man einen bestehenden Speicherplatz auswählen kann (durch seinen aktuellen Wert repräsentiert), oder einen neuen Anlegen (geht nur beim Speichern). Im wissenschaftlichen Modus kommt noch hinzu: Abruf einer Konstante (beliebig viele konfigurierbar), Auswahl einer benutzerdefinierbaren Funktion (beliebig viele als Formelausdruck konfigurierbar), Exponentialeingabe, Zahlensysteme 2, 8, 10 und 16 umschaltbar (Fließkommaarithmetik jedoch nur im Dezimalsystem unterstützt), Winkelfunktionen (Sinus, Kosinus, Tangens) samt Hyperbel-Varianten und inversen Funktionen mit den Modi (Alt-) Grad, Neugrad und Radiant, dezimaler und natürlicher Logarithmus, Fakultät, Quadrieren, Potenzieren, Bitoperationen (Und, inklusives Oder, exklusives Oder, Komplement, links und rechts Schieben), Divisionsrest (Modulo). Es gibt eine Taste zum Löschen der Anzeige und des gesamten Rechenganges im Fortschritt sowie eine Taste zum Löschen nur des letzten Eingabezeichens. Die Zwischenablage wird voll unterstützt. Farbe und Fonts lassen sich konfigurieren. Ebenso die minimale Tastenhöhe und -breite, wobei man das Fenster des Taschenrechners über diese Minimalgröße hinaus beliebig vergrößern kann und er passt sich automatisch an. Das Programm kann auf Wunsch den Anzeigewert beim Beenden für den nächsten Programmlauf speichern. Man kann für die unterstützten Zahlensysteme separate Einstellungen für die Gruppierung von (etwa Tausendertrenner) festlegen. Dabei kann man sowohl Gruppenlänge als auch Trennzeichen frei definieren. Ein Bug zumindest in der Version 2.1.4 sorgt allerdings dafür, dass diese "Tausender"-Trennzeichen auch für Nachkommastellen verwendet werden! Für nicht-dezimale Zahlen kann man die Vorzeichenbehaftung sowie die Bitbreite für die Berechnungen zwischen 1 und 112 frei wählen. Für Dualzahlen kann man darüber hinaus auch noch optional eine frei wählbare Blockgröße angeben, was dann die Anzeige mit führenden Nullen auf ein Vielfaches dieser Größe auffüllt. Er ist weiterhin der schlankeste Taschenrechner unter den hübsch aussehenden / leistungerfähigeren: "nur" 35 MB RAM, 1,5 MB Installationsumfang, und 190 kB Download. Trotz aller Vorteile bleiben ein paar kleinere Nachteile: Es ist unschön dass im wissenschaftlichen Modus die Tasten für Bitoperationen auch dann angezeigt bleiben wenn man im Dezimalsystem arbeitet - wozu soll das gut sein? Außerdem fehlt jede Rundungs- bzw. Fixkomma-Funktionalität, d. h. man kann keine bestimmte stets anzuzeigende Anzahl an Nachkommastellen erzwingen. Auch der "Papiermodus" ist eher ein schlechter Scherz, und nicht mit dem von Speedcrunch zu vergleichen der viel mehr bietet. Somit sieht nur der "Standard Modus" so aus wie man sich das erwarten würde - aber der kann ja so gut wie nichts. Ich würde daher im Normalfall den Speedcrunch oder Qalculate! vorziehen, obgleich der Galculator optisch hübscher aussieht. Nur wenn RAM-Verbrauch ein wichtiger Faktor ist, etwa auf älteren Raspberry-Modellen, würde ich aus diesem Grund galculator vorziehen. Kurzum, Optik und RAM-Verbrauch ist die größte Stärke dieses Programms. der GPE-Calculator braucht zwar noch weniger RAM, aber der ist auf Debian-10 nicht verfügbar.
gcl-2.6.8_pre20090419/dev-lisp/gentoo gcl-2.6.12-102/lisp/debian {programming language}: Eine weitere LISP-Implementierung. Wird aber offenbar nicht sehr fleißig weiterentwickelt; die letzte Upstream-Version ist von 2005. Außerdem sind in Portage alle Versionen wegen "increasingly many problems" hard-gemasked und es wird empfohlen besser clisp oder sbcl zu verwenden. Alles in allem nicht sehr vertrauenserweckend. Update 2022: Das CAS-System "maxima" wird unter Debian standardmäßig mit gcl gebaut. Entweder ist gcl doch nicht so schlecht wie befürchtet, oder die Probleme wurden mittlerweile behoben. Wenn man "maxima" installert hat kann man diese benutzen um in einen LISP-Modus zu gelangen. Daher kann man sich in diesem Falle eine separate Installation von gcl ersparen.
gcr-3.38.1-2/gnome/debian: Der Hauptzweck dieses Pakets ist es zwar irgendwelche D-Bus Services mit Zertifikatsbezug für GNOME bereit zu stellen. Doch vor allem enthält dieses Paket das GUI-Programm "gcr-viewer", welches sich für abgespeicherte X.509-Zertifikate zuständig erklärt und daher automatisch aufgerufen werden kann sobald man diese doppelklickt. Es zeigt dann den Inhalt aller Zertifikatsfelder an, und kann auch ganze Zertifikatsketten anzeigen. Durchaus nützlich, wenn man sich nicht mit den diversen Kommandozeilen-Tools für diesen Zweck herumschlagen will, die in der Regel wegen endlos vieler Optionen kompliziert zu bedienen sind.
geany-0.19.2/dev-util/gentoo {development_environment}{text-editor}{GTK+}: Netter GTK+ basierter projektfähiger Editor für Programmierer. Ist "kate" sehr ählich, jedoch ohne die KDE-Abhängigkeit. Vor allem beherrscht er ebenfalls Lesezeichen, Soft Line Wrapping, Structure Folding und Tabs. Hat weiters Support für einfaches aber sehr praktisches Symbol Browsing (womit er sogar tatsächlich einige "full-featured" IDEs übertrifft welche Symbol-Browsing viel umständlicher als nötig implementieren), "make"-Aufruf und Fehlermeldungsparsing; natürlich Syntax-Highlighting, UTF-8-Support, Begrenzungslinie für rechten Rand, einblendbare Zeilennummern, Text Completion, Completion Macros und unterstützt auch ein VTE-basiertes Terminalfenster als "Kommandozeile" zur einfacheren Ansteuerung von Tools. Mit Plugins erweiterbar. Alles in allem sehr nett, aber es gibt auch Probleme: Konfiguration teilweise (aber nicht ausschließlich) nur mittels kruder Textdateien, Einstellungen lassen sich viel zu wenig auf bestimmte Dateitypen personalisieren (etwa Tab-Settings), Fensterteilungen erlauben kein Soft-Wrapping wie das Urspungsfenster, die konfigurierbaren "Make"-Aktionen im Buttonbar sind nur bedingt "Autotools"-freundlich, unflexibles bzw. unbrauchbares Reformatieren von Kommentaren, keine einfache externe Filtermöglichkeit für den markierten Block (wie "joe" es kann), die Dialoge für Suchen und Ersetzen merken sich ihre Optionen (etwa Relevanz der Groß-/Kleinschreibung) nur teilweise und sind insgesamt etwas unintuitiv zu benutzen. Projektdateien können erstellt werden welche "make"-Einstellungen, Basispfade und und geöffnete Dateien speichern. Eigentlich kann man sich aussuchen ob das zuletzt geöffnete Projekt beim Neustarten automatisch geladen werden soll oder nicht. Aber diese Version hat leider einen Bug dass ohne dieses aktivierte Feature Projektdateien nicht mehr als Kommandozeilenargumente geöffnet werden können (sie werden andernfalls schlicht ignoriert). Geany hat leider höhere Anforderungen an die Rechengeschwindigkeit, so dass es auf schwächeren Rechnern wie den Raspberry Pi 1 zu langsam läuft um komfortabel benutzbar zu sein.
gearman-1.0.6-9/misc/devuan {service manager}: Ein in C++ geschriebenes schnelles Job-Queue-System unter (der besonders anspruchslosen) BSD-Lizenz. Kann Jobs an andere Maschinen, aber auch an parallel arbeitende Worker-Prozesse (optional multi-threaded) auf der lokalen Maschine verteilen. Inklusive Load-Balancing. Arbeitet intern mit dem Map/Reduce-Ansatz. Warnung: Gearman ist *kein* Batch-Queue-System für UNIX-Kommandozeilenbefehle wie "uux" oder "at", obwohl man sicherlich auch so etwas damit implementieren könnte. Sondern Jobs werden von Programmen implementiert, welche das gearman-API benutzen um Funktionen bereit zu stellen, deren Aufruf dann durch Gearman gescheduled werden. Gearman hat daher ähnliche Einsatz-Szenarien wie PVM, MPI oder Googles Map/Reduce für verteilte Berechnungen. Der Gearman-API kann entweder über REST-artige HTTP-Requests oder über eine Library abgewickelt werden. Es auch eine Anbindung der Library für Python. Job-Queues existieren entweder nur im RAM der Job-Server, oder können auch persistent in eine Datenbank gespeichert werden. So überleben sie auch einen eventuellen Absturz des Job-Server. Clusterfähig mit Fail-Over. Kann MariaDB, SQLite3, memcached oder PostgreSQL als Datenbank-Backend für den Server-Prozess verwenden. (Eigentlich würde auch noch tokyocabinet als Backend unterstützt, aber dieses wurden im Debian-Build offenbar nicht freigeschaltet.) Das System kann sowohl über Commandline-Utilities als auch durch Applikationen gesteuert werden, welche das Gearman Client-API benutzen. Zusätzlich kann optional auch HTTP zur (REST-artigen) Ansteuerung verwendet werden. Die Kommunikation zwischen den Prozessen sowie Maschinen des Queue-Systems erfolgt über TCP, kann aber bei Bedarf mittels TLS abgesichert werden. Skalierbar - wird angeblich seit Jahren von großen Webseiten wie Craig’s List, Tumblr, Yelp und Etsy eingesetzt. Klein und schlank genug dass es auch auf Embedded-Systemen zum Laufen gebracht werden kann. Download 200 kB, installiert keine 600 kB.
geda-1.6.2/sci-electronics/gentoo: Dieses Paket ist das Kernpaket der gEDA-Suite zum Entwerfen elektronischer Schaltungen (laut Aussage in den Linuxwochen 2013 das beste Mittel der Wahl für OpenSource-Hardware-Entwicklung). Dieses Paket enthält gschem, einen Schaltplan-Editor CAD-Programm. Man setzt Bauteile ins Dokument, positioniert sie, verbindet die Anschlüsse mit anderen Bauteilen. Bauteile sind Vektorgrafikobjekte. Eine Bibliothek mit vielen fertigen Bauteilen ist bereits dabei, aber man kann auch eigene erstellen. Ebenso kann man Vektorgrafik-Text zur Beschriftung verwenden. Zu beachten ist, dass das vom gschen erstellte Dokument nur logische Verbindungen von Bauteilen darstellt, nicht deren physikalische Position auf einem späteren PCB. Weiters ist ein Netlist-Generator enthalten, ein Programm zum Editieren irgendwelcher Attribute, diverse Tools und Checker. Die gEDA Suite umfasst aber noch mehr Tools, die *nicht* in diesem Paket enthalten sind (sci-electronics/pcb Layoutprogramm, sci-electronics/gwave WaveForm Viewer, ngspice Schaltungs-Simulator, Icarus Verilog Compiler und Simulator, Analyseprogramme für elektromagnetische und Leitungsanalyse, Programm zur Erzeugung von lithografischen Masken).
gedit-48.1-4/gnome/raspbian gedit-3.8.3/app-editors/gentoo {text-editor}{GTK+}: Der Standard-Editor von GNOME. Der Mauszeiger wird versteckt sobald man zu tippen beginnt und sich dieser gerade über dem Text befindet. Sobald man den Mauszeiger bewegt, erscheint er sofort wieder. Das ist hilfreich, damit der Mauszeiger nicht den jene Stelle verdecken kann an der man gerade tippt; das ist häufig der Fall nachdem man etwas mit der Maus markiert hat. Beherrscht alles was Leafpad/Mousepad können, darüber hinaus noch mehrere Tabs (und mehrere offene Dateien) und Syntax-Highlighting. Die Tabs können auch jederzeit per Maus oder Menübefehle aus dem aktuellen gedit-Rahmenfenster gelöst und in eine anderes (oder neues Fenster) verschoben werden. Erweiterbar mittels Plugins, etwa für Rechtscheibprüfung, Sortieren oder Emacs Mode Lines. Weiters kann er die aktuelle Zeile hervorheben, inkrementell Suchen, hat einen Vollbild-Modus und die visuelle Anzeige einer definierbaren rechten Randposition. Er hat auch ein paar sinnlos-ulkige Features, wie ein Raster der Zeichenzellen über den Text gelegt darzustellen (sogar mit unterschiedlichen Rasterzellen für Kleinbuchstaben und die größere Höhe von Großbuchstaben-Höhe). Überdies beherrscht er komplexe UNICODE-Eingaben. Leider wurde dieser ursprünglich sehr gute Editor ab GNOME3 stark verhunzt. Erstens zeichnet er seine Fensterverzierungen selber, so dass sein Fenster völlig anders als alle normalen Fenster aussieht. Konkret fehlt ihnen nun die Titelzeile komplett. Bzw. wurde mit einer Art Menü- und Buttonleiste zusammen geführt. Verschieben lässt sich das Fenster damit zwar immer noch, aber für den Fenstermanager stellt es keinen Titelbalken mehr dar, so dass man damit nicht mehr die am Titelbalken üblichen Operationen des Fenstermanagers ausführen kann. Insbesondere lassen sich so keine Menüs es WM mehr öffnen, was ein Problem sein kann wenn das gedit-Fenster bildschirmfüllend ist. Weiters bietet der gedit nun nur noch eine inkrementelle Suche statt einem herkömmlichen Suchdialog, was den praktischen Umgang häufig deutlich umständlicher gestaltet. Des weiteren wurden aussagekräftige Menü-Titel durch nichtssagende Symbole ersetzt. Und dieser Editor installiert sich im Menü der im Anwendungs-Programme "natürlich" auch mit einem höchst aussagekräftigen Namen: "Texteditor". Damit man sofort Bescheid weiß, welcher es ist! Und das Googeln danach im Fall von Problemen macht sicherlich auch große Freude... Update 2025: Dieses Problem wurde behoben. Der Editor nennt sich nun wieder "gedit" im Startmenü. Beim Versuch die installierten Plugins zu aktivieren, wurde ich nur mit der Fehlermeldung "ImportError: cannot import name '_gi' from partially initialized module 'gi' (most likely due to a circular import)" erfreut. Man kann das Problem angeblich verhindern indem man einen Downgrade auf eine ältere Python-Version durchführt. Irgendwie erschien mir das unverschämt, und ich deinstallierte die Plugins statt dessen einfach wieder. Muss man eben ohne auskommen. Grundsätzlich bleibt es ein halbwegs guter Editor. GNOME-typischer Ärger wie derartiges gehört wohl einfach zum Benutzungererlebnis. Immerhin waren die Plugins mit 4 MB Download-Bedarf ohnehin größer als der Editor selbst mit nur 2,8 MB. Alles in allem ist derzeit Kwrite wohl dennoch die bessere Alternative. Update 2025: Problem behoben; die Plugins lassen sich nun wieder problemlos benutzen.
geeqie-1.0-r2/media-gfx/gentoo {graphics image viewer}: Ein weiterentwickelter Fork von gqview. Die Programme sind daher relativ ähnlich, im Großen und Ganzen ist Geeqie aber etwas mächtiger. Ich gehe im folgenden auf die Unterschiede zwischen den Programmen ein. Der Sortiermanager von Geeqie beherrscht kein Erzeugen symbolischer Links. Dafür kann der Keyword-Manager von Geeqie Schlüsselworte in Baumstrukturen (mit Vererbung) organisieren und nicht nur in flachen Listen. Das ist deutlich mächtiger. Gqview zeigt seine Manager (Exif-Daten, Sortiermanager, Keyword-Manager) immer in mehreren vertikalen Panes rechts neben dem Bild an; das kostet Platz wenn alle eingeschaltet sind. Geeqie hingegen verwendet nur eine einzige Pane und stellt die Manager unter einander dar, wobei Folding (mit Dreiecken zum Aufklappen) dazu verwendet wird den vertikal zur Verfügung stehenden Platz zwischen den Managern aufzuteilen. Außerdem hat Geeqie 5 statt 3 Manager/Anzeigen: Ein Diagramm der Farbverteilung, Titel, Schlüsselworte, Kommentar und Exif-Informationen. Letztere sind in der Normal-Ansicht zwar besser aufbereitet als bei Gqview, letzteres scheint die Daten jedoch "richtiger" aufzubereiten. Nur Geeqie kann jeder Datei 6 verschiedene Markierungen zuweisen, und danach die Anzeige aufgrund dieser Markierungen einschränken, oder Mengenoperationen mit den Markierungen durchführen (um die bestehende Auswahl zu verändern). Die Markierungen können überdies auch in der Dateiliste angezeigt werden. Ein weiterer Unterschied sind die Metadaten - Geeqie kann die Metadaten von Gqview importieren, verwendet aber selbst ein mächtigeres XML-basiertes Format. Es gibt auch mehr Methoden wo diese gespeichert werden. Die Preset Keyword-Liste von Geeqie ist nicht nur baumförmig strukturiert sondern auch um einiges brauchbarer als die Preset Primitiv-Liste von GQview. Verlustlose JPEG-Rotation is möglich wenn das fbida-Paket installiert ist.
geeqie-1:1.6-9+deb11u1/graphics/debian {graphics image viewer}: Bildbetrachter und -organizer. Ein Fork von GQview, allerdings leider weniger intuitiv zu bedienen. Dafür aber Support für Metadaten-Speicherung direkt im Bild, insbesondere zusätzlich auch solche nach dem XMP-Standard. "Sidecar"-Dateien welche Metadaten in separaten Dateien abspeichert werden aber nach wie vor unterstützt. Bei der Vollbild-Anzeige ist es möglich sowohl viel zu kleine als auch viel zu große Bilder exakt auf die Bildschirmgröße anzupassen. Man kann Verzeichnisse und die Dateien darin in einer Seitenleiste anzeigen, wahlweise auch mit Vorschaubildern und Datei-Details wie Änderungsdatum. Das in dieser Leiste aktive Bild wird im Zentralbereich des Fensters dargestellt. Metadaten des Bildes können optional über das Bild eingeblendet werden, z. B. der Dateiname oder die Bilddimensionen. Das ist vor allem im Vollbildmodus manchmal wünschenswert. Zusätzliche Seitenleisten können aktiviert werden, und zwar eine Informationsleiste und ein Sortier-Manager. Die Informationsleiste enthält aufklappbare Bereiche für: Histogramm der vorkommenden Farben (linear oder logarithmisch), Titel (manche Bildformate unterstützen einen separaten Titel unabhängig vom Dateinamen), Schlüsselworte (können in einer freien Hierarchie definiert und jedem Bild zugeordnet werden; eine Beispielhierarchie mit Schlüsselworten wie "Familie" und "Freizeit" ist vordefiniert), Kommentar (Freitext), Bewertung (1 bis 5 oder 0 für keine), EXIF-Informationen (von vielen Digitalkameras bereit gestellt, z. B. Aufnahmezeitpunkt, verwendeter Blitz, GPS Koordinaten, Belichtungsangaben). Der Sortiermanager erlaubt es das aktuelle Bild in ein anderes Verzeichnis oder eine definierte Sammlung zu kopieren, verschieben oder zu symlinken. "Sammlungen" sind von Programm geführte Listen mit Pfadnamen von Bilddateien, welche sich in dieser Sammlung befinden. Sie können im Sortiermanager wie Verzeichnisse benutzt werden, nur dass sich dadurch nichts am physischen Speicherort der Datei ändert. Nützlich vor allem als Zwischenziel in komplexen Organisationsvorgängen, oder wenn man keine Schreibberechtigung in den Originalverzeichnissen hat. Vier Varianten für Umbenennungen von Bilddateien: Direkt in der Dateiliste ohne separaten Dialog (für einzelne Datei) oder 3 Varianten einer Mehrfachumbenennung: Manuelles Bearbeiten aller Zielnamen, Einfügen eines Zählers definierbarer Ziffernzahl mit Namenstext davor und danach, sowie Umbenennen mit Formatcode-Zeichenfolgen. Mächtige Suchfunktion welche nicht nur nach Dateinamen, Dateigrößen oder Änderungszeit sucht, sondern auch nach etlichen Metadaten wie Auflösung oder Bildbewertung. Weiters ist eine Suchfunktion nach Bildduplikaten vorhanden. Diese kann entweder rein Dateinamens-Orientiert arbeiten, via Prüfsummenvergleich oder mit tatsächliche Bildähnlichkeit (rein Pixelbasiert, keine psychovisuellen Modelle; Toleranz-Schwellwert einstellbar). Funktion zum Kopieren der Pfadnamen von selektierten Bilddateien in die Zwischenablage. Regex-basierter Anzeigefilter für die Dateiliste. 10 unabhängige Markierungen die für jedes Bild gesetzt werden können. Anders als Schlüsselworte werden diese jedoch nicht im Bild gespeichert sondern existieren nur temporär während des Programmlaufs. Man kann Bilder aber schnell mit Tastenkombinationen markieren, und danach mit der Suchfunktion diese Bilder selektieren um irgend etwas mit ihnen zu machen - etwa bestimmte Schlüsselworte hinzu fügen, sie zu verschieben oder sie in eine Sammlung aufnehmen. Ein anpassbares Plugin-Menü startet externe Programme mit den selektierten Bilddateien, z. B. GIMP. Diese Liste wird anhand von existierenden *.desktop-Dateien gemäß dem XDG-Standard für installierte Desktop-Anwendungen initialisiert. Dadurch werden automatisch jene Programme angeboten, welche die selektierten Bilddateien bearbeiten oder anzeigen können. Jedoch lassen sich die Einträge auch individuell bearbeiten, insbesondere um zusätzliche Einträge ergänzen. Plugins können auf einzelne Dateien beschränkt werden, oder die Bearbeitung beliebig vieler Dateien zugleich unterstützen. Es gibt einen Rechteck-Modus, wo man mit der Maus ein (ungefülltes) Rechteck ins aktuelle Bild zeichnen kann. Das kann bei Präsentationen hilfreich sein um die Aufmerksamkeit auf einen Bildausschnitt zu lenken. Weiters ist ein Diaschau-Modus vorhanden, wo selektierte Bilder mit definierter zeitlicher Verzögerung der Reihe nach oder zufällig automatisch angezeigt werden, optional auch in einer Endlosschleife. Falls Bilder für die Darstellung in der Größe verändert werden müssen, gibt es verschiedene Algorithmen zur Auswahl so dass auch langsame Rechner nicht überfordert werden. Weiters kann man beim Bildwechsel wählen ob dieser sofort erfolgen soll, so dass man auf langsamen Rechnern den Bildaufbau noch mitverfolgen kann. Oder ob Bilder erst im Hintergrund geladen werden sollen und angezeigt sobald sie vollständig dargestellt sind. Weiters unterstützt das Programm mehrere Stereo-Darstellungsformate für 3D-Brillen, und kann dann zusammengehörige Paare von Bilddateien als "3D"-Bilder anzeigen. Toolbars und Tastenkürzel sind anpasspar. Dateien werden per Vorgabe in einen "Mistkübel" gelöscht (definierberer Dateiordner oder gemäß XDG-Standard), dies lässt sich jedoch auch abschalten so dass sie sofort gelöscht werden.
gegl-0.0.22/media-libs/gentoo: Graph based image processing framework. GEGL provides infrastructure to do demand based cached non destructive image editing on larger than RAM buffers. Through babl it provides support for a wide range of color models and pixel storage formats for input and output. Floating point handling and processing and output of larger 8bit, 16bit integer and 32bit floating point per component buffers larger than RAM. Color correction. C, vala, C#, Python and Ruby interfaces.
geki2-KXL/games-action/gentoo {game}: Ein Xevious-ähnliches 2D-Spiel wo man nach oben scollt und dabei alle Raumschiffe abballert die einem entgegen kommen. Ein großes Plus: Autofeuer mit sehr hoher Frequenz standardmäßig und jede Menge Zusatzwaffen. Leider stirbt es sich trotzdem ziemlich flott, weil die Gegner ballern auch nicht wenig. Nachteil: Leider nur ein Fenster fixer Größe das nicht den ganzen Bildschirm einnimmt, und ausserdem keine redefinierbaren Tasten.
geki3-KXL/games-action/gentoo {game}: Dasselbe wie geki3, nur mit noch tolleren Waffen und von links nach rechts scrollend (wie "Delta" am C-64). Leider auch dieselben Probleme wie geki2. Könnte süchtig machen wenn es nur einen Vollbild-Modus hätte. So muss man leider manuell mit xrandr die Auflösung verkleinern oder ein Briefmarkenfenster akzeptieren. Fragt sich, ob das Spiel *diesen* Mehraufwand immer noch wert ist. Es gibt schließlich noch andere Ballerspiele.
genbackupdata-1.9-1/devel/devuan {backup}: Kein Backup-Programm, sondern ein in Python verfasstes Utility um Backup-Programme zu testen. Es ist ein Generator für Dateibäume, welche Backup-Programme danach testweise backuppen können. Es erzeugt Dateien und Unververzeichnisse pseudo-zufällig (aber wiederholbar mittels identischem Seed) gemäß den Einstellungen. Allerdings kann man im wesentlichen nur Limits für die Größe der erzeugten Dateiinhalte und der Tiefe des Verzeichnisbaums festlegen; die Dateinamen haben immer einen identischen Nummern-basierten langweiligen Aufbau. Es können sowohl binäre als auch effizient komprimierbare Textdateien erzeugt werden. Die Dateiinhalte können optional in Blöcken einer gegebenen Größe (also deren Vielfachem als Dateigröße) erzeugt werden. Um inkrementelle Backups zu testen, kann das Programm auch bereits vorhandene Dateibäume pseudo-zufällig verändern, indem es neue Dateien hinzufügt, bestehende verschiebt, löscht, oder ihren Inhalt verändert. Diese Möglichkeiten lassen sich separat konfigurieren (absolute Anzahl von Dateien oder als Prozentwert der bereits vorhandenen Dateien). Was dem Programm offensichtlich fehlt ist eine Option, Teile von bestehende Dateien in andere zu kopieren, damit man auch nicht-triviale Deduplikations-Szenarien testen kann.
gentoo-0.20.7-1/x11/raspbian {file manager}{GUI}{X11}: Two-pane file manager written by an obvious fan of Amiga's "Directory Opus" - it has the same mediocre user interface, only a lot uglier than the original Amiga version. However, it seems to be quite powerful and the level of detail for filetype configuration is among the best there is. Unfortunately it does not feature tabs for multiple directories, so only the directory history can be used to emulate this to some extent. A quick glance at the user interface tells that file manager is for experts only, definitely not for casual users. On the other hand, with an installation size of about 1.5 MiB it is also exceptionally small. Perhaps it might be good to have it installed as a fallback file manager. One annoying bug of the above version is that it does not seem to be capable of entering directories which are in fact relative symlinks.
gentoo-artwork-0.4.2-r1/x11-themes/gentoo: Viele Icons und Hintergrundbilder für Gentoo. Enthält auch Icons für viele verschiedene bekannte Applikationen in einem einheitlichen Style.
gentoo10-backgrounds-20110309/x11-themes/gentoo: Zwei paar fade und abstrakte Hintergrundbilder in mehreren unterschiedlichen Farbtönen, Seitenverhältnissen und Auflösungen. Schwach.
gforth-0.7.3+dfsg-4/interpreters/devuan: Zwar kann man nicht gerade behaupten dass es sich um ein auch nur ansatzweise schlankes FORTH handeln würde - das Git-Repository ist nach dem Download (nach minimieren, ohne Checkout, und es wurde nur das neueste Commit heruntergeladen) satte 2,8 MB groß. Dafür ist es aber auch sehr vollständig und bringt Support für viele CPU-Architekturen mit: 386, 4stack, 6502, 8086, alpha, amd64, arm, arm64, avr, c165, generic, h8, hppa, ia64, lm32, m68k, mips, mipsel, misc, nibz40, power, r8c, sharc, shboom, sparc, tile. Jeweils mit Assembler- und auch Disassemler-Support für jede Architektur in FORTH. Dafür ist aber ein 1,5 MB großes (zumindest die HTML-Version nachdem diese gebaut wurde)  Handbuch inklusive schönem Tutorial dabei und sicherlich unterstützt gforth alles was man sich wünschen könnte. Ich habe ermittelt, was in einem chroot-jail erforderlich ist um das FORTH zum Laufen zu bekommen: 140K bin/gforth, 44K lib/libltdl.so.7.3.1, 32K lib/libffi.so.6.0.4, 144K lib/ld-2.24.so, 336K lib/libm-2.24.so, 16K lib/libdl-2.24.so, 1,8M lib/libc-2.24.so, 220K usr/lib/i386-linux-gnu/gforth/0.7.3/gforth.fi, 2,7M insgesamt. So oder so - vermutlich ein tolles Arbeitssystem, aber nicht schlank.
ghc/dev-lang/gentoo: Der Glasgow Haskell Compiler. Der 2009 beliebteste Haskell-Compiler. Benötigt sich selbst zum Bootstrappen, d. h. er wird als Binärversion mitgeliefert um sich danach selbst zu übersetzen. Nicht gerade das kleinste Installationspaket: Installationsumfang über 300 MB, hinzu kommen noch 40 MB Download (30 MB Binary, 10 MB Quelltexte). Das ist fett! Aber alle Sprachtheoretiker lieben Haskell. Praktiker offenbar weniger, denn mir wäre keine bekannte Applikation geläufig, die in Haskell geschrieben ist. (Über "Parrot" wollen wir einmal vornehm schweigen.)
ghex/app-editors/gentoo {hex-editing}{GTK+}: Gnome Hex editor. Rather useless, because it requires to load the entire file into RAM for editing.
giggle-0.7-3/vcs/devuan {version control}{GTK+}: Download 1,8 MB, installiert 2,7 MB. Man sieht sofort: Dass ist der GNOME-Gegenspieler von git-cola. Sieht übersichtlicher aus, scheint aber auch weniger zu können. Es wird vom vom Projektmodul des "kate"-Editors direkt unterstützt.
gimageview-0.2.27-r2/media-gfx/gentoo {graphics image viewer}: Und noch ein Programm zur Fotoanzeige und zum simplen organisieren unter GNOME. Keinerlei Nachbearbtungsfunktionen; reine Anzeige. Kann Fotos nur in andere Verzeichnisse verschieben, kopieren, symlinken etc. Keine Rotation. Thumbnail, Slideshow, Einzelbild - das war's. Kein JPEG-2000. Einziges Highlight: Kann die Bilder nach mehr Kriterien sortieren als die meisten anderen Programme, etwa nach Fläche der Bilder, inode change time und anderem. Simpel, aber aufgeräumt. Mit Ausnahme des hübscheren GUI dürfte es aber dem kleineren gqview in jeder Hinsicht unterlegen sein. Allerdings ist auch gimageview ein relativ kleines Programm mit noch akzeptablem Umfang-zu-Funktionalität-Verhältnis.
gimp-2.8.18-1+deb9u1/graphics/raspbian {bitmap image editor}: Der "Über-Bitmap-Foto-Editor" für Linux und der beste OpenSource-Konkurrent für "Adobe Photoshop" (obwohl immer wieder behauptet wird dass Gimp an diesen dennoch bei weitem nicht heran reichen soll). Kann zwar irrsinnig viel, aber selbst die simpelsten Operationen wie das Ziehen einer Linie werden zur Wissenschaft die langes Herumsuchen in der Dokumentation erfordert. In meinen Augen ist das Programm völlig unintuitiv zu bedienen und eine Usability-Katastrophe. Gleichwohl gilt das nur für Gelegenheits-Benutzer; wer viel mit Gimp arbeitet wird die entsprechenden Arbeitsabläufe wohl rasch erlernen und dann sehr gut mit dem Programm arbeiten können. GIMP bietet alles was man von einem Photobearbeitsprogramm erwartet: Viele Filter, Layers, zahlreiche Datenformate werden unterstützt. Es hat auch Vektor-Funktionalitäten, die aber nicht mit expliziten Vektorzeichenprogrammen wie InkScape mithalten können. Ein Vorteil von GIMP sind auch die vielen Makros (in einem LISP-Dialekt verfasst) die diverse Benutzer dafür geschrieben haben, und die man auch selbst erstellen kann. Ebenso kann man Erweiterungen in C/C++ dafür schreiben. Trotz all dieser unbestreitbaren Vorteile benutze ich GIMP immer nur dann wenn keine anderes Programm für eine gegebene Aufgabe ausreicht. Denn nahezu jedes andere Programm ist benutzerfreundlicher, zumindest für Gelegenheitsnutzer.
git-1.5.1.6/dev-util/gentoo {version control}: Snapshot-basiertes Versionsverwaltungssystem. Der Zustand aller Dateien im Projektverzeichnisbaum wird eingefroren und kann komplett wieder rekonstruiert werden. Riesennachteil: Jede Revision is im Grunde eine vollkommen eigenständige Einheit; Zusammenhänge zwischen einzelnen Dateiversionen in verschiedenen Revisionen werden nicht erfasst. Delta-Kompression erfolgt nur bei expliziten Pack-Operationen, und nur zwischen heuristisch gewählten Dateien ohne jede Garantie auf tatsächliche Ähnlichkeit des Inhalts. Aber sehr schnell und speichert Duplikate von identischen Dateiinhalten automatisch nur einmal unabhängig von jeder Revision. Weiters Möglichkeit zum gemeinsamen Verwenden von Repository-Teilen in anderen Repositories: Eine Repository-Liste kann als Suchpfad für die Suche nach Dateiinhalten angegeben werden.
git-cola-2.10-1/vcs/devuan {version control}{Qt}: Download 588 kB, installiert 2,4 MB. Ein komplettes Qt5-basiertes GUI für git. Hat auch eine Warnung wenn man beim Committen die Zeilen zu lange macht. Ärgerlicher Weise unterscheidet es dabei allerdings nicht zwischen der Überschrift und dem Rest-Kommentar. Scheint ansonsten recht viel zu können, und sieht klar besser aus als das klassische Tcl-GUI für git. Aber bevor ich heraus finde was die ganzen Menüoptionen tun, deinstalliere ich es mir lieber wieder... Scheint grundsätzlich aber das mächtigste der git GUIs zu sein. Es wird vom vom Projektmodul des "kate"-Editors direkt unterstützt.
git-gui-1 {version control}{GUI}{X11}: 2.11.0-3+deb9u5/vcs/devuan: Download 883,3 kB, installiert 2,3 MB. Das in Tcl geschriebene Original des git GUI. Nicht besonders schön, aber auch nicht schrecklich hässlich. Kann viel - vermutlich das zweitmächtigste GUI nach git-cola. Leider unterscheidet es eben so wenig zwischen der ersten und den übrigen Zeilen des Commit-Kommentars. Und anders als die meisten der neueren git-GUIs zeigt es nicht einmal die aktuelle Spaltenposition an. Daher völlig unbrauchbar zum Erstellen neuer Commits. Aber ganz passabel beim Durchsehen der Unterschiede.
gitg-3.23.0-1/vcs/devuan {version control}{GTK+}: Download 692 kB, installiert 3,4 MB. Das ist offensichtlich die GNOME3-Version eines git-GUIs. Mit den üblichen "Stärken" wie fehlendem Titelbalken, kryptischen Icons und bescheidener Funktionalität. Erinnert organisatorisch etwas an das Tcl-GUI, aber natürlich nicht optisch, und deutlich versimplifiziert. Es wird vom vom Projektmodul des "kate"-Editors direkt unterstützt.
gl-117-1.3.2-3+b1/games/devuan {game}: Simpler Kampf-Flugsimulator. Dürfte sehr wenig mit einem echten Jet gemein haben. Aber es gibt Tutorials, Gegner, und Missionen. Steuerung bevorzugt mit der Maus, dadurch aber auch sehr empfindlich/schwierig. Ca. 6 MB Installationsumfang.
gl-117/debian: Does not support OpenGL ES, so does not work on RasPi.
glimpse-4.18.7-3/text/devuan: Ein Indizierungs-System für Volltextsuche. Vielleicht interessanter ist jedoch dass dieses Paket auch das "agrep"-Kommando zur Verfügung stellt (welches auch von der Volltextsuche intern verwendet wird) und das Fuzzy-Search bzw. Ähnlichkeitssuche erlaubt. Angeblich ist glimpse sehr beliebt. Allerdings fiel mir auf, dass das Maximum an Unterschieden welches noch als "ähnlich genug" angesehen ist maximal 8 betragen kann - das erscheint mir sehr wenig für längere Suchtexte (wie lange Dateinamen). Und ein Test zeigte auch: Er findet etwa bei umbenannten Filmen keinen einzigen Treffer, obwohl der eigentliche Filmtitel als Teil des Namens identisch blieb. Des weiteren können Suchbegriffe maximal 32 Zeichen lange sein - auch eher unbrauchbar, vor allem wenn man nach Klartext sucht. Noch dazu Außerdem unterstützt "agrep" kein UNICODE - oder nur eingeschränkt. Aber vielleicht ist das auch nur bei chinesisch & Co ein Problem. Bei einem Test fand "glimpse" einen Suchbegriff mit Umlauten sehr wohl. In Summe eher eine halblustige Spielerei als ein Volltext-Suchwerkzeug.
glipper-2.4-4/utils/devuan {clipboard manager}{GTK+}: In Python implementiert. Erfordert einen laufenden DBUS-Session-Daemon um zu funktionieren. Es bietet einen Traybar-Icon mit grafischer Konfiguration. Allerdings gibt es *keinen* Menüpunkt zum Beenden von glipper! Man kann separat auswählen, ob das Clipboard und die primäre Maus-Selektion vom Programm kontrolliert werden sollen. Allerdings kann man nicht auswählen, ob die beiden Quellen mit einander synchronisiert werden sollen. glipper arbeitet dabei so, dass die beiden Quellen nicht synchronisiert werden, aber Daten von beiden in denselben Verlauf aufgenommen werden. Wenn man allerdings einen Eintrag des Verlaufs auswählt, wird dieser in beide Quellen (dann wohl eher Senken) geschrieben. Es gibt eine Option, ob der Verlauf beim Beenden des Programms gespeichert werden soll. (Und anders als bei diodon-1.0.3 wird dies auch beherzigt.) Löblich ist, dass alle "unnötigen" Funktionen wie benutzerdefinierbare Aktionen in Plugins ausgelagert sind. Das spart Ressourcen. Die Plug-Ins haben ihre eigenen Konfigurations-Dialoge, wo erforderlich. Einige der Plug-ins wirken auch interessant, nämlich dass mehrere glipper-Prozesse ihren Verlauf mit einander synchronisieren können. Damit lässt sich über Maschinengrenzen hinweg die Zwischenablage synchronisieren. Die erfolgt direkt über TCP, wobei man Maschinen-Adresse und ein Passwort eingeben muss. Die übertragenen Daten werden mit diesem Passwort AES-verschlüsselt, allerdings leider nur im ECB-Mode, was relativ unsicher ist. Zudem scheint es keinerlei Schutz gegen Replay-Attacks oder böswillige Manipulation der Daten zu geben. Mit anderen Worten, nicht sehr sicher. Es empfiehlt sich daher, dieses Plug-in nur über SSH-Tunnel oder VPNs zu verwenden, und auch dann nur wenn auf beiden Maschinen keine anderen User sind welche die Daten am jeweils lokalen Tunnel-Ende abgreifen könnten. Was den Ressourcenbedarf der Kernprogramms angeht, erkennt man allerdings rasch dass glipper ein Python-Script ist: 50 MB virtuell (was noch OK wäre da diodon dasselbe belegt), jedoch leider auch 33 MB echten RAM-Bedarf (RSS). Und dies, obwohl kein einziges Plug-In aktiviert war. Als ich alle 4 mitgelieferten Plug-Ins aktiviert hatte, wurden 60 MB virtueller Speicher belegt - allerdings kaum mehr RAM. Allerdings sind diese Zahlen wohl ohnehin starken Schwankungen unterworden, da Python eine GC-basierte Sprache ist, allesamt die grundsätzlich mehr RAM benutzen als nötig wäre. glipper bietet keine explizite Möglichkeit, den Verlauf abzuschalten. Aber wenn man die Größe des Verlaufs auf 0 setzt, erreicht man dasselbe. Alles in allem ist gclip grundsätzlich OK, hat allerdings den größten RAM-Bedarf aller Kandidaten. Der einzige Vorteil ist, dass man Plugins hier sicherlich am einfachsten selbst entwickeln könnte, da es nur Python-Scripte sind und man sich mit keinem Compiler herumärgern muss.
glpk-4.45/sci-mathematics/gentoo: Eine GPL-Bibliothek sowie ein Kommandozeilentool zum Lösen linearer Optimierungsprobleme mit Unterstützung bedingter Ganzzahligkeit. Im Gegensatz zum ähnlichen lpsolve arbeitet dieses Paket allerdings mit mehrfachgenauer Arithmetik, was beliebig genaue Ergebnisse ermöglicht. Weiters wird es von mit wesentlich umfangreicherer Dokumentation ausgeliefert. Ein Nachteil ist die Lizenz.
gltron/games-action/gentoo {game}: Sehr tolle TRON-Adaption und echt spaßig im LAN gegeneinander. Leider ziemlich tödlich für wenig stabile Grafikkarten-Treiber.
gmp-5.0.2/dev-libs/gentoo libgmp-dev-2:6.2.1+dfsg1-1.1/libdevel/raspbian: Eine LGPL-3-lizensierte Bibliothek für beliebig genaue Integer-, Bruch- und Fließkomma-Arithmetik. Verwendet teils aufwändige Algorithmen zur Beschleunigung, etwa FFT für sehr große Multiplikationen. Im Gegensatz zu älteren Versionen dieser Library die wegen der GPL-Lizensierung in kommerziellen Produkten nicht eingesetzt werden konnten, gibt es keine derartige Beschränkung für diese Version mehr. Zumindest Debian ist der Meinung, aus Lizenzgründen keine lokale Entwicklungs-Dokumentation für diese Library installieren zu können. Man muss also ständig auf die Webseite zugreifen, oder sich diese mit wget downloaden. Ärgerlich. Ein weiteres Problem ist die dynamische Speicherallokation der Library. Default-mäßig wird das Programm nach der Ausgabe einer Fehlermeldung sofort beendet, ohne dass es eine Chance zum Aufräumen erhält (ob atexit noch abgearbeitet wird ist unspezifiziert). Jedoch lassen sich eigene Speicherallokationen definieren, welche dann selbst entscheiden können wie sie Fehler behandeln. Dabei sind jedoch Grenzen gesetzt: Es ist nicht erlaubt dass ein Fehler in einer der Funktionen ein longjmp() oder eine C++ Exception durchführt, um zu verhindern dass das Programm verlassen wird. Es ist im Gegenteil zwingend vonnöten das Programm nach der Fehlerbehandlung zu verlassen. Offensichtlich können sich interne globale Variablen nach einem Fehler in einem undefinierten Zustand befinden, so dass es nicht möglich ist weiterhin Funktionen der Library aufzurufen. Diese Beschränkung soll zukünfig "möglicherweise" entfernt werden. Derzeit ist es ein ernstes Problem für saubere Programme. Man kann man die Funktionen nur in einen separaten-Service-Prozess auslagern, der nach einem Fehler neu gestartet wird, oder sich bei der Benutzung auf Low-Level-Funktionen beschränken die keine eigenen Speicherallokationen durchführen.
gnome-calculator-3.30.1-2/math/debian {calculator}{GTK+}: Der Eigenwillige. Ein in GNOME3-Optik gehaltener Taschenrechner. Was bedeutet: Grundsätzlich schlicht, übersichtlich und nicht überladen aussehend. Aber dafür eine beschissene non-Standard Fenstertitelzeile da GNOME3 sich zu gut dafür ist der unter X11 üblichen Aufgabentrennung zu folgen, dem zu folge der Fenstermanager für die Titelzeile eines Fensters zuständig ist. Obgleich der Rechner im "Standardmodus" nur die üblichen Basis-Funktionen bietet, wirkt er optisch etwas seltsam da Zifferntasten und Operationstaten weder von einander abgesetzt noch farblich unterschieden sind. Einzig die "="-Taste hat eine andere Farbe. Anders als die meisten Konkurrenten lässt sich dieser Taschenrechner auch nicht über den Ziffernblock bedienen. Drückt man die Tasten im Fenster, fügen sie einfach Zeichen in das Textfeld ein, in dem der auszuwertende Ausdruck steht. Das ist sehr unterschiedlich zur üblichen Bedienung eines Taschenrechners. Qalculate! hat etwa zwar ebenfalls ein Textfenster, aber wenn man die Tasten im Fenster drückt wenden die Operationstasten wie die Wurzel immer auf den Wert in der Anzeige an, und nicht erst auf den nachfolgend eingegeben Ausdruck wie gnome-calculator. Eine Besonderheit dieses Rechners ist sein "Papierstreifen". Sprich der Rest der Fensterhöhe, welcher nach dem Abzug des Tastenfeldes und des immer 2-zeiligen Text-Eingabefeldes übrig bleibt, wird für einen vertikale Liste der bisherigen Berechnungen verwendet. Allerdings auch dies etwas eigenartig: Anstatt wie auf einem richtigen Papierstreifen-Rechner befindet sich nicht nur eine Zahl und ein Operatorsymbol in jeder Zeile. Sondern jede Zeile enthält links den Ausdruck den man ins Textfeld eingegeben hat, dann ein "=", und rechts davon das Ergebnis. Die "=" sind dabei alle exakt unter einander angeordnet, wenn Formel oder Ergebnis zu lange werden, werden sie einfach mit "..." abgekürzt, doch das "=" bewegt sich keinen Millimeter um dies zu verhindern. Immerhin kann man auf jeden Eintrag - egal ob links oder rechts vom "=" im Papierstreifen klicken, und dies wird dann ins Textfeld eingefügt. Es gibt 5 Modi: Den erwähnten Standardmodus mit den Grundrechenarten, Klammern, Wurzel und Quadrierfunktion (interessanterweise fehlen eine 10er-Exponenten-Taste und eine Taste zum Vorzeichenwechsel; auch Speicher gibt es keinen). Den "erweiterten Modus" der einen wissenschaftlichen Taschenrechner entspricht. Hier gibt es immerhin auch die vermisste Exponentialtaste, aber nach wie vor keinen Vorzeichenwechsel. Dafür kann man aber mit komplexen Zahlen rechnen. Und einen Speicher gibt es hier auch - wenn auch ziemlich eigentümlich: Es gibt dafür nur eine Taste "x", und wenn man diese drückt poppt ein kleines Fenster auf wo man erst einen Variablennamen auswählen oder neu eingeben muss, bevor man etwas in diesen speichern kann. Jedenfalls lächerlich umständlich! Schließlich gibt es den "finanztechnischen" Modus, der aber nur wenige Finanzfunktionen bietet und in erster Linie ein Währungs-Umrechner zu sein scheint. Auch hier kein Vorzeichenwechsel zu entdecken. Im "Programmiermodus" kann man wie erwartet mit den üblichen Zahlensystemen und bitwise-Arithmetik arbeiten. Zusätzlich gibt es aber dort nicht erwartete Funktionen wie Fakultät, Logarithmen oder Nachkommastellen-Isolation. Als letztes gibt es den "Tastatur"-Modus, der bei dem einfach das Tastenfeld ausgeblendet wird und man hat nur noch das Eingabefeld. 38 MB RAM-Verbrauch, 6,6 MB Installationsumfang, 1 MB Download. Alles in allem bleibt bei diesem Taschenrechner vor allem der Eindruck "eigentümlich". Grundsätzlich kann er alles relevante, aber es sieht alles etwas seltsam aus und funktioniert noch seltsamer. Freilich trifft das auch für GNOME3 insgesamt zu, weshalb man dies dem Programm vielleicht verzeihen sollte. Schon mehr stört dass einige essenzielle Funktionen wie Vorzeichenwechsel fehlen und die Bedienung des Speichers unintuitiv und umständlich zu sein scheint. Außerdem verrät das Programm GNOME2-typisch niemandem seinen Namen - es bezeichnet sich einfach nur als "Taschenrechner". Was sehr lustig ist wenn man 5 Taschenrechner installiert und sich fragt welcher davon dieser Menüeintrag im Startmenü wohl wäre.
gnome-calculator-3.38.2-1/math/debian {calculator}{GTK+}: Der GNOME3-Taschenrechner. Hieß früher wohl einst "gcalcool". Auf Deutsch heißt er "natürlich" einfach nur "Taschenrechner" - im der GNOME-Tradition verwirrender Namen zu folgen, falls mehr als ein Programm mit derselben Funktion installiert ist. Er kennt folgende Betriebsmodi: "Standardmodus" (enthält neben Prozenttaste immerhin auch Quadrieren und Wurzel, Vorrang-Klammer-Tasten sowie eine AnzeigeLöschtaste, seltsamer Weise keinerlei Speicher-Register), "Erweiterter Modus" (siehe unten), "Finanztechnischer Modus" (inklusive Währungsumrechnung), "Programmiermodus" (Radix-Bases 1, 8, 10, 16; bis zu 64 Bit Wortbreite, auch hier ein paar unübliche Funktionen wie getrenntes Einer- und Zweierkomplement oder das Faktorisieren in ein Primzahlprodukt) sowie der "Tastaturmodus" (keine Tastendarstellung bis auf jene zum Einheitenumrechnen - ansonsten nur ein Eingabefeld wo man Ausdrücke eingeben, welches aber in allen anderen Modi genau so existiert). Allen Modi ist gemeinsam dass sie nur mit Ganz- oder Fließkommazahlen rechnen, mit jeweils maximal 64 Bit Auflösung. Die Bedienung entspricht in keinem Modus *wirklich* einem Taschenrechner, da man z. B. zuerst die Wurzeltaste drücken muss und erst dann ihr Argument eingeben. Das liegt daran dass die Bildschirmtasten nichts anderes tun als Text ans Eingabefeld hinten dran zu fügen, und in der Formelschreibweise kommt der Funktionsname natürlich immer zuerst. Weiters gibt es keine Taste für das Wechseln des Vorzeichens. Auch hier muss man am Anfang bereits vor der Zahl ein Minuszeichen schreiben. Nur im "Standardmodus" gibt es keine Speicher-Funktion, in den anderen Modi wird es - verwirrend da es ähnlich wie das Multiplikationssymbol aussieht - durch eine "x"-Taste bereit gestellt, wo man neue Variablen erzeugen kann oder mittels Drop-Down Menü ihre Inhalte abrufen kann. Dabei gibt es zwei Pseudo-Variablen: "_" ist der Wert des letzten Ausdrucks, und "rand" erzeugt eine Zufallszahl zwischen 0 und 1. Alles davon wird allerdings als Spezialfunktion bzw. Variablenname und nicht etwa direkt als Zahlenwert in das Formelfeld eingefügt. Einfacher geht die Zuweisung mit der Tastatur, man schreibt dazu einfach "variablenname = ausdruck" und schon ist die Variable gesetzt. Das Rechnen mit komplexen Zahlen funktioniert tatsächlich auch im "Standardmodus", indem man die Wurzel aus einer negativen Zahl berechnet. Dies wird auch mathematisch korrekt als "i" angezeigt. Nur direkt eingeben kann man im Standardmodus keine komplexen Zahlen. Das User-Interface sieht in allen Modi grundsätzlich gleich aus: Oben die "Anzeige" - eine Liste mit den letzten Ausdrücken sowie deren Ergebnissen, das aktuelle als unterstes. Darunter dann die Eingabezeile für den aktuellen Ausdruck, die sich nach dem Drücken der "="-Taste in das fett gedruckte Ergebnis wandelt. Darunter schießlich die Tasten welche der jeweilige Modus anbietet, und die nichts weiter tun als Text ins Eingabefeld für den Ausdruck an der aktuellen Stelle einzfügen. Abhängig von Modus befindet sich direkt über oder unter der Anzeige noch ein Feld für die Winkeleinheiten-Umrechnung oder Währungsumrechnung (nur Finanzmodus) oder Zeichenkonvertierung (nur im Programmiermodus; man gibt ein Zeichen ein und erhält eine vorzeichenbehaftete Ganzzahl, eine seltsame Codierung des UNICODE-Codepoints, höhere Codepoints sind negativ). Dieses Feld besteht (außer im Programmiermodus) aus zwei Klappfeldern zur Einheitenauswahl sowie einem Button welche den Wert der Anzeige von oder in die jeweilige Einheit umrechnet. Im Standardmodus und Programmiermodus fehlt dieses Feld jedoch. Im Formelgeld gibt es mehr Umwandlungsfunktionen als jene aus den Klappfeldern. Es können folgende Dinge konvertiert werden: Länge/Flächen/Volumen, Masse, Zahlenbasis, Zeit, Zeichencodierung. Die Hilfe schreibt nicht einmal was für ein Einheiten genau umgerechnet werden können und gibt nur ein paar Beispiele. Ausprobieren ist angesagt. Eine weitere in Taschenrechnern unübliche angebotene Funktion ist eine für das Runden - leider nur auf Ganzzahlen. Aber man kann kann natürlich das Ergebnis für Nachkommastellen dividieren. Der Erweiterte Modus bietet eine Alternative zum (ebenfalls vorhandenen) Potenzierungs-Operator, indem man Text sowohl hochgestellt als auch Tiefgestellt eingeben kann. Hochgestellter Text wird als Potenzierung interpretiert. Tiefgestellter Text dient scheinbar nur zur Verwendung in Variablennamen, wie etwa "iSUB2" wenn "SUB" das tieferstellen an dieser Stelle einleiten würde. Funktionen lassen sich auch selbst definieren. Das geht entweder über den Dialog zur Auswahl zusätzlicher Funktionen, oder man gibt es einfach als "myadd(arg1; arg2) = arg1 + arg2" ins Formelfeld ein. Alles in allem ein eigentlich recht brauchbares Programm, wenn man sich an den fürchterlichen GNOME-üblichen Client-Side-Decorations nicht stört, wegen denen wie üblich der Titelbalken des Fensters fehlt. Außerdem hat es eine ärgerliche Eigenschaft: Die Fenster haben alle eine fixe Größe, man kann diese nicht ändern. Wenn man nur wenig Platz am Bildschirm hat und den Taschenrechner irgendwo zwischen zwei Fenster quetschen will - wird man bei diesem Programm eher Pech haben. Es ist mit 1,8 MB Download-Umfang immerhin relativ schlank (natürlich nur wenn man GTK+ bereits installiert hat), installiert mit 13 MB jedoch seltsamer Weise viel fetter. Mit 50 MB RAM-Bedarf während der Verwendung ist es allerdings leider - ebenfalls GNOME3-typisch - deutlich fetter als es den Anschein hat. Von der Bedienung her hingegen eigentlich nett. Für den Multi-Gigabyte-RAM Desktop daher eine interessante Option, am Raspberry Pi Zero hingegen eine schlechte Wahl.
gnome-clocks-3.22.1-1/gnome/raspbian {reminder}: Eine ganz eine tolle Clock-Applikation, leider im GNOME3-Stil und daher so hässlich, zumindest für die Augen von Nicht-GNOME3-Benutzern, dass ich sie mir sofort wieder deinstalliert habe um keinen Augenkrebs zu bekommen. Funktionen sind: Weltzeit-Uhr - eine sinnlos große Kachel (ja, wie bei Windows8) enthält eine Uhrzeit, viel ungenutzter Rand darum herum, und unter der Kachel steht dann die Stadt wo es diese Zeit gerade hat. Man kann beliebig viele solche Kacheln anlegen - bis einem der Platz am Bildschirm ausgeht, was nicht lange dauern kann. Allerdings stürzte das Programm ab bevor ich genug Zeiten hinzfügen konnte um dies zu testen. Weiters kann man Alarme setzen. Dazu kommt ein Dialiog mit einem riesigen Einstellrad wie man es vom Smartphone her kennt - zum Glück kann man die Zeit aber auch in das Rad eintippen anstatt sich am Rad zum Idioten zu kurbeln. Man kann Stunden, Minuten und Titel eingeben, sowie für jeden Wochentag festlegen ob der Alarm sich an ihm wiederholen soll. Weiters kann man den Alarm noch abschalten oder wieder einschalten. Das war es. Bei "Stoppuhr" gibt es die Buttons zum Starten, Stoppen oder Rundenzeit erfassen. Leider hat die Uhr eine sinnlose popelige Animation, die jede Menge Ressourcen vergeudet. Daher wird man vermutlich keine ausgedehnten Zeit-Intervalle damit stoppen wollen. Zumindest nicht wenn der Rechner auf Akku läuft. Und schließlich gibt es noch den "Timer". Der sieht ähnlich aus wie die Stoppuhr, nur dass er hinunter zählt. Die Animation ist hier wenigstens sinnvoll, denn sie zeigt die verbleibende Restzeit als Grafik an. Während die Stoppuhr läuft gibt es einen Button zum Pausieren und einen zum zurücksetzen. Das war es. Keine unnötigen Funktionen. Nur was man braucht. (Bis auf die Weltzeituhr, vermutlich.) Sieht auch alles sehr aufgeräumt und übersichtlich aus. So gesehen wäre es im Grunde ein Beispiel für gute Usability, wenn es bloß kein GNOME3-Programm  ohne Titelzeile wäre. Das sich daher einbildet sich nicht an die üblichen Konventionen halten zu müssen wie ein Programm mit dem Fenstermanager zusammen arbeiten sollte.
gnome-commander-git-1.2.8.5/app-misc/gentoo {file manager}{GTK+}: Das GNOME-Gegenstück des "Krusader" von KDE, also ein Dateimanager mit zweigeteiltem Fenster in der Tradition des Norton Commanders. Keine Unterstützung mehrerer Tabs mit unterschiedlichen Directories für die beiden Fensterhälften. Ein scheinbar noch relativ neues Programm; kann in Sachen Funktionsumfang mit dem Krusader nicht mithalten. Dafür ist es aber wesentlich stabiler und weniger buggy als die aktuelle Krusader-Version; kann deutlich weniger, das aber zufriedenstellend. Mein derzeit unterm Strich liebster Datei-Manager - allerdings nur deshalb weil Krusader derart buggy ist. Wenn das Ding noch Tabs unterstützen würde, wäre ich sogar ernsthaft damit zufrieden! Update 2010-07: Die neue Krusader-Version hat die schlimmsten Bugs behoben - das war's dann wohl mit dem Gnome-Commander. Zumindest bis zum nächsten "tollen" KDE-Update nach dem nichts mehr funktioniert.
gnome-keyring-2.32.1-r1/gnome-base/gentoo {security}: Ein Daemon, der das Backend für das Passwort-Caching und die eigentliche Schlüsselverwaltung für gnome-base/libgnome-keyring darstellt. Die Crypto-Algorithmen mit denen die Passwörter geschützt werden sind fix festgelegt: AES-128 zur Verschlüsselung und SHA-256 als Hashes. Zukünftige Versionen mögen einst andere Algorithmen verwenden, aber es ist nicht vorgesehen den Benutzer dies auswählen zu lassen. Der Daemon selbst bietet (natürlich) kein GUI, aber mittels app-crypt/seahorse steht ein solche zur Verfügung die durch libgnome-keyring bzw. den DBUS "Secret Service" mit dem Daemon kommuniziert. Der Daemin wird über dem XDG-Autostart-Mechanismus im Hintergrund gestartet und kann dann während der Sitzung über das libgnome-keyring API abgesprochen werden. Der Daemon kann mehrere Schlüsselbünde verwalten, einer davon mit dem namen "login" ist speziell, da er durch PAM direkt durch das Anmelden automatisch entsperrt wird. Genauer gesagt verwendet dieser Schlüsselbund das Login-Passwort als Pass Phrase, und PAM reicht ihm dies durch. Es ist möglich, in diesem Schlüsselbund auch die Passwörter für andere Schlüsselbünde abzuspeichern. Gleichwohl ist dies nur der Default; es ist sehr wohl möglich das Passwort auch für den Login-Schlüsselbund manuell zu ändern und dann ein anderes zu verwenden als für das Login. Ebenso kann man zusätzliche Schlüsselbünde anlegen deren Passworte nicht im "login"-Schlüsselbund gespeichert sind, und dann auf jeden Fall manuell eingegeben werden können. Das kann empfehlenswert sein, da man das Login-Passwort so oft eingeben muss, dass es selten ausreichend lange ist um besonders sicher zu sein. Andererseits, für "weniger geheime" Passworte ist ein "login"-Schlüsselbund der beim Login automatisch entsperrt wird vielleicht dennoch sinnvoll. Solange das Login-Passwort mit dem Passwort des "login"-Schlüsselbunds überein stimmt, wird PAM beim ändern des Login-Passwortes automatisch auch das Passwort für den "login"-Schlüsselbund ändern. Andernfalls sind die beiden Passworte getrennt und eine Änderung des Login-Passworts hat keine Auswirkungen auf das Keyring-Passwort für "login". Allerdings ist geplant, diese Möglichkeit später einmal zu streichen, so dass das "login"-Schlüsselbund Passwort immer identisch mit dem UNIX Login-Passwort sein wird. Aber auch in diesem Fall bleibt die Möglichkeit bestehen, zusätzliche Schlüsselbünde mit autarken Passwörtern anzulegen. Neben "login" gibt es noch einen weiteren speziellen Schlüsselbund namens "session" - dieser wird nie abgespeichert und existiert nur solange die aktuelle Login-Session besteht.
gnome-paint-0.4.0-4/graphics/debian {bitmap image editor}: Ein sehr minimalistisches Bitmap-Zeicheprogramm, dessen User Interface sogar noch spartanischer aussieht als gpaint. Toolbar-Funktionen: Bleistift (1-Pixel Freihand-Linie), Pinsel (Freihand-Linie mit wenigen vordefinierten Pinselformen in je 3 fixen Größen: rund, quadratisch, Diagonalstrich SW-NO, Diagonalstrich NW-SO), Linie, Sprühdose, Polygon, Rechteck, abgerundetes Rechteck, Ellipse, Bezier-Spline (Anfang, Ende, nur ein Kontrollpunkt), Füll-Kübel, Radierer, Farbpalette fixer Größe (jedoch jede Farbe redefinierbar). Für Werkzeuge die eine Linienbreite benötigen: eine fixe Auswahl von 5 Breiten. Für Werkzeuge die geschlossene Objekte zeichnen: 3 Flächen-Modi (mit Vordergrundfarbe füllen, mit Hintergrundfarbe füllen, nicht füllen). Es gibt eine Rechteck-Auswahl mit der man Ausschnitte irgendwie per Doppelklick verschieben / kopieren kann, und die Möglichkeit dabei optional irgend eine Form von Transparenz zu benutzen. Das funktioniert aber unintuitiv, so dass ich nicht herausfinden konnte wie es genau funktioniert. Es gibt 2 Werkzeuge die noch nicht implementiert sind: Text und Freihand-Auswahl. Menü-Funktionen: Undo/Redo, kippen/drehen (90 Grad-Schritte), invertieren. Kann nur ein Bild pro Programm-Instanz geöffnet haben. Keine Zoom-Funktionalität; nur Scrollbalken. Was außerdem fehlt: Größe ändern, beschneiden, Drucken. Fazit: Ähnlich wie gpaint, aber sogar noch schwächer als dieses. Ist mit rund 400 kB Installationsumfang aber auch um 100 kB kleiner als dieses. Empfehlung: Statt dessen besser gpaint nehmen, das mehr kann und in einigen Funktionen noch intuitiver zu bedienen ist. Das einzige Feature die je nach Arbeitsweise gnome-paint besser machen könnte, ist seine Undo-Funktion.
gnome-search-tool-3.6.0-1/gnome/debian: Und noch ein Opfer der GNOME3 "wir müssen alles anders machen als früher"-Devise. Früher ein sehr nettes grafisches Front-End für "locate", startet es nun nicht einmal mehr, wenn man es wagt es von einem anderen DTE als von GNOME3 aus zu starten. Kaputt!
gnome-system-log-3.8.1/app-admin/gentoo: Ein Systemprotokollbetrachter und das GNOME-Gegenstück zu ksystemlog. Es ist wesentlich simpler aufgebaut als letzteres und versucht gar nicht erst den Inhalt der Log-Dateien zu verstehen. Statt dessen zeigt es die Log-Einträge einfach als Text in einer Liste an, wobei es am Ende neu hinzu gekommene Einträge erkennen und in in dicker Schrift hervorheben kann. Es kann beliebige anwachsende Textdateien als Logdateien anzeigen, indem man diese einfach mit einer "Öffnen"-Funktion lädt. Das Programm merkt sich die geladenen Log-Dateien für spätere Aufrufe und zeigt sie in einer Seitenleiste an, so dass man dort die Logdateien die einen interessieren anlegen kann. Das Programm versteht einige Schreibweisen von Datumsangaben in Log-Einträgen, und unteilt dann das Log automatisch in Tage die als dynamisch generierte Untermenüs in der Seitenleiste (unterhalb des Dateinamens) als Datumsfilter verwendet werden kann. Die benutzung dieses Filters ist allerdings optional; man kann immer auch die gesamte Datei anzeigen. Des weiteren kann man benannte Filter definieren, die man global für jede einzelne Log-Dateien anwenden kann oder auch nicht. Diese Filter bestehen aus einer Regular Expression sowie 4 Aktionen welche bei Übereinstimmung durchgeführt werden sollen: Vorder- oder Hintergrundfarbe ändern, Einträgte verstecken oder nur übereinstimmende Einträge anzeigen.
gnome-system-monitor-3.30.0-2/gnome/debian {resource monitor}: Der einfach schönste Taskmanager. (Bei der GNOME3-Umstellung hat sein Aussehen stark gelitten, aber er sieht trotzdem noch ziemlich gut aus.) Allerdings ziemlich fett - 10 MB RAM. Jedoch immer noch deutlich schlanker als der ksysguard, der 4 x so viel RAM frisst. Der Installationsbedarf ist mit 4,5 MB auch nicht gerade schlank (der Download ist aber interessanter Weise nur 700 kB groß). Bietet ein hübsch und flüssig scrollendes hochauflösendes Diagramm von CPU, Speicher und Netzwerkauslastung, Balkendiagramme für den Füllstand aller gemounteten Dateisysteme, Prozessliste mit einklappfähigen ("folding") Vater-Kind Beziehungen und eine Systemübersichts-Seite. Bei der Dateisystem-Ansicht können optional auch alle Dateisysteme angezeigt werden, für diese wird der Füllstand aber immer als 100 % angezeigt da diese Information nicht verfügbar ist solange ein Dateisystem nicht gemountet ist. Andere Informationen wie Mount Point, Größe und Typ können aber auch in diesem Fall angezeigt werden. Die Zeilen in der Prozessliste sind alternierend gefärbt so dass man optisch gut im Auge behalten kann was zur selben Zeile gehört. Gleichzeitig wird die aktuelle Sortierspalte hervorgehoben und lässt sich durch Klicks auf den Spaltenkopf auf- oder absteigend auswählen. Ebenso kann die Spaltenreihenfolge per Drag & Drop verschoben werden und im Einstellungs-Dialog lässt sich die Anzeige jeder einzelnen Spalte individuell auswählen. In der Hinsicht auf die Spaltenkonfigurationsmöglichkeiten ist dies exakt dasselbe wie beim xfce4-taskmanager, nur dass es viel mehr Spalten zur Auswahl gibt und man sogar *alle* ausblenden kann wenn man will... dann sind die Zeilen leer. Bei der Auswahl welche Arten von Prozessen angezeigt werden sollen kann man zwischen allen Prozessen, nur denen des aktuellen Benutzers sowie nur gerade laufenden Prozessen wählen. Eine Unterscheidung zwischen Systemprozessen, eigenen Prozessen und denen anderer User wie in lxtask gibt es nicht. Allerdings ist die Einschränkung auf eigene Prozesse ohnehin die wichtigste, und die Einschränkungsmöglichkeit auf laufende Prozesse ist ebenfalls sinnvoll (und etwas das weder lxtask noch der xfce4-taskmanager beherrschen). Das Aktualisierungsintervall für die Graphen und die Prozessliste kann unabhängig, frei und auch in Sekundenbruchteilen angegeben werden. Es gibt auch noch ein Feature "nach geöffneten Dateien suchen" das sinnvoll klingt, allerdings konnte ich nicht herausfinden wie es funktioniert. Alles in allem ein wundervolles Programm, nur zwei Dinge fielen mir negativ auf: Zum einen kann man bei der Prozessanzeige zwar wählen ob Vater-Sohn-Beziehungen hierarchisch dargestellt werden sollen oder nicht, aber das funktioniert nur wenn die Spalte "Prozessname" eingeblendet ist. Dies ist aber eine Platzverschwendung wenn man zusätzlich noch die Spalte "Befehlszeile" einblenden will da hier dieselbe Information doppelt vorhanden ist. Zum Zweiten herrscht im Programm das "Diktat des Spaltenkopfes": Während man die Breite der Spalten allgemein beliebig mit der Maus festlegen kann, ist es nicht möglich diese schmäler zu machen als die Breite des Textes im Spaltenkopf. Das bedeutet dann, dass man für salbungsvolle Bezeichnungen wie "Virtueller Speicher" eine ziemlich breite Spalte hat in der nur eine ziemlich kurze Zahl steht. gnome-system-monitor ist der Standard-Task-Manager von GNOME, hat aber keine besonderen Abhängigkeiten von GNOME und lässt sich auch problemlos für andere DTEs installieren. Trotz seiner Fettheit startet das Programm aber (zumindest auf einer zeitgemäßen Hardware) ausreichend schnell, dass keine merklichen Wartezeiten dadurch entstehen. Auf einem aktuellen Gerät lässt sich das Programm daher gut zur täglichen Arbeit anstatt lxtask oder xfce4-taskmanager verwenden ohne dass Komforteinbußen durch die Fettheit erkennbar sind.
gnome-terminal-2.30.2/x11-terms/gentoo {terminal emulator}{GTK+}: Das GNOME-Gegenstück zu kde-base/konsole. Ebenfalls ziemlich fett und ziemlich mächtig. VTE-basiert. Braucht GTK+ und das halbe GNOME als Abhängigkeiten. Dennoch vermutlich immer noch etwas schlanker als KDEs konsole. Oder auch nicht. Vermutlich auch nur für Leute interessant, die GNOME verwenden. Oder die halt besonders viele Features brauchen.
gnome-utils-2.32.0-r2/gnome-extra/gentoo: Einhält einige nützliche Zusatzprogramme für GNOME, die aber auch vom anderen DTEs aus nutzbar sind. Rund 8 MB Download zusätzlich zu GTK+. Enthält die folgenden Programme: "Festplattenbelegung analysieren" (Applikation "baobab") ist ein sehr nützliches Programm, um zu ermitteln was die Platzfresser auf der Festplatte sind. Kann sowohl die gesamte Festplatte als auch einzelne Unterverzeichnisbäume analysieren. Die Darstellung erfolgt als Balkendiagramm, hierarchisches Ringdiagramm oder als "Tree-Map", wo die Dateien als Rechtecke dargestellt werden und ihre Fläche dem Platzbedarf entspricht. Man kann wählen, ob die Analyse nur verzeichnisweise oder bis zur Ebene einzelner Dateien durchgeführt werden soll. Das Programm "Krusader" enthält eine ähnliche Unterfunktion; baobab ist aber ein unabhängiges Tool und benötigt auch keine KDE-Libraries. "Wörterbuch" (Applikation "gnome-dictionary") ist ein simples grafisches Interface zur Abfrage von Wörterbuch-Servern. Nichts besonderes. "Bildschirmfoto aufnehmen" (Applikation "gnome-screenshot") ist ein komfortables Programm zum einfachen Erstellen eines Screenshots. Es kann sowohl der ganze Bildschirm, ein einzelnes Fenster oder ein frei definierbarer Bereich aufgenommen werden. Auch ob der Mauscursor im Screenshort enthalten sein soll lässt sich einstellen. Eine Auslöseverzögerung lässt sich als Sekundenwert frei einstellen. Sogar simple Effekte wie "Rahmen" ode "Schlagschatten" lassen sich einschalten. Der Ergebnis kann entweder als Datei gespeichert oder in die Zwischenablage kopiert werden. "Nach Dateien suchen..." (Applikation "gnome-search-tool") ist ein grafisches Tool zur Suche nach Dateien in einem gegebenen Verzeichnisbaum. Es verwendet intern die Tools "locate", "find" und "grep". Die folgenden Suchkriterien (im Fall von mehreren immer UND-verknüpft) werden unterstützt: "Dateiname enthält", "Enthält den Text", "Geändert vor/nach X Tagen", Mindestgröße/Maximalgröße/Leer, gehört gegebenem Benutzer oder Gruppe, unbekannter Besitzer, "Dateiname enthält nicht", Regulärer Ausdruck für Dateinamen. Unterstützte Optionen: Verborgene- und Sicherungsdateien einbeziehen, Symlinks folgen, auch ein Dateisystem begrenzen. Keine Möglichkeit nach Verzeichnissen, Spezialdateien oder gezielt nach Symlinks zu suchen. Mit anderen Worten: Simpel, aber zumeist ausreichend. Außerdem ist es normalerweise sehr schnell da es auf der "locate"-Datenbank basiert. "Systemprotokollbetrachter" (Applikation "gnome-system-log") ist ein Textdateibetrachter für Systemprotokolldateien. Er besteht als 2 Panes - links eine schmale Liste der verfügbaren Protokolldateien, der Rest der Fensterbreite zeigt die in der Liste ausgewählte Protokolldatei an. Wenn die Datei bei der Anzeige ans Ende gescrollt ist, werden neue Einträge automatisch erkannt und angezeigt, so dass immer die letzte Zeile der Datei im Fenster zu sehen ist mit so vielen Zeilen davor wie ins Fenster passen. Es gibt eine simple Suchmöglichkeit und benutzerdefinierbare Filter. Diese werden benannt erstellt und basieren auf Regexes, die wählweise Zeilen verbergen oder Zeilen ganz oder teilweise hervorheben. Überdies gibt es eine Option überhaupt nur solche Zeilen anzuzeigen, in denen sich hervorgehobener Text befindet. Als verfügbare Protokolldateien werden initial diejenigen in /var/log/messages angezeigt für die man Leserechte handelt, man kann aber beliebige Dateien zur linken Pane hinzufügen und dann als Protokolldatei verwenden. Ein alles in allem sehr nützliches Paket. Installationsumfang ca. mitsamt einer erforderlichen Zusatzlibrary knapp unter 5 MiB zusätzlich zu GTK+.
gnote-43.1-1/gnome/raspbian {wiki}: Eine in C++ implementierte Notiz-Anwendung, welche ihre Notizen in einem "tomboy"-kompatiblen Format speichert. Im wesentlichen scheint es ein etwas schlankerer (im RAM-Verbrauch; das Executable ist hingegen doppelt so fett) Klon von "tomboy-ng" in GNOME3 Optik zu sein, welcher ein paar zusätzliche Features mitbringt. Siehe den Eintrag für tomboy-ng für eine genauere Beschreibung der gemeinsamen Features. Zumindest ein Feature scheint gnote zusätzlich zu haben: Es kann interne Hyperlinks zwischen den Notizen anlegen. Entweder kann tomboy-ng das nicht, oder ich konnte die Funktion bloß nicht finden. Daher auch die Einstufung als Wiki, zumindest ein sehr rudimentäres. Ein weiterer Unterschied ist dass gnote ein eigenes Fenster für die Bedienung anzeigt, während tomboy-ng darauf ausgerichtet ist (abgesehen vom Editieren der Notizen selbst) komplett über sein Traybar-Icon bedient zu werden. In diesem Fenster gibt es einen "Alle"-Karteireiter, wo sämtliche "Notebooks" (quasi Ordner) in der linken Fensterhälfte angeordnet sind, und rechts die Notizen des selektierten Notebooks in einer Liste angezeigt werden. Zusätzlich kann man jede Notiz als eigenen Karteireiter permanent (bis man ihn wieder schließt) öffnen. Das Programm merkt sich die offenen Karteireiter über Beendigung und Neustart hinweg. Ein weiterer Unterschied ist, das gnote sich markierten Text (via Maus oder Tastatur) merkt, so dass sie wiederhergestellt wird wenn eine solche Notiz später wieder öffnet.  Schließlich unterscheiden sich noch die Synchronisations-Möglichkeiten der Programme. Während tomboy-ng nur git oder einen Ordner im lokalen Dateisystem als Synchronisierungs-Gegenstelle unterstützt, beherrscht gnote kein git, ebenfalls lokale Ordner, zusätzlich aber auch WebDAV ond "Online Ordner" womit konkret Google Drive gemeint zu sein scheint. Vermutlich gibt es aber Plugins um noch andere Online-Dienste ansprechen zu können. Aber WebDAV ist schon einmal sehr gut, das ist relativ einfach einzurichten (serverseitig) und kann von vielen Programmen zum Datenaustausch verwendet werden. Weiters bietet nur tomboy-ng die Auswahl des Synchronisierungs-Intervalls (in Minuten an) falls automatische Synchronisation aktiviert ist; tomboy-ng kennt nur eine Stunde als Intervall. Die Synchronisation von Notizen zwischen tomboy-ng und gnotes funktioniert "out of the box" ohne spezielle Vorbereitungen. Allerdings ignoriert tomboy-ng Hyperlinks und abgespeicherte Text-Selektionen, da es dies nicht beherrscht. Falls man die Notiz in tomboy-ng bearbeitet, geht die gespeicherte Maus-Selektion dabei zwar verloren, die Hyperlinks bleiben aber erhalten. Schließlich fällt noch auf, dass gnote auch für Deutsch und einigen weiteren Sprachen lokalisiert wurde, tomboy-ng hingegen nur englische Menütexte und Dialoge kennt. Weiters gibt es offenbar viele Plugins für gnote, während tomboy-ng kein Plugin-System besitzt. Download 3,5 MB, 42 MB RAM-Verbrauch, 22 MB PSS, 146 virtuell. Fazit: gnote scheint als Nachfolger von tomboy-ng konzipiert worden zu sein und bietet weitgehend dieselbe Funktionalität plus einige Erweiterungen. Sein RAM-Verbrauch ist sogar geringer als der des Originals.
gnu-smalltalk-3.2.5-1.3+b2/interpreters/debian: Eine recht schlanke Smalltalk-Implementierung, die in erster Linie für Commandline-Scripte und -anwendungen konzipiert wurde, und anders als viele andere Smalltalk-Implementationen auch auf "Headless"-Systemen benutzbar sein soll. Tatsächlich erwies sich die Runtime als ziemlich schlank, gerade mal 6 MB RAM verschlingt die laufende interaktive Smalltalk-Shell welche zudem extensive Autocompletion-Features bietet. Natürlich konnte GNU sich erneut nicht beherrschen ein paar "Verbesserungen" in der Sprache vorzunehmen, so dass mir nicht ganz klar ist wie kompatibel dies zu ANSI Smalltalk tatsächlich ist. Statt dessen musste ich sofort an GNU Guile denken, wo versucht wird Scheme als Scripting-Sprache zu etablieren, doch dabei nich ganz dem Sprachstandard gefolgt wird. Verdächtig ist auch dass ich kein anderes Paket fand dass von GNU Smalltalk abzuhängen scheibt - große praktische Relevanz scheint es daher nicht zu besitzen. Und so etwas hat meist einen guten Grund. Auf jeden Fall dürfte die SqueakVM eine viel beliebtere Smalltalk-VM sein, die jedoch wiederum weniger (soweit überhaupt) für Scripting und Headless-Betrieb geeignet ist.
gnu-smalltalk-browser-3.2.5-1.3+b2/interpreters/debian: Sollte eigentlich eine visuelle grafische Oberfläche für die Smalltalk-Entwicklung darstellen. Ist selbst ebenfalls in Smalltalk geschrieben und liegt komplett als Scripte bzw. Quelltext vor. Problem jedoch: Es funktioniert schlicht nicht. Zumindest nicht unter x86-32. Beim Versuch zu starten kommen nur lauter Errors. Vielleicht funktioniert es unter amd64. Aber jedenfalls nicht sehr vertrauenerweckend.
gnuit-4.9.5-r1/app-misc/gentoo {file manager}{hex-editing}{text-terminal IO}: mc/htop für Arme. Bietet im wesentlichen einen 2-Pane File-Manager, einen Process-Viewer und einen Text/Hex-Editor. Alles im Character Mode. Ein "typisches UNIX Tool": Statt Menüs wie bei mc/htop werden verschrobene an den Emacs gemahnende Tastenkombinationen verwendet, die man ständig umständlich in der Dokumentation suchen muss. Das Ding startet standardmäßig monochrom, unterstützt aber auch Terminalfarben. Leider sind diese per Default schlecht lesbar (lässt sich aber sicherlich konfigurieren). Im Vergleich zu mc/htop wirkt das Programm in den Features extrem abgespeckt, aber dafür ist es auch nur halb so groß (1,5 MB) wie der mc (3 MB). Und htop mit 500 KB ist ja auch noch integriert. Vielleicht in einem initramfs oder so sinnvoll; auf einem System wo man nicht um jedes Byte kämpfen muss würde ich es jedenfalls nie installieren.
gnujump-1.0.8-3+b1/games/debian {game}: Ein Plattform-Hüpf-Spiel, wie der Name schon suggeriert. SDL Fullscreen-Grafik. Hat eigentlich eine recht hübsche flüssige Grafik, nur dass es dabei fast nichts zu sehen gibt. Im wesentlichen besteht der Bildschirm nur aus verschiedenen Ebenen die man durch Hüpfen erreichen muss. Es handelt sich dabei im wesentlichen um eine 2D-Scroller: Während der Bildschirm langsam von unten nach oben scrollt, muss man schneller als dieser die diversen Plattformen erhüpfen welche von oben kommend in den Bildschirm hinein scrollen. Dabei kämpft man - zumindest anfangs - gegen keinerlei Gegner oder Fallen, sondern ausschließlich mit der reinen Tastatursteuerung die einen immer wieder in den Tod stürzen lässt. Man stirbt jedoch auch dann wenn man den unteren Bildschirmrand berührt, weil man beim Springen auf die Plattformen nicht schnell genug erfolgreich war. Macht einen sehr schweren Eindruck auf mich, und ist auch nicht wirklich meine Art von Spiel. Wenn man friedliche Geschicklichkeitsspiele mag, möglicherweise aber ein Geheimtipp. Freilich weiß ich allerdings nicht ob das Spiel auch so friedlich bleibt wenn man weiter käme. Das Spiel hatte zumindest auf meiner integrierten INTEL Onboard-Grafik erhebliche Probleme mit der OpenGL-Darstellung (wildes Flackern), allerdings kann man diese abschalten und danach funktionierte alles prächtig und ohne erkennbare grafische Einbußen.
gnumeric-1.8.1/app-office/gentoo: Eine GTK+ basierte Tabellenkalkulation, die es durchaus mit den fetteren Office-Paketen aufnehmen kann und diese in Einzelbereichen - etwa dem "Solver" - sogar schlägt. So beherrsches es etwa quadratische Optimierung. Nun ja, außer man kommt auf die Idee diese auch einmal *anwenden* zu wollen. Dann erscheint nämlich ein lustiger Dialog wo einem mitgeteilt wird dass dieses Feature noch nicht implementiert ist, und man wird gefragt ob man nicht Lust hätte dies zu tun. Insgesamt ist der Funktionsumfang schon merklich geringer als der von OO Calc, aber dafür ist gnumeric auch zigmal schlanker. Im Vergleich zu kspread schien mir gnumeric hingegen deutlich überzeugender. Kurzum ein gutes Programm für Situationen wo einem OOo zu viele Ressourcen frisst.
go-md2man 1.0.5-1/community/archlinux: Kann angeblich Text mit "markdown"-Markup in man-Pages umwandeln. Leider funktioniert das aber nur bei den simpelsten markdown-Dokumenten; insbesondere versagt go-md2man wenn vom "markdown" unterstütztes HTML-markup im Dokument vorhanden ist. Daher praktisch wertlos. Besser das normale "markdown"-Paket nutzen, und die HTML-Ausgabe in Text umwandeln.
gocr-0.49-2/graphics/devuan {OCR}: gocr ist ca. 20 x schneller als Tesseract und liefert zwar allgemein wesentlich schlechtere, jedoch nachvollziehbare Ergebnisse welche offensichtlich unabhängig vom Kontext sind. Ein großer Vorteil ist dass man die Zeichen einschränken kann welche im zu erkennenden Text vorkommen können; so kann man vor allem bei Codes aller Art bessere Ergebnisse erzielen. gocr hat Problem mit Symbolen, die *keine* Zeichen sind (z.B. Icons), die ersten Zeichen hinter einem Icon werden nicht (korrekt) erkannt.
gocryptfs-1.6.1-1+b20/devel/debian {security}{FUSE}: Angeblich ein in in "Go" geschriebener Ersatz für das sehr nützliche encfs, jedoch ohne dessen notorische Sicherheitsprobleme. Grundsätzlich scheint es ganz gut zu funktionieren, und bietet erfreulicher Weise auch eine Option benötigte Zufallszahlen aus /dev/random anstatt /dev/urandom zu beziehen. Allerdings bietet es nur eine einzige Wahlmöglichkeit bezüglich der Verschlüsselung an, und zwar "AES-SIV" anstatt dem GCM-Mode (vermutlich ebenfalls mit AES) zu verwenden. Wobei nicht einmal erklärt wird wie viele Schlüsselbits verwendet werden. Der Ressourcenverbrauch ist allerdings erheblich: Ein kleines Testdateisystem belegte 870 MB virtuellen Speicher und 12 MB RAM. Zum Vergleich: EncFS belegt im Betrieb typischer Weise 50 MB virtuellen Speicher und 300 kB bis 3 MB RAM. Auf jeden Fall *deutlich* weniger. Sollte gocryptfs wirklich sicherer sein was noch zu verifizieren ist, mag man diesen Overhead in Kauf nehmen wollen solange man nur wenige solche Dateisysteme, etwa via NFS oder WebDAV-Shares, gemountet hat. Aber für den Dauergebrauch und wenn man sehr viele solche Dateisysteme mounten will, dürfte der Ressourcenverbrauch übel hoch sein. Zumindest die Basics scheinen aber zu passen: scrypt für die Schlüsselableitung, GCM mit 128 Bit IV, Base-64 codierte Dateinamen, jedes angelegte Directory erhält einen eigenen 128-Bit IV. Auch kurze verschlüsselte Dateien sind ausreichend lange, dass zumindest ein per-Datei IV sowie eine MAC darin Platz finden dürften. Die Dateien enthalten keine erkennbaren Header. Allerdings legt gocryptfs selbst einige Dateien mit einheitlichen Namen ab, so dass immer klar ist womit die Dateien verschlüsselt wurden. Das ist bei EncFS allerdings auch nicht anders, und insofern kein Nachteil.
golly-2.4/app-misc/gentoo {game}: Ein wirklich nettes und auch flottes (trotz dem in Python geschriebenes) "Game Of Life"-Spiel. Genauer gesagt kann es alle möglichen Arten von zellulären Automaten simulieren, und man kann die Regeln auch aus bestimmten Primitives aufbauend selbst festlegen. Das "Spielfeld" kann sehr groß sein und Zoom sowie Scrollbalken sind verfügbar. Der Knüller des Programms ist allerdings die große Library an mitgelieferten Basis-Patterns (wie Sliders, Kanonen usw.) und kompletten Spielfeldern, die man einfach nur abzuspielen braucht. Darunter natürlich vor allem besonders interessante Setups die dem Auge etwas bieten. Wirklich sehr nett gemacht!
gpa-0.9.1_pre20100416/app-crypt/gentoo {security}: Dies ist ein GTK+-basiertes grafisches Front-End für das Kommandozeilen-Tool "gpg" des GNU Privacy Guard ("GnuPG"). Es arbeitet auch mit dem "pgp-agent" zusammen um Passworte cachen zu können. (Dieser wiederum verwendet dann ein separates PIN-Entry Programm zur eigentlichen eingabe der Pass-Phrases.) Über den Menüpunkt "Backend-Einstellungen" können auch viele der Optionen aus den GnuPG-Konfigurationsdateien komfortabler editiert werden. Das Paket ist mit nur knapp über einem MiB und nur einer Hand voll Dateien Installationsumfang ein angenehm kleines Paket, zumindest verglichen mit anderen Paketen die annhähernd dasselbe bieten. Es ist auch in C/C++ verfasst und in keiner Script-Sprache - wodurch sich sicherheitsrelevante Aspekte wie das Handhaben der Pass-Phrases besser kontrollieren lassen (keine Garbage Collection etc). Allerdings ist das Programm tatsächlich nur ein grafisches Front-End; die eigentlichen Arbeiten werden alle von der Kommandozeilenapplikation "gpg", "gpg-agent" usw. durchgeführt. Das Programm besteht aus vier unterschiedlichen Fenstern die gleichzeitig oder auch nur einzeln geöffnet sein können und vier separate Teilgebiete der Funktionalität abdecken. "Schlüsselverwaltung" dient der Verwaltung des GnuPG-Schlüsselbundes. "Dateiverwaltung" erlaubt es Dateien zu der im Fenster angezeigten Liste hinzu zu fügen, um diese danach zu verschlüsseln usw. Leider ist diese Version buggy und stürzt ab falls man die Dateien per Drag & Drop zur Liste hinzu fügt, was sicherlich angenehm wäre und offenbar auch so gedacht ist. Daher muss man die Dateien klassisch über "Öffnen" zur Liste hinzu fügen. "Zwischenablage" bietet ein Textfenster in welches man Texte von und zur Zwischenablage kopieren kann, um diese danach genau wie in der "Dateiverwaltung" verschlüsseln usw. kann. Optimal um e-Mails zu verschlüsseln wenn das e-Mail-Programm keinen direkten Support für so etwas hat. "Kartenverwaltung" schließlich dient der Arbeit mit Smart-Cards; ich habe mir dies nicht genauer angesehen da ich keine PGP-fähige SmartCard besitze. Alles in allem ist gpa das grafische Interface mit für GnuPG dem besten Umfang/Leistung-Verhältnis das mir bislang unter gekommen ist. Eigentlich braucht man kein anderes.
gpaint-0.3.3-6.1/gnome/debian {bitmap image editor}: Ein sehr minimalistisches Bitmap-Zeichenprogramm. Toolbar-Funktionen: Bleistift (Freihand-Linie), Linie, Bogen (Ellipsen-Segment), Polygon, Rechteck, Ellipse, automatisch geschlossene Freihand-Linie, Füll-Kübel, Radierer, Freihand-Auswahl, Polygon-Auswahl, Text, dynamischer Pinsel (vermutlich: drucksensitiv), Farbpalette fixer Größe (jedoch jede Farbe redefinierbar), globaler Schalter "Füllen oder nicht" (für Rechtecke etc.), Pull-Down-Menü "Stiftbreite in Pixel", Pop-Up-Menü "Fontauswahl", Drucken. Menü-Funktionen: Copy/Paste von Selektionen, die wichtigsten Effekt-Filter, in 90 Grad-Schritten Rotieren, Spiegeln. Kann nur ein Bild pro Programm-Instanz geöffnet haben, jedoch sind gütigerweise mehrere Programm-Instanzen erlaubt. Was ich nicht finden konnte, war jedwede Zoom-Funktionalität. Wenigstens bietet es Scrollbalken... Was außerdem fehlt: Größe ändern, beschneiden, Undo. Fazit: Einfach und intuitiv zu bedienen und für alle Arten von schnellen Sketchen gut geeignet. Doch wegen der fehlenden Zoom- und Klon-Funktion nicht zur Foto-Nachbearbeitung geeignet.
gpe-2.8/gpe-base/gentoo {GPE}{DTE}: Die ganze Suite an GPE-Anwendungen; ein Meta-Paket. Eine Sammung an simplen Applikationen für PDAs.
gpe-calculator-0.2/gpe-base/gentoo {calculator}{GPE}{DTE}: Ein einfacher wissenschaftlicher Taschenrechner wie die billigen TI-Taschenrechner ohne Programmierfunktionen für die Schule. Nichts besonderes, aber OK.
gpe-calendar-0.92-6/utils/raspbian {PIM}{GPE}{DTE}{reminder}: Ein GTK-GUI Kalender. Ansichten für Tag, Woche, Monat und "Agenda" (Terminliste, sogar mit wählbarem Berichts-Bereich mit einer Granularität von Tagen, Wochen, Monaten oder Jahren). Kann sogar Alarme setzen, sogar mit Vorwarnzeit, wo dann zur Fälligkeit ein Fenster erscheint um einen darauf aufmerksam zu machen. Zumindest falls die Anwendung dann gerade läuft. (Es gibt ein Zusatz-Programm gpe-announce-0.14-2/utils/raspbian mit dem man theoretisch auch während der Kalender gerade nicht läuft einen Alarm gemeldet bekommen kann und es könnte sogar einen Sound abspielen, aber praktisch ist jenes andere Programm leider hoffnungslos veraltet und schafft es nicht mehr einen Sound auszugeben.) Man kann Einträge auch erstellbaren (Name und Farbe) Kategorien zuordnen. Termine können auch mit den folgenden Granularitäten wiederholt werden: Jährlich, monatlich (an einem bestimmten Wochentag, davon aber beliebig viele festlegbar: An jedem, dem 1., 2., 3., 4., vorletzten oder letzten des Monats), wöchentlich (einzelne Wochentage selektierbar), täglich. Alle diese Wiederholungen sind zudem mit einem Intervall ("alle N Monate" etc.) versehen. Weiters kann man auch einen Endtermin für die Wiederholung festlegen, entweder als Anzahl oder als Datum. Weiters kann man mehrere Kalender (mit unterschiedlichen Farben und Namen) anlegen, denen die Termine zugeordnet werden. Kalender können sogar von einander abhängen, so dass ein Termin in einem Unterkalender automatisch auch ein Termin im Hauptkalender ist. Es gibt 3 Typen von Kalendern: "Local" (einfach nur lokal gespeichert), "Publish" (wird auf einen Server hochgeladen, man gibt URL, Username und Passwort ein) und "Subscribe" (dieselben Angaben wie "Publish", und zusätzlich noch ein Update-Intervall wie oft am Server auf neue Versionen geprüft werden soll, von 1 mal pro Jahr bis 99 mal pro Stunde wählbar). Und, oh Wunder, der Kalender wird sogar in einer SQLite-Datenbank und nicht in einer Textdatei abgespeichert! Zwar unverständlicher Weise nur SQLite2.1, aber dennoch eine echte Datenbank. Außerdem ist das Paket sqlite-2.8.17-14/database/raspbian gerade mal 20 kB groß, und man braucht es zudem auch nicht um mit dem Kalender zu arbeiten. Alles in allem eine für GPE-Verhältnisse überragend mächtige Anwendung, die sich auch vor wesentlich größeren Lösungen nicht wirklich zu verstecken braucht. Und das beste, sie ist keine 200 kB groß! Offenbar in C++ und GTK+ implementiert.
gpe-clock-0.27-2/x11/raspbian {GPE}{DTE}{reminder}: Eine Uhr für den Traybar, die auch einen Alarm setzen kann, entweder an einem bestimmten Datum oder mit wöchentlicher Wiederholung bei auswählbaren Wochentagen. Dieses Programm ist immerhin der Beweis dafür, dass es irgend einen Standard fürs Docking von Applikationen an einen bereits laufenden WM geben muss, denn es versucht dort eine Uhrzeit-Anzeige einzufügen. Allerdings gelingt dies aufgrund völlig falscher Fontgröße nicht wirklich; man sieht nur die halbe Uhrzeit. Zumindest solange man die Zeit als Ziffern anzeigt. Wählt man die Analogdarstellung, so kann man die ganze Uhr sehen - mit einer Lupe. Der Dialog zum Einstellen der Alarme hat zudem ein Problem mit Umlauten, aber das ist nur ein weiterer optischer Makel und beeinträchtigt die Funktionalität nicht. Sobald der Alarm fällig ist und einen ein Fenster darauf hinweist, bietet dieses sogar eine Funktion zum Stummschalten und eine "Snooze"-Funktion die auf 5 Minuten voreingestellt ist, sich jedoch frei als Stunden und Minuten festlegen lässt. Es gibt ein Zusatz-Programm gpe-announce-0.14-2/utils/raspbian mit dem man theoretisch auch während der Kalender gerade nicht läuft einen Alarm gemeldet bekommen kann und es könnte sogar einen Sound abspielen, aber praktisch ist jenes andere Programm leider hoffnungslos veraltet und schafft es nicht mehr einen Sound auszugeben. Wegen dieser Defizite ist das Programm als Uhr unbrauchbar, aber ein passabler Wecker. Zumindest solange man am Gerät sitzt und das Alarmfenster sehen kann. Ein Luxus welcher diesem Programm fehlt ist ferner eine "Beenden"-Funktion. Man muss es abschießen. Am besten öffnet man eines der Fenster des Programms und wendet dann "xkill" darauf an.
gpe-contacts-0.49/gpe-base/gentoo {GPE}{DTE}: Eine "tolle" Adressverwaltung, die ziemlich genau wie der kleine Bruder des Adressbuches eines x-beliebigen Mail-Programms aussieht. Ein paar vordefinierte Felder pro "Karte", und man kann beliebig viele dieser Karten in einer Liste anlegen.
gpe-dm-0.51-r1/gpe-base/gentoo {GPE}{DTE}: Tut nichts wenn X schon läuft. Vermutlich der GPE X11 display-manager als Ersatz für xdm, kdm oder gdm.
gpe-edit-0.41-1/x11/raspbian {GPE}{DTE}: Ein an Simplizität wohl kaum zu unterbietender Editor. Einfach nur ein Feld in dem man herumeditiert. Sieht aus wie ein mehrzeiliges Edit-Control jedes x-beliebigen Toolkits. Immerhin *gibt* es einen Buttonbar mit den folgenden Funktionen "Neu", "Öffnen", "Speichern", "Speichern unter", "Suchen", "Suchen und Ersetzen", "Kopieren", "Einfügen", "Beenden". Übers Kontextmenü kommt dann noch "Ausschneiden", "Löschen" und "Alles Markieren" hinzu. Womit auch bereits alle Funktionen dieses Editor genannt wären. Dass die "Suche"- sowie "Ersetzen"-Funktion nur simple Substrings finden kann und keine Steuerzeichen wie "\n", "\t" oder gar RegExes unterstützt, versteht sich wohl von selbst. Außerdem öffnen diese Funktionen nicht etwa einen Dialog, sondern fügen unter dem Editierbereich ein (Search) oder zwei (Replace) weitere einzeilige Text-Felder samt "find" und "replace"-Button hinzu. Undo? Luxus; gibt es nicht. Das war's! Wenigstens beherrscht der Editor Line-Wrapping; das ist ja schon was. Außerdem hatte er keine Performance-Probleme mit einer mehrere MB großen Textdatei. Das tolle kwrite von KDE hat bei derselben Datei schlapp gemacht bzw. ist gekrochen! Und außerdem startet er blitzartig. Sein einziges echtes Problem ist dass man keine Schriftart auswählen kann, sondern er immer irgend eine proportionale Systemschriftart benutzt. Das macht ihn für Quelltexte leider unbrauchbar.
gpe-filemanager-0.31-2/utils/raspbian {GPE}{DTE}{file manager}{GUI}{X11}: Viel simpler geht es nicht mehr: Ein Directory Pane mit URL-Zeile und ein File Pane. In der File Pane gibt es ein Kontextmenü mit den üblichen Einträgen wie Open, Rename, Copy, Paste etc. Immerhin gibt es die Wahl zwischen detaillierter Ansicht und Icon-Ansicht. Tabs? Drag and Drop? Mehrere Panes für unterschiedliche Verzeichnisse? Bookmarks? Luxus! Gibt es alles nicht. Wenn man Dateien von Directory A nach B kopieren will, muss man erst nach A gehen, dort die Files markieren und "Copy" aufrufen, dann zu B navigieren und dort "Paste" ausführen. Und dann wieder zurück zu A navigieren um das nächte Set an Files zu bearbeiten. Das kann mühselig werden wenn die Files in vielen Directories verstreut sind! Vermutlich wird erwartet, dass man in solchen Fällen mehrere Instanzen des Programmes laufen lässt, eine pro Zielverzeichnis, um das Problem so zu umgehen. Aber: Es gibt nicht einmal eine Funktion, um ein Verzeichnis mit einer neuen Instanz des Dateimanagers zu öffnen. Man muss das daher extern erledigen. Immerhin sieht das GUI übersichtlich aus, und in der Dateilistenansicht sind die Zeilen sogar abwechselnd eingefärbt. In der neueren Version des Programms gibt es zudem auch eine Seitenleiste mit Directory-Browser.
gpe-gallery-0.97/gpe-base/gentoo {graphics image viewer}: Das noch am beeindruckendste Programm der ganzen Suite: Eine Browser für Fotos. Simpel, aber effektiv; kann die Bilder einzeln anzeigen, oder als Slideshow. Kennt auch Fullscreen-Mode. Die Bilder können auch (im Speicher) gedreht, geschäft oder weichgezeichnet werden. Sogar eine Ansicht wo Dateiname, Thumbnail, Dateigröße, Datum und Bildbreite/höhe zu angezeigt wird gibt es. GQView für Arme, aber immerhin. Eindeutig besser als der Rest dieser "tollen Programme" in der Suite.
gpe-julia-0.0.6/games-misc/gentoo {GPE}{DTE}: xaos für Arme. Zeichnet ein Apfelmännchen; erlaubt es rein- oder rauszuzoomen; sogar interaktiv und flüssig. Natürlich Null Einstellungsmöglichkeiten. Etwas lästig ist die fixe Breite und Höhe des gerenderten Bereichs (320 x irgendwas oder so): Das Fenster kann zwar größer sein, dann bleibt der Rest aber leer.
gpe-lights-0.13/games-puzzle/gentoo {GPE}{DTE}{game}: Ein Spiel! Das Spielfeld ist ein rechteckiges Raster. Jedes Feld kann eine Glühlampe enthalten oder nicht. Entspricht 1 und 0. Durch das Klicken auf ein Feld wird eine XOR-Operation durchgeführt: Ein 3 x 3 "Plus"-Zeichen wird an dieser Stelle geXORt. Offensichtlich ist es das Ziel des Spiels, alle Glühlampen verschwinden zu lassen. Chancenlos, wenn man sich keine Strategie überlegt hat sondern nur wild drauf los klickt, wie ich bemerken musste.
gpe-login-0.95-r3/gpe-base/gentoo {GPE}{DTE}: Ein grafischer Login-Manager - mit On-Screen-Keyboard für die Eingabe der Account-Daten. Doch egal was ich eingab, es war ihm nicht recht. Vermutlich sollte das Ding von gpe-dm aus gestartet werden. Außerdem ein winziger Font für die Zeichen am On-Screen-Keyboard - während das Keyboard selbst aber auf die volle Bildschirmbreite skaliert. ;-)
gpe-ownerinfo-0.28/gpe-utils/gentoo {GPE}{DTE}: Soll offensichtlich den Namen und Kontaktinformationen des PDA-Besitzers anzeigen, falls der PDA verloren geht und jemand anderes ihn findet. Vollkommen sinnlos auf einem PC mit tausenden Applikationen.
gpe-plucker-0.4/gpe-utils/gentoo {GPE}{DTE}: Ein simpler Reader für das "Plucker"-Ebook-Format. Kann absolut nichts anderes als den Text darstellen und Hyperlinks folgen - aber immerhin.
gpe-screenshot-0.4-4/x11/debian {GPE}{DTE}: Das so ziemlich kleinste Screenshot-Programm mit GUI. Leider kann es auch nur sehr wenig: Ein Screenshot des gesamten Bildschirms wird erstellt und in einem Vorschaufenster angezeigt. Man kann es entweder in einer PNG-Datei speichern oder zu irgend einem komischen Webdienst hochladen. Es ist nicht möglich nur von einem bestimmten Fenster einen Screenshot zu machen, oder gar interaktiv einen Bereich auszuwählen.
gpe-taskmanager-0.20/gpe-utils/gentoo {GPE}{DTE}: Wow, wie toll: Ein Fenster zeigt die Namen der Fenster anderer Applikationen. Keine weiteren Details. Dazu 3 Buttons "Abbrechen", "Springe zu" oder "Kill". htop ersetzt das Ding nicht so ganz. Wohl eher ein Ersatz für [Alt]+[Tabulator], wenn ein WM dieses nicht beherrscht.
gpe-todo-0.58-1/utils/raspbian {GPE}{DTE}: Eine simple Aufgabenliste. Pro Eintrag kann man festlegen: Titel, optionales Fälligkeitsdatum, Priorität (niedrig, normal oder hoch), Status (nicht begonnen, im Verlauf begriffen, abgeschlossen, nicht mehr verfolgt), Kategorie (definierbar als ein Name mit einer Farbe) sowie einem mehrzeiligen Textfeld für beliebige weitere Anmerkungen. Diese Einträge werden dann in einer Liste angezeigt, die man anhand den meisten der zuvor genannten Felder sortieren lassen kann. Weiters kann man die Liste filten, und zwar nach Kategorie sowie dem optionalen Verstecken bereits erledigter Aufgaben. Das war es. Macht einen sinnvollen und brauchbaren Eindruck. Ist auch nur klein: Keine 350 kB Installationsumfang. Download-Umfang gar nur 50 kB. Das eigentliche Programm ist gar nur 30 kB lang, der restliche Platz wird für Icons und Übersetzungen in viele Sprachen verwendet. Ein klarer Fall: Das muss von den selben Autoren wie gpe-calender stammen, das ein ähnlich gutes Verhältnis von Installationsgröße und Funktionalität aufweist. Dieser Verdacht wird noch dadurch bestärkt, dass auch dieses Programm seine Einträge nicht einfach in irgend einer Textdatei ablegen die nicht skaliert, sondern in einer SQLite2.1 Datenbank. Das Programm sollte daher auch kein Problem mit sehr vielen Einträgen haben.
gpe-watch-0.11-1/utils/raspbian {GPE}{DTE}: Eine Analog-Uhr mit einem schmuck- und zifferlosen, kurzum leeren, weißen Kreis als Uhrblatt. Darunter ist noch Datum, Wochentag und Kalenderwoche angezeigt. Mehr scheint es nicht zu können. Aber mehr braucht eine Uhr auch nicht zu können! Und trotz seiner Schlichtheit sieht es immer noch besser aus als xclock. Lustig: Man kann die Zeiger sogar mit der Maus bewegen. Allerdings schnellen sie in der nächsten Sekunde sofort wieder zurück wo sie waren. Trotzdem es hübscher als xclock aussieht, kommt es aber leider nicht an dessen Funktionalität heran: Weder kann es eine Digitaluhr anzeigen, noch den ressourcenverschwendenden Sekundenzeiger entfernen, noch kann man die Schriftgröße verändern oder gar ein eigenes Zeit- oder Datumsformat für die Anzeige festlegen. Typisch GPE eben. Auch wenn es Ausnahmen wie gpe-calendar gibt. Aber dieses Programm ist offensichtlich keine!
gpe-what-0.43/gpe-utils/gentoo {GPE}{DTE}: Ein weiterer Beweis dass fremde Programme sich an den Traybar eines WM andocken können. In diesem Fall erscheint dort ein Rettungsring. Wenn man diesen anklickt toggelt er zwischen Ausgefüllt und Leer hin- und her. Sonst tut sich nichts. Toll. Muss wohl eine Art Hilfesystem sein, das nicht richtig konfiguriert ist.
gpg-ringmgr-1.12/app-crypt/gentoo {security}: Entgegen der hochtrabenden Paket-Kurzbeschreibung die eher einen grafischen Keyring-Manager erwarten lassen, handelt es sich hierbei nur um ein simples Perl-Script mit dem PGP-Keys zwischen verschiedenen Schlüsselbünden hin- und herkopiert oder verschoben werden können. Es hat im Bedarfsfall sicher seine Berechtigung, ist aber *kein* grafisches Interface zur Schlüsselverwaltung.
gphoto2-2.4.14/media-gfx/gentoo: Commandline-Client für die direkte Ansteuerung etlicher Digitalkameras mittels verschiedener Protokolle.
gpicview-0.2.5-3/graphics/debian gpicview-0.2.1/media-gfx/gentoo {graphics image viewer}: Ein kleiner, schlanker, simpler GTK+ basierter Image-Viewer ohne zusätzliche Abhängigkeiten, der aber trotzdem OK aussieht und genau das kann was man meistens braucht: Ein oder mehrere Bilder ansehen, optional im Vollbildmodus; die angezeigten Bilder drehen und zoomen. Vor allem kann er sich im Gegensatz zu einigen anderen schlanken Viewern auch merken dass man die Bilder beispielsweise immer auf die Fenstergröße anpassen will. Kann auch den EXIF-Orientierungs-Marker aus JPEG-Dateien auslesen und das angezeigte Bild entsprechend automatisch drehen. Beherrscht Diashows. Nicht so mächtig wie GQView, aber für Neulinge weitaus einfacher zu bedienen. Die einzigen Features die ihm zu fehlen scheint sind die verkleinerte Vorschau aller Bilder im Verzeichnis, sowie - unverständlicher Weise - auch das Umbenennen von Bilddateien. Löschen oder Speichern unter anderen Namen beherrscht er hingegen. Da andere Bildbetrachter dies bieten ist es ein Ausschlusskriterium auf einem normalen Desktop-System. Auf jedem System mit beschränkten Ressourcen würde ich gpicview als einen Bildbetrachter erster Wahl empfehlen. Er beherrscht alle wichtigen älteren Bildformate, aber nicht die neuesten wie WebP oder JPEG-XL. Wenn man jedoch das Paket "heif-gdk-pixbuf" dazu installiert, beherrscht er auch das neue *.avif-Format, dem zweitwichtigsten (Stand 2023) neuen Format neben WebP.
gprolog/dev-lang/gentoo: Mag nett und schnell sein - aber leider unter GPL so dass man damit keine kommerziellen Anwendungen schreiben kann.
gpw-0.0.19940601-10/utils/debian {security}: Ein Passwort-Generator für aussprechbare Passworte nach der Trigraph-Methode. Aussprachbar mögen sie sein, aber da sie in einer Wurst und nicht als Worte generiert werden, sind sie dennoch schwer zu merken. Hat nur 2 Parameter: Die Anzahl und Länge der Passworte. Keine weiteren Optionen; insbesondere kann kein Seed angegeben werden. Holt sich seine Zufallszahlen immer aus /dev/random. Entsprechend gibt es keinerlei Garantie wie kryptografisch stark die Passworte sind. Vergessen!
gqview-2.0.1/media-gfx/gentoo {graphics image viewer}: Der bester Bildbetrachter/Organizer für Maschinen mit begrenzten Ressourcen. Nur 1,5 MB groß. Bilder werden in Verzeichnissen oder Collections (Textdateien die eine Liste von Dateinamen enthalten) organisiert. Zuordnung von beliebigen Keywords zu jedem Bild. Zeigt mehr EXIF-Daten an als die meisten der "großen" Bildverwaltungsprogramme. Thumbnails. Simple Slideshow-Funktion. Gute Möglichkeit zum Verschieben/Kopieren/Symlinken in andere Verzeichnisse. Favoriten-Listen für Keywords und Zielordner. Angezeigte Bilder können nur rotiert/gezoomt werden, keine dauerhafte Veränderung. Auch Thumbnails, Keywords, Collections und Comments werden unabhängig von den Bildern als Textdateien gespeichert. Allerdings können zehn beliebige externe Programme eingebunden werden, etwa zur verlustlosten Rotation oder der GIMP. Suchfunktionen: Name, Datum, Keywords, Kommentare, Bildgröße, Duplikate, Bildähnlichkeit, verschachtelte Suche in vorherigen Suchergebnissen, Ergebnisse als Collection speicherbar. Nachteile: Unterstützt kein JPEG-2000 oder JPEG-Kommentare, eher mäßig schneller sichtbarer Bildaufbau, keine Plugins, Keywords sind nicht strukturiert, simpel aussehend, GTK+ basiert, nicht datenbankbasiert (Suche langsam bei großen Bildmengen).
grace-1 {X11}: 5.1.25-9/math/debian: Ein interaktives X11-Programm zum Visualisieren von X/Y-Daten. Diese können auf vielfältige Weise visualisiert werden. War früher als "Xmgr" bekannt. Benutzt die hässlichen originalen X11-Widgets. Besitzt eine eingebaute Hilfe samt Tutorial. Normalerweise werden die Daten aus Textdateien geladen. Auch FIFOs werden als Datenquellen unterstützt. Weiters verfügt das Programm auch über eine Scripting-Sprache mit der neue Datenpunkte aus Formeln generiert oder aus bestehenden Datenpunkten transformiert werden können. Tatsächlich sind die Textdateien aus denen die Daten geladen werden keine CSV-Dateien oder dergleichen, sondern vielmehr Scripte welche die Daten als Literale enthalten. Allerdings können Daten auch von "Block-Dateien" importiert werden, die jeweils nur eine Spalte (also X- oder Y-Koordinaten) vom Datenpunkten enthalten. Mittels "cut" kann man daher entsprechende Eingabedateien aus CSV-artigen Dateien erzeugen. Grace kann auch Kurven an die Datenpunkte anpassen, Regressionskurven (für gegebene lineare und nicht-lineare Funktionen) dafür erstellen, oder eine FFT durchführen. Datenpunkte können in einem Spreadsheet-artigen Editor oder einen normalen Texteditor bearbeitet werden. Weiters können Eigenschaften wie Spitzenwerte aus den Kurven extrahiert werden. Grace bietet weniger Visualisierungsmöglichkeiten als gnuplot, ist dafür aber auch ein mächtiger interaktiver Editor und nicht nur für Batch-Darstellung geeignet. Ca. 1,5 MB Downloadumfang für die Installation, wenn X11 und FFTW bereits installiert sind.
gracer-0.1.5/games-sports/gentoo {game}: Das wohl erbärmlichst aussehende 3D-Rennspiel das ich je sah. Die Anzahl der Polygone ist derart gering dass man gerade noch erkennen kann was sie darstellen sollen. Noch dazu sauschwer in der Steuerung - man glaubt permanent auf Eis zu fahren. Und das "beste": Es gibt nicht einmal Gegner (zumindest nicht beim Single-Player-Spiel; allerdings gibt es eine Server-Option), sondern man "kämpft" gegen die Uhr (und den Brechreiz). Unglaublich schlecht! Zumindest optisch. Spielerisch, na ja, vielleicht eine Herausforderung weil es so sauschwer zu steuern ist. Einziges Plus: Mit 500 KB Länge sind die Installationsdateien angenehm kurz.
grafx2 2.4-7/community/archlinux {bitmap image editor}: Ein Pixelgrafik-Malprogramm und kein Fotobearbeitungsprogramm. Erinnert irgendwie sehr an DeluxePaint vom Amiga, welches auch das Vorbild dafür war. Leider bedeutet dies auch, dass es in sehr geringer Auflösung daher kommt und entsprechend grobpixelig aussieht. Andererseits ist das bei einem pixelbasierten Malprogramm vielleicht sogar ein Vorteil, da man die Pixel deutlicher sieht. Kann nur Paletten-basierte Bilder bearbeiten, bevorzugter Maßen solche mit 256 Farben (was zugleich auch das unterstützte Maximum darstellt). Innerhalb dieser Grenzen bietet es sehr viele Bearbeitungswerkzeuge und Funktionen, wie etwa Ebenen und Animationsphasen. Mit knapp 1 MB Installationsumfang auch sehr kompakt. Allerdings: Wer will heute schon noch mit Paletten-indizierten Bildern arbeiten? Und für das Bearbeiten simpler Bitmaps (für Cursor oder Icons) scheint das Programm angesichts seiner vielen Funktionen fast schon ein Overkill zu sein. Nützlich hingegen dass man auch animierte GIFs damit erstellen und bearbeiten kann. Daneben kann es PNG, ILBM (Amiga Bildformat), PCX und BMP sowie ein paar Exoten-Formate laden und speichern. JPEG-Bilder kann es zumindest importieren (werden dabei aber wohl in 256 Farben quantisiert). Interessant ist auch die Scripting-Fähigkeit, die auf der ziemlich mächtigen Scriptsprache Lua (Version 5.3) basiert.
grande-KXL/games-arcade/gentoo {game}: Ein weiteres im Grunde extrem nettes 2D-Ballerspiel welches daran krankt, dass es nur in einem briefmarkengroßen Fenster läuft.
graphviz-2.38.0-17/graphics/debian: Erzeugt aus Textbeschreibungen von Daten grafische Diagramme. Es sind viele Tools enthalten, die grundsätzliche Aufteilung der Arbeit ist aber diese: Man erstellt mit mitgelieferten interaktiven graphischen Editoren "dotty" oder "lneato" sogenannte "Graphen" - das sind Blasen ("Knoten") welche durch Linien ("Kanten") verbunden sind. Man kann die Attribute von Knoten und Kanten ändern - so dass es etwa Pfeile statt Linien werden, Kästchen statt Blasen, färbig statt schwarzweiß. Auch kann man alle Objekte mit Beschriftungen versehen. Die grafischen Editoren erlauben zwar auch eine freie manuelle Anordnung der Objekte, doch normalerweise werden dazu Layout-Plugins benutzt, welcher alles automatisch nach verschiedenen Algorithmen anordnen. Die grafischen Editoren sind nur Front-Ends für ein gemeinsames Basisprogramm namens "lefty", welches ein textbasierter grafischer Struktureditor mit eingebauter Programmiersprache ist. Er ist es auch welcher die Graphen tatsächlich am Bildschirm anzeigt. Die grafischen Editoren steuern "lefty" nur mit Mausaktionen an und verbergen seine Textanzeige. Gerendert werden die Graphen aber nicht von lefty selbst sondern dem Kernprogramm "dot" übergeben, welches Bitmap-Grafiken aus der textbasierten Beschreibungssprache für die Grafen generiert, und diese zeigt lefty dann an. Bevor lefty die textbasierten Graphen-Beschreibungen zum Rendern übergibt, ruft es noch die erwähnten Layout-Plugins auf. Das sind Filter, welche die textbasierten Graphen-Beschreibungen einlesen und um berechnete Koordinaten ergänzen. Dot hat ebenfalls einen Layout-Algorithmus (namens "dot") eingebaut, und verwendet diesen immer dann wenn noch keine Koordinaten in der Eingabe vorhanden sind. Soweit zu einer Übersicht von graphviz. Im einzelnen kann man in diesen Prozess aber frei eingreifen und Tools durch andere ersetzen oder auch komplett weg lassen. Grundsätzlich sind Graphen Texte in einer simplen Beschreibungssprache für die Knoten, Kanten und globalen Attribute des Graphen, und es ist belanglos ob man diese mit den genannten Tools erstellt, eigenhändig in einem Texteditor, oder von einem selbst geschriebenen Programm als Ausgabe erhält. Bis auf lefty und "dot" selbst sind alle anderen Programme der Suite nur Transformations-Filter, welche die Textdarstellung der Graphen verändern. Sei es um deren Layout zu verändern, oder komplett neue Graphen anhand von anderen Daten zu erzeugen. Die eingebaute und standardmäßig verwendete Layout-Engine von dot (ebenfalls "dot" genannt), versucht den Graphen als typischen hierarchischen Baum mit der Wurzel oben darzustellen. Die "Knoten" (Blasen) sind per Default nur durch normale Linien ("Kanten") verbunden. Über die "layout"-Eigenschaft des Graphen können jedoch alternative Layout-Engines eingestellt werden, welche tatsächlich externe Programme sind welche Graphen in Textdarstellung einlesen und um konkrete Koordinaten ergänzen. Man könnte folglich auch problemlos eigene Layout-Engines schreiben. Folgende zusätzliche Layout-Engines werden mitgeliefert:  "twopi" zeichnet eine Baumstruktur mit der Wurzel in der Mitte, von welcher aus Linien kreisförmig zu Kindknoten weiter außen zeigen, und von dort aus noch weiter nach außen. Sieht wie ein "Eroberungs-Diagramm" für Planeten aus einem Strategiespiel aus. "neato" tut zumindest bei einem Graphen welches eine Baumstruktur darstellt exakt dasselbe und sogar noch hübscher. Allgemein ist "neato" aber genau wie die weiters verfügbaren Layouter "fdp" und "sfdp" ein auf Federkräften bzw. Gewichten basierender Layouter, der bei nicht-baumförmigen Graphen ein völlig anderes Layout benutzt. Irgendwie tun alle drei ähnliches und ordnen die Knoten in einer 2-dimensionalen gitterartigen Struktur mit unterschiedlichen Abständen an. "sfdp" ist dabei angeblich besser für sehr große Graphen geeignet. Der genaue Unterschied zwischen den dreien ist mir aber noch nicht klar geworden. "circo" ordnet alle Knoten der Reihen nach im Kreis herum an - sieht wie ein Rad mit vielen völlig irr angebrachten Speichen aus. "patchwork" kann auf quadrat-ähnlichen Rechtecken basierende "Treemaps" anzeigen, in denen die Knoten als annähernde Quadrate mit variierendem Flächeninhalt so angeordnet werden dass der gesamte Platz im umschließenden Quadrat ausgenutzt wird und keine Lücken entstehen. Der Flächeninhalt der Pseudo-Quadrate wird dabei zumindest im Falle eines Baumdiagramms durch die Baum-Ebene bestimmt in der sich die Knoten logisch befinden. Aber vermutlich kann man die Flächeninhalte auch explizit einstellen. "osage" versucht die Knoten matrix-förmig anzuordnen (jedoch anders als "patchwork" nach wie vor als separate Blasen). Es kann in überfüllten Graphen auch Cluster erkennen und die entsprechenden Einzel-Knoten durch eine geringere Anzahl an zusammenfassenden Cluster-Knoten ersetzen. "dotty" sowie "lneato" sind grafische (Motif-look...) Editoren, wo man mit der Maus Graphen erstellen und editieren kann. "acyclic" entfernt Zyklen aus gerichteten Graphen. "bcomps" und "ccomps" zerlegen einen Graphen in seine Verbund-Bestandteile. "cluster" identifiziert Cluster in Graphen. "diffimg" erzeugt Differenzbilder von Bitmap-Grafiken. "dijkstra" Berechnet die Knoten-Entfernungen von einem Ausgangs-Knoten. "edgepaint" und "gvcolor" können Bestandteile der Graphen anhand von Kriterien einfärben. "gvgen" kann eine Vielzahl grafischer Objekte in Graphenform erzeugen, wie Zylinder, Gitter, Moebius-Band, Zufallsgraph, Baumstrukturen, Fraktale Kurven. "tred" entfernt Knoten in zu dicht "bevölkerten" Gebieten des Diagramms um den Rechenaufwand bei der Darstellung erträglich zu halten wenn es dabei zu viele Knoten darzustellen gilt. "unflatten" verändert die Abstände im Diagramm so dass Graphen die sich vorwiegend nur in einer Dimension ausdehnen zweidimensional betrachtet besser aussehen. "mm2gv" extrahiert Daten aus schwach besetzten Matrizen. "gc" zählt die Bestandteile von Graphen. Die Eingabe der Programme (also das native Datenformat von "dot") sind Deklarationen in einer simplen Sprache, die Knoten und Kanten der Graphen Namen geben und Titeltexte zuweist, sowie deren Verbindung spezifiziert. "nop" ist ein Pretty-Printer für diese Dateien. Es sind Konverter enthalten, welche zwischen dieser Sprache in dem folgenden anderen Sprachen mit ähnlicher Zielsetzung umwandeln können: GLX, GML, GRAPHML sowie GV/DOT. "gvpr" ist ein Datenstrom-Editor ähnlich wie sed/awk, jedoch für die knotenorientierte Struktur der Sprache von Graphviz geeignet. Damit kann man Graphen automatisiert verändern und durchsuchen sowie extrem mächtige Transformationen durchführen. Die folgenden Ausgabeformate können direkt von "dot" erzeugt werden: .bmp (classical Microsoft bitmap format), OpenEXR, Dateien für "xfig", GIF, .ico (Icon Image File Format), JPEG 2000, JPEG, json, PDF, .pic (Kernighan's PIC graphics language, etwa von "troff" verwendet), PNG, POV-Ray markup language, PostScript (sowohl normales, als auch encapsulated EPS, sowie eine Variante speziell für die Erfordernisse von PDF), SVG (inklusive .svgz), .tga (Targa), TIFF (Tagged Image File Format), Tcl/Tk Quelltext, x11 (zeigt selbst unter X11 die Grafik in einem Fenster an, keine Ausgabe), VRML, wbmp (Wireless BitMap format), webp (Image format for the Web), imagemap (anklickbare Knoten und Kanten für Webseiten-Grafiken) und noch ein paar Exoten. Zumindest die Debian-Version des Pakets enthält nicht alle erforderliche Dokumentation - konkret fehlen die Tutorials und die Dokumentation der interaktiven "dot"-Editoren. Dafür gibt es ein separates *-doc Paket, das noch einmal 5 MB Installationsumfang (3 MB Download) erfordert. Bezüglich der grafischen Darstellung kennt "dot" 3 Hauptkategorien: Polygon-basiert wie Blasen oder Kästchen (als Unterkategorie der Polygon-basierten Formen werden aber auch B-Splines unterstützt, so dass man praktisch keine Einschränkungen bei der Gestaltung hat), Datensatz-orientiert (etwa um einzelne "structs" von "C" darzustellen, die wiederum Zeiger auf andere Objekte enthalten, sowie benutzerdefinierte Formen. Letztere können momentan entweder PostScript- oder Bitmap-Grafiken sein. Allerdings erlauben die mitgelieferten grafischen Editoren keine Bearbeitung solcher Objekte - sie lassen sich nur einbinden. Man braucht daher zusätzlich noch einen Vektoreditor wie InkScape wenn man benutzerdefinierte Formen selbst erstellen will, anstatt mit den vielen bereits vorhandenen  Formen auszukommen. Neuere Versionen von graphviz unterstützen neben der normalen Festlegung von Attributen auch eine Subset von HTML, wo man Farben, Textstile etc. mit HTML-artigem Markup erzeugen kann. Das erspart jemandem der bereits HTML beherrscht sich in die native Sprache von graphviz tiefer einarbeiten zu müssen.
grass-7.8.5-1+deb11u1/science/debian {GIS}: Ein in Python implementiertes GIS-System das in der akademischen Welt als auch von staatlichen Stellen häufig verwendet wird. Macht einen sehr umfangereichen Eindruck. Das GUI ist mit wxWidgets verfasst. Kann sowohl 2D und 3D Vektor- als auch Rasterdaten verwalten. Ebenso DEM-Daten (Höheninformationen), etwa aus der NASA SRTM-Datenbank. Kann eine Vielzahl von ASCII- und Binärdatenformaten importieren und exportieren. Scheint ebenfalls PostgreSQL- und SQLite-Datenbanken mit PostGIS/SpatiaLite-Erweiterung zu unterstützen. Das UI besteht aus 2 Fenstern, ein Hauptfenster für Einstellungen und Parameter, und ein Darstellungsfenster für die eigentliche Kartenansicht. Viele Funktionen die für staatlichen Planer interessant sind, wie Hydrologie-Funktionen (etwa Grundwasserfluss), Sonnenbestrahlung und Beschattung, Feuerausbreitung, Hangneigung, Patch-Analyse (ich vermute damit sind Flächen gleicher Eigenschaften gemeint). GRASS kann nicht nur räumliche, sondern auch Raum-Zeit-Daten erfassen - sowohl für Vektor- als auch Rasterdaten. Dies kann dann z. B. als Animationen angezeigt oder in Analysen verwendet werden. Eine umfangreiches Offline-Anleitung im HTML-Format ist als optionales Zusatzpaket verfügbar. Anders als andere GIS-Programme fragt einem GRASS bereits beim ersten Start "Löcher in den Bauch", indem man einen Wizard mit zahlreichen Einstellungen durchgehen muss. So muss man sich z. B. auch entscheiden welche geografische Region mit dem Programm verwaltet werden soll. Auch GRASS scheint keinen direkten Support für OSM-Daten zu besitzen, bzw. muss man diese vorher erst in PostgreSQL/SQLite Datenbanken importieren die GRASS unterstützt.
gravitywars-1.102-34+b1/games/debian {game}: Ein theoretisch ganz nett gemachtes Spiel, wo man Level dadurch abräumen muss indem man Gegenstände mit seinem Düsengetriebenen Raumschiff berühren muss. Dabei muss man ständig auf dem Schub reiten und darf weder zu schnell gegen Wände knallen oder diese überhaupt berühren (es gibt verschiedene Typen von Wänden). Sieht optisch auch ganz nett aus. Leider hat es praktisch aber das Problem dass es offensichtlich direkt an die Rechnergeschwindigkeit gekoppelt ist. Dadurch ist es bei modernen Rechnern unspielbar schnell. Vielleicht werden zukünftige Versionen dieses Manko irgendwann beheben. Bis dahin ist es leider nur auf langsamen bzw. alten Rechnern spielbar.
grisbi-0.5.9/app-office/gentoo: Nett gemachtes Finanzprogramm a la Quicken. Deckt angeblich alle Erfordernisse der französischen Amtserfordernisse (vermutlich der Steuererklärungen von Privaten) ab. Mehrwährungsfähig, UTF-8 Support, deutsche Lokalisation, Euro-Zeichen. Toll, super und überhaupt. Allerdings habe ich irgendwie nicht die geringste Lust, meine Daten in so eine komische Applikation einzuklopfen, die statt einer normierten Datenbank alles in irgendwelchen komischen programmspezifischen Dokumentendateien ablegt, genau wie ein x-beliebiges Office-Programm.
grive-0.2.0-1.1/net/debian {dirtree sync}: Ein Linux-Client für Google Drive. Leider scheint er derzeit nur den gesamten Inhalt von Google Drive mit einem lokalen Verzeichnis synchronisieren zu können. Ich habe allerdings keine Lust, bis zu 15 GB auf meiner lokalen Platte zu verbraten, nur weil ich vielleicht an einer *einzigen* Datei auf meinem Google Drive interessiert bin. Sicher nett als Backup-Lösung (wenn man Google vertrauen wollte) - aber sehr ärgerlich dass man die Synchronisation nicht auf eine Dateiauswahl beschränken kann.
grml32-full_2014.03.iso/live-system/GRML {linux distribution}: Eine Linux-Distribution, die vor allem als Rettungs-/Reparatur-System geeignet ist. Diese Version ist auch für nur-32-Bit-Rechner geeignet und läuft auch (praktisch getestet) auf einem 686er-Rechner mit MMX aber ohne SSE oder PAE. Da neuere Versionen von GRML diverse Nachteile haben, ist dies die *vielleicht* beste GRML-Version soweit die Treiber einem nicht zu alt sind. Es gibt nämlich einen Bug der in der 2013.09-Version von GRML möglicherweise noch nicht existiert (testen!) im grml2usb-Installer, wo eine fehlerhafte Fehlerabfrage unnötiger Weise das Installieren von USB-Datenträgern verhindert welche als "USB-ZIP" vom BIOS gebootet werden sollen. (Allerdings kann man diese Abfrage einfach manuell aus den Script entfernen - wenn einem dieser Umstand bekannt ist, daher hier vermerkt.) Ansonsten siehe Eintrag vom grml96-full_2013.09.iso für genauere Beschreibung, die ich hier nicht wiederholen will.
grml96-full_2013.09.iso/live-system/GRML {linux distribution}: Eine Linux-Distribution, die vor allem als Rettungs-/Reparatur-System geeignet ist. Das "96" bezieht sich auf den Umstand dass eine 32- und eine 64-Bit Version sich per Bootloader auswählbar am selben Datenträger befinden. Neben dem Live-Linux-System ist noch FreeDOS (nützlich für BIOS-Updates die ein MS-DOS basiertes System erfordern), MirOS (ein BSD-basiertes Mini-Rettungs-System, allerdings nur für BSD-Kenner von Wert), GRUB all-in-one sowie ein PXE-Loader vorhanden. Letzterer erlaubt es einem System auch dann einen Netzwerk-Boot via PXE durchzuführen, wenn dessen BIOS dies nicht unterstützt, aber diese ISO booten kann. Mit grml2usb kann man auch einen bootfähigen USB-Datenträger erstellen, auf Wunsch auch nur mit dem PXE-Loader und den anderen Boot-Addons (wie GRUB "all in one") aber ohne das eigentliche GRML. Damit kann man auch einen sehr kleinen USB-Stick (16 MB) in einen PXE-Netzwerk-Bootloader verwandeln, um das eigentliche System von einem PXE-Server zu booten. Ferner kann GRML auch als PXE-Server fungieren; damit andere Rechner via PXE die LiveDVD übers Netz booten können. In diesem Fall kann man auch konfigurieren dass der gebootete Rechner einen SSH-Server mit einem bestimmtem Passwort laufen haben soll. Dies ist die von mir bislang am besten getestete GRML-Version, die klaglos funktioniert - was man leider keinesfalls von allen Nachfolgern behaupten kann.
grml96-full_2014.11.iso/live-system/GRML {linux distribution}: Eine verschlechterte Version von grml96-full_2013.09, die folgende Funktionalitäten eingebüßt hat: MirOS Minimalsystem, funktionierndes PXE-Server-Setup. Dafür ist sie um 200 MB größer. Bis auf neuere Treiber wenig Grund diese Version zu benutzen.
grml96-full_2017.05.iso/live-system/GRML {linux distribution}: Eine verschlechterte Version von grml96-full_2014.11, die folgende Funktionalitäten eingebüßt hat: sysvinit. Statt dessen wird nun systemd benutzt. Somit unbrauchbar für Leute die systemd nicht ausstehen können. Dafür ist sie erneut um 200 MB größer als die 2014'er Version. Bis auf neuere Treiber wenig Grund diese Version zu benutzen.
grml96-full_2024.02.iso/live-system/GRML {linux distribution}: Eine Linux-Distribution, die vor allem als Rettungs-/Reparatur-System geeignet ist. Das "96" bezieht sich auf den Umstand dass eine 32- und eine 64-Bit Version sich per Bootloader auswählbar am selben Datenträger befinden. Unter anderen enthält dieses System die folgenden Programme, welche für mich besonders interessant auf einem Reparatursystem sind: aptitude, bc, buffer (pipe progress indicator), busybox, cpio, cpuid (decodiert CPU Features in längere einzeilige Beschreibungen), cryptsetup, curl, fdisk, firefox-esr, fluxbox, gawk, git, haveged, hwinfo (ähnlich wie "lshw"), htop, lshw, lvm2, lzop (große Datenmengen komprimieren), make (allerdings kein C/C++-Compiler, nur "cpp" und "ld"), man (und die meisten man-pages der installierten Utilities), mc (für mcedit als brauchbarem Editor), mkfs.exfat, mkfs.ext4, mkfs.nfts, mkfs.vfat, ncdu (Dateisystem-Belegung analysieren), nmap, partimage (), perl, python3, qemu-guest-agent, qemu-system-x86, qrencode, rpm, rsync, ruby3.1, samba, screen, scriptlive (wie "scriptreplay" nur werden die Befehle real ausgeführt), smartmontools, socat, sqlite3, squashfs-tools, ssh, sshfs, strace, syslinux-common (MBR-Code für gpt und mbr PTs geeignet), tcl8.6, telnet, tmux, usb-modeswitch-data, uuid-runtime, w3m, wdiff, wget, x11vnc, xpdf, xserver-xorg, xterm, zstd.
groff-1.19.2-r1/sys-apps/gentoo: Powerful text formatting system much like TeX, but generally less bloated. However, the current versions have a big flaw: Although they can output UTF-8 formatted text, they cannot accept any UNICODE text encoding as input yet. There is a patch for japanese input, but input for most western languages is restricted to Latin-1. This means it is currently not possible to use the Euro-symbol directly in input text, unless reverting to the special escape sequence "\(Eu".
groupoffice-2.18.6/www-apps/gentoo: Groupware in PHP geschrieben. Kalender, Adressbuch, Notizbuch, Mail (POP3 und IMAP), "Timesheet", Webseiten-CMS sind in der OpenSource-Version enthalten. Für PDA/SmartPhone/Outlook Synchronisations-Clients muss man jedoch blechen. Danke. Nächster, bitte.
gscan2pdf-1.3.0/media-gfx/gentoo {PDF}: Eine in Perl geschriebene GUI-Anwendung um Dokumente einzuscannen /oder aus bereits gescannten Dateien zu laden), das Ergebnis mit OCR zu erkennen, und daraus durchsuchbare mehrseitige PDF- und DJVu-Dateien zu erzeugen. Als erstes lädt man die bereits gescannten Dateien welche die Seiten des Zieldokuments darstellen sollen (hier wird nur normale Mehrfachauswahl aber keine Rekursion unterstützt) oder benutzt das Programm um die Seiten einzuscannen. Dazu wird auf Standard-Linux-Programme zum Scannen einzelner Seiten oder mittels automatischem Blatteinzug zurück gegriffen. Beim Import von mehrseitigen PDF- oder TIFF-Dateien wird man jedesmal nach dem Seitenbereich gefragt den man Importieren will (oder alle Seiten). Grundsätzlich können folgende Dateiformate importiert werden: JPEG, PNG, PNM, TIFF, PDF, DJVU, PS, GS2P (das proprietäre Format zum Speichern einer Sitzung des Programms). Beim Import werden nur Bildinhalte importiert; eventuell bereits vorhandene (etwa OCR-erkannte) Textinhalte werden übersprungen. Während des Imports werden alle Seiten komplett dekomprimiert, was sehr viel Temporärspeicherplatz erfordern kann und auch recht lange dauert - ein paar GB sollte man schon einplanen. Danach hat man die Option sie zumindest per LZW zu komprimieren, um den Arbeitsplatzbedarf wieder zu senken. Nach dem Import werden links die verkleinerten Seiten dargestellt, rechts die aktuell ausgewählte Seite zum Bearbeiten. Man kann nun die Reihenfolge der Seiten ändern, Seiten löschen, die Seiten anders nummerieren (für PDF-Anzeigeprogramme welche die im PDF-Dokument gespeicherten Seitennummern anzeigen) oder Seiten in 90 Grad schritten drehen. Weiters kann man Seiten für die Bearbeitung selektieren, entweder mit der Maus, alle Seiten, nur gerade oder nur ungerade Seiten. Weiters gibt es Bearbeitungswerkzeuge wie S/W-Schwellwertfilter, Invertierung, Unschärfe-Maske oder Zuschneiden (mit fixen Koordinaten). Damit sollte man die Seiten falls gewünscht in eine OCR-freundliche S/W-Darstellung bringen. Leider gibt es kein Tool zum Entfernen von Halbtonrasterung. Allerdings kann man externe benutzerdefinierte Tools zu diesem Zweck konfigurieren - wenn man denn eines finden kann. Danach kann dann, falls es installiert ist, das "unpaper"-Programm zum Bereinigen aufgerufen werden - dieses dreht Seiten gerade, entfernt Sprenkel usw. Es gibt eine Undo- und Redo-Funktion, jedoch nur für einen einzigen Schritt - was im Falle mehrerer in einem Schritt bearbeiteter Dateien bedeutet dass keine Rücknahme pro Einzeldatei möglich ist. Die OCR-freundlich aufbereiteten Seiten können dann OCR-erkannt werden, wobei mehrere OCR-Programme unterstützt werden - primär jedoch Tesseract. Nach der Erkennung kann man für jede Seite die Darstellung zwischen Bild und OCR-erkanntem Text anzeigen. Man kann dann die OCR-erkannten Worte welche an der Original-Position fixert sind anklicken um Erkennungsfehler zu korrigieren. (Dies ist ziemlich primitiv und funktioniert nur für kleinere Korrekturen sinnvoll.) Danach kann man das Gesamtergebnis als PDF- (oder DJVU-) Datei abspeichern, wobei der OCR-erkannte Text unsichtbar unter dem Bild angebracht ist. Dadurch kann das PDF-Dokument nun durchsucht und/oder indiziert werden, oder der Textinhalt daraus extrahiert. Ein Nachteil des Programms ist dass es nur primitive PDF-Komprimierungsalgorithmen unterstützt, insbesondere keine TIFF/Fax-Komprimierung oder JBIG/JBIG2. Man sollte das erzeugte PDF-Dokument daher nachträglich noch mit einem anderen Programm in eine der genannten effizienteren Komprimierungsformate umwandeln lassen.
gthumb-2.8.1/media-gfx/gentoo {graphics image viewer}: Fotos anzeigen unter GNOME. Unterstützt kein JPEG-2000. Sehr primitiv - kann wirklich nur das nötigste: Anzeigen, Thumbnails, Slideshow, Bilder in Sammlungen zusammenfassen, verschieben, kopieren, umbenennen, löschen, Kommentar eingeben, primitive unstrukturierte Keywords zuweisen. Immerhin - die wichtigsten Nachbearbeitungsfunktionen sind vorhanden, aber auch die wirken primitiv: Schieberegler, keine Zahleneingabe möglich. Immerhin auch verlustlose Rotation. Das war's. Alles in allem eine Enttäuschung und sogar von den Features (von den Nachbearbeitungsfunktionen abgesehen) her klar schwächer als das deutlich kleinere gqview, bloß dass das gthumb GUI etwas hübscher aussieht.
gtimer-2.0.0-1.2/utils/raspbian: GUI-App zum Aufzeichnen der verbrauchten Zeit für Tägigkeiten. Nützlich für das Zuordnen verbrauchter Arbeitszeit zu Projekten und Kostenstellen. In GTK+ verfasst ohne weitere Abhängigkeiten. Man kann jederzeit zwischen den Tätigkeiten umschalten, denen die aktuelle Zeit zugeordnet wird. Ebenso ist es möglich, die gerade vergehende Zeit mehr als einer Tätigkeit zuzuordnen. Das Programm kann auch Inaktivität erkennen und diese dann wieder von der zugeordneten Zeit zu einer Tätigkeit abziehen. Es kann auch Reports generieren und dann mittels eines benutzerdefinerbaren Kommandos ("lpr" als Vorgabe) ausgeben.
gtk2fontsel 0.1-5/community/archlinux: Zwar ist dieses Programm laut Beschreibung auch ein "Preview Tool", jedoch ist es in Wahrheit nichts anderes als ein normaler Font-Auswahldialog, der auch ein Beispiel des aktuell ausgewählten Fonts anzeigt. Weder kann man damit einfach eine Übersicht aller installierten Fonts bekommen (außer man selektiert jeden einzelnen Font der Reihe nach), noch ist es in der Lage eine Vorschau nicht-installierter separater Font-Dateien anzuzeigen. Ein eher sinnloses Tool daher.
gtkdialog-0.8.2/x11-misc/gentoo {cmdline-dialog}: Das vermutlich mächtigste Tool zum Erstellen von grafischen Dialogen zur Verwendung aus Shell-Scripten heraus. Man kann sogar direkt mit dem GTK-Dialog-Editor XML-Dateien erstellen die den Dialog beschreiben, und gtkdialog verwendet diese dann. Leider hat diese Mächtigkeit ihren Preis in Form eines komplexeren Aufrufs über Pipes zwischen separaten Prozessen im Shell-Script, was es für simple Interaktionen als Overkill erscheinen lässt. Ein weiteres Problem ist die geringe Verbreitung und eingeschränkte Verfügbarkeit auf anderen Linux-Distributionen. Auf der anderen Seite erlaubt es nahezu beliebig komplexe Dialoge und die Interaktionen mit diesen unabhängig von einer bestimmten Programmiersprache.
gtkdiskfree-1.9.3-r1/app-admin/gentoo: Zeigt die Speicherplatzauslastung aller gemounteten Partitionen an. Eine Zeile pro Dateisystem. Default-Layout Als Text: Device, Gesamtkapazität, Benutzer Platz, Freier Platz, Mount Point. Grafisch: Prozentueller Auslastungsstand, sowohl als Zahl als auch als horizontaler Grün-Rot Gradient-Balken. Diese Anzeigedetails können noch durch zahlreiche Optionen angepasst werden. Optional können auch alle in /etc/fstab verfügaren Dateisysteme angezeigt werden; in diesem Fall ist der Füllstand ausgegraut. Mit definierbaren externen Kommandos können die angezeigten Partitionen auch gemountet oder ungemountet werden. Dabei sind für SAMBA-basierte Dateisysteme separate Kommandos definierbar. Zusätzliche Spalten sind verfügbar; Spalten lassen sich aktivieren oder deaktivieren sowie sortieren - nicht aber in der Reihenfolge ändern. Eine Copy-Option kopiert die Werte der gewählten Zeile in die X Selection. Größenangaben können global als Kilo-, Mega- oder Gigabytes angezeigt werden, sowie dynamisch als eines davon. Das Update-Intervall für die Anzeige kann ebenfalls festgelegt werden. Der Systemfont wird verwendet und lässt sich nicht im GUI anpassen. Dafür sind die Zeilen alternierend gefärbt. Ein Manko dieser Version ist dass sie keine .desktop-Datei installiert - man muss daher selbst für den Menüeintrag sorgen. Dieses Tool ist eine abgespeckte Version des GNOME-Tools "baobab" (Teil von "gnome-utils") bzw. des KDE-Tools "KDiskFree"; auch der Dateimanager "Krusader" enthält eine mächtigere Version eines derartigen Tools als Subfunktion. Allerdings ist gtkdiskfree mit rund 400 KiB Installationsumfang deutlich kleiner als die anderen Tools mitsamt ihren Library-Abhängigkeiten. Wenn es allerdings nicht auf jedes Byte ankommt, würde ich eher "baobab" als bestes Tool für die Platzanalyse empfehlen.
gtkimageview-1.6.4/media-gfx/gentoo: Anders als der Name dies vermuten lässt, ist dies kein Bildbetrachter sondern nur eine Library - konkret ein GTK-Kontrollelement zur Anzeige von Bildern. Für Endbenutzer daher uninteressant.
gtkwave-3.3.28/sci-electronics/gentoo: Ein "Wave form"-Betrachter für die grafische Anzeige der Ausgabe vom elektronischen Schaltungen. Es stellt ein zeitliches Diagramm der Zustände von Ein- und Ausgängen dar. Dieses Programm wird beispielsweise verwendet, um die Ausgaben von Schaltungs-Simulatoren wie nsplice oder dem iverilog simulator zu visualisieren. GTKWave ist das beliebteste derartige Tool im OpenSource-Bereich (Stand 2013).
gucharmap-1: 9.0.2-1/gnome/raspbian: Die Zeichen-Auswahltabelle von GNOME. Zwei Panes neben einander: Links wahlweise eine Auswahl des aktuellen Unicode-Blocks oder Schriftsystems. Rechts davon dann als zwei Tabs die entsprechenden Zeichen sowie am anderen Tab die Details des gerade ausgewählten Zeichens. Diese Details sind in gekürzter Form aber zusätzlich auch in der Statuszeile angezeigt, so dass man den Tab normalerweise nicht umzuschalten braucht außer man will es ganz genau wissen. Weitgers gibt es ein Textfeld in welches man per Doppelklick selektierte Zeichen einfügen kann, und einen Button um diese in die Zwischenablage zu kopieren. Natürlich gibt es auch eine Suchfunktion, sowohl nach dem eingegebenen Zeichen auch nach dessen UNICODE-Name. Funktional und brauchbar. Installationsumfang 3,6 MB.
guile-1.8.8-r1/dev-scheme/gentoo {programming language}: GNU Guile ist ein in C geschriebener Scheme-Interpreter, der sowohl als Standalone-Interpreter als auch zur Einbettung als Scriptsprache in Applikationen konzipiert ist. Der komplette R5 Scheme-Sprachstandard wird unterstützt, inlusive Continuations, beliebig genaue Integer- und Bruchzahl-Arithmetik, Fließkommaarithmetik und komplexen Zahlen. Daneben gibt es noch zahlreiche Erweiterungen, etwa ein Modulsystem und ein Foreign-Function-Interface zur direkten Einbindung beliebiger externer Funktionen aus DLLs ohne dazu selbst Glue-Code in C verfassen zu müssen. Überdies werden bereits zahlreiche Bindungs für die meisten POSIX-Funktionen fertig mitgeliefert, sowie Hilfs-Funktionen um Shell-ähnliche Unterstützung externer Kommandos zu ermöglichen. Bemerkenswert ist überdies die sehr ausführliche Anleitung, die auch als Scheme-Lehrgang für Neulinge in dieser Sprache geeignet ist. Strings und Arrays sind in Guile eigene Datentypen mit effizienter Low-Level-Implementierung, und nicht etwa höchst ineffiziente vorwärts verkettete Listen wie im originalen LISP. Es gibt zudem spezielle Datentypen für Integer-Arrays verschiedener Wortbreiten sowie effiziente Bit-Arrays, um den Speicherplatz-Overhead heterogener Arrays zu vermeiden. Guile wirkt damit insgesamt sehr ausgereift, vom Umfang her komplett und nützlich, und stellt mit seiner vorgesehenen Verwendung einen direkten Konkurrenten zu Lua dar. Es ist von den Möglichkeiten der Sprache (etwa Continuations und mehrfachgenaue Arithmetik) her mächtiger als Lua und hat auch umfangreichere mitgelieferte Standardfunktionen (etwa vollwertige regular Expressions und echter Multithreading-Support). Dafür ist allerdings auch der Installationsumfang rein für die Executables um den Faktor 3 größer (ca. 1 MB), und das beinhaltet noch nicht die zusätzlich zur Laufzeit benötigten als Scheme-Quelltext ausgelieferten Teile der Standardbibliothek welche (bei Verwendung) ebenfalls mit installiert werden müssen. Hinzu kommt die allgemeine "Gewöhnungsbedürftigkeit" der Scheme- bzw. LISP-Syntax mit ihren unzähligen Klammern. Geringfügig performanter als Lua, aber oft nur im Zehntelsekundenbereich. Dabei war der Bytecode-Compiler von guile dabei bereits aktiviert. Guile ist daher für die meisten Aufgaben ausreichend schnell. Eine wirkliche Katastrophe ist jedoch die Implementation von CALL-WITH-CURRENT-CONTINUATION: Dieses CALL/CC ist dadurch implementiert, dass der komplette C-Stack durch Kopieren mit jenem der anderen Continuation ausgetauscht wird. Es funktioniert daher zwar, dürfte aber schweinelangsam sein. Exceptions sind in Guile aus diesem Grund nicht mit CALL/CC implementiert, sondern mit einem einem eigenen (non-Standard soweit ich weiß) Feature namens "delimited continuations" welches ein CALL/CC nur unter bestimmten Bedingungen ersetzen kann, dann jedoch ohne das erwähnte Kopieren auskommt. Weiters unschön ist dass Guile auf dem BoehmGC basiert, einem meiner Meinung nach hirnrissigen Methode um Garbage Collection zu implementieren welche nicht garantieren kann dass alle nicht mehr verwendeten Objekte frei gegeben werden. Und schließlich entdeckte ich 2021-01 einen horrenden Bug, wo die Tail Recursion nicht korrekt arbeitete und sich das Programm in einer Endlos-Schleife aufhängte. Der Bug existierte offenbar "nur" in der x86-32 Version, aber das ist schon schlimm genug. Will man sich wirklich auf eine Implementation verlassen die *solche* Fehler macht? Dennoch bleibt Guile ein interessanter Kandidat zur Implementation von hochkomplexen (aber nicht übermäßig performance-kritischen) Script-Applikationen auf Systemen mit minimalem Stand-Alone-Installationsumfang, da dieser immer noch wesentlich geringer ist als der meisten anderen Scriptsprachen (mit Ausnahme von Lua, Wren und Tcl). guile ist zudem eine der wenigen Sprachen, die ohne zusätzliche Maßnahmen korrekt und automatisch auf Fehler (inklusive E/A-Fehler) reagieren.
gwenview/kde-base/gentoo {graphics image viewer}: Bislang bester KDE-Bildbetrachter. Kann dem Konqueror als ein Bildbetrachter dienen. Kann aber auch als eigenständiger Bildbetrachter eingesetzt werden. Verwendet für JPEG-2000 leider auch den langsamen KDE-Decoder. Unterstützt auch KIPI-Plugins. Kann Drehen, Spiegeln, Zoomen, Autozoom, Vollbild- und Browsing-Modus, Diashow, Nachbearbeitungsfunktionen für Kontrast etc - auch Tastaturbedienbar. Unterstützt eigene Lesezeichen und Thumbnails. Kann EXIF-Kommentare von JPEG-Bildern ändern. Riesenplus: Die überall dargebotenen 90-Grad-Dreh- und Spiegelungs-Buttons arbeiten auch ohne die KIPI-Plugins gleicher Funktionalität verlustlos falls man speichert. Erlaubt das Konfigurieren von externen Programmen über die Kontextmenüs. Früher als media-gfx/gwenview bekannt.
gxine-0.5.905/media-video/gentoo {media-player}: Ein xine-lib Front-End und sehr minimalistischer Media-Player, der nicht einmal über einen "next/last Title"-Button verfügt - man scheint Songs nur über die Play-Liste gezielt wechseln zu können. Auch sonst sehe ich keinen erkennbaren Mehrwert gegenüber xine-ui. Außer vielleicht dass es eine native GTK+ Anwendung ist, während "xine" eine TCL/Tk-Anwendung ist.
gxmessage-3.4.3-1/gnome/raspbian {cmdline-dialog}: Ein auf GTK+ basierendes Drop-In Replacement für "xmessage". Anders als das Original hat gmxmessage keine Probleme mit Unicode oder UTF-8. Eine Erweiterung von xmessage ist die Zurverfügungstellung eines Texteingabefeldes. Außerdem kann der Zeichensatz explizit angegeben werden; so erspart man sich eine etwaige vorherige Konvertierung der anzuzeigenden Texte. Grundsätzlich wirkt gxmessage nett und brauchbar. Aber anders als xmessage oder zenity ist es ein Exot der kaum jemals irgendwo vorinstalliert sein dürfte.
gyp-0.1+20150913git1f374df9-1/python/devuan {software build system}: Gyp ist ein Meta-Buildsystem, welches temporäre Projekt-Dateien (sprich sie werden nicht mit den Quelltexten ausgeliefert da sie maschinen-spezifische Details enthalten) für das Ninja-Buildsystem generiert. gyp ist ein Google-Produkt, wo Projekt-Dateien als JSON erzeugt werden und offenbar auch JavaScript tief ins Framework integriert ist. JSON hat zwar einige Vorteile wie dass man verschiedene Projektdateien bzw. Teilprojekte effektiv automatisch mergen kann. Aber es sieht grässlich aus und ich hasse es!
gzip-1.9-3/utils/debian {compression}: Dieses Paket enthält eine ganze Suite von Utilities zum Umgang mit dem bekannten *.gz Dateiformat. Das primäre Werkzeuge ist das Kommando "gzip" zum Komprimieren und Dekomprimieren von Dateien in das bzw. aus dem Gzip- bzw. *.gz-Dateiformat. Dieses Dateiformat kann nur jeweils eine einzelne Datei komprimieren, anders als das noch bekanntere Zip-Dateiformat dem es technisch ähnelt kann es nicht mehrere Dateien in eine Archivdatei packen. Man umgeht dies normalerweise dadurch, indem man mehrere Dateien zunächst mit einem nicht-komprimierenden Archivierungsprogramm wie tar, cpio, pax oder ar in eine einzelne Archivdatei archiviert, und diese dann mit gzip komprimiert. Auf diese Weise entstehen beispielsweise die bekannten *.tar.gz bzw. *.tgz-Dateien. Die Kompression von gzip ist vergleichsweise schwach, hat jedoch auch drei Vorteile: Zum einen haben Gzip-komprimierte Dateien nur einen sehr kleinen Metadaten-Overhead, so dass bereits kleine Originaldateien meist am kleinsten werden wenn man sie mit gzip komprimiert. Ab einer gewissen Mindestgröße fällt der Metadaten-Overhead dann aber nicht mehr ins Gewicht, und dann wird gzip zunehmend ineffizienter in der Kompression. Der zweite Vorteil entsteht wenn bereits komprimierte Dateien mit gzip erneut komprimiert werden sollen. gzip erkennt dies nämlich und versucht dann nicht die Dateien erneut zu komprimieren wodurch sie nur größer würden. Wenn man ohne Unterscheidung alle Dateien in einem Verzeichnis komprimiert, verursacht gzip dann im Falle von bereits komprimierten Dateien dann häufig den geringsten Overhead bei den Ausgangsdateien. Der dritte Vorteil ist die Option "--rsyncable" welche man beim Komprimieren großer Abbild-Dateien benutzen kann. Diese Option versetzt "rsync" sowie andere auf dem dahinter stehenden "rsync"-Algorithmus aufbauende Werkzeuge in die Lage, Unterschiede zwischen alten und neuen komprimierten Versionen der Abbild-Dateien zu erkennen, und so nur diese zu übertragen, anstatt dass man die gesamte Abbild-Datei im Falle eines Updates erneut übertragen muss. Werkzeuge welche direkt von dieser Fähigkeit Gebrauch machen können sind: rsync, zsync, rdiff und xdelta3. Vermutlich hilft diese Option auch allgemein bei binären Diff-Werkzeugen wie bsdiff, allerdings kommt es dann immer darauf an wie der jeweilige Algorithmus konkret arbeitet. Es kann daher sinnvoll sein neben mit leistungsstärkeren Komprimierungsprogrammen wie "xz" erzeugten Versionen von Abbild-Dateien auch eine mit "gzip --rsyncable" erzeugte auf einem Download-Server abzulegen obwohl diese um einiges größer sein wird, insbesondere wenn zusätzlich auch noch eine *.zsync-Datei für die *.gz Datei mit dem zsync-Utility erstellt und ebenfalls zum Download anbietet. Das erlaubt dann einen Download von nur den geänderten Teilen eines Datenträger-Abbilds im Falle eines Updates, ohne dass man dafür einen "rsync"-Service auf dem Download-Server bereit stellen müsste (mit dem dasselbe auch ohne *.zsync-Datei möglich wäre). Neben dem erwähnten "gzip"-Utility stellt das Paket noch die folgenden weiteren Utilities zur Verfügung, von denen die meisten allerdings nicht viel mehr tun als eine Datei temporär zu entpacken und dann an irgendwelche externen Standard-Tools zur Verarbeitung zu übergeben. "gzexe" packt ausführbare Dateien so dass sie kleiner werden aber ausführbar bleiben. Das verursacht dann zur Laufzeit dieser ausführbaren Dateien zwar Performance-Nachteile beim starten und vermutlich auch erhöhten RAM-Bedarf, hat aber ansonsten keine weiteren negativen Auswirkungen. Dieses Feature kann sinnvoll sein, falls ein anderswo benötigtes ausführbares Programm ansonsten nicht auf einen kleinen Datenträger passen sollte, und man dem Anwender auch nicht zumuten möchte ein komprimiertes Archiv zu erhalten dass er erste entpacken müsste bevor er das ausführbare Programm darin benutzen kann. "gzexe" kann die Komprimierung aber auch wieder vom ausführbaren Programm entfernen, so dass man wieder die Originaldate erhält. Ein kleiner Vorteil solcher komprimierter Programme ist der Umstand dass das Gzip-Dateiformat, auch im Sonderfall komprimierter ausführbarer Dateien, eine Prüfsumme enthält, so dass Datenträgerkorruptionen in der Datei erkannt und gemeldet werden, anstatt ein beschädigtes komprimiertes ausführbares Programm einfach zu starten und es stürzt dann ab (wenn man noch Glück hat). "gunzip" ruft "gzip" mit der Option zum Dekomprimieren auf. "zcat" dekomprimiert die Datei und gibt ihren Inhalt auf die Standardausgabe aus. "zcmp" und "zdiff" dekomprimieren die Dateiargumente temporär falls es sich um .gzip-Dateien handelt, und vergleichen die Inhalte danach mit "cmp" bzw. "diff". "zforce" untersucht Dateien anhand des Inhalts ob es sich im Gzip-komprimierte Dateien handelt, und fügt benennt diese um damit sie ".gz" als zusätzliche Datei-Endung haben, falls dies nicht bereits der Fall ist. "zgrep", "zless" und "zmore" extrahieren ähnlich wie "zcat" die Datei temporär und rufen dann die gleichnamigen Utilities (mit Ausnahme des "z" am Anfang) für die temporären Dateien auf. "znew" erlaubt es Dateien die im noch älteren (und noch schwächer komprimierenden) *.Z-Dateiformat komprimiert sind automatisch in *.gz-Dateien zu rekomprimieren. Obwohl gzip nur einzelne Dateien als *.gz-Dateien komprimieren kann, erlaubt es aber zumindest dennoch mehrere einzelne Dateien als Kommandozeilenargumente anzugeben und diese dann alle mit einem einzigen Aufruf des Utilties zu komprimieren (oder zu dekomprimieren).
handbrake-0.9.4/media-video/gentoo: Converts videos from various sources (most importantly from DVD) into MPEG-4/AVC/x264/H.264 Matroska files. Other output formats are also supported but not as important. Aims to become a rival to the "DVDShrink" Windows package.
hardlink-0.3.2+b2/utils/raspbian {deduplication}: Stellt das "hardlink" Utility bereit, welches Verzeichnisbäume nach Duplikaten durchsucht und diese durch Hardlinks ersetzt. Es bietet auch --dry-run für eine Vorschau was es tun wird. Alternativ kann es auch "reflinks" anstatt Hardlinks verwenden, das sind Copy-On-Write Klone. Allerdings muss auch das Dateisystem dieses Feature unterstützen, was nur wenige Dateisysteme (Stand 2021: btrfs, cifs, nfs v4.2+, ocfs2, overlayfs, bcacheFS und xfs) tun. Per Default beachtet hardlink auch Permissions und Ownership beim Vergleich; dies lässt sich jedoch abschalten. Optional kann man verlangen, dass nur Dateien deren "basename" identisch sind für einen Vergleich heran gezogen werden. Extended Attributes werden per Default beim Vergleich ignoriert, man kann jedoch auch einstellen dass sie beachtet werden. Ein Problem dieses Programms ist dass es viele unterschiedliche Implementierungen unter demselben Namen gibt. Nicht alle arbeiten so wie hier beschrieben. Das Verhalten ist daher Distributions-spezifisch. Hat man keine Ansprüche beim Vergleich der Dateiattribute, ist "rdfind" daher eine sicherere Alternative.
haveged 1.9.1-2/extra/archlinux: Ein Daemon, welcher effizienter Entropie sammelt als /dev/random dies intern tut, und diese Entropie dann /dev/random zuführt. Angeblich benutzt haveged "CPU-timings", auch Cache-Timings sollen in den Algorithmus eingeben - aber nirgends wird genau erklärt wie dieser "HAVEGE"-Algorithmus tatsächlich funktioniert. Daher kann ich nicht einschätzen wie ernsthaft er ist. Störend an haveged ist, dass er seine Entropie nur nach /dev/random füttern kann, mit /dev/urandom wo er vielleicht mehr Sinn machen würde (solange man die Qualität der angeblichen Entropie nicht nachvollziehen kann) funktioniert er nicht richtig bzw. führt zu 100 % CPU-Auslastung. Ein Vorteil des Programms ist jedoch, dass es keine spezielle Hardware benötigt um zu funktionieren. Die Gefahr bei der Benutzung dieses Programms ist, dass /dev/random eine höhere Entropie vorgegaukelt werden könnte, als haveged tatsächlich generieren kann (da man es mangels Wissen um die Funktionsweise der Implementierung nicht überprüfen kann).
hdup-2.0.14-4+b2/utils/devuan {backup}{compression}: Benutzt einfach das "tar"-Dateiformat, wahlweise mit bzip oder gzip komprimiert (scheinbar keine weiteren Alternativen), wahlweise mit "mcrypt" verschlüsselt, und erlaubt es diese Backup-Archive dann mittels ssh auf einem Remote-Server abzulegen, wobei das Archiv auf Wunsch noch in Teile mit einer Maximalgröße zerlegt werden kann. Man fragt sich ernsthaft, wozu man hierfür eigentlich ein spezielles Programm braucht. Zumal das Programm offenbar (glib-basiert) in C geschrieben ist. Es gibt Hinweise darauf dass die aktuelle Version (Stand 2019) vielleicht auch PGP-Encryption und LZO-Komprimierung versteht; außerdem kann sie rsync anstatt SSH als Transportmechanismus verwenden. Dennoch.
herbstluftwm-0.9.2-1/x11/debian {window manager}{GUI}{X11}: Ein Tiling Window manager. Bringt ein Utility "herbstclient" zum Übermitteln von Befehlen an den WM mit. Kann mit dem Befehl "wmexec" im laufenden Betrieb auf einen anderen WM wechseln.
hexcurse/app-editors/gentoo {hex-editing}{text-terminal IO}: Cannot edit large files.
hexedit/app-editors/gentoo {hex-editing}{text-terminal IO}: Simple console hex editor. Supports large files and does not need to load the whole file at once. Can edit block devices. Provides the usual split hex/ASCII screen layout. Search for hex and ascii. Jump to any offset. Truncate or grow the file. Copy a byte range to a buffer and use it to overwrite bytes elsewhere. Cannot insert or remove bytes from somewhere within the edited file. ("joe" can do that, however.) A flaw of hexedit is its inability to adjust the number of hex bytes displayed per line. It only depends on the display width.
holotz-castle-1.3.14-9/games/debian {game}: Ein Jump'n Run Platform Game. Typisch von einem Programmierer und keinem Grafiker designed, denn die Männchen und Objekte sehen alle sehr holprig bzw. grafisch eher schlecht gestaltet aus. Die Levels haben unterschiedliche Größe, füllen aber in der Regel den Bildschirm nicht aus sondern nur einen kleinen Teil davon. Allerdings kam ich nicht sehr weit, vielleicht werden spätere Levels noch größer. Grundsätzlich scheint der Spielablauf im jedem Level so zu sein, dass man alle Schlüssel einsammeln muss um das level über eine Art blauen Beam-Strahl verlassen zu können. Dabei muss man hüpfen und springen sowie über Leitern klettern und dabei Hindernissen, Gegnern und Fallen ausweichen. Grundsätzlich vielleicht gar nicht so schlecht wenn man gerade Lust auf so eine Art von Spiel hat. Etwas nervig allerdings die Sprechblasen mit Text die zwischen den Leveln immer wieder und mehr als nur eine davon eingeblendet werden, und mit der die Spielfigur Monologe oder Dialoge hält (scheinbar ist man mit einem Bruder unterwegs, der einen zumindest anfangs aber nicht durch die Levels begleitet) und mit der wohl eine Hintergrundgeschichte erzählt werden soll. Nur: Wenn interessiert bei so einem Plattformer schon die Hintergrundgeschichte: Mehr als ärgerlich auf die Tasten hämmern damit diese blöden Sprechblasen endlich wieder verschwinden ist kaum drin. Immerhin ist das Spiel nicht groß - 2,7 MB samt aller Levels (es scheint 33 davon zu geben), Sounds und Grafiken (so holprig sie auch optisch sein mögen).
horde-3.3.11/www-apps/gentoo {wiki}: PHP-basierte Groupware mit Mail Client, Adressbuch, Kalender, Notizen, To-Do-Listen, Dateimanager, Wiki, Zeiterfassung, Aktivitätserfassung, Ticket-Tracking-System.
hpanel-0.3.2-4/x11/debian {desktop panel}: Ein Fork bzw. der Nachfolger von fspanel. Kann ebenfalls nichts anderes als Workspaces umschalten und einen Taskleiste der laufenden Programme anzeigen, behebt jedoch einige Bugs von fspanel (wie Probleme mit maximierten Fenstern). Der einzige erkennbare Unterschied ist dass fspanel zwei Buttons zum Wechseln der Workspaces anzeigt, während hpanel so viele nummerierte Buttons (quasi ein "Pager") zum Umschalten anzeigt wie Workspaces vorhanden sind. Somit skaliert fspanel besser mit vielen Workspaces, aber hpanel arbeitet angenehmer mit einer begrenzten Menge an Workspaces. Auch hpanel hat keine Konfigurationsdatei sondern hard coded Settings die nur durch Rekompilierung geändert werden können.
hsetroot-1.0.5-1/x11/raspbian {graphics image viewer}: Ein sehr kleines Programm (11 kB Download unter raspios), welches ausschließlich das Hintergrundbild des X11-Desktops setzen kann. Es unterstützt dazu die Bildformate welche die "libimlib2" unterstützt, was zumindest alle relevanten klassischen Formate sind (sowie einiger neuer wie WebP, HEIF und JPEG-XL). Es lässt sich auch als Back-End für das Wallpaper-Setter Front-End "fbsetbg" der FluxBox benutzen. Doch leider hat dort es die ärgerliche Angewohnheit, beim Aufruf eine unerbetene Zeile mit Diagnose-Meldungen is Terminal zu schreiben. Dadurch wächst möglicherweise das Error-Log des X11-Servers unnötiger Weise an.
ht-2.1.0+repack1-3+b1/devel/debian {hex-editing}{text-terminal IO} {security}: Console-based hex editor "hte" (not "ht", executable has most likely been renamed by package maintainers due to naming conflicts) using "midnight-commander"-like color style. Borland-style textmode GUI with menus and dialogs. Can edit very large files and block-devices in-place. Views: hex, text, 16/32 bit, x86/amd64/Alpha/PowedPC, ARM, AVR, JAVA bytecode disassembly (including xrefs, automatic label creation, follow disassembled jump instructions, x86 direct assembler, file header section viewer for executable binaries). Different executable formats supported, including MS-DOS, Windows and Linux executables. Optional format autodetection when opening files. Multiple open files and window views. Calculator-like expression evaluator (just line input though, no fancy buttons, yet with command history). Built-in offline help. Project files. Clipboard. Has display issues with block graphics symbols in UTF-8 locales (does not impair functionality, though, and can be "fixed" by invoking "hte" using the POSIX locale). Block operations can perform certain operators on marked ranges of the file, using a simple interpretive expression language. Search for ASCII data, RegEx search (not in the binary data but in its on-screen representation, including disassembly and hex data), search for simple byte or ASCII strings, search by evaluating an expression (which may reference data located at different offsets relative to the current search position) continuously calculated for every location, search by statically matching the result of an expression, search for entropy (random-looking data, may be used to locate cryptographic keys or hashes), replace found data in-place.
html2text-1.3.2/app-text/gentoo: Converts HTML 3.2 documents (and to a lesser extent also HTML 4 documents) to plain text. Users a tolerant parser which is able to skip most unknown HTML constructs. Understands tables and enumerations and can convert them into appropriately formatted plaintext equivalents. Hyperlinks are displayed as text in brackets. Images are displayed as file names in separate paragraphs. Special formatting such as boldface or underlined will be simulated to some extent using various techniques such as overprinting. (This can be disabled, though.)
htop/sys-process/gentoo: Very nice console-based interactive replacement for "ps". Shows the threads and processes in different ways, easily customizable in the GUI. Can also view the process inheritance tree and the full command lines of the processes. Furthermore, allows selecting, killing and re-nicing of processes. An invaluable tool!
httpfs2-0.1.4-1/web/debian {FUSE}: Erlaubt es, beliebig viele explizit einzeln beim Mounten angegebene URLs als eben so viele einzelne virtuelle Dateien innerhalb des Mountpoint-Verzeichnisses einzublenden. Mit anderen Worten, man kann sich damit keinesfalls etwa rekursiv durch die Link-Struktur einer Webseite bewegen und sie so "erforschen". Man erspart sich nur den Aufruf von wget/curl zum direkten Herunterladen einer *einzelner* Dateien deren URL man bereits vorher angegeben haben muss. Somit ein eher sinnfreies Dateisystem welches bestenfalls dann einen Sinn macht, wenn eine Datei sehr häufig am Web-Server aktualisiert wird und man zu faul ist jedesmal wget aufzurufen.
httptunnel-3.3-r2/net-misc/gentoo: Stellt die vergleichsweise schlanken Kommandos hts und htc zur Verfügung. Mit hts kann man einen TCP-Forwarding-Server auf einem externen Server einrichten, welcher über eine "harmlose" HTTP-Verbindung von einen Client hinter einer Firewall erreicht werden kann. hts erlaubt es dem Client dann, SSH, telnet oder was auch immer für Verbindungen vom Server aus durchzuführen. htc muss am Client installiert sein und lauscht dort an einem Port, dessen Verbindungen es dann über den HTTP-Tunnel an die hts-Instanz am Server weiterleitet. Alles nett und schön, nur: Das alles kann socat auch, ohne dass man ein eigenes Tool dafür bräuchte. Allerdings ist das socat-Executable auch wesentlich länger. httptunnel scheint zudem keinen speziellen Support für Reverse-Proxy-Verbindungen zu besitzen.
hugin-2011.0.0/media-gfx/gentoo: Erstellt Panoramaaufnahmen aus Einzelbildern, kann aber auch dazu verwendet werden um eingescannte Teilbilder eines übergroßen Originals wieder zu einem einzelnen Bild zusammen zu setzen. Mit GUI. Sehr mächtig, aber auch ziemlich komplex. Es gibt aber etliche Tutorials zum Herunterladen.
hunspell/app-text/gentoo: A spell checker. An improved replacement for MySpell in OOo. Based on MySpell which was its predecessor in OOo, but can in addition also handle UTF-8. Mozilla Firefox and Thunderbird can use make use of hunspell for spell checking. Hunspell is also the most popular backend for the Enchant spell-checker abstraction library.
hydrogen-0.9.3/media-sound/gentoo {audio}{music}: Nice, graphical drum machine. Features Patterns, Songs, Mixer, SFX - all that you need. Songs can also be exported as MIDI files. Note that the Rosegarden sequencer can import hydrogen tracks.
hyperestraier-1.4.10-r1/app-text/gentoo: Ein Volltext-Suchsystem. Ein Commandline-Tool erzeugt oder aktualisiert einen Index, indem es eine Verzeichnisstruktur nach unterstützten Dateitypen durchsucht. Inkrementelles Arbeiten ist dabei möglich indem die Modifikationszeit einer bereits indizierten Datei als Indikator für Änderungen genommen wird. Der Suchindex wird in einer NoSQL qdbm-Datenbank abgelegt. Man kann entweder ganze Directory-Trees indizieren, dann aber Dateien mittels primitiver Joker der Basenames ex- oder inkludieren. Oder man gibt übergibt den Programm bereits die Liste der Dateien (ähnlich wie tar -T). Die Durchführung der eigentlichen Suche ist über ein Commandline-Tool oder ein CGI-Script möglich welches Teil der Installation ist. Weiters bringt das Programm Libraries mit, so dass auch andere Programme die Such- und Index-Funktionen per API ansteuern können. Die bekannte KDE-Desktopindex-Lösung "Strigi" kann (als eine mögliche Variante) hyperestraier als Suchmaschine verwenden. hyperestraier indiziert nicht nur einfach ein Dokument als ganzes, sondern erlaubt es verschiedene Attribute davon unterscheidbar zu indizieren. Bei Mails etwa könnten die diversen Mail-Header-Felder als von Mailtext unterscheidbare Attribute indiziert werden. Als Datentypen kennt das Programm grundsätzlich nur Zahlen und Zeichenketten; Datumsangaben werden beim Parsen in UNIX-Timestamps konvertiert. Die Größe eines Suchindexes ist schon allein Datenbankseitig auf 1 TB begrenzt, da das zugrunde liegende qdbm keine größeren Datenbanken unterstützt. hyperestraier unterstützt UNICODE und UTF-8 und versucht bei Dokumenten wo das Encoding nicht angegeben ist dieses aus dem Inhalt zu erraten. Jedes Dokument erhält beim indizieren eine interne Nummer, sowie eine URL welche dem Pfad des Dokuments im Dateisystem entspricht. Diese URL kann aber durch eine Regular Expression für die Anzeige im Suchergebnis in eine andere transformiert werden, welche dann typischerweise eine URL des Web-Servers darstellt auf dem das Such-CGI-Script angeboten wird. Folgende Dateiformate werden von den mitgelieferten Tools erkannt (man kann aber eigene Tools für andere Formate schreiben die sich der dokumentierten Libraries des Programms bedienen): Plain text (".txt", ".text" or ".asc"), HTML (".html", ".htm", "xhtml", or ".xht"), MIME/e-mail (".eml", ".mime", ".mht", or ".mhtml"). Document draft (."est") ist ein proprietäres Textformat des Programms mit speziellem Format, in das andere Dokumenttypen konvertiert werden können um im Anschluss indiziert werden zu können. Das .est-Format ist im wesentlichen ein simples UTF-8 Textdokument mit ein paar speziellen Header-Zeilen am Anfang welche benannte Attribute definieren. Nicht direkt unterstützte Dokumenten-Formate können beim indizieren auch "On The Fly" in eines der obigen Formate konvertiert werden, indem man dem Indizierungstool ein selbst geschriebenes Filterkommando übergibt. Der Index wird normalerweise von einem cron-Job aktualisiert; auf jeden Fall muss das Tool dazu explizit aufgerufen werden. Wenn der Speicherplatz von gelöschten oder ersetzten Dokumenten wieder freigegeben werden soll, ist eine spezielle zusätzlich Kompressions-Operation erforderlich (ähnlich wie bei Git). Die Suche erlaubt implizites AND und explizites OR zwischen Suchworten, sowie exakte Phrasen in Hochkommas. Weiters sind ANDNOT und sowie Präfix- und Suffix-Suche in Worten möglich. Regular Expressions werden auch unterstützt, allerdings nur innerhalb eines Wortes. Es gibt "simplified" und normale Suchsyntax; die simplified Syntax entspricht mehr oder dem was man von der allgemeinen Bedienung bei Google gewohnt ist. Für benannte Attribute gibt es zusätzliche Suchmethoden, etwa für Datumsvergleich. Ein bisschen schwach ist die Reihung der Ergebnisse: Man kann diese entweder nach Attributfeldern sortieren lassen (etwa Datum), oder nach "Score". Dieser ist aber weit primitiver als der von Google; der Scrore wird einfach aus der Anzahl der übereinstimmenden Suchworte im Dokument berechnet. Man kann beim Erzeugen des Indexes einige Tuning-Parameter mitgeben, etwa die (erwartete) Maximalzahl der Dokumente; hier gibt es mehrere Abstufungen zwischen 50 Tausend 10 Millionen oder mehr Dokumenten. Das Indizierungstool erlaubt es eine Maximalgröße für Dateien festzulegen, damit Datenbanken etc. nicht irrtümlich mitindiziert werden. Ebenso ist eine heuristische Erkennung für Binärdateien einschaltbar. Die Interpretation des Encodings der gefundenen Dokument-Pfadnamen im Dateisystem ist ebenfalls explizit definierbar. Das Programm hängt nur von wenigen Libraries ab: qdbm, zlib und libiconv (das Teil der glibc ist). Der Installationsumfang ist mit 3,5 MiB auch harmlos. Neben den Commandline-Tools und dem "C"-API werden noch Bindings für Perl, JAVA und Ruby mitgeliefert. Der Index verwendet File Locking, so dass Zugriff durch mehrere Tools zugleich kein Chaos auslöst. Alles in allem macht hyperestraier einen nützlichen Eindruck, und auch der Umstand dass er alles in einer einzigen Datei unterbringen kann statt seinen Index auf unzählige Dateien aufzuteilen wirkt zumindest grundsätzlich sympathisch. Der sehr primitive Scoring-Algorithmus sowie das Fehlen eines NEAR Operators dürften sich aber negativ auf die Relevanz der gelieferten Suchergebnisse bzw. deren Reihenfolge auswirken - zumindest soweit das Scoring in der Dokumentation korrekt beschrieben ist. Weiters gibt es keine direkte Möglichkeit, komprimierte Archivinhalte zu indizieren, es sei denn man entpackt sie selbst "On The Fly". Schließlich fehlen Features wie Stemming und Stop Words. Jedoch bietet es Support für app-text/mecab, einen "Part-of-Speech and Morphological Analyzer" hat, was immer das auch genau ist, der vielleicht einige dieser Mankos beseitigen mag.
i3lock-2.4.1-1/x11/debian {screen locker}{GUI}{X11}: Supposed to be a minimalistic screen-locker for X11 with DPMS support. However, it does not do anything. Just displays the usage help as if some invalid option had been specified. Even if no options have been specified at all! And the manual says it's OK to call it without any option. In other words, it is currently unusable.
icebreaker-1.21-11/games/debian {game}: Ein Quix-ähnliches Spiel, bei dem man eine Eisfläche unterteilen muss bis die Fläche klein genug geworden ist, um darin gefangene Pinguine "einzusperren". Die Grafik ist nicht häßlich, aber schlicht. Das Fenster ist in der Größe beschränkt. Braucht zwar nur wenig Ressourcen, ist aber auf längere Zeit stinklangweilig und weitaus weniger fesselnd als das originale Quix. Besser vergessen. Allerdings ist es dennoch allemal besser als xonix, wohl auch da man es mit der Maus steuern kann.
icewm-1.2.30/x11-wm/gentoo {window manager}{GUI}{X11}: Very nice X11 themeable windows manager, provides what most people need without the overhead of a real DTE. Integrated docklet for displaying time, network traffic and CPU load. Heavily customizable via feature-packed configuration files.
iec16022 0.2.4-2/community/archlinux: Bibliothek und Kommandozeilenprogramm zum Erzeugen von IEC-16022 2D-Barcodes, auch "DataMatrix" sowie "Semacode" genannt. Ausgabe als Textdatei (mit Sternchen und Leerzeichen), Encapsulated PostScript (EPS), PNG, Binary/Hex (als Bitmuster) sowie "Stamp" (was auch immer das sein soll).
ii-esu-1.0a.dfsg1-8/games/debian {game}: Ein sehr abstrakt aussehender von einem Japaner verfasster Vektorgrafik-Shooter. In D geschrieben und mit SDL implementiert. Das Fenster ist nur relativ klein, quadratisch und lässt sich nicht in der Größe verändern. Vollbildmodus scheint ebenfalls nicht unterstützt zu werden. Das ist schade, weil eigentlich wirkt das Spiel durch seine ungewohnte Drahtgitter-3D-Grafik recht interessant, und wirkt auch recht rasant. Allerdings hat man keinen Schimmer was man eigentlich zu tun hat, bzw. auf was man schießen soll und auf was nicht. Die Steuerung ist auch sehr gewöhnungsbedürftig, aber in erster Linie weil man mit der Mauszeiger ständig irrtümlich aus dem relativ kleinen Fenster heraus fährt, und dadurch völlig in die falsche Richtung steuert. Sound soll im Original enthalten gewesen sein, wurde aber aus Lizenzgründen entfernt. Kurzum, wirkt zwar optisch interessant, ist aber wegen der erwähnten Mängel kaum sinnvoll zu spielen.
ikiwiki-3.20140916/www-apps/gentoo {text-formatting}{wiki}: Ein in Perl geschriebener "Wiki-Compiler". Ziemlich fett für ein Perl Programm, über 10 MB Installationsumfang mit den rund 70 Paket-Abhängigkeiten (zusätzlich zu einer bereits vorhandenen Perl-Vollinstallation). Basiert auf der grundsätzlich vernünftigten Idee, ein Wiki aus Quelltexten zu erzeugen welche von einem Versionskontrollsystem kontrolliert werden. Etwas unverschämt ist aber das Default-Setup-Script, welches frech und ungefragt irgendwelche Dateien und Unterverzeichnisse direkt unterhalb von $HOME anlegt, ohne vorher um Erlaubnis zu fragen. Allerdings kann man das Wiki manuell auch ohne diese Nachteile aufsetzen. Die Quelltexte sind in der MarkDown-Syntax zu verfassen, die um ein paar Funktionen erweitert wurde um Verweise, Shortcuts, Übersichtsseiten und Smileys zu erstellen sowie Meta-Informationen (wie den Seitentitel) zu definieren. Es werden auch diverse Templates und CGI-Scripte mitgeliefert, mit dem man ein Wiki im Browser editieren kann. Die Änderungen werden dabei eingecheckt, falls man ein Versionskontrollsystem für das Wiki konfiguriert hat. Mit Plugins sind auch andere Quelltextsprachen möglich, wie ReStructured Text, WikiText, reines HTML oder Textile. Eine Spezialität sind Backlinks - am Ende einer Seite werden automatisch Links zu den Seiten angezeigt, welche auf diese Seite verweisen. Hyperlinks können relativ oder absolut zur einer Wurzel sein, oder auch komplexe Suchausdrücke mit Jokern und booleschen Operatoren enthalten sein. Dabei können viele Metadaten einer Wikiseite zum Vergleich benutzt werden - inklusive Datumsbereiche, Tags und GUIDs. Der Compiler setzt dann die Ergebnisse der Abfragen ein. Ganz nett, aber die Installation scheint mit für das gebotene irgendwie zu fett mit zu vielen Paket-Abhängigkeiten (auch wenn es nur Perl-Module sind).
imagemagick-8 6.9.7.4+dfsg-11+deb9u7/oldlibs/raspbian {bitmap image editor}{graphics image viewer}{graphics drawing}: In erster Linie enthält diese Suite Kommandozeilenprogramme mit "endlos vielen Optionen" zur Konvertierung und Manpipulation von Bitmap-Bildern aller Art. Es enthält aber auch ein Programm zum interaktiven Anzeigen von Bildern, das auch einige Filter und Bearbeitungsfunktionen anbietet. Allerdings nur solche Bearbeitungsfunktionen welche sich aufs ganze Bild oder einen Ausschnitt davon beziehen; es ist kein Malprogramm wo man mit der Maus im Bild herumändert. Einige der vielen Filter-Kommandos stellen tatsächlich Unterbefehle für traditionelle Zeichenoperationen in Bitmaps zur Verfügung, wie Linien, Rechteck, Ellipse, Kreisbögen, Polygon, Bezierkurve, Flood Fill, Textausgabe. Dadurch lassen sich auch aus Shell-Scripten heraus Grafiken, Diagramme usw. komplett neu dynamisch erzeugen, oder über vorhandene Bilder zeichnen um diese zu annotieren. Die Programme arbeiten allerding meistens sehr langsam und nicht auf hohe Performanz optimiert, gleichen dies aber durch unzählige Funktionen teilweise wieder aus. Generell ist imagemagick sehr nützlich um aus Scripten heraus aufgerufen zu werden. Auch wenn IM primär mit Bitmaps arbeitet, kann es sehr wohl Vektordatenformate wie PDF oder PostScript importieren und diese in Bitmap-Bilder zur weiteren Verarbeitung umwandeln. Enthaltene wesentliche Kommandozeilenprogramme: "animate" zeigt Animationen an (unklar ob es auch welche bearbeiten kann, etwa aus GIF-Dateien), "compare" vergleicht Bilder (mathematisch oder visuell) auf Unterschiede und markiert diese, "composite" überlappt mehrere Bilder und verknüpft sie mit verschiedenen Operatoren, "conjure" ist ein Interpreter für die "Magick Scripting Language" (MSL, einer umständlichen da XML-basierten Macrosprache zum Aufruf und Kombinieren von ImageMagick-Funktionen), "convert" ist das Haupt-Tool das Bildformate konvertieren und Filter sowie Transformationen auf Bilder anwenden kann, "display" ist das eingangs erwähnte interaktive Anzeige-Programm das auch einige Bearbeitungs-Funktionen enthält (leider ein potthässliches Interface), "identify" analysiert das Dateiformat und Eigenschaften des Bildes (Farb-Histogramm etc.) und gibt diese aus, "import" kann einen Screenshot erstellen und weiter verarbeiten, "mogrify" ist eine Art "inplace"-Version von "convert" welche das Originalbild überschreibt bzw. ersetzt während "display" eine neue Datei erstellt, "montage" kann ähnlich wie "composite" mehrere Bilder zu einem kombinieren nur dass der Fokus hier am nicht-überlappenden Anordnen liegt und auch Rahmen erzeugt werden können, "stream" extrahiert Teile eines Bildes sowie bestimmte Pixelattribute (wie ausgwählte Farbkomponenten) - und das schneller und ressourcenschonender als mit "convert" jedoch mit weniger Funktionen. "display" hat leider einen ärgerlichen Bug (Stand 2023-12, raspios) so dass beim Setzen von JPEG- und PNG-Bildern als Desktop-Background immer einen Return-Code von 1 zurück gibt, obwohl alles in Ordnung zu sein scheint. Scripte welchen den Return-Code prüfen glauben daher, "display" hätte versagt obwohl dem nicht so ist.
imediff2-1.1.2-r3/dev-util/gentoo {text-diff}{text-merge}{no-soft-line-wrap}{text-terminal IO}: Ein in Python geschriebenes interaktives ncurses-basiertes Diff- und Merge-Tool für 2 Eingabedateien. Verwendete wenn möglich auch Farben. Ähnlich wie kompare, benötigt aber kein X11. Völlig unbrauchbar für Fließtext-Dateien. Entwickelt bei großen solchen Dateien zudem einen riesigen Speicherbedarf der das ganze System ins Disk-Thrashing durch Swapping treiben kann.
img2pdf-0.4.0-1/utils/debian {PDF}: Kann bestehende PNG-, JPEG- und JPEG2000-Grafikdateien ohne zusätzlichen Konvertierungsverlust in PDF-Dateien umwandeln. Man kann daher mit externen Encodern zunächst solche Grafikdateien mit dem bestmöglichen Komprimierungsverhältnis oder der besten visuellen Qualität erzeugen, und das Ergebnis dann bei unveränderter Komprimierung in PDF-Dateien umwandeln.
incron-0.5.10-3+b2/admin/devuan: Ein Daemon der einen crond- sowie crontab-ähnlichen Mechanismus für Änderungen am Dateisystem zur Verfügung stellt. Basiert auf dem inotify-Mechanismus des Linux-Kernels. Kann sowohl für privilegierte Aufgaben als auch von unprivilegierten Benutzern verwendet werden. Unterstützt dabei auch einen allow/deny-Ansatz ähnlich wie "/etc/hosts.allow". Primitiv. Verschickt keine Mails (aber natürlich kann man selber "mailx" aufrufen). In C++ geschrieben. Sehr schlank - nur 125 kB für die Programmdatei und überschaubarer RAM-Verbauch (3 MB bei einem aktiven Job, ca. 500 kB ohne definierte Jobs). Ein Problem von incron ist jedoch dass jeder Job nur ein einzelnes Verzeichnis überwachen kann. Die Schuld daran liegt zwar nicht am Programm sondern dem darunter liegenden inotify-Mechanismus. Aber man fragt sich doch ob es dann nicht einfacher wäre einfach manuell ein inotify-Tool laufen zu lassen anstatt einen großartigen Hintergrunddienst dafür zu installieren. Der einzige Mehrwert scheint mir zu sein dass man damit Systemverzeichnisse überwachen kann, auf die normale Benutzer keinen Zugriff haben.
industri-1.01/games-fps/gentoo {game}: OSS QUAKE-Reimplementation. Benötigt allerdings die originalen Level-Dateien von der kommerziellen CD. Leider nur unter 32 Bit lauffähig.
info2www-1.2.2.9-24/doc/debian: Installiert ein CGI-Script, mit dem ein lokal installierter HTTP/WWW Web-Server "info"-Anleitungsseiten im Webbrowser anzeigen kann wenn man die URL http://localhost/cgi-bin/info2www/ ansurft, der Web-Server läuft und sein CGI-Modul aktiviert ist. Ein Problem sind allerdings Umlaute und Sonderzeichen: Zumindest per Default sendet der Server zwar UTF-8 codierte Webseiten an den Browser, gibt dies jedoch nicht in den HTTP-Kopfzeilen an, so dass zumindest der Firefox-Browser die falsche Codierung "Westlich" verwendet und man bei jeder neu geladenen Seite die Textcodierung erst manuell auf "Unicode" umstellen muss.
inkscape-0.92.1-1/graphics/raspbian: "Das" freie Vektorgrafik-Zeichenprogramm. Kann "alles". Was weniger bekannt ist und was es auch recht gut kann, ist PDF-Dokumente importieren und ihre Formatierung dabei *besser* zu erhalten als, zum Beispiel, LibreOffice Draw.
insight/dev-util/gentoo: Ein GUI-Debugger von Red Hat. Wie auch schon beim Source-Navigator macht er einen sehr guten Eindruck auf den ersten Blick. Beim zweiten muss man allerdings feststellen, dass bereits eine so simple Funktion wie "CPU-Register anzeigen" den Debugger mit einem Core-Dump ins Jenseits schickt. "Red-Hat-Stabilität" nenne ich dies. Trotzdem gefiel mir dieses GUI-Frontend des GDB noch am besten verglichen mit den anderen. Vor allem hat er ein zuschaltbares gdb-Konsolenfenster, mit dem man auch die exotischeren GDB-Kommandos erreichen kann. Seine Darstellung von Variablen und Strukturen ist ebenfalls gut gelungen, seine Kontext-Menüs sind hilfreich. Außerdem bietet er sinnvolle Source-Anzeige-Möglichkeiten an: Nur Source, Source und Assembler in einem Fenster, oder beides in 2 getrennten Fenstern aber synchronsiert. Für die Steuerung kann man ferner die GDB-üblichen Buchstabentasten verwenden, die man von der Commandline-Version her schon kennt. Fast wie der Single-Key-Modues des gdbtui. Auf jeden Fall alles sehr ansprechend - wenn nur die Stabilität besser wäre. Aber man kann das "info register" ja auch in der GDB-Konsole eintippen!
ioquake3-rbp 20130111-3/alarm/archlinux {game}: Ein Quake-3 Port, der bereits auf dem unmodifizierten Raspberry Pi Version 1 lauffähig ist. Die GPU des RPi liefert dabei genug Leistung, dass eine annähernd flüssige Darstellung dieses 3D 1st-Person Shooters gelingt. "Annähernd", da die Framerate insgesamt doch recht bescheiden ist, und bei komplexen Szenen ein Ruckeln bemerkbar wird. Das Paket selbst ist nur 30 MB groß, jedoch erfordert es dass man die Level-Dateien des kommerziellen Original-Spiels nach /opt/ioquake3-rbp kopiert was rund 460 MB zusätzlich belegt. Zusätzlich benötigt man noch einen Lizenzschlüssel, dessen Code beim ersten Start des Programms eingegeben werden muss. Das Paket ist alles in allem eine beeindruckende Demo der Leistungsfähigkeit des RPi. Als Spiel ist es jedoch uninteressant. Zumindest im Einzelspielermodus, da Q3 leider keine richtige Einzelspielerkampagne besitzt, sondern als Ersatz nur Mehrspieler-Level bietet, in denen man gegen Bots kämpfen kann. Dies wird rasch langweilig. Wenn man das Spiel hingegen als echten Multiplayer-Shooter benutzt, stört rasch die im Vergleich zu deutlich rechenstärkeren PCs doch ziemlich geringe Framerate, wegen der man im Nachteil ist was die Reaktionsgeschwindigkeit betrifft. Wenn man andererseits nur gegen Spieler antritt welche dieselbe Hardware nutzen, mag das Spielerlebnis möglicherweise befriedigend sein.
irrlicht/dev-games/gentoo: Eine offenkundig sehr beliebte freie 2D und 3D Game-Engine für Linux, Windows und andere Plattformen. Verwendet OpenGL oder Direct3D als Backend. Bindings in viele Sprachen; darunter auch die meisten Scriptsprachen. Schatten, Partikelsysteme, Character-Animation, Collision Detection, UNICODE, schlichter 2D-GUI Support. Kein Sound-, Netzwerk- oder Input-Support. Angeblich gute Dokumentation und Tutorials. Wird auch in kommerziellen Spielen verwendet. Angeblich relativ klein; in C++ geschrieben. Stable. War 2009 in aktiver Weiterentwicklung.
iselect-1.4.0-2/utils/raspbian {text-terminal IO}: Ein Text-Modus/Terminal Tool zum Auswählen von Texten aus einer Liste, welche entweder von der Standardeingabe oder den Argumenten stammt. Schlank, in C geschrieben, ncurses-basiert, wenige Abhängigkeiten. Problem: Es interpretiert zahlreiche XML-ähnliche Markup-Befehle als Teil der Strings für die Darstellung. Man kann daher nicht einfach irgendwelche Strings angeben, sondern muss sie erst gegebenenfalls escapen. Das ist so aufwändig, dass man aber lieber gleich die Texte in einem simplen Texteditor bearbeitet/auswählt, wo man sich um kein Escaping kümmern muss. Ohne den Markup-Schwachsinn, den man offenbar auch nicht abschalten kann, wäre es vielleicht ein gelegentlich nützliches Tool.
iso-codes-3.30/app-text/gentoo: Eine Sammlung von XML-Dateien und zugehöriger GETTEXT-Übersetzungsdateien, die Länder und Sprachen mit den zugehörigen ISO-Abkürzungen und Länder-Codes verbinden. Man kann damit beispielsweise den 2-Zeichen ISO-Sprachcode "DE" für die Sprache "Deutsch" finden. Auch die Bundesstaaten, Territorien, Provinzen und ähnliches so ziemlich aller Staaten der Welt sind hier erfasst.
ispell/app-text/gentoo: Screen-oriented spelling checker. The "de facto" spelling checker in the UNIX world. Grandfather of all UNIX spelling checkers. Primitive and outdated by today's standards, but still widely supported. Although it supports many languages, its correction algorithms are biased towards English. Spell-checking UTF-8 text files requires special versions of the dictionaries and seems not to integrate cleanly with the overall usage of the tool. Ispell had a very simple interface and spell-checked a file specified on the command line, or through a pipe.
iv/media-gfx/gentoo {graphics image viewer}: Primitiver GTK+ Bildbetrachter. Unfähig. Extrem hässliches GUI.
iverilog-0.9.1/sci-electronics/gentoo: Icarus VERILOG. Eine Hardware-Beschreibungssprache. Auf den Linux-Wochen 2013  wurde das C-ähnliche ältere VERILOG auch als mehr als Ada-ähnliche VHDL empfohlen; bei letzterem "tippe man sich die Finger wund" vor lauter Deklarationen. Ein weiteres Problem von VHDL sei dass es keine ausgereifte OpenSource-Unterstützung gäbe, während Icarus VERILOG wesentlich standardkonformer sei. Tatsächlich unterstützt iverilog zwar nicht den kompletten IEEE-1694 VERILOG Standard, aber beinahe. Dieses Paket enthält einen VERILOG-Compiler sowie einen Simulator mit dem das Kompilierte ausgeführt werden kann. Mir ist ein wenig unklar was das genau bedeutet. Vermutlich sieht man nur die Ausgabe von Diagnose-Befehlen, die man in VERILOG-Quelltexte zur Debugging-Ausgabe einbauen kann, um Statusinformationen über den aktuellen Zustand der Schaltung auszugeben.
ivtools-bin-1.2.11a1-8/graphics/devuan {vector image editor}: Enthält den X11 Vektorgrafik-Editor "idraw", der EPS Postscript-Dateien erzeugen und danach wieder editieren kann. Das gilt auch für Dateien, die durch die "Postscript Plotter"-Funktion der "GNU libplot" erzeugt wurden. Dies gilt für alle mittels "-T ps" erzeugten Ausgaben der Programme "graph", "plot", "pic2plot", "tek2plot" und "plotfont". Diese ps-Dateien kann man mit "ps2pdf14" aus dem ghostscript-Paket auf PDF-Dateien umwandeln, und mit "pstoedit -f idraw" aus dem "pstoedit"-Paket wieder retour. Allerdings werden bei solch einer Umwandlung alle grafischen Objekt-Gruppierungen aufgebrochen, die im Original-EPS gespeichert waren. Ca. 2,7 MiB Installationsumfang. Der Editor ist in hässlichem uralt-X11-Stil gehalten. Man kann damit Linien, B-Splines, Polygonzüge, Rechtecke, Ellipsen, Polygone und von B-Splines begrenzte geschlossene Objekte und Textobjekte erstellen. Es gibt eine sehr begrenzte Anzahl fix vordefinierter Füllmuster, Vorder- und Hintergrundfarben und Linen-Arten (durchgezogen oder strichliert in mehreren Dicken, Pfeile an den Enden der Linienzüge). Es gibt auch nur eine Hand voll Fonts zur Auswahl (Courier, Helvetica, Times Roman) in wenigen fixen Stilen (darunter bold und italic) und wenigen fixen Schriftgrößen. Allerdings lassens ich die Text-Objekte nach ihrer Erstellung beliebig skalieren. Das Programm selbst kann nur Bitmap-Fonts zur Darstellung verwenden was grausig aussieht, die später dargestellten PS/PDF-Dateien benutzen dann aber schöne Outline-Fonts bei der Darstellung. Ein Vorteil der begrenzten Font-Auswahl ist der Umstand, dass Font-Embedding deswegen unnötig ist. Das hält die Dateigröße klein. Einzel-Objekte können gruppiert und wieder aufgebrochen werden. Dies funktioniert auch verschachtelt. Zur Manipulation von Objekten und Gruppen gibt es folgende Funktionen: Select (nur ganze Objekte bzw. Gruppen), Move, Scale, Rotate, Alter (Editieren von Einzelobjekten, wie hinzufügen von Eckpunkten oder Verschieben derer), Magnify, Text. Es gibt auch Funktionen zum (mehr oder weniger) exakten Verschieben (Pixel, Punkte, Zentimeter oder Inches), Skalieren und Rotieren (Dezimalgrad) durch Eingabe von Fließkommazahlen. Horizontales und vertikales Spiegeln ist ebenfalls möglich. Ein Gitter mit benutzerdefinierter Auflösung kann angezeigt sowie (unabhängig von der Sichtbarkeit) zum Einschnappen benutzt werden. Eine Zoom-Funktion ist verfügbar. Selektierte Objekte können in den Vorder- oder Hintergrund gebracht werden, können entlang aller Seiten ihres umschließenden Rechtecke angeordnet werden, oder entlang ihrer Zentren (vertikal, horizontal, beides). Schließlich können die Objekte noch direkt an einander angrenzend, jedoch wahlweise in x- oder y-Richtung, angeordnet werden. (Diese Funktion ist allerdings etwas seltsam da sie trotzdem - scheinbar konstante - Abstände zwischen den Objekten lässt.) Eine Funktion zum Anordnen mit gleichmäßigen Abständen fehlt. Schließlich ist noch eine Undo/Redo-Funktion vorhanden. Alles in allem hat "idraw" einige Ähnlichkeiten mit "xfig", kann jedoch vermutlich weniger, hat dafür aber den Vorteil EPS-Dateien als natives Datenformat zu benutzen, welche man vielfältig nutzen kann. Neben "idraw" enthält das Paket auch "comdraw", so man die zuvor genannten Möglichkeiten über Textkommandos absetzen kann. Damit kann man nicht-interaktiv "idraw"-EPS-Dateien erzeugen, anzeigen und manipulieren. "comterp" ergänzt dies noch um einen Interpreter für eine C-ähnliche Sprache welche die Grafikbefehle nutzen kann­. "dclock" ist eine skalierbare Digitaluhr im LCD-Look. Sie kann keine Sekunden anzeigen. "drawtool" ist eine erweiterte Version von "idraw", die eher sinnlose zusätzliche Features wie Annotations, Clipping oder Import von Bitmap-Grafiken und ein paar Effekte für letztere anbietet. "flipbook" erweitert "idraw" um mehrere Dokumente als einzelne Seiten in einer einzelnen Datei speichern zu können. Allerdings verwendet es dazu ein eigenes Datenformat, kann jedoch idraw-Einzelseiten importieren. Es kann ein mehrseitiges Postscript-Dokument erzeugen, bei dem die erste Seite als gemeinsamer Hintergrund aller weiteren Seiten verwendet wird. flipbook kann es seine Einzelseiten auch als primitive Slideshow (ohne Übergänge) wiedergeben. "graphdraw" ist eine veränderte Version von "idraw" zum Zeichnen von Graphen. Dabei gibt es beschriftete Ellipsen welche die Knoten darstellen, und verbindende beschriftete Pfeile als Kanten. Sieht sehr primitiv aus. Kann ähnlichen Editoren aus dem "graphviz"-Paket vermutlich nicht das Wasser reichen, erlaubt dafür aber möglicherweise mehr Freiheiten beim absoluten Positionieren.
iw 4.1-1/core/archlinux: Ein Tool zum Konfigurieren von WLAN-Schnittstellen über deren (portableres) "nl80211" API. Das ähnliche Tool "iwconfig" tut dies ebenfalls, jedoch über ein Legacy-API. Man sollte daher nach Möglichkeit immer "iw" den Vorzug geben. Aber leider unterstützen nicht alle Wireless-Geräte dieses neue API, daher braucht man gelegentlich auch iwconfig. Außerdem kann "iw" weder den Kanal wechseln noch den "master mode" (Software Access-Point) einschalten. (Andererseits macht man dies normalerweise ohnehin nur mit hostapd.) Ein einfacher Test ob ein WLAN-Gerät iw untestützt, ist zu schauen ob nach dem Laden der Treiber das Verzeichnis /sys/class/ieee80211/ nicht leer ist. Ist es jedoch leer, muss man iwconfig verwenden.
jbig2enc-0.28-r1/media-libs/gentoo {PDF}: Enthält ein tool jbig2 sowie ein Python-Script pdf.py, welche zusammen eine Liste an Dateien in ein JBIG2-komprimiertes mehrseitiges PDF-Dokument konvertieren können.
jbigkit 2.1-2.1/community/archlinux: Enthält Tools zum Konvertieren zwischen JPEG-Dateien und JBIG-Dateien... aber leider nur das veraltete bzw. überholte JBIG-1. Das neuere JBIG-2, wie es beispielsweise in verlustbehaftet eingescannten S/W-Bildern für PDF-Dateien zum Einsatz kommt, beherrscht dieses Paket nicht. Daher wenig interessant.
jed-1 {text-editor}{text-terminal IO}: 0.99.19-7+b1/editors/debian: Ein vergleichsweise schlanker Text-Editor (350 kB für das Executable) fürs Terminal. Hängt nicht wie die meisten derartigen Programme von der ncurses- sondern von der slang-Bibliothek ab. Letzteres ist eigentlich eine eingebettete Scriptsprache, weswegen man davon ausgehen kann dass man den jed intern mit Makros in dieser Scriptsprache erweitern kann. Zumindest wird diese Fähigkeit aber dazu genutzt, dass es mehrere Kompatibiliäts-Bindungs für jed gibt. Mitgeliefert werden 3: Wordstar, Emacs und EDT. Es gibt auch eine X11-Version von jed, "xjed" genannt, doch diese ist ein eigenes Paket (sowie ein Scherz wenn man es sich installiert: Diese "X11-Version" sieht genau wie der normale Textmodus-jed aus, wenn er in einem Terminalfenster läufen würde). jed kann ähnlich wie joe mehrere Dateien in unterschiedliche Puffer laden und kann diese in mehreren Fenstern darstellen. Er beherrscht auch Syntax-Highlighting. Angeblich kann er auch folding, aber ich brachte das nicht zum Funktionieren. Insgesamt hatte ich den Eindruck dass er alle Haupt-Funktionen von "joe" mit Ausnahme des Hex-Modus beherrscht. Aber es fehlen ihm viele der Nebenfunktioen von joe, wie vor allem das Bearbeiten von "flowed"-Text. Dafür hat jed normale RegEx-Suchfunktionen; nicht die sehr seltsamen non-Standard-Varianten von joe welche noch dazu weniger können. jed hat recht normal aussehende Drop-Down-Menüs; allerdings funktionieren diese nicht normal sondern sehr eigentümlich bezüglich der Tastatursteuerung. Vermutlich reine Gewöhnungssache. Es gibt ein umfangreiches eingebautes Hilfesystem, welches auch die Funktionen und Variablen umfasst, welche die Slang-Scriptsprache im Editor benutzen kann. In vielen Fällen bekam ich aber nur einen leeren Text angezeigt - offensichtlich muss man dazu zusätzliche Dokumentation installieren. Aber grundsätzlich ist das Hilfesystem jedenfalls recht umfangreich. Womit ich allerdings gar nicht zurecht kam, ist die Tastaturbelegung. Vermutlich kommt das daher dass jed defaultmäßig Emacs-kompatibel arbeitet, und mit dem komme ich ja genau so wenig zurecht. Im Wordstar-Modus fand ich mich als "joe"-Benutzer besser zurecht. Allerdings sind trotzdem noch viele Tasten völlig anders belegt. Leider sind die Konfigurationsdateien von jed tatsächlich slang-Scripte, und daher ist es etwas mühsam sich darin zurecht zu finden ohne diese Scriptsprache zu erlernen. Weiters gibt es noch ein Paket "jed-extra", welches eine Auswahl von slang-Scripten für verschiedene Zwecke mitbringt. Man gewinnt dadurch den Eindruck, dass jed recht interessant sein dürfte wenn man einen programmierbaren Editor fürs Terminal sucht, aber sich nicht wie in Emacs mit LISP herumärgern zu müssen, sondern eine "C"-artigere Scriptsprache zu benutzen. Download 139,6 kB, installiert 365,6 kB. Fazit: Man kann jed durchaus als eine schlankere Alternative zu "joe" begreifen, die zudem erheblich mächtiger mittels Scripten erweiterbar ist. Das "schlanker" relativiert sich zudem, wenn man auch die slang- und ncurses-Bibliotheken einbezieht, von denen die beiden Programme abhängen. Dann benötigt jed rund 400 kB mehr an komplett-Installationsumfang als joe. Ein Vorteil von jed ist jedoch bessere UNICODE-Unterstützung: Er kann anders als joe problemlos NFD-normalisierte UTF-8-Dateien bearbeiten.
jedit-5.5.0+dfsg-1/editors/debian {development_environment}{text-editor}{Swing}: Ein in JAVA geschriebener und auf so ziemlich allen Plattformen lauffähiger Texteditor für Programmierer. Erweckt auf den ersten Blick den Eindruck eines "Eclipse für Arme": Obwohl der Basis-Editor bereit einen ziemlichen Funktionsumfang hat, gibt es dazu noch viele Plugins (sicher 100) welche noch zusätzliche Funktionalität hinzu fügen können. Grundsätzlich erinnert das Programm etwas an den geany oder kate, nur hat es aufgrund seiner JAVA-Grundlage natürlich wesentlich fettere Installation-Dependencies. Wenn man JAVA aber ohnehin bereits installiert hat, ist der Download des eigentlichen Pakets nur 2,4 MB groß (11,5 MB installiert). Obwohl das Programm grundsätzlich einen brauchbaren Eindruck vermittelt, gab es ein paar Dinge welche mich störten: Man hat es mit der Modularität ein wenig übertrieben, selbst um Tabs zu bekommen braucht man ein Plugin. Des weiteren beherrscht der Editor Folding, aber die vorhandenen Folding-Funktionen tun scheinbar nichts. Ähnlich wie der Geany gibt es ein Plugin für Sessions und auch einen eingebauten Projekt-Editor samt Build-Support; grundsätzlich sollte das Ding daher als IDE taugen. Es gibt auch ein gdb Plugin. Jedoch ist die Bedienung oder Konfiguration des Projekteditors so kompliziert oder zumindest nicht auf den ersten Blick verständlich (so gibt es etwa ein Feld wo man die "Web-Adresse" des Projekts eingeben soll - wtf?), so dass ich es nicht schaffte ohne intensiveres Studium ein Projekt anzulegen. Fazit: Eine vermutlich recht brauchbare Light-IDE, welche aber umständlicher als Geany zu bedienen scheint. Vermutlich verfügt jedit aber über mehr Funktionen - erst recht wenn man die vielen Plugins einbezieht. Außerdem bezieht sich das "Light" hier nur auf den Installationsumfang - weil der Editor verprasste satte 186 MB RAM - nur für den Eigenbedarf, ohne auch nur ein einziges Dokument geöffnet zu haben. JAVA halt. Andererseits, wenn man 8 GB RAM hat kann man 200 MB locker verschmerzen wenn die Funktionalität stimmt. Das öffnen großer Dokumente dauert auch deutlich länger als bei den in C/C++ geschriebenen Editoren - aber wenn sie dann erst einmal geöffnet sind, gibt es keine erkennbaren Verzögerungen mehr. Obwohl, ab und zu "stottert" das Programm beim Scrollen kurz und bleibt hängen. Möglicherweise ist das aber auch nur die Garbage Collection, die man sich mit JAVA ja zwangsweise einhandelt. Und bei 186 MB RAM muss sicherlich eine ganze Menge Garbage collected werden, weil mit sinnvollen Daten sind diese hunderten MB sicherlich nicht alle gefüllt. (Allein schon da ja noch gar kein Dokument geladen war.) Fazit: Ein vermutlich mächtiger und toller Editor, aber primär wahrscheinlich eher auf anderen Plattformen nützlich wo man die gewohnten Linux-IDEs nicht benutzen kann aber trotzdem etwas ungefähr vergleichbares sucht. {development_environment}{text-editor}{Qt} eric-5.0.5/dev-util/gentoo: Großartig-supertolle Python-IDE. Projekte und Mehrfachprojekte. Multiuser-Chat. Debugger. Makros. Lesezeichen. Plug-Ins. Syntax-Highlighting. Folding. Word Completion. Stark integrierter Support für Qt4-basierte Features, insbesondere PyQt. Dokumentations-Generator. Nur eines fand ich zumindest auf die Schnelle nicht: Einen Symbol-Browser. (Muss man halt Geany dafür nehmen. Das ist auch 3 x kürzer als Eric.) Fazit: Sicher eine gute IDE, wenn man in Python und PyQt entwickeln will. Irgendwie so eine Art Kdevelop für Python. Eric selbst ist ebenfalls in Python geschrieben (PyQt); daher sollte es leidlich gut auf andere Plattformen portierbar sein.
jigdo-file-0.8.1-1/utils/raspbian: Ein angeblich schneller Downloader für Debian Live-Images. Anstatt diese Images als Ganzes von Debian-Servern herunter zu laden was den Nachteil hat dass es dafür zu wenige Mirrors gibt welche daher ständig überlastet sind, setzt ein in diesem Paket enthaltene Utility das ISO-Image aus regulären separat downgeloadeten Dateien zusammen welche durch alle regulären Debian-Mirrors unterstützt werden. Praktisch funktionierte 2025 keine einige Download-URL für jigdo-Images. Dafür funktionierten die ebenfalls vorhandenen Bittorrents dafür um so besser. Ein Vorteil von jigdo gegenüber Bittorrent ist jedoch dass jigdo auch inkrementell arbeiten kann. Wenn man die letzte vorhandene Version des Images loop-mountet und jigdo zum Scannen angibt, vermeidet diese alle Downloads von Dateien deren Inhalte (via md5sum verglichen) bereits in Scan-Verzeichnis vorhanden sind. Beim Zusammensetzen des neuen Images werden diese lokal bereits vorhandenen Dateien dann gegenüber einen Download bevorzugt. Sie auch das Paket "jigit" welche Tools zum Erzeugen und Verwenden von jigdo-Downloads enthält.
jigit-1.22-3+b7/utils/raspbian: Eine Methode ähnlich wie zsync, um Updates von großen Dateien wie ISO-Images inkrementell herunterladen zu können. Jeder Download besteht aus 2 Dateien, "*.template" und "*.jigso". Die "*.template" Datei enthält komprimiert den Inhalt der Ziel-Imagedatei, jedoch sind Teile des Inhalts ausgelagert und nur als Referenzen auf die MD5-Prüfsummen der ausgelagerten Dateien in der Datei enthalten. Die Datei "*.jigdo" enthält die ausgelagerten Dateien als Paare MD5-Prüfsumme und Download-URL. Man kann auch Verzeichnisse angeben die auf Dateien gescannt werden deren MD5-Prüfsummen berechnet werden. Wenn beim Zusammensetzen ein Dateiinhalt referenziert wird dessen md5sum sich bereits in einem der gescannten Verzeichnisse befindet, wird auf den Download verzichtet und der Dateiinhalt statt dessen aus dem gescannten Verzeichnis verwendet. Die Idee ist dass ISO-Dateien aktualisiert werden sollen deren einzelne Dateiinhalte über die *.jigdo Datei beschrieben werden. Wenn eine ältere Version der ISO-Datei bereits verfügbar ist, wird diese lokal loop-gemountet und als Scan-Directory angegeben. Alle unveränderten Dateiinhalte können dann aus der alten Version übernommen werden und brauchen nicht neu downgeloadet zu werden. Gegenüber zsync welches ebenfalls Image-Dateien inkrementell aktualisieren kann hat jigdo den Vorteil dass die Inhalte von Paketdateien direkt aus dem Mirror-Verbund einer Distro geholt werden können, und die *.template Datei nur solche Daten des ISO-Images einer Installer-DVD enthalten muss welche etwas anderes als Paketdateien sind. Bei einem Live-Image dürfte der Nutzen geringer sein, da sich dort vorwiegend bereits entpackte Dateien befinden die nicht einzeln vom Mirror-Verbund downgeloadet werden können.
jmtpfs-0.5-2+b2/utils/debian {FUSE}: Erlaubt es viele Multimedia-Geräte wie Digicams, portable Music Player oder Camcorder welche das MTP (Media Transfer Protocol) unterstützen als Pseudodateisystem zu mounten. Häufig werden solche Geräte dabei durch ein USB-Kabel mit dem Computer verbunden, neuerdings erfolgt die Übertragung aber zunehmend auch drahtlos via Wi-Fi oder Bluetooth. Dieses Dateisystem ist ferner dafür gedacht von nicht-privilegierten Benutzern benutzt zu werden - Vorausgesetzt natürlich sie haben Zugriff auf USB bzw. Wi-Fi/Bluetooth. Im Grunde eine sehr schöne Sache, die aber leider einen Haken hat: Im Praxistest zeichte sich dass jmtpfs bestimmte Dateien nicht sehen kann (und daher auch nicht anzeigt), obwohl sie am Multimediagerät vorhanden sind. Das hängt davon ab ob der lokale Dateiname am MTP-Gerät bestimmte Zeichen enthält welche jmtpfs offensichtlich nicht unterstützt. Das ist nie ein Problem mit den Dateien welche diese Geräte selbst erstellt haben wie Videos oder Bildern, kann aber ein Problem sein wenn man selbst benannte Dateien auf dieses transferiert hat (etwa Musikdateien oder Filme mit bestimmten Sonderzeichen als Teil ihres Namens).
joe-4.6-1+b1/editors/debian {text-editor}{text-terminal IO}{hex-editing}{development_environment}: Mein Lieblings-Texteditor fürs Terminal. Word-Star-ähnliche Tastenkombinationen. Beherrscht kein Soft-Line-Wrapping, hat dafür aber die fähigste Reformatierfunktionen aller Texteditoren die ich bislang kenne. Vor allem kommt er beim Reflowen auch mit den meisten Kommentaren von Programmiersprachen zurecht. Er kann mehrere Dateien gleichzeitig bearbeiten, wahlweise umschaltbar oder per Split-Screen (vertikal unterteilt). Er kommt mit UTF-8 zurecht - zumindest solange keine Combining-Characters enthalten sind. Dann wird es etwas seltsam, aber nur in der Darstellung. Verarbeitet wird korrekt. Joe besitzt einen Hex-Edit- und einen normalen sowie Rechteck-Auswahlmodus. Leider betrifft der Hex-Modus nur die Anzeige; die Eingabe bleibt eine Texteingabe und man muss binäre Werte mühselig über spezielle Befehlssequenzen als Hex-Codes einzeln eingeben. Aber es geht. Es lassen sich primitive Makros definieren. Joe kann auch als Filter in einer Pipe arbeiten. Man kann auch umgekehrt ein Kommando angeben, und joe verbindet sich bidirektional mit dessen Ein- und Ausgabe. Joe kann neu erstellten Text an eine bestehende Datei anhängen. Joe kann einen Ausschnitt aus einer Datei (von/zu als Byteposition, hex/dezimal/oktal) editieren - so kann man etwa ähnlich wie in FORTH Inhalte von Disk-Sektoren editieren. Spell-check wird unterstützt wenn aspell installiert ist. Es gibt einen simplen IDE-Modus, wo ein beliebiges Build-Kommando aufgerufen wird und Fehlermeldungen des C-Compilers geparsed werden. Diese werden dann in einer Liste angezeigt und man kann direkt zur Fehlerstelle springen. Einen ähnlichen Modus gibt es auch für grep, so dass man dessen Fundestellen in verschiedenen Dateien anspringen kann. De facto beherrscht joe damit auch das Suchen von Texten in nicht geladenen Dateien. Das interne Suchen/Ersetzen von joe beherrscht hingegegen nur sehr rudimentäre Joker, aber immerhin kann man wenigstens auch Newlines und Tabulatoren damit suchen/ersetzen. Joe beherrscht ein paar mathematische Funktionen, die man direkt in einer Kommandozeile aufrufen kann oder sie auf selektierten Text anwenden (etwa Summieren, Berechnen des Durchschnitts, oder die in einem Texteditor etwas deplatziert wirkende lineare und nicht-lineare Regressionsanalyse inklusive Prognosefunktionen). Es gibt einen einblendbaren mehrseitigen Hilfeschirm der die meisten Kommandos anzeigt. Darunter auch eine ASCII/Latin-1 Code-Tabelle (leider nur mit dezimalen Wertangaben). Joe kann selektierten Text durch ein beliebiges externes Shell-Kommando leiten, und die Ausgabe ersetzt den selektierten Text. Weiters gibt es einen Shell-Modus, wo man eine "normale" Shell-Kommandozeile innerhalb des Textes bekommt. Alle Ein-/Ausgaben erzeugen so automatisch zusätzlichen Text im Editor. (Leider funktioniert Tab-Completion in diesem Modus nicht, was seine praktische Nützlichkeit drastisch einschränkt.) Joe kann paarige Klammern anspringen und vorhandene tags-Dateien zur Suche nach Symbolen verwenden, welche das Programm ctags erstellt hat. Er kann die Einrückungstiefe markierter Textpassagen ändern. 10 Bookmarks lassen sich setzen. Dateien lassen sich an der Cursorposition einfügen, und markierter Text lässt sich als separate Datei abspeichern. Mehrstufiges Undo/Redo ist vorhanden (allerdings ist Redo so dämlich belegt dass ich es auf einer deutschen Tastatur noch nicht zu erreichen geschafft habe). Es gibt auch eine simple Wort-Vervollständigungs-Funktion. Die meisten Textbearbeitungskommandos lassen sich rekursiv auch in den Kommandozeilen-Prompts verwenden. Man kann also beispielsweise bei der Eingabeaufforderung für Suchtext Text aus der eigentlichen Datei hinüber kopieren oder durch ein Shell-Kommando modifizieren, bevor man das Ergebnis als Suchtext verwendet. Joe kommt auch mit MS-DOS-Zeilenenden zurecht und hat eine beherrscht neben UTF-8 auch die meisten ISO-Textkodierungen. Er besitzt Syntax-Highlighting für viele Sprachen. Er hat einen Picture-Mode der sich für "ASCII-Art"-Zeichnungen eignet da man hier mit dem Cursor durch den Text fahren kann ohne sich darum kümmern zu müssen ob die Zeilen an dieser Stelle überhaupt lang genug sind. Joe ist alles in allem ein sehr mächtiger Editor, nur vernünftige Regular Expressions beim Suchen/Ersetzen und eine mächtigere Makrosprache wären wünschenswert. Das Executable ist rund 800 KiB groß, der Paket-Download 561 kB groß, installiert sind es 2,2 MB. joe hängt nur von der ncurses-Bibliothek und der C-Runtime (dabei auch von der libm) ab.
joomla/www-apps/gentoo: CMS in PHP geschrieben. Danke. Nächster, bitte.
josm-0.0.svn17428+dfsg-2/utils/debian {GIS}: Ein in JAVA geschriebener interaktiver Editor für OpenStreetMap (OSM) Daten. Kann auch GPS-Daten im GPX-Format bearbeiten. Greift beim Start frech ohne Nachfrage aufs Internet zu und lädt dort eine nicht spezifizierte Menge Daten ungefragt herunter. Weiters versaut es dann auch irgendwie offene xterm-Fenster, so dass diese danach keine Tastatureingaben mehr entgegen nehmen können. Ich fand keine Möglichkeit, dies zu beheben, außer durch Öffnen eines neuen xterm-Fensters. Auch die Fluxbox wurde irgendwie negativ beeinflusst, den ein Neustart des WM stürzte offenbar ab und beendete die laufende X11-Sitzung. Man kann diese Effekte aber vermeiden, indem man das Programm mit der Kommandozeilenoption --offline=ALL startet, wodurch man allerdings den Startmenü-Eintrag des Programms dann nicht verwenden kann. Aber selbst im Offline-Modus greifen viele Menüpunkte aufs Internet zu ohne vorher zu fragen ob der Offline-Modus dazu beendet werden soll. Das Arbeiten mit diesem Programm ist daher gefährlich, wenn man ein begrenztes Datenvolumen hat.
joy2key-1.6.3/app-misc/gentoo: Kann Joystick-Bewegungen in Keyboard-Events transformieren. Bietet sowohl für X11 als auch die Linux VT-Consolen eine Lösung. Sinnvoll wohl primär dazu um Joystick-Bewegungen in Cursortasten-Events umzusetzen.
joystick-1.4.2/games-util/gentoo: Ein Programm zum Testen und Kalibrieren von Joysticks und Joypads. Es gibt dabei speziellen Support für Force-Feedback-Joysticks. Sowohl Achsen als auch Buttons können kalibriert werden. Die ermittelten Kalibrations-Konfigurationen werden von einem X11-Hintergrundprogramm angewendet, welcher etwa via udev nur dann gestartet zu werden braucht wenn das entsprechende Joystick auch tatsächlich angeschlossen ist. Das Programm bietet des weiteren die Möglichkeit, Eingaben von altertümlichen über die serielle Schnittstelle angeschlossenen Joysticks in normale Joystick-Events umzusetzen, mit denen normale X11-Programme etwas anfangen können.
jq-1.6-2.1/utils/raspbian {stream-filter}: A sed-like stream editor for manipulating JSON files. JSON objects are connected via filtergraphs which apply operators, such as extracting fields or adding list members. About 400 kB download size, including 2 helper libraries.
jshon-20131010-3/utils/raspbian: jshon parses, reads and creates JSON. It is designed to be as usable as possible from within the shell. Where "jq" uses a relatively complex scripting language to express its operations, jshon accomplishes everything via simple 1-letter command line options. jshon can sort JSON lists and extract, add or remove particular records from them. It less stream-oriented than 'jq' and can manpipulate larger units such as lists or maps as a whole. jshon is a small installation (around 50 kB download size including a helper library).
juffed-0.8.1-1/editors/debian juffed-0.10-89-g3690b60-5+b1/editors/raspbian {text-editor}{GUI}{X11}: Eine von LXDE empfohlene Alternative zu leafpad, das nicht mehr weiterentwickelt wird sobald LXDE zu Qt gewechselt hat. Obwohl der mit Qt verfasste Editor nicht schlecht wirkt und auch auf dem Raspberry Pi Model 1 trotz Syntax Highlightings noch schnell genug funktioniert um grundsätzlich damit arbeiten zu können, und er auch sonst so ziemlich alles beherrscht was leafpad kann, wird er bei größeren Dateien leider schweinelangsam und ist leafpad dort damit hoffnungslos unterlegen. Dafür bietet er aber Tabs, Sessions, Section Folding, Syntax Highlighting, hervorheben der aktuellen Zeile (mit freier Einstellung der Farben - bei KDE- und GNOME3-Programmen ist dies immer ein großer Jammer) und kann optional auch Regular Expressions suchen/ersetzen (sogar mit ein/mehrzeilig-Modifier) statt nur simpler Texte. Man kann auch verschiedene Zeichensätze oder Zeilenenden-Konventionen auswählen, Lesezeichen benutzen, Leerzeichen und Tabulatoren anzeigen, und ein paar nützliche Spezialfunktionen durchführen wie Blöcke einrücken, paarige Klammern anspringen, Zeilen zu Kommentaren machen oder Großschreibung ändern. Des weiteren lässt sich jeder Tab vertikal oder horizontal in zwei verschiedene Sichten derselben Datei aufteilen. Auch eine Spaltenmarkierung kann gesetzt werden, um beispielsweise Spalte 80 als gewünschtes Ende aller Textezeilen zu kennzeichnen. Mitgelieferte Plug-Ins erweitern seine Funktionalität; so kann man in angedockten Fenstern einen Dateibrowser anzeigen lassen, eine Liste offener Dateien, eine Suche in externen Dateien, oder einen Symbol-Browser der zumindest C und C++ beherrscht. Ein netter Editor für Quelltexte am Raspberry Pi, aber nicht für große Dokumente mit dynamischem Zeilenumbruch. Schade dass es keinerlei Integration von externen Kommandos gibt; man kann daher nicht etwa ein "make" mit einem Tastendruck starten sondern muss das in einem separaten Terminalfenster machen. Nachteil sind einige ärgerliche Bugs die das Programm hat. Wenn Zeilen "weich" an der rechtesten Spalte umgebrochen werden, wird das Leerzeichen nicht mehr am Ende dieser Zeile sondern am Anfang der nächsten angezeigt. An der Korrektheit des gespeicherten Textes ändert es nicht, doch es sieht sehr komisch aus. Weiters ärgerlich ist dass wenn man die [Pos1]- oder [Ende]-Taste inmitten eines mehrzeiligen Absatzes mit weichen Zeilenumbruch drückt, der Cursor dann an den Anfang oder Ende des Absatzes springt und nicht von der optisch sichtbaren physischen Zeile! vim hat zwar dasselbe Problem, aber dem sieht man es nach da ohnehin niemand ernsthaft mit diesem Programm längerfristig arbeiten will. Bei meinem ersten Review hielt ich dies noch für Bugs einer frühen Version, aber nachdem dieselben Bugs auch ein gutes Jahrzehnt später noch vorhanden sind werden sie wohl noch länger bleiben. Ein weiteres Ärgernis: Der Mauszeiger wird nicht versteckt sobald man zu tippen beginnt und sich dieser gerade über dem Text befindet; das ist häufig der Fall nachdem man etwas mit der Maus markiert hat. Dann verdeckt der Mauszeiger oft genau dort Zeichen wo man gerade tippt. Derzeit fährt man mit kwrite aber um Welten besser und sicherer, wenn man nicht gerade einen alten Raspberry Pi Model 1 hat der zu rechenschwach für kwrite und gedit ist.
juk/kde-base/gentoo {audio}{music}: KDE-Gegenstück zu WinAMP & Co. Reines Audio-Abspielprogramm (MP3, OGG, etc) mit mehreren Playlisten, Abspiel-Warteschlange, History der gespielten Songs, ID3-Tag-Editor. Kann es nicht mit Amarok aufnehmen, ist aber deutlich ressourcenschonender. Etwas nervig: Keine automatische Funktion um den gerade abgespielten Song in der Playliste zu lokalisieren.
julia-0.6.0-2/science/raspbian {programming language}: Eine super-trendige fast-so-schnell-wie-C-Sprache (genauer gesagt: etwa halb so schnell), die ganz toll auf LLVM und JIT-Compilation aufbaut, und in einem wilden Mix aus C++, SCHEME und sich selbst verfasst ist. Erzeugt angeblich nativen Code, hat aber eine LISP-ähnliche REPL-Eingabeaufforderung ähnlich den Interaktiven Python-Interpreter. Man kann angeblich sogar Scripte damit erstellen die dann so ähnlich wie Shells-Scripte ausgeführt werden. Das sollte man sich aber vielleicht noch einmal überlegen, denn wenn die REPL startet ohne dass man auch nur den 1. Befehl eingetippt hätte, belegt dieser bereits 130 MB RAM und 300 MB virtuellen Speicher - das ist nur knapp weniger RAM als der Firefox verschlingt. Schlank ist jedenfalls anders. Download-Bedarf für eine Standard-Installation samt Dokumentation (Stand 2018-08) ca. 25 MB, installiert 73 MB.
jupp-3.1.38-1/editors/debian {text-editor}{text-terminal IO}{hex-editing}: jupp ist die "portable" Version des "joe"-Editors. Damit ist allerdings nicht gemeint dass es ohne Installation direkt von einem USB-Stick läuft, sondern nur dass es auf verschiedenen Betriebssystem-Plattformen läuft, darunter auch solchen die nicht dem POSIX-Standard entsprechen. Im wesentlichen ist es eine abgespeckte Version von joe, aber das Programm ist dafür auch nur halb so groß. Alle Hauptfunktionen von joe inklusive Hex-Modus, Rechteck-Modus und Picture-Modus sind enthalten. Aber es fehlen einige Nebenfeatures. Etwa der "flowed"-Modus, mit dem man unter joe Fließtext-Dokumente mit als weichen Zeilenumbrüchen markierten harten Zeilenumbrüchen bearbeiten kann. Als Ausgleich gibt es aber ein paar neue Features, vor allem das optionale Anzeigen von Tabulatoren und Leerzeichen. Außerdem zeigt die Statuszeile von jupp mehr Informationen an: Neben der Zeile und Spalte auch noch die absolute Position vom Beginn der Datei an, sowie den Code des Zeichens unter dem Cursor. Diese beiden zusätzlichen Angaben werden sowohl dezimal als auch Hexadezimal angezeigt. Etwas seltsam ist der Umstand, dass jupp anders als der joe noch die libpcre als Abhängigkeit hat, jedoch man trotzdem nur die joe-artigen (verpfuschten) RegExes für die Suche verwenden kann. Doch der größte - und for "joe"-Benutzer sehr ärgerliche - Unterschied zwischen den Programmen ist es jedoch, dass jupp in dem meisten Fällen andere Tastenkombinationen für dieselben Befehle benutzt. Für Neueinsteiger ist das egal, aber erfahrene joe-Benutzer werden mit jupp daher keine rechte Freude haben. Davon abgesehen kann man jupp wirklich als ziemliche 1:1-Kopie von joe mit der halben Größe auffassen, von den zuvor genannten Unterschieden abgesehen. Download 235,3 kB, installiert 628,7 kB.
jupyter-notebook-6.2.0-1/science/debian {development_environment}: Eine bei Data Scientists angeblich sehr beliebte Alternative zu Excel. Im Kern ist es eine grafische Oberfläche für Programme die in Julia, Python oder R gedacht ist (daraus setzt sich auch der Name zusammen) und welche im Web-Browser ausgeführt wird. Damit werden dann allerdings digitale "Notizhefte" als lokale Dokumente (im JSON-Format) bearbeitet, die sich als normale Dateien kopieren und auch an andere weiter verteilen lassen. Man kann damit Kommentare und Notizen auf einfache Weise mit den Quelltexten der Programme kombinieren, und auch die Ausgaben der Programme wieder in die Notizen einbinden. Dies kann auch in Form von Diagrammen und Statistiken geschehen und die Form von kompletten Forschungsberichten einnehmen. Ebenso kann man Excel-artige interaktive wenn-dann Analysen damit durchführen, indem als Eingangsparameter der Scripte verwendete Werte im Heft verändert werden, wodurch sich die Ergebnisse im Heft ebenfalls ändern. Die Notizen bzw. Kommentare selbst werden dabei in einer vereinfachten Wiki-artigen Sprache verfasst. Im wesentlichen scheint es also ein simplifiziertes dateibasiertes Wiki mit integrierter Programmausführung der ebenfalls enthaltenen Quelltexte zu sein. (Nicht dass ich es schon jemals ausprobiert hätte.) Das grundlegende Konzept der Notizhefte die unterschiedliche Zell-Typen (Kommentar, Programm, Tabelle, Diagramm, usw.) als Einträge enthalten erscheint mir vom kommerziellen Mathematica abgeschaut - aber damit ist es nicht allein. Negativ fiel mir auf, dass zwar eine unfangreiche Hilfe über Menüs vorhanden ist, doch dies verweist immer auf Online-Webseiten, und ist daher ohne Internet-Zugriff nicht verfügbar. Zwar scheint es irgendwelche Offline-Installationspakete zu geben, aber die werden zumindest von Debian nicht direkt unterstützt und man müsste sich das wohl irgendwie manuell einrichten. "Out of the box" gibt es jedenfalls keine Offline-Hilfe.
jwm-2.0.1/x11-wm/gentoo {window manager}{GUI}{X11}: Nice minimalistic X11 window manager, similar to IceWM but far less customizable (only the commands launched, the icons, fonts, foreground and background color are customizable for different parts of the user interface). Supports multiple workspaces. Windows can be sent to different workspaces, "shaded" (only title bar remains visible), minimized as traybar icons or assigned to a specific one of a fixed number of layers. Layers generalize the concept of "always in the foreground / background" by assigning each layer a specific Z depth. Within the same layer, windows clicked upon raise to the top, possible obscuring parts of other windows. But even if a window has been raised to the top of its layer, the whole layer will always be obscured by windows belonging to a different layer with a lower Z depth. Does not support the Enhanced Windows Manager Hints which is important for usability of some applications.
kaboodle/kde-base/gentoo {audio}{music}: Wichtiges Plugin für diverse Dateimanager (kpart). Spielt aber auch als eigene Applikation einzelne Audiodateien ab. Kennt dabei auch alle möglichen Codecs. Unterstützt aber kein Video. Der "kleine Bruder" von juk, aber ohne dessen Playlisten und Organisations-Features.
kaddressbook/kde-base/gentoo {PIM}: Manages names, phone numbers, email addresses and postal addresses relating to specific persons or other contacts. Only needed when using the KDE PIM/Mail/Organizer features. Has some display issues with displaying long entries. Also integrates with kpilot for synchronizing with a PalmOS PDA.
kalarm/kde-base/gentoo {reminder}: The alarm clock for the KDE desktop. Nice application to set alarms for desktop notification and schedule reminder mails or timed command execution. Quite bloated, of course, like everything in KDE.
kali-linux-2017.2-i386.iso.xz/live-system/kali {linux distribution}: Eine auf Security und Forensik spezialisierte Live-Distro. Basiert auf Debian, benutzt jedoch ein "Rolling Release"-Modell. Versucht alles im RAM zu halten und schreibt nie etwas auf die Festplatte/Live-Medium. Allerdings gibt es die Option, die Anpassungen im Live-System auf einen USB-Stick zu sichern - wahlweise verschlüsselt oder unverschlüsselt. So kann man sich das System anpassen, möglicherweise ohne es "richtig" in ein beschreibbares Dateisystem installieren zu müssen. Denn leider ist die Anleitung hier nicht klar, ob die persistenten Daten sich am selben Medium befinden müssen wie das Live-Image. Die Beispiele verwenden jedenfalls immer dasselbe Medium. Weiters gibt es einen vorbildlichen Installer - sowohl einen grafischen als auch im Text-Modus - um das System auf eine Festplatte zu installieren (bis hin zu GRUB). Sogar mehrsprachig und Offline ohne zusätzliche Downloads! Auch die gewünschte Locale und Tastaturbelegung wird gleich vorinstalliert. Natürlich kann die Installation dabei auch als verschlüsseltes LVM (inklusive initialem Füllen mit Zufallsbytes) realisiert werden. Leider basiert Kali auf der GNOME Shell, sprich systemd und somit Entmündigung des Users zum Quadrat. Sonderlich flott ist es auch nicht. Es sind zwar Unmengen an Security-relevanten Programmen sowie Firefox installiert, aber LibreOffice und Mail-Programm fehlen. Kali funktioniert dafür sehr gut unter KVM, auch mit dessen VNC Backend.
kalzium-4: 20.12.0-1/science/debian: Zeigt das Periodensystem der chemischen Elemente sowie eine Tabelle der Isotopen in verschiedenen Ansichten an. Ein KDE-Programm im Qt-Look. Neben den numerischen Attributen der chemischen Elementen kann es auch das Atommodell (Elektronenkonfiguration) und eine Spektralansicht (auch als Grafik exportierbar) grafisch anzeigen. Weiters sind auch Textinformationen wie etwa zur Endeckung oder dem Namensursprung der Elemente verfügbar. Kann Moleküle aus Dateien laden und interaktiv zoom- und rotierbar 3-dimensional auf verschiedene Weisen (Kugeln, Stäbe, van-der-Waals-Kräfte) anzeigen. Molekülmassen-Rechner: Bestimmt die Molekülmasse von verschiedenen Molekülen, indem man z. B. "H2O" eingibt. Zeigt dann an aus welchen Atomen mit welchen Massen der Stoff besteht. Man kann dann auch Aliase wie "Wasser" dafür festlegen. Konzentrations-Rechner: berechnet Stoffmengen, Lösungsmittelvolumen oder Stoffkonzentration. Nuklear-Rechner: berechnet Restmengen nach radioaktivem Zerfall. Gas-Rechner: bestimmt die Temperatur, den Druck, das Volumen, die Gasmenge. Gleichungslöser: Gleicht chemische Gleichungen automatisch aus. Dazu verwendet man Ein-Buchstaben-Variablen für die Anzahl der Atome oder Atomgruppen in der Ausgangs- und Zielgleichung, und das Programm errechnet deren Werte. Optional können auch elektrische Ladungen angegeben werden. Titration-Rechner: bestimmt den Äquivalenzpunkt einer mit dem pH-Meter durchgeführten Titration und die beste Anpassung durch eine hyperbolische Tangente. Kann auch ein System von Gleichungen lösen, wie sich die Konzentration eines Ions als Funktion eines anderen ändert. Weiters werden von der EU standardisierte "R" und "S"-Datensätze zur chemischen Gefährlichkeit angezeigt oder können zum Filtern der Ansicht benutzt werden. Der Installationsumfang des eigentlichen Programms ist zwar gering, jedoch kommen noch Paketabhängigkeiten für spezifische Daten- und Berechnungs-Bibliotheken hinzu was ca. 60 MB Downloads (270 MB installiert) verursacht. Darin sind die benötigten allgemeinen Qt- und KDE-Libraries noch nicht eingerechnet.
kalzium/kde-base/gentoo: Nette Periodentabelle für KDE. Daten, Bilder, geschichtlicher Hintergrund, Spektrum.
kapman-4.3.1/kde-base/gentoo: Pac-Man Klone für KDE mit einer Art Indiana-Jones Style (Player = Indy; Geister = Mumien). Skalierbare Fenstergröße; grundsätzlich nichts auszusetzen. Aber irgendwie gefällt mir die Grafik nicht besonders.
karbon-1.6.2/app-office/gentoo: Auch als Karbon14 bekannter Inkscape-Clone und sehr komfortabler KDE SVG-Editor. Sehr hübsch und wohlgefällig gemacht. Kann ziemlich genau dasselbe wie Inkscape; letzteres dürfte aber besser getestet und wohl auch verbreiteter sein. Ausserdem ist Inkscape nicht von KDE abhängig. Mein Eindruck ist dass Inkscape in Summe auch mehr kann. Anderseits mag karbon in Verbindung mit KDE ressourcenschonender arbeiten. Vielleicht hat karbon auch eine bessere Unterstützung für Echtfarben, der in Inkscape recht primitiv gelöst ist.
karm/kde-base/gentoo {PIM}: Helps you keep track of what you are doing, and when. This is useful for associating spent time with the tasks performed during that time. Unfortunately, it pulls in kontact and kaddressbook as rather heavyweight dependencies.
kasteroids/kde-base/gentoo: Not really bad, but inferior to Maelstrom
katapult/kde-misc/gentoo: Ein Application-Launcher auf der Basis inkrementeller Substring-Suche in den Namen aller Startmenü-Einträge. Die Suchsequenz wird normalerweise rein Tastaturorientiert durch einen Hotkey eingeleitet. Der inkrementell gefundene beste Eintrag wird automatisch vervollständigt im On-Screen Display angezeigt.
kate-4:20.12.2-1/editors/raspbian kate-3.5.7-r1/kde-base/gentoo {development_environment}{text-editor}{Qt}: Der KDE-Programmiereditor. Beherrscht alles wichtige, darunter alles was kedit kann. Der Mauszeiger wird versteckt sobald man zu tippen beginnt und sich dieser gerade über dem Text befindet. Sobald man den Mauszeiger bewegt, erscheint er sofort wieder. Das ist hilfreich, damit der Mauszeiger nicht den jene Stelle verdecken kann an der man gerade tippt; das ist häufig der Fall nachdem man etwas mit der Maus markiert hat. Dazu noch Rechteckmodus, Syntax-Highlighting, intelligentes Einrücken, automatische Vervollständigung, Code Folding, HTML-Export, Plugins. Kate kann im Gegensatz zu kwrite beliebig viele Dokumente gleichzeitig geöffnet haben und diese Sammlung auch als "Sitzung" speichern. Als Plugins sind Dinge wie Vorlagen, Symbol-Browser, Terminal, make-Support und ähnliches verfügbar. Ein Nachteil von Kate, wenn man ihn nicht unter KDE betreibt, ist dass es beim Start einen Hintergrundprozess kactivitimanagerd startet, diesen nach dem Beenden von kate jedoch weiter laufen lässt. Tipp: Wenn kate ohne KDE installiert wird und im "Ersetzen"-Dialog nur unsichtbare Icons für die Suchoptionen angezeigt werden, dann ist kein Symbolthema ausgewählt. Dazu muss man die Applikation "Qt5-Einstellungen" aus dem "Einstellungen"-Untermenü des Startmenüs aufrufen, und dort eines der Icon-Themes auswählen. Vermutlich betrifft dieses Problem nicht nur kate sondern alle KDE-Anwendungen die unabhängig von KDE installiert sind.
katomic/kde-base/gentoo {game}: Sokoban-ähnliches Logik-Spiel, nur dass man hier die Objekte immer nur anstoßen kann und sie bewegen sich bis sie auf ein Hindernis stoßen. Statt die Objekte so auf bestimmte Zielfelder bewegen zu müssen geht es hier aber darum, sie in bestimmte 2-dimensionale Anordnungen zu bringen, welche chemische Formeln darstellen. Leider auch hier wieder das KDE-Games-Problem: Eher kleine Icons und Sprites in fixen Größen; die Grafiken skalieren nicht auf die Größe des Bildschirms. Aber immerhin kann man hier wenigstens das *Fenster* vergrößern!
kbandwidth/net-misc/gentoo: Another network I/O rate monitor. Has nice traffic load bars similar to IceWM's standard docklet, but the bars are laid out horizontally. Although it looks nice enough, it has a problem actually detecting network activity: The bars often remain idle in situations when other monitors like knetstats already report activity.
kbattleship/kde-base/gentoo: Das Schiffe-versenken-Spiel, wie man es weiland in der Schule spielte. Spieler gegen Computer oder Client-Server basiert übers Netzwerk. Nett gemacht; leider auch hier wieder Grafiken fixer Pixelgröße welche nicht auf Fullscreen skaliert werden können. Nettes Demonstrationsobjekt für Client/Server Spiele. Ansonsten wohl nur für Tafelklassler interessant.
kbattleship/kde-base/gentoo: Das gute alte Schiffe-Versenken aus der Volksschule. Einzelspieler oder zu zweit via Netzwerk. Leider nur kleines, nicht vergrößerbares Fenster. Wohl nur etwas für die geistig besonders jung gebliebenen.
kblackbox/kde-base/gentoo: Das gute alte "Atome erraten"-Spiel. Detektorstrahlen werden in eine Blackbox geschossen und man muss daraus folgern wo die Atome sitzen. Gut geeignet wenn man während einer kritischen Echtzeitoperation am Computer möglichst keine Rechenzeit verbrauchen will.
kblocks-4.3.1/kde-base/gentoo: Tetris im "Ägypten"-Style. Der Sound ist nervig; doch gottlob abschaltbar. Skalierbare Fenstergröße, optisch alles OK - aber irgendwie "eiert" die Steuerung; man hat den Eindruck dass die Tasten erst leicht verzögert reagieren. Das ist auf den ersten Eindruck ein schwerer Mangel für die Spielbarkeit; doch vielleicht kann man sich daran gewöhnen.
kbounce/kde-base/gentoo {game}: Nett gemachtes Spiel auf der Grundidee von Quix aufbauend: Bälle fliegen herum und man kann horizontale und vertikale Wände aufbauen lassen. Trifft ein Ball eine im Aufbau befindliche Wand verliert man ein Leben. Erreicht die Wand jedoch das gegenüberliegende Ende erobert man den "abgemauerten" Abschnitt. Sobald man genug erobert hat kommt das nächste Level.
kbreakout-4.3.1/kde-base/gentoo {game}: Der typische Breakout/Arkanoid-Klon. Untadelig mit skalierbarer Fenstergröße. Aber irgendwie gefällt mir games-arcade/lbreakout besser. Mag allerdings sein dass kbreakout bei hohen Auflösungen besser aussieht da alle KDE4+ Spiele vektorbasierte Grafiken zu verwenden scheinen während lbreakout noch pixelbasiert zu sein scheint.
kcalc-4 {calculator}{Qt}: 18.04.1-1/math/debian: Der Normale. Netter Taschenrechner. Was man erwartet und sieht sehr schlicht, aber immer noch hübsch genug aus um nicht die Nase rümpfen zu müssen. Rein funktionell und nicht verspielt. Verfügt auch über optional zuschaltbare Tasten für Statistik, naturwissenschaftliche Funktionen, belegbare Konstanten und Hex/Oct/Boolean Berechnungen. Witzig wenngleich eher sinnlos: Zuschaltbare Bit-Darstellung der angezeigten Zahl als Check-Boxen, so dass man mit der Maus einzelne Bits an- und abschalten kann. Kennt nur den normalen algebraischen Bedienungsmodus klassischer Taschenrechner, keinen RPN-Modus oder noch abenteuerlichere Modi. Man kann beliebige Schriftarten getrennt für Tastenfeld und Anzeige festlegen. Es lassen sich unterschiedliche Farben für vordefinierte funktionale Gruppen von Tasten festlegen. Ebenso wie die Vorder- und Hintergrundfarbe der Taschenrechner-Anzeige. Ziffern in der Anzeige werden gemäß der Locale gruppiert. Für binäre, oktale und hexadezimale Zahlen kann man separate Gruppierungen festlegen. Es gibt ein Menü mit in Summe keinen 20 vordefinierten naturwissenschaftlichen Konstanten. Weiters kann man 6 eigene Konstanten festlegen (oder aus dem zuvor erwähnten Konstantenmenü auswählen) welche dann optional in eben so vielen Buttons angezeigt werden. Etwa Pi und e. Leider fand ich keine Möglichkeit, weniger als alle 6 Tasten anzuzeigen wenn man gar nicht so viele Konstanten benötigt. Alle Funktionen sind entweder mit der Maus oder über Tasten steuerbar. Wenn man die Strg-Taste gedrückt hält, verschwinden die normalen Tastenaufschriften und werden durch die Tastensymbole ersetzt welche man drücken kann um die zugehörige Bildschirmtaste zu drücken. Das Programm hat zwar kein editierbares Formelfeld, aber ein Linksklick aufs Anzeigefeld kopiert den Wert in die Zwischenablage und ein Rechtsklick von dort in die Anzeige. Kurzum, tut und kann einfach was man von einem normalen Taschenrechner erwartet. In der "einfachen" Ansicht auch gut für unbedarfte Benutzer geeignet. Allerdings kein Ersatz für Qalculate! das noch viel mehr als dies kann. 43 MB RAM-Verbrauch, 2,5 MB Installationsumfang, 550 kB Download. Der größte Vorteil dieses Taschenrechners ist sein "Normalheit". galculator braucht zwar weniger Speicher und sieht noch besser aus, aber sein wissenschaftlicher Modus ist sehr seltsam mit Tasten bestückt. Speedcrunch ist sehr bedienungsfreudlich und bietet seinen "Papierstreifen", erfordert aber das Arbeiten in einer Eingabezeile was nicht der gewohnten Bedienung eines Taschenrechners entspricht. Qalculate! kann viel mehr, erfordert aber aufgrund seiner Mächtigkeit und seiner vielen Modi auch deutlich mehr Einlern- und Konfigurationsaufwand. Ein Nachteil von kcalc ist allerdings seine Abhängigkeit der KDE-Bibliotheken - wenn diese nicht bereits installiert sein sollten weil man keine anderen KDE-Programme nutzt, würde dies beträchtlichen Installations-Overhead für diese Abhängigkeiten bewirken.
kcharselect-4: 16.08.0-1/utils/raspbian: Die Zeichen-Auswahltabelle von KDE. Zwei Panes und darüber zwei Klappfelder. Das linke Klappfeld selektiert die Script-Familie (Europäisch, Afrikanisch, Symbole, ...) und das rechte Klappfeld wählt dann einen Codebereich innerhalb der Familie, etwa "Basic Latin", "Latin Extended-A" usw. Die linke Pane zeigt dann alle Zeichen aus der Wahl des rechten oberen Klappfelds an, und die rechte Pane die zugehörigen Zeichen-Informationen. Da die rechte Pane daher ständig zu sehen ist, kommt das Programm anders als gucharmap auch keine Statuszeile um dort die wesentlichen Daten des Zeichens zusammen zu fassen. Es gibt keinen normalen Suchdialog, sondern noch über den Klappfeldern ein permanent angezeigtes Textfeld. In diesem findet eine inkrementelle Suche statt wenn man etwas eintippt. Leider kann das auch einer langsamen Maschine ziemlich "eiern", auf denen verwendet man wohl doch besser gucharmap auch wenn es vom Installationsumfang her deutlich fetter ist. Auch hier kann man sowohl nach den Zeichen selbst als auch nach ihren UNICODE-Bezeichnungen suchen. Und auch hier gibt es ein Textfeld in welches man per Doppelklick selektierte Zeichen einfügen kann, und einen Button um diese in die Zwischenablage zu kopieren. Ebenfalls funktional und brauchbar. Installationsumfang 153 kB. Zwei Kleinigkeiten sind in gucharmap besser gelöst: Es startet schneller, und man findet die komplette ASCII- bzw. LATIN1-Tabelle auf einem Bildschirm. Bei kcharselect sind die Zeichen aber über verschiedene Tabellen verstreut, etwa eine für Steuerzeichen, eine für die restlichen ASCII-Zeichen, eine für die Umlaute etc. Daher ist die Übersicht auf den ersten Blick nicht überragend. Aber durch die Suchfunktion findet man dennoch alles.
kchart-1.6.3/app-office/gentoo: Die Chart-Komponente von koffice. Sehr benutzerfreundlich, kann auch Stand-Alone verwendet werden. Da OpenOffice aber seine eigene Chart-Komponente hat, macht kchart nur Sinn wenn man das schlankere koffice statt dem fetten OpenOffice einsetzt.
kconvert/sci-calculators/gentoo {calculator}: Ein extrem primitives GUI-Programm, aber optisch OK, das erst in einem eigenen Dialog auffordert einen Themenbereich zu wählen, und dann muss man erst recht aus einen Pulldown-Menü die Einheiten auswählen. Sinnlos umständlich. Des weiteren kennt es nur 3 Währungen, darunter keinen ATS, und erweiterbar scheint das Ding auch nicht zu sein. Am besten vergessen.
kcron/kde-base/gentoo {service manager}: Ein GUI für "crontab". Unterstützt allerdings nur Standard-cron-Funktionalität; daher zwar brauchbar für Vixie-cron, aber unbrauchbar für fcron.
kdat-3.5.5/kde-base/gentoo: Tool zum Arbeiten mit Magnetbändern. Gut und schön - nur recht sinnlos, wenn man über keinerlei Band-Speichermedien im Einsatz verfügt.
kdbg/dev-util/gentoo: GDB-GUI-Frontend mit Qt-Widgets. Sieht natürlich sehr hübsch aus. Dürfte auch alles können was man so braucht. Tasten sind offensichtlich zum Microsoft-Pendant kompatibel. Das nervt etwas wenn man den Commandline-gdb gewohnt ist. Zu funktionieren scheint er soweit auch. Und dass er für die Programmausgabe automatisch ein neues Fenster im Hintergrund öffnet, ist gar nicht unpraktisch. Was mich allerdings in den Wahnsinn trieb, war die Tatsache dass er beim Single-Steppen immer nur soweit scrollt wie es nötig ist. Sprich, man sieht immer nur die unterste Zeile am Bildschirm wenn der Programmfluss ständig nach unten geht. Das *nervt*! Außerdem fehlt ihm etwas ganz wesentliches: Er bietet keinerlei Zugriff auf die gdb-Konsole! Dadurch kann man auch etwa die Disassembler-Anzeige nicht auf Intel-Format umstellen. Dafür hat jede Source-Zeile einen kleinen Knubbel, wo man ihr Disassembler-Listing im AT&T-Format anzeigen kann. Also sehr viele Knubbels, die man fast nie braucht, und die normalerweise nur die Anzeige übersäen. Eine weitere unglückliche Design-Wahl war die Entscheidung, bei der Anzeige von Variablen die Adresse zum Typ zu schreiben. Da die Anzeige 2-spaltig erfolgt, verbraucht die linke Spalte so viel mehr Platz als wäre die Adresse in der rechten Spalte wo die Wert stehen. Der "insight"-Debugger macht dies wesentlich intelligenter. Überhaupt sind die Fenster und Panes im Layout meiner Ansicht nach etwas unglücklich angeordnet und man muss manuell viel zurecht rücken und resizen bevor man sinnvoll arbeiten kann. Was die Kontextmenüs angeht, so sind diese ebenso fantasielos und bescheiden wie der Rest des Debuggers. Insgesamt kann dieser Debugger zwar alles was man mindestens erwartet, aber kein bisschen mehr. Mein Resümee: Ein Debugger, der für Neulinge und Anfänger vermutlich gut geeignet ist, da er niemanden mit großer Funktionsfülle "verwirrt". Er erinnert stark an den Visual Basic Debugger, und kann auch kaum mehr als dieser.
kdeartwork-kscreensaver/kde-base/gentoo: Die KDE-Bildschirmschoner. Es sind sehr schöne darunter, aber auch sehr nützliche wie Slideshows für eigene Bilder (darunter auch eine 3D-Variante).
kdeartwork-kworldclock/kde-base/gentoo: Ebenso unnötig wie kde-base/kworldclock, und erfordert letzteres auch noch. Weg damit.
kdenlive-20.12.3-1/video/debian {video-editor}: Kdenlive ist ein auf KDE + Qt basierender nicht-linearer Video-Editor. Kdenlive ist 2022 auf Platz 1 der beliebtesten nichtlinearen Video-Editoren (auf slant.co). Er bietet eine sehr vollständige Videobearbeitungslösung. Seit Version 17 ist es ein sehr stabiles Programm. Viele Einstellungen können in Keyframes verankert werden. Mehrere Spuren können zu einer Gruppe vereinigt werden. Man kann Effekte und Funktionen aber auch umgekehrt auf mehrere selektierte Spuren anwenden. Das Programm kann Audiospuren genau so wie Videospuren bearbeiten, was es zugleich zu einem der besten Audio-Editoren macht. Verwendet Keyboard-Shortcuts ähnlich wie Adobe Premiere; diese lassen sich jedoch anpassen. Nachteile sind Abstürze beim Editieren von überlagerten Videos, insbesondere wenn ein Alpha-Kanal genutzt wird. Auch der Effekt zum Ändern der Abspielgeschwindigkeit führ häufig zu Abstützen. Der Zeitlinien-Cursor funktioniert nicht richtig. Schwacher Support für Multicore- und GPU-Rendering. 2022 ist der RAM-Bedarf direkt nach dem Start 277 MB RAM.
kdesdk-strigi-analyzer/kde-base/gentoo: These plugins allow Strigi Desktop Search to extract additional information about some file formats often used in software development, such as Patch files (diff), Qt Linguist files (ts), and Gettext translation files (po).
kdevelop/dev-util/gentoo {development_environment}{Qt}: Sehr hübsche, popelige und maßlos ressourcenverschwendende C++ IDE für KDE. Kann alles was man von einer IDE erwartet. Erzeugt darüber hinaus auch noch autoconf/automake-basierte Projekte, die folglich auch ohne kdevelop von dritten übersetzt werden können. Allerdings enthält kdevelop auch viele Komponenten, die sich speziell auf KDE- und Qt-Entwicklung beziehen. Ausserdem ist diese IDE derart groß und toll, dass man vor lauter Features erschlagen wird. Simple Dinge hingegen, wie das Erstellen einer static-Library als Projekt, wird nicht direkt unterstützt und man kann sich erst recht mit Makefiles herumquälen. Man sollte sich daher wohl wirklich überlegen, ob man dieses tolle Monster braucht. Vermutlich werden sich die Features wie der integrierte Symbol-Browser etc. erst bei umfangreicheren Projekten auszahlen.
kdf-3.5.5/kde-base/gentoo: Provides two GUI tools, KDiskFree and KwikDisk. KDiskFree displays a graphic equivalent of "df -h". That's ok, but nothing special. KwikDisk is a KDE control panel application which pops up a large window with the same information, but only in textual form. Both tools also allow mounting and unmounting devices on the fstab mountpoints. KwikDisk is not terribly useful, but KDiskFree's disk usage bar charts are unparalleled in their simplicity. Nice for GUI-only guys, but of very little usefulness for command-line cracks because the "df" command is much faster to launch.
kdialog-4:22.12.3-1/utils/raspbian {cmdline-dialog}: Ein weiteres Utility zum Anzeigen von grafischen Dialogen aus Shell-Scripten heraus. Dieses verwendet Qt und sieht entsprechend grafisch vergleichsweise hübsch aus (da Qt mehr Wert auf schöne Optik hängt als z. B. GTK+). Es ist eine Art Qt-Gegenstück zu zenity. Lässt sich auch via D-Bus ansprechen (zumindest für einen Progress Dialog), jedoch funktioniert es offenbar auch wenn D-Bus nicht läuft. Es gibt die folgenden Widgets: Meldungstext mit vorkonfigurierten Standard-Button-Variationen (Ja, Nein, Abbrechen, OK usw.) und Icons (Error, Warning usw.), Passwortfeld, Texteingabe, Textanzeige (kann aus einer Datei stammen), Bildauswahl (mit oder ohne zugeordnetem Anzeigetext), Radio-Buttons, Ankreuzbuttons, "Speichern"-Dialog, "Öffnen"-Dialog, Directory-Auswahl-Dialog, Icon-Auswahl, Fortschrittsbalken, Farbauswahl, Schieberegler für Werte, Kalender, Einbetten in andere Fenster. Insgesamt recht ähnlich wie zenity. Font-Auswahl-Dialog gibt es ebenfalls genau so wenig. Eine Besonderheit ist ein schwebendes Benachrichtigungsfenster, das nach einer gegebenen Zeit wieder von selbst verschwindet. Allerdings erscheint das Fenster normal am Bildschirm, und nicht im Benachrichtungsbereich des Fenstermanagers. Was auffällt ist das komplette Fehlen von Dokumentation. Mit Ausnahme der eingebauten "--help"-Option welches aber keine Konzepte erläutert, scheint es nichts zu geben. Offensichtlich wird erwartet dass man immer im Web nachsieht. Zum Glück fand ich die Dokumentation auf einer einzelnen HTML-Seite [ https://develop.kde.org/docs/administration/kdialog/ ], welche sich einfach lokal als zukünftige Offline-Dokumentation abspeichern lässt. Das Utility selbst ist sehr schlank, erfordert aber Tonnen an installierten KDE-Libraries als Laufzeit-Abhängigkeiten. Ich erkenne wenige Vorteile gegenüber dem wesentlich häufiger installierten zenity, nur optisch ist es hübscher weil Qt allgemein besser aussieht als GTK+.
kdiff3/kde-misc/gentoo {dir-diff}{text-diff}{character-diff}{soft-word-wrap}{text-merge}: Das Power-Tool für grafisches Diff / Compare. Mit 2 oder 3 Quellen. Kann sowohl Verzeichnisse mit Unterverzeichnissen als auch einzelne Dateien vergleichen. Auch manuelles Editieren der zusammengeführten Einträge ist möglich. Sehr mächtig, durch die Farbcodierungen ist aber ein Lesen der Anleitung nötig um den Sinn der Markierungen zu erfassen. Trotz aller Power ist es grafisch nicht so hübsch und einsichtig verständlich wie kompare. Aber es kann auch deutlich mehr. Eine Stärke von kdiff3 ist der Vergleich von Absatz-orientiertem Fließtext mit weichem Wortumbruch für die Anzeige. Während die Konkurrenten meist nur zeilenorientiert vergleichen können, ist kdiff3 zwar auch grundsätzlich zeilenorientiert (wobei hier eine "Zeile" eigentlich ein ganzer Absatz ist), kann aber sowohl Unterschiede innerhalb der Zeilen anzeigen, als auch diese für die Anzeige umbrechen.
kedit-3.5.7/kde-base/gentoo {text-editor}{GUI}{X11}: Ein simpler KDE Text-Editor, der aber alles kann was man von einem derartigen Texteditor erwartet. Vor allem beherrscht er auch weichen Zeilenumbruch und kann mit allen möglichen Codierungen umgehen, insbesondere UTF-8. Suchen/Ersetzen, Rechtschreibprüfung. CUA-orientiert. Allerdings ist er ein Text- und kein Programmier-Editor.
keditfiletype-4.11.2/kde-base/gentoo {installed applications menu editing}: Ein Editor für die Dateiverknüpfungen sowie ".desktop"-Dateien gemäß des freedesktop.org-Standards. Editiert welche Programme für welche Dateitypen zuständig sind, aber auch die Details der Programme wie Kommandozeile, Icon und Eintragstext im Startmenü, Beschreibung etc. Das Programm ist zwar Teil von KDE, die von ihm editierten Dateien können aber von allen Desktop-Environments genutzt werden die sich an den freedesktop.org-Standard halten.
keduca/kde-base/gentoo: Nettes KDE-Programm zum Erstellen von Prüfungsfragen und Tests sowie zum Lernen basierend auf den erstellten Test-Fragen. Unterstützt eine Vielzahl verschiedener formularbasierter Test-Varianten, wie Multiple-Choice-Test, Test mit auszufüllenden Feldern, etc. Ausserdem können zu jeder Testfrage Hinweise eingegeben werden, die Punktezahl bei korrekter Lösung, usw. Macht einen brauchbaren Eindruck für den Fall dass etwas gelernt werden soll.
keepassx-0.4.3/app-admin/gentoo: Qt-basierter Passwort-Manager. Ein *IX-Fork von Keepass für Windows. (Nicht zu verwechseln mit "keepass2" welches in .NET/mono geschrieben und ein entsprechendes Machwerk ist.) Der noch beste Passwort-Manager für X11 der mir bislang unterkam. Passwörter werden über die Zwischenablage oder simulierte Tasten-Events ("Auto-Type") an Passwörter wartende Eingabefelder übertragen. Hat auch einen ganz brauchbar wirkenden Passwort-Generator. Die Datenbank wird in einer Datei gespeichert, wobei wahlweise AES-256 oder TWOFISH-256 zur Verschlüsselung der Datenbank zum Einsatz kommt. Die Datenbank kann dabei mit einem Passwort und/oder einer Schlüsseldatei verschlüsselt werden. Passwörter können in Gruppen und Untergruppen organisiert werden. Pro Passwort können Titel, Benutzername, Passwort, Ablaufdatum, URL, Anhang, und Kommentar gespeichert werden. Es kann nur ein Anhang pro Eintrag gespeichert werden. Dieser wird dafür aber (als BLOB) tatsächlich in der Datenbank gespeichert, und nicht etwa nur ein Verweis auf die Datei. Das Attachment kann nur gelöscht oder (entschlüsselt) angespeichert werden. Kopien gelöschter oder veränderter Einträge können optional in eine "Backup"-Gruppe verschoben werden. Die Einträge dort können dann manuell entfernt oder optional nach einer gewissen Zeit endgültig gelöscht werden. Es gibt auch ein Suchfeld mit dem man Schlüssel schnell durch Substring-Suche in den Eintragsfeldern herausfiltern kann. Das Programm kann beliebig viele Datenbanken (nach einander) verwenden; es kann konfiguriert werden sich die aktuelle Datenbank zu merken und diese beim nächsten Start automatisch zu laden.
keepassx-2.0.3+git20190121.1682ab9-2.2/utils/debian: Ein Passwort-Manager mit hübschem Qt-basiertem GUI. Für die grundlegenden Funktionen siehe die Beschreibung der älteren 0.x Version. Die 2+.x Versionen des Programms unterscheiden sich im Detail leider erheblich von der "klassischen" 0.x Version. Vorteile gegenüber der früheren Versionen: Beliebig viele für jeden Eintrag frei definierbare benutzerdefinierte Felder zusätzlich zum allgemeinen Kommentarfeld. Beliebig viele binäre Anhänge pro Eintrag. Einträge haben nun auch einen Zeitstempel für den letzten lesenden Zugriff sowie eine UUID. KeepassX-Datenbanken im alten Format können importiert werden. Die aktuelle Datenbank kann im CSV-Format exportiert werden. Nachteile gegenüber früheren Versionen: Keine alternative TWOFISH-Verschlüsselung mehr; nur noch das von der NSA wärmstens empfohlene AES wird unterstützt. Datenbanken können nicht ins frühere Format der klassischen Versionen exportiert werden. Ebenso wenig ist es möglich, zuvor als CSV exportierte Datenbanken wieder zu importieren. Der Import und Export im XML-Format wurde sogar komplett gestrichen. Es gibt somit keine Möglichkeit mehr, den Datenbankinhalt in eine Textdatei zu exportieren, dort zu editieren, und das Ergebnis wieder zu re-importieren. Die Möglichkeit zum Definieren und Editieren von Favoriten-Datenbanken wurde ebenso gestrichen. Es gibt lediglich einen Verlauf der zuletzt benutzten Datenbanken, den man ansonsten nur noch löschen kann. Das größte Argument für die Benutzung dieser neuen Version ist der Umstand dass es Qt5-basiert ist, während die klassische Version das veraltete Qt4 benötigt das unter Debian 11 nicht mehr offiziell verfügbar ist. Update 2021-12: Es wurde bekannt, dass dieser Fork nicht mehr weiter entwickelt soll. KeepassXC wird als Nachfolger empfohlen.
keepassxc-2.6.2+dfsg.1-1/utils/debian: Ein Passwort-Manager. Ein Fork des nicht mehr weiter entwickelten KeepassX und von dessen Autoren sogar als Nachfolger empfohlen. Kompatibel mit (neueren) Versionen von Keepass und KeepassX. Für Android gibt es (unter anderem) KeepassDX (OpenSource, auch in f-droid zu finden) zum Bearbeiten der Passwort-Datenbanken, und Strongbox wird für iOS empfohlen. Die Unterschiede von KeepassXC zum Vorgänger KeepassX sind: "browserartigeres" Aussehen. Die Icons, Farben und Darstellungseffekte entsprechen denen einer Browser-App. Icons sind nur S/W, was mieser aussieht als früher. Aber zumindest sind sie gut zu erkennen, was beim (vermutlich verwendeten) "Material Design" keine Selbstverständlichkeit ist. Die Anzeige des Fensters braucht deutlich mehr horizontalen Platz als früher, wo die halbe Bildschirmbreite ausreichte. Das liegt einerseits daran dass allgemein ein größerer Font verwendet wird, dass die linke Seitenleiste anders als früher eine recht ordentliche Minimalbreite hat, und dass rechts in der Listenansicht der Einträge mehr Spalten vorhanden sind. Zum Glück lassen die angezeigten Spalten sich aber frei auswählen. Doch auch die rechte Seite hat eine recht große Minimalbreite. Mit etwas Mühe schafft man es dennoch, das Fenster wie früher auf die halbe Bildschirmbreite zu bringen - bei einem Full-HD Display. Früher sah man dabei allerdings mehr auf einen Blick. Ein Ärgernis sind die Scrollbalken - nur sehr schmal, gerade einmal etwas dickere Striche, und anders als bei GNOME3 klappen diese auch nicht zu größeren Balken auf wenn die Maus sie berührt. Außerdem sind sie in vergleichsweise geringem Kontrast zum Listenhintergrund gehalten. Zum Glück gibt es mehrere Designs zur Auswahl - ein helles und dunkles browserartiges, sowie "Klassisch" welches bis auf die Icons und Schriftgröße die meisten der obigen Beschwerdepunkte ausräumt und wieder ein Qt-GUI mit normalen Scrollbalken darstellt. Ein Segen! Beim Starten braucht das Programm "ewig" - ob es vielleicht ungefragt aufs Internet zugreifen will? Es gibt eine Funktion zum Herunterladen von "Favicons" - jene zu Webseiten gehörenden kleinen Icons welche Browser in der Adressleiste anzeigen. Optional kann man DuckDuckGo für das Herunterladen der Icons verwenden. Ein herunter geladenes "Favicon" ersetzt dann die fix im Programm eingebauten Icons für den Eintrag. Ebenso kann man für alle Einträge einer Gruppe die Favicons herunterladen lassen. Eine Browser-Integration ist vorhanden und lässt sich optional aktivieren. Browserseitig geschieht dies über AddOns. Derzeit unterstützte Web-Browser: Firefox, Chrome, Chromium, TOR Browser, Vivaldi, Brave. Es gibt zwar jede Menge Optionen um diverse Sicherheitsabfragen abzustellen, aber keine die erzwingt dass jedes Ausliefern eines Passworts an den Browser vom Passwort-Manager erst nach einer Nachfrage erfolgt. Zudem scheint es ein Alles-oder-Nichts zu sein: Entweder man kann vom Browser aus auf alle Einträge zugreifen, oder man muss die Browser-Integration komplett abschalten. Immerhin gibt es für jeden Eintrag eine Option, seine Sichtbarkeit für das Browser-Plugin komplett zu unterbinden. Per Default ist diese Versteck-Funktion jedoch deaktiviert, so dass man leicht vergessen kann sie für einen Eintrag abzuschalten. Wegen der offensichtlichen Gefährlichkeit dieser Features sollte man eine separate Keepass-Datenbank nur für die Verwendung im Browser anlegen. Was nur Sinn macht wenn man dessen eingebauter Passwort-Verwaltung nicht traut und sie gegen Keepass ersetzen will. Eine neue Funktion ist die Integration mit dem SSH-Agent. Leider kann man nur eine Instanz des Agenten global für das Programm festlegen (entweder durch Verwendung der $SSH_AUTH_SOCK Umgebungsvariable oder explizite Angabe eines Socket-Pfades), wenn man mit mehreren Agenten arbeitet funktioniert das nicht (oder man muss andauernd das globale Setting ändern). Es gibt eine neue Funktion "KeeShare", die einzelne Gruppen einer Keepass-Datenbank in eine andere exportieren oder von dort importieren kann. Es gibt auch ein Synchronisations-Feature, was vermutlich dasselbe in beide Richtungen macht. Es gibt eine optionale Integration an den "Secret Service", einen DBUS-Dienst der im Falle von Passwort-Nachfragen von GNOME-Programmen benutzt wird. Auch hier bleibt unklar ob man einschränken kann welche Passworte dadurch erreicht werden können oder ob man zumindest eine interaktive Bestätigung des durch den Passwort-Manager erzwingen kann. Das native Datenformat des Programms sind .kdbx Dateien. Neu ist die Funktion zum Zusammenführen zweier Passwort-Datenbanken (was vermutlich einen mischenden Import darstellt). Ebenfalls neu ist eine Funktion zum Speichern eines Backups unter anderem Namen. Was entfernt wurde ist der Punkt zum Reparieren einer Datenbank. Der Verlauf wird nun versteckt solange ein Eintrag noch nicht geändert wurde. Der Verlauf wird nun pro Eintrag verwaltet. Es scheint keine globale Funktion mehr zu geben, ihn komplett für alle Einträge zu löschen. Jede Änderung lässt daher die Datenbank anwachsen, außer man geht sofort in den Verlauf und löscht sie. Der Verlauf wird beim Abspeichern immer mitgespeichert. Das globale komplett-Deaktivieren der "Papierkorb"-Funktion ändert nichts am Verlauf-Feature, und es ist völlig unklar was dieses Feature überhaupt tut. Eine Verbesserung ist dass man einzelne benutzerdefinierte Schlüssel-Wert Paare eines Eintrags als "geschützt" kennzeichnen kann, so dass ihr Inhalt verborgen wird bis man auf eine Schaltfläche zum Anzeigen klickt. Das ist für sekundäre Passwörter nützlich. Doch leider hat man die Funktion vergessen, die versteckten sekundären Passwörter in die Zwischenablage zu kopieren. Statt dessen muss man dazu immer den Eintrag bearbeiten, wo es dann doch eine Funktion zum Anzeigen der verborgenen sekundären Passwörter gibt. Insgesamt ist das jedoch so umständlich dass man sich besser 2 x überlegt ob man ein sekundäres Passwort verbergen will. Der Passwort-Generator wurde erweitert. So kann man nun auch benutzerdefinierte Zeichen zur Auswahl hinzufügen, oder aber entfernen. Man kann so z. B. hexadezimal-ASCII Passworte erzwingen. Außerdem lassen sich neben Passworten nun auch Phrasen generieren, die aus einer bestimmten Anzahl vordefinierter englischer Worte bestehen. Außerdem gibt es mehr vordefinierte Zeichengruppen zum Ein- und Ausschließen. In allen Fällen wird die errechnete Schlüsselstärke in Bit immer angezeigt. Allerdings ist diese Berechnung etwas seltsam, da sie unterschiedliche Werte für verschiedene Passwörter anzeigt, welche mit exakt denselben Einstellungen generiert wurden. Das größte Manko bleibt allerdings bestehen: Man erfährt nicht woher die Entropie für die Passworte kommt, und kann auch nicht mittels "Mausrühren" eigene erzeugen. Vermutlich werden daher minderwertige Passworte aus /dev/urandom genommen, und man sollte den Passwort-Generator allgemein nur für mäßig wichtige Zugangsdaten verwenden. Allerdings war das bei neueren KeepassX-Versionen nicht besser. Nur bei KeepassX 1.x konnte man auch "Maus-rühren". Die neue optionale SSH-Agent-Integration erlaubt es, private SSH-Keys entweder aus externen Dateien oder aus im Eintrag gespeicherten Attachments zu lesen. Im beiden Fällen wird das Passwort des Eintrags zum Entschlüsseln des SSH-Keys benutzt (und ist nur erforderlich falls dieser überhaupt verschlüsselt war). Man kann den mit dem Eintrag verbundenen Schlüssel dann auf Tastendruck in den SSH-Agenten speichern oder wieder aus diesem löschen. Man kann auch ein Timeout einstellen, nach dem der Schlüssel automatisch wieder aus dem Agenten entfernt wird. Es wird der öffentliche Schlüssel angezeigt sowie seine MD5 sowie SHA2-256 Fingerprints. Die "VisualHostKey"-Darstellung wird aber nicht angeboten. Die SSH-Einstellungen des Eintrags werden automatisch als zusätzlicher Anhang des Eintrags gespeichert, den man auf diese Weise auch Abspeichern bzw. Reimportieren kann. Es handelt sich dabei um eine XML-Datei. Anders als bei der Browser-Integration die offenbar vorbehaltlos der Sicherheit des Browser-Plugins (und damit auch dem Browser selbst) vertraut, gibt es eine Option pro Eintrag, dass man vor jeder Verwendung des SSH-Schlüssels (via interaktivem Pop-Up) gefragt wird. Ebenso kann man festlegen, dass ein Schlüssel automatisch beim Öffnen/Entsperren der Datenbank zum Agent hinzugefügt werden soll, oder beim Sperren/Schließen wieder automatisch entfernt. Insgesamt erscheint der SSH-Support nützlich, nur nur der Umstand dass man sich auf einen Agenten beschränken muss ist ärgerlich. Neu ist ferner der TOTP-Support. Hier wird mehr oder weniger dasselbe geboten wie bei anderen Anwendungen (etwa "freeotp" unter Android) zur Anzeige eines auf einem festen Schlüssel basierenden zeitlich variierenden Pass-Codes. Man kann den Schlüssel und die OTP-Parameter festlegen, diese für die Übertragung auf ein anderes Gerät als QR-Code anzeigen lassen, oder den aktuellen Code direkt im Passwort-Manager anzeigen lassen. Diese Einstellungen werden als spezielles Schlüssel-Wert paar in den benutzerdefinierten Feldern des Eintrags gespeichert; der Wert ist eine "otpauth://"-URL (welche auch im QR-Code übertragen würde). Alle weiteren Funktionen von KeepassXC sind soweit ich sehen konnte mit denen von KeepassX identisch. Ein großer Vorteil von keepassxc ist der Umstand, dass die Twofish-Verschlüsselung nun wieder verfügbar ist welche auch von früheren Versionen von keepassx wie 0.43 noch unterstützt worden war, seit keepassx 2.x jedoch nocht mehr. Und überdies fügt keepassxc auch noch ChaCha20 als dritte Option für das Verschlüsseln der Datenbank hinzu. Also nicht mehr länger Zwangs-Vertrauen in das von der NSA solch wärmstens empfohlene AES! Allein das ist bereits ein ausreichender Grund, keepassxc dem bisherigen keepassx vorzuziehen. Einzig der RAM-Verbrauch des Programms ist beschämend bzw. sehr hoch im Vergleich zu früher. Aber man muss es ja auch nicht andauernd laufen lassen. Ein Problem bekommt man jedoch, wenn man eine *.kbdx-Datei auch mit älteren Android-Versionen von KeePass verwenden will. In diesem Fall darf man das neue ChaCha20 nicht nützen, sondern nur AES oder Twofish. Außerdem muss man das KDBX 3.1 Datenbankformat verwenden, welches AES-KDF benützt. Das neuere Argon2 im KDBX 4 Format bleibt außen vor. Ein großes Problem des Programms ist das Importieren sowie Exportieren. Einfach geht das nur im CSV-Format. Leider unterstützt das CSV-Format keine Dateiaanhänge, und alle solchen Anhänge wie z. B. SSH-Schlüssel gehen entweder komplett verloren oder werden später als Dateien der Länge Null re-importiert. Nur importieren kann man das alte Keepass-Format (Version 1, auch von alten Versionen von KeepassX benutzt) sowie "1passwort"-Dateien. Nur exportieren kann man im HTML-Format. Es gibt allerdings ein Zusatzprogramm namens keepassxc-cli, welches auch im XML-Format importieren und exportieren kann. Jedoch nur im Format KDBX 3.1 werden auch Anhänge exportiert. Beim Export des KDBX 4 Formats gehen sie verloren. Wenn man jedoch die XML-Datei wieder re-importiert, wird sie im KDBX 4 Format erzeugt ohne dass man dies ändern könnte! Auch die Verschlüsselung wird auf AES zurück gesetzt. Dadurch kann man diese Datei nicht mehr erneut verlustfrei exportieren, außer man ändert vorher manuell in der GUI-Applikation den Typ wieder zurück nach KDBX 3.1. Sehr ärgerlich!
kenolaba/kde-base/gentoo {game}: Ein Abalone-Klon für KDE. Dieses Spiel mit den 6 Kugeln in einer Reihe auf einem sechseckigen Spielfeld. Allein gegen den Computer, gegen einen zweiten Spieler oder im Netzwerk. Grafisch schlicht, aber funktional.
kexi-1: 3.1.0-4/database/debian kexi-1.6.3/app-office/gentoo: KDEs Klon von MS-ACCESS. Leider beherrscht es keine Unterformulare, und ist somit praktisch für viele Anwendungen unbrauchbar. Update 2021: Scheint immer noch so zu sein. Beherrscht Tabellen, Abfragen, Formulare und Berichte. Datenbanken werden entweder als lokale Dateien in einer SQLite3-Datenbank abgelegt oder - mit Plugin - in PostgreSQL- oder MySQL-Datenbanken auf einem DB-Server. MS-Access Datenbanken können direkt importiert werden. Danach kam dann allerdings sofort die idiotische Meldung dass diese eine SQLite3-DB sei und daher leider nicht geöffnet werden könnte. Dabei hat das Programm die Datei gerade selbst erstellt! Das Programm hat weiters erhebliche grafische Probleme - zumindest in den Menüs und Tabs. Die Schrift passt häufig nicht in ihre Container, Werkzeugleisten verschwinden obwohl sie da sein sollten etc. Die eigentlichen Tabellen und Formulare funktionieren aber zufriedenstellend. Was den Tabellenentwurf angeht - Es gibt nur Primärschlüssel auf einem einzelnen Feld und auch keine Beziehungen zwischen den Tabellen. Zumindest nicht mit dem grafischen Designer. An Datentypen gibt es nur: Text, Ganzzahl, Fließkommazahl, Ja/Nein, Zeit/Datum, Objekt. Letzteres sind im wesentlichen externe Dateien welche als BLOB in den Datensatz geladen werden können. Vermutlich in erster Linie für Fotos gedacht. Der Formular-Editor ist ebenfalls sehr minimal: Man kann verschiedene Steuerelemente aufs Formular ziehen und dort auswählen aus welcher Tabelle/Abfrage und welchen Feld darin der Inhalt des Steuerelements stammen soll. Der Berichts-Editor kann sogar noch weniger (da die interaktiven Steuerelemente natürlich wegfallen). Das war's datentechnisch. Unnötigen Firlefanz wie Farben und Fonts kann man allerdings schon einstellen. Was hingegen komplett fehlt sind Funktionen wie Steuerelemente auf einheitliche Größe zu bringen, bündig anzuordnen etc. Das muss man alles mit der Hand machen, und ein relativ kleines Einschnapp-Raster dessen Größe man nicht einmal ändern kann ist die allereinzige Hilfe dabei. Insgesamt nach wie vor völlig unbrauchbar außer für die trivalsten mehrspaltigen Listen bzw. völlig simple Formulare. Das einzig wirklich nützliche was das Programm derzeit zu vollbringen scheint, ist eine bestehende MS-Access Datenbank in eine SQLite3-Datei zu konvertieren. Andererseits war das über CSV-Import/Export immer schon möglich, wenn auch mit mehr Aufwand. Außerdem würde ich angesichts des geringen Leistungsumfangs von kexi nicht darauf wetten wollen, dass auch tatsächlich alle Daten konvertiert wurden und nicht vielleicht ein paar Feldtypen fehlen die kexi derzeit nicht unterstützt. Angesichts der langen Entwicklungszeit und da es schon vor Jahren und zahlreiche Versionsnummern nicht viel weniger konnte, bezweifle ich dass dieses Programm noch aktiv weiter entwickelt wird. Derzeit ist der sqlitebrowser jedenfalls ein deutlich leistungsfähigeres Werkzeug als kexi - bis auf die Formulare, so schwach sie auch seien.
keytouch-2.4.1/x11-misc/gentoo: Eine "All-In-One"-Lösung für Multimedia-Tasten auf Tastaturen und sonstigen Eingabegeräten. Das Programm kommt mir einer großen Datenbank bereits fertig konfigurierter Eingabegeräte daher, aber man kann x11-misc/keytouch-editor verwenden um beliebige zusätzliche Geräte zur Datenbank hinzu zu fügen. Im Grunde ist das Programm sehr simpel zu verwenden: Man startet es, wählt per GUI-Dialog eine Tastatur bzw. Multimedia-Gerät aus, und das war's dann. Ein Systemdienst läuft ab dann im Hintergrund und sorgt dafür dass alles prima funktioniert. ZUMINDEST IN DER THEORIE. Praktisch stürzte besagter Hintergrunddienst ständig ab, so dass diese zwar seher tolle und hübsche Programm in der Praxis zu überhaupt nichts zu gebrauchen war! Allerdings mag das Problem in diesem Fall an meinem spezifischen System liegen, denn keytouch verwendet den acpid-Daemon, aber genau der crasht derzeit selbst immer und mag den keytouchd daher "mit in den Tod" genommen haben. Ich habe meine Multimediatasten (es ging um Lautstärkeregelung per Tasten am USB-Headphone) dann ganz ohne tolles Programm mittels xev, xmodmap, xset -r, amixer und dem Xfce4-Keyboard Shortcut Editor implementiert.
keytouch-editor-3.1.3/x11-misc/gentoo: Ein sehr komfortabler Editor zum Erstellen neuer Tastenzuordnungen für die Verwendung durch x11-misc/keytouch. Im wesentlichen gibt man dem neuen Gerät nur einfach einen Namen, sei es eine Tastatur, ein Joystick oder der Laustärkeregler am USB-Kopfhörer, und drückt dann die Tasten am Gerät welche der Editor darauf hin erkennt. Dann kann man der Taste noch einen Namen geben, sowie ihr eine Funktion zuordnen. Beides wird in einer Viezahl von Fällen heuristisch bereits korrekt ausgefüllt. Wirklich nett und einfach zu bedienen.
kfloppy/kde-base/gentoo: Diskette format tool for KDE. Who uses diskettes anymore? And even then, this tool is only for those who are afraid of command line usage.
kformula-1.6.2/app-office/gentoo: Die Formel-Komponente von koffice. Sehr benutzerfreundlich, kann auch Stand-Alone verwendet werden. Da OpenOffice aber seine eigene Formel-Komponente hat, macht kformula nur Sinn wenn man das schlankere koffice statt dem fetten OpenOffice einsetzt.
kfouleggs/kde-base/gentoo: Eine sehr simple, aber süchtig machende Tetris-Variante: Die herunterfallenden Elemente bestehen immer aus nur 2 Kugeln meist unterschiedlicher Farbe. Alle zusammenhängenden Kugeln derselben Farbe werden abgebaut sobald sie zu liegen kommen, auch wenn es komplexe Pfade sind. Großer Suchtfaktor.
kgeography/kde-base/gentoo: Lerne welche Länger und Kontinente wo auf der Landkarte liegen. Gut gemacht, aber natürlich kein Alltagstool.
kgoldrunner/kde-base/gentoo: Das klassische Loderunner-Spiel. Nett gemacht, doch die Steuerung ist etwas gewöhnungsbedürftig. Auch hier leider wieder eine fixe Pixelgrafik-Größe die sich nicht auf einen Riesenschirm anpassen lässt. Allerdings ist das Fenster groß genug dass man mit nicht all zu hohen Auflösungen immer noch problemlos spielen kann.
khangman/kde-base/gentoo: Nett gemachtes, deutschsprachiges Galgen-Spiel. Für Kinder aber sicher super.
khexedit/kde-base/gentoo {hex-editing}{Qt}: KDE Hex editor. Rather useless, because it required to load the entire file into RAM for editing.
kig-4.11.5/kde-base/gentoo: Ein Tool zum Erlernen von Geometrie. Vordergründig ähnlich wie ein CAD-Programm aufgebaut. Es gibt jede Menge Primitives die man auf ein Koordinaten-Spielfeld platzieren kann, und sie dann mit einander kombinieren oder als Hilfsobjekte benutzen kann um andere geometrische Objekte zu platzieren oder zu transformieren. Dazu gibt es auch mächtige Tools wie Überprüfung auf Parallelität usw. Man kann auch eigene neue Primitives als Python-Quelltexte hinzufügen. Das ganze wirkt hübsch, übersichtlich und frei erweiterbar. Bei näherer Betrachtung zeigt sich aber, dass es sich in der Tat um ein Lernprogramm und kein CAD-Programm handelt: Es gibt nur Koordinaten, aber keine Einheiten oder Maßstab. Es gibt keine Kombinationsmöglichkeiten um Objekte zu gruppieren, schon gar nicht verschachtelt, und sie danach wie Primitives weiter zu benutzen. Koordinatentransformationen hingegen gibt es sehr wohl, aber eben nur bei Primitives. Ich kann zwar nicht ausschließen dass man über das Hinzufügen benutzerdefinierter Primitives so etwas irgendwie selbst implementieren könnte - aber vermutlich wäre es aufwändig und nicht trivial.
kino/media-video/gentoo {video-editor}: Ein NLE-Videoeditor zum Schneiden von Dateien im DV-Format für Linux. Kann allerdings wirklich nur in diesem Format arbeiten; auch wenn das Programm andere Formate unterstützt werden diese immer zuerst ins DV-Format konvertiert (ausser die finale Ausgabe; hier werden mehrere Codecs unterstützt). Ansonsten ist das Programm sehr minimal und bietet kaum etwas das über das nötigste hinaus geht. Für das Verarbeiten von Camcorder-Aufnahmen ist Kino daher toll; für alles andere nahezu unbrauchbar.  Openshot ist 2022 auf Platz 6 der beliebtesten nichtlinearen Video-Editoren (auf slant.co).
kitchensync/kde-base/gentoo {PIM}: Synchronization framework for various PIM-related KDE applications including kpilot. Not required otherwise.
kivio-1.6.2/app-office/gentoo: VISIO-Klon für KDE. Erstellt Flussdiagramme und andere Schaudiagramme. Zahlreiche vorgefertigte Vektorobjekte wie Disketten, Computer, Monitore, Schaltsymbole etc. sind vorhanden. Was man so braucht ist vorhanden, für Geld kann man mehr zukaufen. Ist aber auch so ausreichend.
kjots-4.3.3/kde-base/gentoo: Programm für Textnotizen. Zweigeteiltes Fenster: Links sind Ordner ("Bücher") und Eintragsnamen aufgelistet, rechts wird der entsprechende Eintrag angezeigt. Jeder Eintrag ist ein Rich-Text mit Hyperlink-Verweismöglichkeit auf andere Einträge. Support für mehrstufige Gliederungen im Textbereich. Dieses Programm ersetzt im wesentlichen den "Haufen Zettel" den man sonst oft herumliegen hat, mit der Einschränkungen dass keine Skizzen möglich sind.
kjumpingcube/kde-base/gentoo {game}: Sieht aus wie eine Art verkapptes Domino-Spiel mit 2 Farben. Jedes Feld hat eine unterschiedliche Anzahl von Augen; durch Anklicken erhöht sich diese. Alle angrenzenden Felder mit geringerer Augenzahl werden dadurch automatisch angeeignet. Das Spiel ist insofern ungewöhnlich, als sich bei jedem Zug ein Großteil der Felder den Besitzer wechselt; ständig ändern sich die Farben der meisten Felder. Wenn alle Felder des Gegners so übernommen wurden, gewinnt man. Der Spielverlauf erscheint dem Neuling sehr wirr und chaotisch. Großes Plus: Wenigestens dieses KDE-Spiel besitzt ein frei vergrößerbares Fenster.
klibc-1.5.12-r1/dev-libs/gentoo: A static (non-shared) library to directly use Linux kernel syscalls in a C application rather than linking to libc in order to do it. Is implemented as a wrapper "klcc" around the "gcc" compiler driver. Easy to use: Run "kcll" instread of "gcc" as the C compiler, and you are done. That is, if your application can actually avoid requiring functions from libc. Many standard C functions have been ported into klibc - but not all of them. Therefore, klibc is primarily targeted towards minimalistic and statically-linked, rather small programs.
klickety/kde-base/gentoo: Nett gemachtes Abbau-Spiel. Man spielt gegen die Uhr. Es geht darum, das Spielfeld so schnell wie möglich so leer wie möglich zu räumen. Das Spielfeld besteht aus farbigen Blocks. Wenn immer man auf eine Gruppe benachbarter Blocks derselben Farbe aus mindestens zwei Blocks klickt, verschwinden alle Blocks der Gruppe und die verbleibenden Blocks "sacken" in sich zusammen. Macht Spaß. Nachteil: Die Steine sind nur relativ klein und das Fenster hat eine fixe Größe. Das ist lästig auf einem Riesenschirm.
klines/kde-base/gentoo: 5-in-einer-Reihe einmal anders. Für den nächsten Zug werden drei neue farbige Kugeln am Spielfeld angekündigt, allerdings werden diese dann zufällig positioniert. Man kann bei jeden Zug eine Kugel zu jedem anderen beliebigen Punkt des Spielfeldes bewegen der auf freiem Weg erreichbar ist. Schafft man es so fünf oder mehr Kugeln in einer Reihe anzuordnen, verschwinden alle diese Kugeln. Es geht darum möglichst lange auszuhalten bevor das Spielfeld voll ist.
kmag-4.12.5/kde-base/gentoo: Eine hübsche und komfortabel benutzbare Bildschirm-Lupe. Es ist allerdings auch komplexer und hat weit mehr Optionen als xmag. Der wesentliche Unterschied von kmag gegenüber xmag ist jedoch, dass kmag die vergrößerte Ansicht (zumindest im Standard-Betriebsmodus; nicht habe mir nicht alle Optionen angesehen) ständig aktualisiert, während xmag nur einmalig einen Ausschnitt statisch vergrößert. kmag ist daher besser geeignet wenn man häufig verschiedene Bereiche des Bildschirms vergrößern muss, etwa weil man eine Sehbehinderung hat. Der Nachteil ist jedoch der deutlich höhere Ressourcenverbrauch, vor allen an Rechenleistung, während der Ausführung des Programms (zumindest wenn man den Cursor bewegt und der vergrößerte Ausschnitt des Bereichs um den Cursor herum daher aktualisiert werden muss).
kmail/kde-base/gentoo: Mail-Client für KDE. Kann eigentlich alles, ausser eines: Unerwünschte Attachments aus empfangenen Mails entfernen ohne deswegen die ganze Mail löschen zu müssen. Daher: Unbrauchbar.
kmilo/kde-base/gentoo: KMilo lets you use the special keys on some keyboards and laptops. Usually this includes volume keys and other features. KMilo is a service of kded, the kde daemon. Currently KMilo comes with plugins for powerbooks, vaios and generic keyboards with special keys.
kmines/kde-base/gentoo: Das klassische Minen-Such-Spiel. Auch dies bedarf keiner Erläuterung. Untadelig gemacht.
kmplayer/media-video/gentoo {media-player}: Kmplayer ist eine einfache Benutzeroberfläche für MPlayer, Xine und FFMpeg. Das Programm wird gebraucht zum Abspielen von Videodateien der von MPlayer/Xine unterstützten Formate, sowie zur Wiedergabe von DVDs, VCDs oder TV/Kamera. Eine eher sinnlose Angelegenheit, da Mplayer alleine bereits ein GUI mitbringt.
kmplot/kde-base/gentoo: Very nice made KDE function plotter. However, in a world where anyone uses gnuplot for that purpose, there is little use in installing it. But it is certainly the most user-friendly simple function plotter I have seen so far.
knemo/net-misc/gentoo: Highly sophisticated network monitor, by its own standards. Installs itself deeply into the heart of KDE. Mostly useless overhead, it seems. It also tends to hide its applet, and it's not easy to figure out how to get it back on screen. Better use a simpler monitoring tool like knetstats.
knetdockapp-0.67.5.3/kde-misc/gentoo: Another network I/O rate monitor. It displays a nice LCD-Lookalike in the context menu and can also open a window with a beautiful chart. But it cannot draw that chart into the docked app window where one can see it (only a color-coded symbol is rendered there), so it's a rather useless tool.
knetstats-1.6.1/kde-misc/gentoo: Simple Docklet monitor applet, displaying up/download rate of selectable interfaces as Symbol, Text or curve graph. Not very sophisticated, but it looks OK and does its job quite well.
knetwalk-4.4.5/kde-base/gentoo: Eines meiner Lieblingspuzzles. Man muss einen Server zu allen Workstations verbinden, wobei alle Kabel verwendet werden und aktiver Teil der Verbindungen sein müssen. Absolut süchtig machend. Vor allem gut zum "Zwischendurch"-Spielen, da eine Runde nur ca. 5 Minuten dauert. Auch nette Grafik. Riesennachteil: Benötigt einen großen Teil von KDE als installierte Abhängigkeiten, auch wenn es nicht unter KDE verwendet wird.
knewsticker-scripts/kde-base/gentoo: Sollte man installieren, wenn man auch kde-base/knewsticker installiert hat. Sonst völlig sinnlos.
knewsticker/kde-base/gentoo: Ähnlich wie akregator, zeigt die News jedoch als Laufschrift-Ticker an. Völlig ausreichend für gelegentliche Benutzung. Empfehlenswert zur Installation, wenn man überhaupt RSS-Feeds anzeigen will. Doch braucht das wirklich irgend jemand? Meiner Ansicht nach macht einen eine ständig scrollende Laufschrift nur sinnlos nervös. Nachrichten kann man ohnehin vergessen - da kommen ja permanent Updates. Wenn man also nicht gerade ein Broker ist der ständige Börsenkurs-Updates benötigt, braucht *kein Schwein* einen RSS-Feed! Und wenn schon, dann bitte mit einem crob-job prüfen, und nicht mit einem New-Ticker.
knode/kde-base/gentoo: Netter Newsreader (USENET-basiert) für KDE. Wem der kleine Newreader im Thunderbird nicht reicht, ist hiermit sicher gut bedient. Seit der Spam-Problematik werden Newreader aber zunehmend uninteressant, oder sind ohnehin Web-basierte Dienste.
knotes/kde-base/gentoo: "Post It" notes for the desktop. How braindead does one have to be in order to actually use something like that?
kobodeluxe-0.5.1-10/games/debian {game}: Ein Klon von "xkobo", übertrifft das Original aber in jeder Hinsicht. Ein 2D-Scroller (in alle 4 Richtungen). Man steuert ein Raumschiff und muss alle Festungen zerstören die es im aktuellen Level gibt. Die Festungen bestehen aus vielen Wänden und sind mit automatischen Geschützen verteidigt, die man alle zestören muss bis man überhaupt zum Zentralreaktor der Festungen durchdringen kann der die (Reste der) jeweiligen Festung dann bei seiner Zerstörung ebenfalls mit vernichtet. Es gibt verschiedene Arten von Geschützen und Geschossen die unterschiedliche Herausforderungen darstellen, darunter auch andere Raumschiffe die auf einen schießen. Gelegentlich kommt auch ein UFO daher das einen rammen will, man muss Meteoriten ausweichen und dergleichen. Es gibt viele Levels (zumindest 50), und sie scheinen sich zumindest bis dorthin entweder nicht zu wiederholen oder sind algorithmisch generiert. So oder so, sehr actionreich und mir schwerem Suchtfaktor ausgestattet (zumindest bei mir). Absolut empfehlenswert! Mit 1,6 MB Größe zudem auch ein ziemlich kleiner Platzbedarf (2,2 MB installiert), insbesondere wenn man den großen Unterhaltsungswert bedenkt. Es gibt auch eine N900-Version dieses Spiels wo man es durch Neigen des Phones steuern konnte. Leider gibt es keine Android-Version davon.
koctave/sci-mathematics/gentoo {programming language}: Ein "GUI", haha, das im wesentlichen aus einem Konsolenfenster besteht... aber hübsch im KDE-Look. Octave ist - eine Programmiersprache. So als hätte jemand FORTRAN nachprogrammiert, so wie die guten alten BASIC-Interpreter. Mit jeder Menge nützlicher Funktionen fest eingebaut. Matrizenberechnungen etwa. Kann man schön in die Kommandozeile eintippen. Irgendwie - wie FORTRAN als Interpreter. Wer's braucht... Aber zumindest soll es relativ stark "MatLab"-kompatibel sein. Ansonsten eine fade Sache, aber sicher nützlich wenn FORTRAN jemandem zu schwierig ist.
kodo-3.5.7/kde-base/gentoo: Zeigt Mausgeschwindigkeit und zurückgelegte Entfernung an. Sehr schön! Aber irgendwie vollkommen absolut sinnlos.
kolf/kde-base/gentoo: Minigolf-Spiel. Verwendet nach heutigen Maßstäben winzige, nicht skalierbare Pixelgrafiken. Nicht direkt schlecht, aber nach einmal durchspielen wird es schnell langweilig. Die Steuerung ist auch nicht besonders gut.
kolourpaint-4:20.12.0-1/graphics/debian kolourpaint/kde-base/gentoo: Ein simples Malprogramm ohne Extras; immerhin kann es alle Bildformate (inklusive etwaigem Alpha-Kanal) bearbeiten für die KDE I/O-Module bereit stellt; also recht viele. Man kann Text in einem rechteckigen Textrahmen eingeben, Linien ziehen, Freihändig zeichnen, einen Radiergummi benutzen, mit einem "Pinsel" malen (aus 12 fix vordefinierten Pinselformen auswählbar), Farbkübel (Flood Fill), "Farbradierer" (keine Ahnung was der Unterschied zum Radiergummi ist), Spraydose, abgerundetes Rechteck, Rechteck, Polygon, Ellipse, mehrere zusammenhängende Linien ziehen, einzelnes Bezier-Spline. Ein Klon-Pinsel fehlt. Man kann eine Farbähnlichkeit festlegen, so dass alle Operationen (etwa der Farbkübel) die ansonsten nur auf Pixel einer bestimmten Farbe (meist die aktuelle Vorder- oder Hintergrundfarbe) wirken dann auch auf solche mit ähnlicher Farbe wirken. All dies mit oder ohne Anti-Aliasing, mit wählbaren Linienstärken und Farben. Als aktuelle Vordergundfarbe kann man Transparenz oder 2 x 11 Farben direkt auswählen. 16 der Farben sind benutzerdefinierbar und können mit einem *richtigen* Farbauswahldialog redefiniert werden. In diesem Dialog gibt es ferner 48 vordefinierte Farben zur Schnellauswahl. Die aktuelle Hintergrundfarbe kann nur durch Vertauschen mit der aktuellen Vordergrundfarbe festgelegt werden, wozu es einen Button aber kein Tastenkürzel gibt. Es gibt eine freihändige, rechteckige und elliptische Auswahl und 2 Auswahl-Modi: Transparent oder deckend. Die ausgewählten Bildbereiche können entweder direkt mit der Maus verschoben werden, skaliert, gedreht (in 90, 180 oder 1 Grad Schritten) oder gespiegelt. Ebenso können sie ausgeschnitten und wieder als schwebende Auswahl eingefügt werden. Mit der [Entf]-Taste kann der umrahmte Inhalt einfach gelöscht (durch Hintergrundfarbe ersetzt) werden. Weiters kann man die gesamte Grafik auf die Auswahl beschneiden. Es gibt einige Effekte, die auf Bild oder Auswahl angewendet werden können: Helligkeit, Kontrast, Gamma, Relief, Tint, Equalizer, Farbton, Sättigung, Farbreduktion (256 Farben, S/W), Scharf- sowie Weichzeichner. Mehrstufiges Undo/Redo wird unterstützt. Was das Programm nicht beherrscht sind jegliche Vektor-Operationen, Ebenen, Kanaltrennung. TIFF-Bilder können mit LZW-Komprimierung geladen werden; beim speichern werden sie jedoch unkomprimiert gespeichert. Ein simples Malprogramm, mit dem man aber bereits einiges tun kann ohne GIMP bemühen zu müssen. Mit 6 MB Download und 10 MB installiert leider nicht gerade schlank für seinen eher überschaubaren Funktionsumfang. Es ist allerdings deutlich einfacher zu benutzen als das viel schlankere und ansonsten eher mächtigere mtpaint. Dieses sollte man auch deshalb zusätzlich behalten, da er im Gegensatz zu kolourpaint einen Klonpinsel, ein Gradienten-Mal-Werkzeug sowie ein Verwisch-Werkzeug und Ebenen verfügt.
komi-1.04-5+b2/games/debian {game}: Man steuert Komi, den Weltraum-Frosch, in einem Galaga-ähnlichen Bildschirm-Setup. Man bleibt immer am unteren Rand und kann sich nur links/rechts bewegen, während am restlichen Bildschirm Feinde herumfliegen die einen bei Berührung vernichten. Anders als bei Galaga schließt man hier aber nichts ab, sondern muss alle gelben Objehte mit der Zunge des Frosches einfangen und fressen bis das Level von diesen Objekten geräumt ist. Dann kommt das nächste Level. Grundsätzlich nicht schlecht, aber erstens ziemlich schwer. Die Grafik ist nicht direkt hässlich, aber sehr schlicht. Es gibt nur eine fixe Auflösung, so dass das Spiel nur ein eher kleines Fenster füllt, oder man schaltet in den Full-Screen Modus. Dann hat man zwar das Größenproblem nicht mehr, dafür werden die Pixel aber unschön grob. Alles in allem ein tolerables Spiel, aber etwas zu schwer und auch grafisch nicht besonders berauschend.
kompare/kde-base/gentoo {text-diff}{no-soft-line-wrap}{text-merge}: Einfach zu verstehendes grafisches Tool für 2 Dateien oder Verzeichnisbäume. Dennoch optisch sehr gut umgesetzt. Der sicherlich einfachst zu benutzende und intuitivste Diff-Viewer für KDE. Für all jene Fälle, wo kdiff3 ein Overkill wäre. Ausserdem spart man beim simplen kompare das Studium des Handbuchs. Überdies kann man "kompare" mit der Option "-o" aufrufen und einen Patch als Argument angeben. Dessen Inhalt wird vom "kompare" grafisch so dargestellt als hätte es gerade selbst zwei Dateien verglichen und der Patch wäre dabei das Ergbnis gewesen, obwohl es tatsächlich überhaupt nichts selbst verglichen hat.
konquest/kde-base/gentoo {game}: Planeten-Eroberungsspiel; nur Icon-Grafik. Das übliche: Man schickt seine Schiffe von/zu Planeten und sie erobern diese oder nicht. Gähn. Aber ganz OK gemacht; eigentlich kann man nichts am Spiel aussetzen ausser dass es *stinklangweilig* ist. Aber das ist natürlich eine rein subjektive Wertung meinerseits, die sicher nicht alle teilen werden.
konquest/kde-base/gentoo: Ein fades Planeten-Eroberungsspiel nach den üblichen Schema: Schicke X Schiffe von Planet Y nach Planet Z. Dort werden sie entweder siegreich sein oder nicht. Und so geht das weiter bis man einschläft. Reine Symbolgrafik. Nichts los. Gähn.
konsole-4.4.5/kde-base/gentoo {terminal emulator}{Qt}: Der X11 Terminal-Emulator von KDE. Extrem mächtig. Extrem fett. Braucht subjektive Ewigkeiten um zu starten und wirkt nicht gerade ressourcensparend. Dafür spielt er aber auch wirklich alle Stückerl... alle sinnlosen Grafik-Blödheiten für verspielte Teenies finden sich hier. Themes, Transparenz, Tabs, alles. Nur für Leute interessant, die KDE benutzen. Und selbst die sollten sich überlegen ob es nicht auch etwas schlankeres gibt.
konsolekalendar/kde-base/gentoo {PIM}: Access the korganizer calender from the command line. Only useful if korganizer is also installed.
kontact/kde-base/gentoo {PIM}: KDE's personal information manager. This is mostly a shell for accessing individual other KDE applications, such as kaddressbook, korganizer etc. Not necessary on its own, but nice to integrate the features of the other PIM-related KDE applications.
kopete/kde-base/gentoo: Der beste Instant-Messaging Client für KDE. Unterstützt ICQ, AIM, Jabber, MSN - was halt so "wichtig" ist. Wer noch zu jung für IRC ist, braucht so etwas.
korganizer/kde-base/gentoo {PIM}: KDE's calendar/"to do"-list component. Also integrates with kpilot for synchronizing with a PalmOS PDA.
kphotoalbum-2.2/media-gfx/gentoo {graphics image viewer}: a.k.a. as "kimdaba". No functionality to modify images (except via external plugins), but powerful ways to organize them "by reference", i. e. via an XML file. This means it never touches the image files themselves and saves all its information in a single, separate file. It can therefore also organize images on read-only media. Identifies image files by hash value if file name or location changes. Also supports offline-storage of images, only displaying thumbnails in those cases. Multiple fully customizable keyword hierarchies. Set-based keyword assignment. Disadvantages: No database, loading and saving the XML file takes bloody ages for large collections (but it works). When turning keywords into group identifiers, somewhat flawed behavior. Keyword assignments can then be lost if the user is not very careful. Uses KDE's intrinsic JPEG-2000 support - rotten slow.
kpilot/kde-base/gentoo {PIM}: KDE-based data synchronizer and desktop application for PalmOS-based PDA devices. Can synchronize data with kontact-applications such as kaddressbook or korganizer. Looks nicer, but did not work as well as jpilot - at least for me. It is also much more bloated. If you just need a desktop interface for your PalmOS device, jpilot is all you need and kpilot seems to be overkill. Of course, this will be different if you also want use the kontact applications on their own.
kplato/app-office/gentoo: Eine Projekt-Management-Anwendung ähnlich MS Project. Nicht übermäßig toll in den Möglichkeiten, kann aber zumindest alles was man zumindest erwarten kann. Und da es unter Linux in dieser Kategorie bislang nichts anderes zu geben scheint, fällt die Wahl nicht schwer.
kpresenter-1.6.3/app-office/gentoo: Ein sehr einfach zu benutzendes Folien-Präsentationsprogramm a la Powerpoint für KDE. Kann auch andere KDE-Objekte wie Diagramme importieren. Folien, Vorlagen, Übergänge - alles vorhanden. Und sicherlich Ressourcenschonender als OpenOffice Impress. Andererseits kann es sicherlich nicht mehr als Impress, und es hat wohl wenig Sinn beides am selben Rechner zu installieren. Auch ist die PowerPoint-Kompatibilität von Impress sicherlich besser. Für Neulinge dürfte kpresenter aber einfacher zu benutzen sein.
krdc-3.5.5/kde-base/gentoo: Ein voll integrierter TightVNC-Client für KDE. Angenehm: Das KDE Wallet kann für Passwörter verwendet werden; außerdem das KDE-Look-And-Feed. Nachteil: Man kann keine expliziten Compression-Settings angeben wie beim echten TightVNC-Client, sondern nur Wischiwaschi-Angaben wie "low quality", "medium quality" etc. die alles mögliche bedeuten können und einem somit die wichtige Kontrolle über die Kompressionsparameter entziehen.
krec/kde-base/gentoo {audio}: Sound-Recorder für KDE. Arbeitet eng mit aRts zusammen. Bietet diverse Regler zum Einstellen der Pegel. Aber nichts besonders. Ausserdem speichert er seine Dateien in einem eigenen Format und man muss sie erst nach wav, mp3 oder ähnlichen Formaten exportieren.
kreversi/kde-base/gentoo {game}: Das klassische Othello/Reversi. Was muss man noch sagen? Ein Spiel das man immer zur Hand haben sollte. Leider hat auch dieses KDE-Spiel eine fixe Fenstergröße, die in diesem Fall zwar wohl ausreichend ist, aber einen auf Riesenschirmen wohl zur Verzweiflung treiben kann.
krfb-3.5.5/kde-base/gentoo {KVM sharing}{Qt}: Ein in KDE integrierter TightVNC-Server für X11. Erlaubt es Einladungen auszusprechen, Passworte zu vergeben etc. Sicher super wenn man jemanden fremden auf seinen Rechner "einladen" will. Für Admins hingegen nichts als sinnloser Overhead; ein x11vnc oder echter TightVNC-Server tut's genau so oder besser.
krita-1.6.3/app-office/gentoo {bitmap image editor}: Der vermutlich einfachst zu erlernende und zu benutzende aber gleichzeitig ausreichend mächtiger pixelbasierter Grafikeditor für KDE. Keine überflüssigen Features wie Vektorobjekte, aber alles was man erwartet. Allerdings werden nur eigene und keine KIPI- oder GIMP-Plugins unterstützt. Arbeitet auch mit Ebenen und Alpha-Masken. Farbmanagement. RGB/Druckfarben/Graustufenbilder. Von Palettenfarben bis zu 32-Bit-Fließkomma pro Farbkomponente jedes Pixels wird alles geboten. Übertrifft in dieser Hinsicht GIMP. GIMP hat allerdings viel mehr Funktionen. Krita ist des weiteren nach eigener Aussage mehr aufs Malen ausgelegt, und GIMP mehr auf Nachbearbeitung existierender Bilder.
krusader-2:2.8.0-1/kde/raspbian krusader-2:2.7.2-2/utils/debian krusader-2.0.0/kde-misc/gentoo {file manager}{Qt}{dirtree sync}: Ein ziemlich umfangreicher Nachbau des von Windows bekannten "Total Commanders", also ein zweigeteilter Dateimanager in der Tradition des Norton-Commanders. Sehr umfangreiche Funktionen durch zahlreiche Plugins. Sehr mächtiges Synchronisationsfeature für zwei Verzeichnisbäume das fast alles bietet was der TC auch kann (außer erkennen von Dateien mit identischem Inhalt trotz verschiedener Namen). Gute Editor-Komponente mit Syntax-Highlighting, Folding, Soft Line-Wrapping. Ebenso Mehrfachumbenennung via krename. Mit dem "Eigenschaften"-Dialog von Dateien können neben Anzeige und Änderung des zugeordneten Dateityps auch die Berechtigungen der Datei (inklusive POSIX-ACLs falls vom Dateisystem unterstützt) und Besitzer/Gruppe geändert werden. Weiters ist es möglich die folgenden Prüfsummen über den Dateiinhalt zu berechnen und optional in die Zwischenablage zu kopieren: MD5, SHA-1, SHA2-256, SHA2-512. Man kann auch eine gegebene Prüfsumme in ein Textfeld kopieren, und des wird dann angezeigt ob sie mit der tatsächlichen übereinstimmt.
ksame/kde-base/gentoo {game}: Praktisch dasselbe Spiel wie klickety, nur ohne das Zeitlimit und mit Kugeln anstatt quadratischer Felder. Auch verschwinden die Kugelgruppen sofort beim Anklicken; es gibt keine Animation des Verschwindens; nur des Zusammensackens. Auch dieses Spiel läuft in einem Fenster fixer Größe. Allerdings sind die Kugeln von Haus aus deutlich größer als die Quadrate bei klickety, weshab dieses Spiel auf einem großen Schirm besser spielbar ist. Hoher Suchtfaktor; kann auch rein zur Entspannung gespielt werden.
kscd/kde-base/gentoo {media-player}: CD Player für KDE. Mit CDDB-Support und den üblichen Spielchen. Durchaus nett gemacht. Wer allerdings braucht in Zeiten wo jedes Medienwiedergabeprogramm (etwa VLC) auch CD-Abspielsupport bietet noch einen separaten CD-Player?
ksensors/kde-misc/gentoo {resource monitor}: KDE docklet GUI for "LM sensors" motherboard sensors project. I cannot say much about it as my lm_sensors package is not yet configured properly.
ksh/app-shells/gentoo: Korn shell, usually version 1993. The 1988 version was the basis of the POSIX standard, but there are differences between the versions. Has many features of bash and has an even larger executable than bash. Unfortunately, it does not support a "local" builtin. But then, the original Bourne shell also did not. So, ksh is very standard-compliant. But unfortunately it does behave differtly from BusyBox' ash, bash or dash at times, which means ksh scripts will not run on many Linux default shells unless they carefully avoid very useful features like "local". In any case, ksh is good at testing scripts for rather strict POSIX compliance.
ksig-3.5.7/kde-base/gentoo: Ein "Signatur"-Editor für KDE. Wird wohl nur zusammen mit KDE und kmail Sinn machen.
ksirc/kde-base/gentoo {chat}: Netter IRC-Client für KDE. Wer einen Firefox verwendet, wird aber vermutlich eher das IRC-Plugin des FF verwenden. Zwar ist ksirc sicherlich ressourcensparender als ein FF mit IRC Plugin. Aber wenn der FF ohnehin ständig läuft, bringt das natürlich nichts.
ksirtet/kde-base/gentoo {game}: Das ganz klassische Tetris-Spiel. Ein Originalgetreu. Der bislang einzige Klon den ich unter KDE fand und mich zufrieden stellte. Einziger Kritikpunkt auch hier wieder die fixe Größe des Fensters das für hohe Auflösungen sehr winzig wirkt. Aber es reicht gerade noch. Leider immer noch die beste Tetris-Version soweit.
ksmiletris/kde-base/gentoo {game}: Tetris-Variante mit Smileys. Kein vergrößerbares Fenster. Nichts besonderes.
ksnake/kde-base/gentoo {game}: Das klassische an TRON angelehnte Spiel, wo eine Schlange immer länger wird je mehr sie frisst, und sie darf weder in eine Wand, noch in sich selbst noch mit der computergesteuerten Gegener-Schlange zusammenstoßen. Nett gemacht, obwohl die Schritte in denen die Schlange sich bewegt etwas zu klein sind als dass man sie einfach zielsicher steuern könnte.
ksnip-1.8.0-2/graphics/debian {bitmap image editor}: Ein in Qt verfasstes Programm das schnell startet und zum Annotieren von Screenshots gedacht ist. Es kann auch selbst als Bildschirm-Schnappschüsse aufnehmen. Es bietet nur die Bildformate PNG, JPEG und BMP beim Speichern und Laden an. Tatsächlich kann es aber viel mehr Formate zumindest Laden, etwa TIFF. Ärgerlich ist der Umstand dass sich der "Öffnen"-Dialog nicht das letzte Verzeichns merkt. Am besten daher man startet das Programm über den Dateimanager direkt zum Öffnen einer Bilddatei. Immerhin merkt er sich zumindest der "Speichern"-Dialog das letzte Verzeichnis. Man kann Pfeile, Doppelpfeile und Striche erstellen. Es gibt einen Leuchtstift, mit dem man mit Rechtecken, Ellipsen oder Freihandlinien markieren kann. Dasselbe gibt es auch als normale Stifte ohne "Marker"-Optik. Linienbreite und Farbe können festgelegt werdem. Der Farbauswahl-Dialog bietet 11 vordefinierte Farben sowie einen *ernsthaften* Farbauswahldialog wo man beliebige Farben auswählen kann. Man kann Smileys auf die Leinwand kleben. Man kann eine Serie automatisch nummerierte Scheiben setzen - etwa für Fortschritts-Anweisungen. Es gibt eine Variante davon welche zusätzlich ein Dreieck aus der Kugel stülpt den man als eine Art Pfeil-Ersatz nutzen kann.  Schließlich gibt es auch automatisch erzeugte Nummern (ohne Scheibe) mit einem echten Pfeil zum damit auf Etwas deuten. Diese drei Möglichkeiten gibt es auch für selbst eingegebenen Text anstatt einer automatisch hochzählenden Nummer. Man kann rechteckige Bereiche verpixeln oder unscharf machen. Man kann Text mit oder ohne Umrahnung und Füllung erstellen, jedoch immer nur eine Zeile pro Textobjekt. Man kann zwar Farbe, Größe usw. aller Textobjekte individuell ändern, jedoch verwenden alle dieselbe Schriftart welche man nur global im Programm einstellen kann. All diese Funktionen erzeugen schwebende Vektorobjekte, welche beim Abspeichern mit dem Bildinhalt vereinigt werden. Doch solange das Bild nicht geschlossen wird, kann man die Objekte weiterhin verändern und manipulieren. Man kann das ganze Bild zuschneiden und skalieren. Es gibt eine "Hochladen"-Funktion, wo das Bild auf irgend eine Webseite hochgeladen wird wo man sicherlich irgendwelche "tollen" Social-Media-Dinge damit aufführen könnte. Ich hatte keine Ahnung wie man das Bild von dort wieder löscht! Allerdings hoffe ich, das geschieht automatisch nach einiger Zeit da ich keinen Account oder dergleichen dort hatte. Was es nicht gibt, sind Effekte (abgesehen von den erwähnten) oder Filter. Invertieren, Aufhellen, Farben ändern - nicht mit diesem Programm. Mit rund 350 kB Download-Größe ist es aber auch kein großes Programm.
ksokoban/kde-base/gentoo {game}: Ein grafisch schön gemachter Sokoban-Klon. Auch schöner als easysok. Allerdings fehlt ihm im Gegensatz zu letzterem ein Solver, der Lösungen sucht wenn der Spieler keine mehr findet. Ein schweres Versäumnis! Allerdings gibt es separate Solver im Internet zu finden inklusive auf neuronalen Netzen basierenden, und *keiner* von denen kann alle Levels (zumindest nicht von der Internet Testsuite) lösen. Es gibt übrigens ein standardisiertes Textformat zur Beschreibung von Sokoban-Levels sowie auch für Lösungen. (Keine Ahnung ob *diese* Sokoban-Version etwas damit anfangen könnte.)
kspaceduel/kde-base/gentoo {game}: Zwei Gegener kreisen um eine Sonne, drehen sich beschleunigen (alles 2D), beballern sich, legen Minen und schnappen sich Goodies wie Energie oder Schilde. Zu zweit, gegen den Computer oder Computer gegen sich selbst. Nett gemacht.
kspread-1.6.2/app-office/gentoo: Sehr nett gemachtes resourcensparendes Tabellenkalkulation für KDE. Für sich allein völlig ausreichend. Aber im Vergleich zu OpenOffice Calc kann es bei weitem nicht mithalten. So hat es etwa keinen Solver und auch sonst wesentlich weniger Features. Aber es ist deutlich schlanker.
kstars/kde-base/gentoo: Sterne, Sternbilder, Planeten, Konstellationen etc. Nett gemacht. Allerdings, da es mit Celestia ein sehr viel besseres derartiges Programm gibt, ist fraglich wofür man es brauchen sollte. Ein Unterschied ist, dass kstars immer alles nur vom Standpunkt Erde aus anzeigt und diese Anzeige entsprechend optimiert ist, während man bei Celestia typischerweise selbst durch das Weltall reist.
ksysguard-4 {resource monitor}{Qt}: 5.14.5-1/utils/debian: Ein Prozess-Monitor, Task-Manager und KDE-Gegenstück zum gnome-system-monitor von GNOME. Das Programm selbst nennt sich dabei "Systemmonitor". Er bietet nur Prozessanzeige und Performance-Graphen per Voreinstellung, letztere sehr ähnlich aber weniger hübsch als beim GNOME-Gegenstück. An Funktionen steht hier pro Prozess das Senden einer beschränkten Auswahl der wichtigsten Signale zur Verfügung. Weiters das Setzen von "Priorität" (wobei unklar ist ob dies die Niceness ist oder tatsächlich die Priorität), der Prioritätsklasse (Round-Robin, FIFO, etc) und auch der I/O-Priorität und -klasse. Man kann zum Elternprozess in der Liste springen. Oder das Fenster des zugehörigen Programms nach oben holen. Dazu passend gibt es bei den angezeigten Spalten auch den Fenstertitel. Die Kommandozeilenargumente des Aufrufs kann man sich ebenfalls in einer Spalte anzeigen lassen. Eine Anzeige der Dateisysteme fehlt, und auch die Anpassungsmöglichkeiten der Prozessanzeige sind etwas geringer. Die große Stärke des Programms liegt aber darin neben den beiden erwähnten vorkonfektionierten Tabs noch beliebige weitere benutzerdefinierte hinzu fügen zu können die andere Datenquellen (im Programm "Sensoren" genannt) anzeigen können. Diese "Arbeitsblätter" genannten Tabs lassen sich auch abspeichern und exportieren bzw. auf anderen Maschinen wieder reimportieren. Grundsätzlich muss man für jedes Arbeitsblatt zunächst einmal die Anzahl der Spalten und Zeilen festlegen - die Sensoren werden als Matrix angeordnet. Danach zieht man dann mit der Maus aus einer Liste aller verfügbaren Sensoren einen auf einen noch freien Platz in der Matrix und wählt dann einen Diagrammtyp aus: Liniendiagramm, Balkendiagramm, Digitalanzeige, in Datei protokollieren. In die ersten beiden Typen von Diagramm kann man auch mehrere Sensoren ziehen, sie dann neben bzw. übereinander dargestellt werden. Beim letzten Typ kann man ein Intervall und einen Dateinamen angeben, und die entsprechenden Werte werden dann, zusammen mit Datum, Uhrzeit, Rechnername und Sensorname als Zeilen zur gewählten Logdatei hinzu gefügt. Man muss die Protokollierung aber explizit starten und stoppen - sie beginnt nicht sofort. Man kann sogar Schwellwerte für Warnungen bei festlegen (seltsamer Weise nicht immer, scheint auf bestimmte Diagrammtypen oder Sensoren beschränkt zu sein), die beim Unter bzw. Überschreiten ausgelöst werden. Doch alle wunderbare Anpassbarkeit ändert nichts daran, dass es keinen brauchbaren Ersatz für die Anzeige der Dateisysteme des gnome-system-monitor gibt. Und das obwohl man sehr wohl diese "Sensoren" zur Verfügung hat! Nur, wer hat schon Lust 20 Dateisysteme in eben so viele Zeilen des Arbeitsblattes zu ziehen und dann für jedes einzelne dieselben Einstellungen zu tätigen. Zumal je ständig dynamisch weitere Dateisysteme hinzu gemountet werden oder wieder ungemountet werden könnten. Unbrauchbar! Man kann mit dem Programm auch entfernte Rechner überwachen, indem dort ein "ksysguardd"-Agent gestartet/abgefragt wird. SSH wird dabei unterstützt. Was die Anzeige der Prozesse angeht, sind vor allem die Detailinfos recht interessant die für einzelne Prozesse angezeigt werden kann: Neben den üblichen Angaben auch eine Memory-Map des Adressraums, eine Auflistung der geöffneten Dateien des Prozesses sowie eine Liste der geladenen Libraries. Ergänzt wird das ganze durch eine sehr ausführlich erklärte Zusammenfassung der verschiedenen Arten von Speicher (Shared, Private usw.) die dem Prozess zugeordnet sind. Darunter auch die für eine faire Beurteilung des Speicherverbrauchs wichtige "Proportional Set Size", welche den Anteil des gemeinsam benutzten Speichers durch die Anzahl der nutzenden Prozesse dividiert. Sobald man seine Arbeitsblätter wohlgefällig definiert hat, kann man die Liste der Sensoren verkleinern bis sie verschwindet und das Programm dann beenden. Es speichert die neu erstellten Einstellungen automatisch, so dass die zusätzlichen Tabs fortan stets zur Verfügung stehen. Für KDE-Verhältnisse ist das Programm sogar ziemlich schlank: 750 kB installiert, 200 kB Download. Allerdings natürlich zusätzlich zu den bereits vorhandenen KDE- und Qt-Libraries. RAM-Verbrauch: 120 MB. Heftig. Das ist gut 4 x so viel wie der gnome-system-monitor oder der xfce4-taskmanager!
ksystemlog-4.11.5/kde-base/gentoo: Ein Systemprotokollbetrachter und das KDE-Gegenstück zu gnome-system-log. Leider hat es im Gegensatz zu letzterem den Nachteil, dass es in der Defaultkonfiguration mit vielen vorkonfigurierten Log-Dateien daher kommt, deren Namen alle falsch sein können und man hat danach viel Aufwand alles wieder richtig zu stellen. Ein weiterer Nachteil ist dass das User-Interface für diese vielen vorkonfigurierten Log-Dateien auch noch mit vielen Buttons daher kommt was unübersichtlich wirkt. Ein Vorteil des Progamms ist hingegen dass es über eine Vielzahl spezialisierterer Parser für einzelne Log-Dateitypen daher kommt, was zumindest in der Theorie ein Vorteil ist. Praktisch scheint der Mehrwert gering und der höhere Konfigurationsaufwand störend.
ktalkd-3.5.7/kde-base/gentoo: "KTalkd ist ein erweiterter talk-Dämon [...] wurde konzipiert für einen Ein-Benutzerarbeitsplatz und sollte nicht auf einem Mehr-Benutzercomputer verwendet werden [...] kann man den talk-Dämon veranlassen, jeden beliebigen Befehl auszuführen." Noch Fragen?
kteatime/kde-base/gentoo: Eine Art Eieruhr für KDE, nur eben für Tee. Wer ständig Tee säuft mag es gebrauchen können, sonst wohl kaum jemand. Zumal es allgemeinere Timer-Programme für KDE gibt.
ktimer/kde-base/gentoo {service manager}: GUI for scheduling commands to be run after a certain number of seconds as delay. Rather useless, because for simple tasks "sleep" can do the same, and for more complex tasks cron is available.
ktnef/kde-base/gentoo: Unnötiges Programm zum Anzeigen von unnötigen MS-spezifischen e-Mails im nicht minder unnötigen KTNEF-Format. Wird leider von korganizer als Abhängigkeit gebraucht.
ktouch-4.11.5/kde-base/gentoo: Sehr nett gemachtes, gelungenes  Maschinschreib-Lernprogramm für KDE. Ein komplett ausgearbeiteter Lehrkurs. Wer das 10-Finger-System erlernen will, ist hiermit sicher gut bedient.
ktron/kde-base/gentoo: Das gute alte TRON. Völlig schlicht ohne jeden grafischen Schnickschnack. Einfach eine blaue und eine rote Spur.
kturtle/kde-base/gentoo: Eine LOGO-"Entwicklungsumgebung" komplett in Deutsch. Sicher gut geeignet für 2-jährige die noch sabbern. OK gemacht, aber im wesentlichen ein Text-Interface. Ohne die Anleitung kommt man nicht weit. Dafür hat man aber natürlich immer die "Turtle" am Schirm.
ktux/kde-base/gentoo: Ein besonders ressourcenfressender Bildschirmschoner mit vielen Grafiken von einem Pinguin der in einem Raumfahrzeug kreuz und quer den Bildschirm durchpflügt. Eher sinnlos und sieht auch nicht besonders großartig aus. Zwar nicht schlecht - aber es gibt bessere Bildschirmschoner.
kugar-1.6.2/app-office/gentoo: Report-Generator für KDE. KPart. Soweit keine speziellen Plugins dafür implementiert werden, holt es Daten und Report-Definition aus XML-Dateien und stellt sie dar. Grafischer Report Designer und Previewer. Beliebig (?) viele Gruppenebenen, Header, Footer. Beherrscht aber keine Sub-Reports. Daher nett aber unbrauchbar ausser im jenen simplen Fällen wo man ohne Subreports auskommt.
kuickshow-3.5.7/kde-base/gentoo {graphics image viewer}: Simpler, aber sehr schneller Bildbetrachter und Bild-Verzeichnis-Browser. Kann kein JPEG-2000. Kontrast, Gamma, Helligkeit, 90-Grad-Rotationen, Spiegelung und Zoom können mit standardmäßig im Vollbildmodus mit der Tastatur oder Kontextmenü bedient werden. Kann auch Diashow und Drucken. Keine KIPI-Plugins. Nachteil: Reiner Betrachter - zum Organisieren unbrauchbar. Eigenständig - nicht als Anzeigemodul in Konqueror verwendbar.
kuser-3.5.7/kde-base/gentoo: Hübscher KDE GUI-Editor zum anlegen und verwalten von UNIX User- und Group-Accounts. Allerdings wohl etwas sinnlos; sowas macht man doch nun wirklich aus der Kommandozeile!
kview-3.5.7/kde-base/gentoo {graphics image viewer}: Noch simplerer Bildbetrachter als kuickshow. Kann nichts anderes als Bilder anzeigen. Verwendet dazu die in den kde-base/kdelibs eingebauten Bildformate; somit kennt er auch die krötenlangsame JPEG-2000 Implementierung. Auch kann er Dia-Show, Zoomen und 90-Grad-Rotieren. Aber er kann nicht: Vollbild-Zoom, KIPI-Plugins, Kontrast/Helligkeit oder sonstige Nachbearbeitungsfunktionen. Einfach nur primitiv. Einziges Plus: Kann dem Konqueror als ein Bildbetrachter dienen.
kvoctrain/kde-base/gentoo: Guter KDE Vokabeltrainer. Unterstützt alle möglichen Lernmode. Gut für Sprachschüler.
kwallet-4.11.5/kde-base/gentoo {security}: Ein Passwort-Safe und das KDE-Gegenstück zu Seahorse von GNOME. Es ist dazu gedacht, dass KDE-Programme sich direkt die Passwörter aus diesem Safe holen können, und man kann einstellen ob dazu eine Nachfrage nötig sein soll oder nicht. Außerdem werden die Zugriffe protokolliert. KWallet speichert im Wesentlichen eine Ordnerstruktur mit Schlüssel-Wert-Paaren in den Blättern, wobei es als spezialfälle "Passwords" gibt die dasselbe sind nur dass es keinen Schlüsselnamen und nur einen Wert - dann als Passwort interpretiert - gibt. Im Gegensatz zu Seahorse ist hier immer vorgesehen dass man das Wallet durch Passworteingabe vor der ersten Nutzung entsperren muss - es gibt kein automatisches Verwenden des (meist relativ schwachen) Login-Passworts zu diesem Zweck. Des weiteren gibt es standardmäßig zwei Wallets pro User, wenngleich man bei bedarf beliebig viele anlegen kann, und das zweite Wallet ist für sensitivere Daten (Online-Banking usw.) gedacht als die Alltagspassworte die man im Haupt-Wallet speichert. Es gibt mehrere Einstellungsmöglichkeiten wann das Wallet geöffnet werden soll und wann bzw. unter welchen Umständen es wieder geschlossen werden soll. Insgesamt macht KWallet einen wesentlich durchdachteren Eindruck als Seahorse. Erfreulich auch dass es nicht AES sondern das vertrauenswürdigere Blowfish zur Verschlüsselung einsetzt (allerdings nur mit 156 Bit Schlüsselstärke - doch das sollte stark genug sein). Ein Nachteil ist dass das Passwort scheinbar ohne Salt direkt mit SHA-1 gehashed und als Schlüssel verwendet wird, womit Rainbow-Table-Angriffe auf zu kurze Passwörter möglich werden. Dieses Manko sollte sich allerdings in der Praxis dadurch umschiffen lassen indem man KWallet nicht als Primären Passwort-Manager verwendet, sondern nur als zusätzlichen. Und ein sehr langes Zufallspasswort als Passwort für Kwallet verwendet, das man selbst wiederum dem anderen (und besseren) Passwort-Manager (etwa KeePassX) entnommen hat.
kwin4/kde-base/gentoo: Vier-in-einer-Reihe. Nichts technisch daran auszusetzen, nur eben total sinnlos.
kword-1.6.3-r1/app-office/gentoo: Kombiniertes Textverarbeitung und DTP-Programm für KDE. Rahmenbasiert. Beherrscht nicht so viele DTP-bezogene Funktionen wie Scribus, ist dafür aber ein vollwertiges Textverarbeitungsprogramm mit Serienbrieffunktion, Tabellen etc. und hat auch kein Problem mit langen Texten. Wer allerdings OpenOffice und Scribus installiert hat, wird kword kaum mehr brauchen. Für sich alleine ist es aber wesentlich ressourcenschonender als die beiden anderen.
kwordquiz-4.11.5/kde-base/gentoo: Wirkt wie ein Vorgänger von kde-base/parley, kann nur ein Subset davon und wirkt umständlicher in der Bedienung (längere Wege mit der Maus zurück zu legen). Der Rest der Funktionalität scheint gleich zu sein.
kwordquiz/kde-base/gentoo: Ein extrem simples 1:1 Frage-Antwort-Programm. Kommt nicht an kvoctrain heran, ist aber auch weniger für Vokabel als allgemeines Wissens-Fragen gedacht. Ebenfalls voll selbst konfigurierbar. Diverse Modi. Wenn man irgend welche Fakten schnell auswendig lernen muss, sicher nicht schlecht.
kworldclock/kde-base/gentoo: Zeigt eine quadratisch projizierte Weltkarte an mit winzigen Kästchen. Bewegt man die Maus darüber, wird der Name des Ortes und die dortige Lokalzeit und Zeitzonen-Info eingeblendet. Schwachsinnig wegen der winzigen Kästchen die keinerlei Übersicht bieten.
kwrite-4.11.5/kde-base/gentoo kwrite-4:20.12.2-1/editors/raspbian {text-editor}{Qt}: Abgespeckte Version von Kate, die früher Teil desselben Pakets war doch nun eine separates Paket wurde. Kwrite ist das KDE-Gegenstück zu gedit. Allerdings stimmt diese Analogie nicht ganz, da gedit mehrere Dokumente in Tabs geöffnet haben kann - während Kwrite ein Single-Document Editor ist. So gesehen ist Gedit eher ein Zwischending zwischen Kwrite und Kate - mächtiger als Kwrite doch weniger mächtig als Kate. Einen Vorteil hat Kwrite gegenüber Gedit jedoch: Das Programm kommt mit längeren Textdateien wesentlich besser zurecht, insbesondere wenn dynamische Zeilenumbrüche verwendet werden. Zwar scheint auch Kwrite hier Performance-Probleme zu geben da es ein Setting gibt mit dem man die maximale Zeilenlänge (eigentlich: Paragrafen-Länge) begrenzen kann. Doch selbst wenn man dies auf 0 stellt und damit unbegrenzt lange Paragrafen erlaubt, ist Kwrite immer noch schneller als Gedit. Ein interessantes Feature ist auch, Leerzeichen nur am Zeilenende sichtbar zu machen, wo sie meist irrtümlich vorhanden sind. Wenn diese Funktion nur nicht einen großen Nachteil hätte: Diese Markierung erscheint auch während des Tippens - und erscheint daher sobald man am Ende der Zeile ein Leerzeichen eintippt, verschwindet jedoch sofort nachdem man weiter tippt. Dadurch entsteht ein "Blink-Effekt" der einem nach kurzer Zeit sehr auf die Nerven geht so dass man die Funktion wieder abschaltet. Ein ärgerlicher Bug der oben genannten neuesten Version ist es auch, dass man die Anzeige-Markierungen für dynamischen Zeilenumbruch nicht zum Verschwinden bringen kann, obwohl es dafür eine Option gibt. Aber diese tut einfach nichts. Bzw. wird immer wieder von selbst auf "Markierungen sichtbar" zurückgesetzt. Der Mauszeiger wird versteckt sobald man zu tippen beginnt und sich dieser gerade über dem Text befindet. Sobald man den Mauszeiger bewegt, erscheint er sofort wieder. Das ist hilfreich, damit der Mauszeiger nicht den jene Stelle verdecken kann an der man gerade tippt; das ist häufig der Fall nachdem man etwas mit der Maus markiert hat. Insgesamt hat sie viel getan bei kwrite gegenüber früheren Versionen - es ist nun ein ausgezeichneter und komfortabler Texteditor geworden, der auch mit sehr großen Dateien (wie *dieser* hier...) zurecht kommt und kaum Wünsche offen lässt. Wenn es nur nicht so fett wäre: 148 MB RAM für eine einzelne offene Datei ist schon happig! Es ist damit das nach derzeitigem Wissen zweitfetteste (vergleichsweise) simple Texteditor-Programm. Hier ein kleiner Vergleich des RAM-Verbrauchs (RSS) mehrerer Editoren, die alle dasselbe Dokument geöffnet haben: LibreOffice Writer 529 MB, AbiWord 223 MB, kate 97 MB, kwrite 86 MB, TEA 83 MB, juffed 82 MB, gedit 48 MB, mousepad 35 MB, leafpad 28 MB, nedit (beherrscht allerdings kein UTF-8) 13 MB. Falls man das Problem "unsichtbarer Icons" haben sollte - siehe den Eintrag für "kate" wo die Lösung erläutert wird.
kxmleditor-1.1.4/app-editors/gentoo: Ein schlichter XML-Editor für KDE. Hübsch anzusehen und bunt und voller Icons, kann aber nichts besonderes. Wie etwa validieren. Aber immerhin erfüllt er seinen eigentlichen Job, nämlich XML-Dokumente in der Baumsicht als Folding Editor bearbeiten zu können.
kyotocabinet-1.2.69/dev-db/gentoo {key/value store}: Ein Key/Value-Store in der Tradition von dbm. LGPL. Der Nachfolger von dev-db/tokyocabinet. In jeder Hinsicht besser als dieses. Bietet B+ Trees mit 4 Byte Overhead pro Record oder Hash-Tables mit 16 Byte Overhead pro Eintrag. Keys und Values sind binär mit variabler Länge. Maximale Datenbankgröße 8 EiB. In C++ implementiert (und hat daher die C++ Runtime-Libraries als Abhängigkeit). Bindings für C, C++, Java, Python, Ruby, Perl und Lua werden bereits mitgeliefert. Sehr schnell - Einfügen von 1 Million Einträge binnen einer Sekunde. Ein Problem allerdings: "Tokyocabinet can and will corrupt beyond repair when the system goes down unexpectedly in case of a power outage or crash"
l3afpad-0.8.18.1.11-4+b1/editors/raspbian {text-editor}{GTK+}: Ein Fork von "Leafpad" welches anders als der Original noch weiter entwicklelt zu werden scheibt. Es handelt sich um einen sehr schlanken und minimalen Texteditor, der entsprechend auch sehr schnell startet. Im Vergleich zu Leafpad hat er vermutlich ein paar Bugs gefixed. Leider kamen auch ein paar neue hinzu. So erscheinen Zeilennummern oft nur verzögert oder sobald man mit dem Cursor über die Zeilen fährt, anstatt permanent angezeigt zu werden. Außerdem wurden die Farben geöffnet; der Kontrast zwischen (nur falls eingeschaltet) permanent angezeigten Zeilennummern und dem eigentlichen Text ist nun so gering dass er kaum noch zu erkennen ist. Beim Scrollen springt der Cursor manchmal seltsam zwischen den Zeilen eines weich umgebrochenen Absatzes herum. Zum Glück sind diese Bugs nur optischer Natur und ändern nichts an der grundsätzlich korrekten Funktionsweise des Programms.
lazarus-2.0.0+dfsg-2/devel/debian {development_environment}: Eine sehr Visual Basic für Windows erinnernde IDE, die jedoch an Free PASCAL anstatt auf BASIC als darunter liegende Programmiersprache aufbaut. Sie bietet eine Ehrfurcht gebietende Menge an Toolbars, die mit einer noch beeindruckenderen Menge an Icons für die verschiedenen grafischen Bedienungselemente bevölkert sind, die man mit der Maus in den Formular-Editor ziehen kann. Sobald man dies mit einem Bedienungselement getan hat, zeigt die IDE dessen Eigenschaften in einem Eigenschafts-Editor an wo man nun alle Attribute des neu hinzu gefügten grafischen Bedienungselements bearbeiten kann. Ein Doppelklick auf das Bedienungselement oder eine seiner Ereignis-Attribute öffnet den Code-Editor, wo bereits automatisch das Grundgerüst zur Ereignisbehandlung ausgefüllt ist - man muss nur noch den eigentlichen Ereignis-spezifischen Code ergänzen. Natürlich bietet der Code-Editor auch alle "Smart"-Features die man von einer solch hochintegrierten IDE gewartet ist, wie etwa dass eine Liste aller Strukturelemente zur Auswahl erscheint, sobald man im Code den "." zum Zugriff auf ein Struktur-Element eingetippt hat. Selbstredend kann der Editor auch Syntax-Highlighting, Struktur-"Folding", Refactoring-Features (abstrakte Methoden implementieren etc.) und was man sonst noch erwarten würde. Allgemein scheint die IDE als OpenSource-Ersatz für die proprietäre Object-PASCAL IDE "Delphi" zu sein, was dem Vernehmen nach auch recht gut gelungen sein dürfte. Anders als das originale Delphi haben Lazarus und Free PASCAL allerdings den Vorteil, nicht nur für Windows sondern nahezu auf allen verbreiteten Betriebssystemen, in erster Linie Linux, verfügbar zu sein. Der Native-Code Compiler von Free PASCAL unterstützt dabei auch alle verbreiteten Hardware-Plattformen; und zwar sowohl in 32 als auch 64 Bit (wo es beides gibt). Ähnlich wie JAVA verfolgt Free PASCAL ein "Write Once, Run Everywhere"-Konzept, welches es allerdings nicht durch plattformneutralen Bytecode erreicht, sondern durch einen eigenen native-Codegenerator Backend des Compilers für jede Plattform. FPC benutzt dazu nicht etwa den GCC oder clang als Back-Ends, sondern bringt vielmehr seine eigenen, selbst wiederum in PASCAL verfassten Compiler mit. Das einzige was mir nicht gefiel war die mangelnde Offline-Hilfe: Zwar bekommt man auf Knopfdruck Hilfe für alles direkt aus dem Internet - aber wenn man die Offline-Hilfspakete installiert, decken diese nur einen Bruchteil der verfügbaren Hilfe ab. Man muss daher entweder mit viel Mühe alle möglichen zusätzlichen Hilfepakete manuell downloaden und zusätzlich installieren um Offline-Hilfe zu erhalten, oder akzeptieren dass ein Großteil der Aufrufe zur Hilfe-Anzeige ins Internet ergeht, womit man neugierigen Beobachtern verrät woran man gerade arbeitet bzw. interessiert ist. Von dieser Einschränkung abgesehen erscheinen die Möglichkeiten der IDE beeindruckend - neben allen üblichen Bedienungs-Elementen für grafische Toolkits gibt es auch solche zum Erstellen von Datenbank-Anwendungen, Bearbeiten von Quelltexten mit intelligentem Syntax-Highlighting, Einfügen von grafischen Diagrammen, Druck-Unterstützung und weiteres. Die Datenbank-Abstraktions-Schicht unterstützt viele populären Datenbanken direkt (MS-SQL, SyBase, Postgres, ORACLE, MySQL, SQLite3, Firebird) sowie viele weitere via ODBC, aber auch CSV-Daten und Datensätze aus Textdateien mit mit festen Feldbreiten. Neben grafischen Elementen werden auch Dinge wie Timer, XML-RPC und andere Kommunikationsprotokolle direkt durch Hilfskomponenten unterstützt. Es gibt auch ein grafisches Bedienungselement für "PascalScript", welches es dem Benutzer der Applikation offenbar erlaubt selbst verschiedene Aspekte in einer PASCAL-artigen Scriptsprache in einem Quelltext-Feld für die Automatisierung zu hinterlegen. Natürlich fehlt auch ein integrierter Debugger nicht. Ebenso enthalten ist ein Unit-Editor, mit dem man PASCAL Units mitsamt ihren Abhängigkeiten komfortabel in der IDE verwalten kann. Insgesamt ein hervorragender Eindruck, zumal auch die erzeugten PASCAL-Executables in der Regel schlank und performant sind. Der einzige Wermutstropfen ist dass man sich zur Nutzung auf Free PASCAL als Programmiersprache einlassen muss. Dieses ist zwar durchaus mächtig und kann (durch seine vielen objektorientierten Erweiterung) durchaus mit C++ verglichen werden, gehört aber zur Gruppe der Sprachen wo "=" und "==" durch ":=" und "=" ersetzt wurden, was zu katastrophalen Programmierfehlern führen kann sobald man wieder eine Sprache mit "==" benutzen muss (anders herum kann kaum etwas passieren da PASCAL kein "==" kennt).
lbreakout2/games-arcade/gentoo {game}: Grafisch tadellos gemachter Breakout-Clone für SDL; Windowed oder Full-Screen. Netzwerkmodus für mehrere Spieler möglich. Viele Gimmicks und Spezialsteine. Viele Levels. Level-Editor vorhanden. Das beste Break-Out für Linux, das ich bislang sah. Trotzdem ein ziemlich langeweiliges Spiel mit eher geringer Langzeit-Motivation. Obwohl es die Funktion gibt, ab den letzten geschafften Level weiter zu spielen. Aber es bleibt trotzdem immer irgendwie dasselbe. Was mich persönlich vor allem stört, sind die vielen Steine mit negativen oder unbekannten Effekten, die man häufig unerwünschter Maßen berührt. Die positiven Effekte halten hingegen meist nur unterdurchschnittlich kurz an. Das macht das Spiel langwieriger als es nötig wäre und sogar schwieriger als wenn es überhaupt keine Spezial-Steine gäbe.
le-1.14.3/app-editors/gentoo: Ein Menü-/Textmode-UI-basierter Text Editor. Block-Markierungen werden mit der Umschalt-Taste aufgezogen/erweitert. Dies funktioniert sowohl in einem Terminal-Fenster als auch in der Linux Terminal-Konsole. Die meisten Befehle werden über die Funktionstasten aufgerufen. Verfügt über einen HEx-Modus, in dem wahlweise direkt im Hex- oder UNICODE-Text-Format eingegeben werden kann (die Anzeige erfolgt dann als LATIN-1-Zeichen, doch sobald der Hex-Modus wieder beendet wird, wird UTF-8 wieder korrekt dargestellt). Es gibt Blockfunktionen zum Ändern auf Groß- oder Kleinschrift, die auch mit Umlauten korrekt funktionieren. Ein Block kann durch ein externes Kommando gefiltert werden. Sowohl rechteckige als auch normale Blöcke werden unterstützt. Ein RPN-Kalkulator ist integriert. Eine Funktion erlaubt es, mit (einfachen) Linien-Grafik-Zeichen Rahmen/Tabellen zu malen. Weiter eingebaute Spezialfunktionen: Tabulatoren in Leerzeichen umwandeln, Wechsel der Zeilenend-Konventionen UNIX oder MS-DOS, Zeichentabelle. Es gibt einen interaktiven Reformatierungs-Modus, wo man entweder den ganzen Text oder einzelne Absätze reformatieren kann, oder einzelne Zeilen als link-, rechtsbündig oder zentriert. Man kann den Cursor auf eine Zeilennummer oder einen bestimmten Byte-Offset repositionieren. Es können Bookmarks mit 1-Zeichen-Kürzel gesetzt und angesprungen werden. Word-Wrap wird unterstützt, jedoch nur harter (automatisches Einfügen eines echten Zeilenende-Zeichens). Funktion vorhanden, eine Zeichenkette als Präfix vor alle Zeilen eines Blocks einzufügen. Ein- und Ausrücken von Blöcken. Es gibt simplen Development-Support, indem einige vordefinierte Kommandos mit externe Kommandos wie "make" belegt werden können. Suchen und erstetzen unterstützt "vollwertige" (jedoch offenbar nur "basic") Regular Expressions. Ein Vorteil von le ist dass durch die Menü- und Funktionstasteb-basierte Bedienung die Einlernzeit geringer ist als bei vielen anderen Editoren mit komplexen Befehlskürzeln.
leafpad-0.8.18.1-5/editors/raspbian {text-editor}{GTK+}: Ein sehr simpler GTK2+ basierter Texteditor mit Druck-Support. Download 0,1 MB, 27 MB RAM-Verbrauch, 102 MB virtueller, 8 MB PSS. Mehrsprachiges GUI. Entspricht in etwa dem Notepad von Windows. Angenehmerweise allerdings auch dessen Tastenbelegung. Kann nur eine Datei pro Instanz öffnen; kein Tab-Support, keine Historie der zuletzt geöffneten Dateien. Der Mauszeiger wird versteckt sobald man zu tippen beginnt und sich dieser gerade über dem Text befindet. Sobald man den Mauszeiger bewegt, erscheint er sofort wieder. Das ist hilfreich, damit der Mauszeiger nicht den jene Stelle verdecken kann an der man gerade tippt; das ist häufig der Fall nachdem man etwas mit der Maus markiert hat. Leafpad kann suchen/ersetzen, aber nur mit normalen Zeichenketten (mit oder ohne Unterscheidung von Groß-/Kleinschreibung) und ohne RegEx-Support. Es gibt auch kein Ausrichten der Suche an Wortgrenzen. Dafür beherrscht er aber weichen Zeilenumbruch und kann Zeilennummern am Anfang der Zeile einblenden. Weiters kann man mit der Tabulator-Taste ganze markierte Blocks ein- und ausrücken. Kurzum: Ähnlich wie kedit, aber wesentlich kleiner und ressourcenschonender. Und deutlich schneller bei großen Dateien! Leafpad ist der Standard-Editor von LXDE, besitzt aber keine Library-Abhängigkeiten von diesem. Mein liebster Vorgabe-Texteditor für schnelle Bearbeitungen ohne besondere Ansprüche (wie etwa Syntax-Highlighting oder sprachabhängige Einrückungsprofile). Leider haben neuere Versionen von Leafpad eine sehr ärgerliche Marotte entwickelt: Oft schließt sich das Fenster einfach nicht wenn man das Programm beendet; es scheint noch auf irgend etwas zu warten was offensichtlich nicht eintrifft. In solchen Fällen muss man das Programm erneut starten, dabei beendet sich die alte Instanz dann plötzlich doch. Möglicherweise irgend ein dbus-Service den ich deaktiviert habe. Update 2025: Dieser Fehler tritt trotz identischer Version nicht mehr auf. Vielleicht liegt es tatsächlich an DBUS, welcher nun permanent bei mir läuft. Leafpad hat einen fork namens Mousepad, der dasselbe und noch mehr kann, und dieses seltsame Verhalten nicht an den Tag legt, dafür aber langsamer startet und auch viele andere Verschlechterungen gegenüber Leafpad hat. Leider hat auch leafpad zumindest einen Bug, nämlich dass es sich beim Ersetzen manchmal "vertut" und das Wort vor oder nach der Ersetzung beschädigt (angrenzende Zeichen werden gelöscht oder verdoppelt). Man sieht das aber bereits in der Voranzeige der Änderung (soweit man sich die Fundstellen anzeigen lässt) und kann solche Problemfälle daher überspringen. Oder man lässt die Ersetzung zu und korrigiert die meist nicht dramatischen Fehler nachträglich mit einer Suche nach dem Ersatzbegriff manuell. Es ist somit zwar ein ärgerlicher, aber nicht übermäßig problematischer Fehler.
lemon-3.16.2-5/devel/debian {parser/lexer-generator}{code-generator}: Das ist der Parser-Generator, der intern zum Bauen von SQLite benutzt wird, und scheinbar auch von Leuten aus dem Umfeld des SQLite-Projekts abstammt. Er erzeugt C-Quelltext, der sich aber auch mit einem C++-Compiler übersetzen lässt. Entsprechend schlank (60 kB) und in C geschrieben ohne Abhängigkeiten von weiteren Libraries abseits der C Runtime. Lemon erledigt denselben Job wie yacc/bison, aber angeblich besser, sauberer (re-entrant und thread-safe) und auf eine weniger fehleranfällige Weise zu benutzen. Die gesamte Dokumentation wird in einer 40 kB HTML-Datei mitgeliefert. Alles in allem ein angenehm schlankes und vermutlich auch brauchbares Tool. lemon ist schneller als bison, merkt aber an dass neuere bison-versionen inzwischen ebenfalls re-entrant und thread-safe code erzeugen können. Sowohl flex als auch bison sind allerdings wesentlich fettere (obwohl immer noch vergleichsweise schlanke) Installationen als lemon, und zweifellos mit einer viel längeren Anleitung mit der man sich abmühen muss (noch dazu im eher bedienungsfeindlichen GNU "info" Format). Lemon ist allerdings genau wie bison nur ein Parser, kein Lexer. Der von Lemon erzeugte Code muss von einem Lexer aufgerufen werden, der dem Parser das jeweils nächste Token überreicht (bei yacc/bison ist es genau anders herum). Tokens werden durch int-Werte repräsentiert. Lemon kann jedoch als der Grammatik-Definition ein Header-File erzeugen, welches geeignete #defines für die verwendeten Tokens enthält. Parsen bzw. "lexen" muss man die Tokens aber selbst, oder ein anderes Tool wie flex oder re2c dazu benutzen.
leptonica-progs-1.79.0-1.1/graphics/debian {PDF}: Enthält einige Kommandozeilen-Programme, welche Fähigkeiten der leptonica-Bibliothek (die ihrerseits vor allem von der Tesseract-OCR benötigt wird) Shell-Scripten zur Verfügung stellt. "convertfilestopdf" konvertiert alle Grafikdateien (oder nur solche mit einem gemeinsamen gegebenen Namemsteil) aus einem Verzeichnis in eine einzelne PDF-Datei (mit den wählbaren Komprimierungsmethoden JPEG, FaxGroup4, flate oder JPEG2000 sowie ebenfalls auswählbarer Qualität), "convertfilestops" konvertiert alle oder bestimmte Dateien aus einem Verzeichnis in eine PostScript-Datei, "convertformat" konvertiert zwischen diversen Grafikdateiformaten (BMP, JPEG, PNG, TIFF, TIFFG4, PNM, GIF, WEBP, JPEG2000) - leider scheinbar ohne auswählbare Qualitätseinstellungen für die Kompression, "convertsegfilestopdf" extrahiert spezifizierte Bildausschnitte (im "boxaa" Format wie tesseract es vermutlich irgendwie mit seinen page segmentation modes erzeugen kann) aus allen oder einigen Dateien in einem Verzeichnis als separate Seiten und speichert sie als eine einzelne PDF-Datei, "convertsegfilestops" tut dasselbe wie nur dass es eine PostScript-Datei erzeugt, "converttopdf" konvertiert alle oder einige Dateien aus einem Verzeichnis in ein einzelne PDF-Datei (dabei ist unklar was der Unterschied zu "convertfilestopdf" sein soll - Vermutung: Die Eingabedateien können auch PDFs sein), "converttops" tut dasselbe doch erzeugt eine PostScript-Datei, "fileinfo" zeigt technische Informationen (Größe, Auflösung, etc.) über Grafikdateien an, "xtractprotos" extrahiert Prototyp-Definitionen aus C Quelltexten.
lfhex-0.3.7.2/app-editors/gentoo {hex-editing}{Qt}: A small and fast Qt hex editor. Can edit large files without loading them as a whole. Supports hex/dec goto. Can switch between hex, ascii, binary and octal displays. Can also convert values between Hex, ASCII, Int, Float and Double (with optional big/little endian conversion). Can also search using the value in the conversion dialog. Has Undo/Redo. The only flaw is that the editor cannot show hex and ASCII data at the same time. However, it is easy to switch display modes.
lftp-4.8.4-2+b1/net/debian: Ein leichtgewichtiges Download-Programm für die Protokolle FTP, BitTorrent, FTPS, HTTP, HTTPS, HFTP, FISH, SFTP und "file://". Ist insbesondere auch in der Lage Bittorrents mittel "magnet"-Links sowie info_hash-IDs (sowohl Hexadezimal als auch Base-32 codiert) herunter zu laden. Der Client "lftp" ist wie das klassische ftp-Kommando interaktiv. Dieser enthält auch eine Queie-Verwaltung für mehrere gleichzeitig laufende Downloads. Für einzelne nicht-interaktive Downloads (a la "wget", jedoch nur für einzelne Dateien) gibt es das Front-End "lftpget". 800 kB Download. 2,4 MB installiert.
libXaw-1.0.9/x11-libs/gentoo {runtime utility library}: X Athena Widgets ist ein GUI-Toolkit für X11, dessen sich die meisten "Ur-Applikationen" bedienen, wie etwa xterm, xconsole, xclock oder xcalc. Diese für ihre besondere Hässlichkeit bekannten Tools verdanken ihr Aussehen der libXaw. Xaw implementiert alle möglichen grafischen Widgets wie Buttons und Texteingabefelder basierend auf der libXt, welche das Framework für libXaw bildet jedoch so gut wie keine Widgets selbst implementiert. libXaw ist ein direkter "Konkurrent" für andere Toolkits wie GTK+, Qt, FLTK, FOX usw, übertrifft diese alle aber an Häßlichkeit. Es kann auch nur das allernötigste; über Layout-Manager verfügt es etwa nicht. Allerdings ist Xaw gut als Fallback, da es meist sowohl auf Qt als auch GTK+ Systemen zusätzlich für alte Tools wie xterm installiert ist. Außerdem ist es klein - libXaw mit sämtlichen abhägigen Libraries inlusive der libc belegt in Summe nicht mehr als 6 MB Platz. Die Dokumentation ist altbacken in (hunderten von) man-Pages verfügbar. Das geht sich selbst auf den kleinsten Systemen noch aus, und ist kein Vergleich zu den anderen wesentlich schöneren, aber auch fetteren Toolkits.
libXt-1.1.1/x11-libs/gentoo {runtime utility library}: Das X11 Intrinsics Toolkit, eine Basisbibliothek welche ein Framework zur Implementierung von Widgets zur Verfügung stellt, diese aber selbst nicht implementiert. Es kümmert sich um Callbacks, Widget-Hierarchieverwaltung, koordiniert Maus- und Keyboard-Grabs, vereinheitlicht die Event-Schleife usw. Die eigentliche Darstellung muss das Applikationsprogramm selbst durch entsprechende Callbacks zum Zeichnen der Widgets implementieren. libXt ist die Basisbibliothek auf der die extrem hässlichen GUI-Toolkits libXaw und Motif/LessTif basieren. Die meisten Toolkits greifen auf bestimmte Funktionen von libXt zurück, so etwa auch GTK+, FOX oder FLTK. Auch xdm und twm und sogar der xorg-Server (falls Multi-Head Support installiert ist) selbst benötigen es. Einzig Qt scheint ohne libXt auszukommen. Dennoch kann man davon ausgehen dass libXt als Low-Level-Abhängigkeit praktisch auf so ziemlich jedem X11-System installiert sein wird. Es repräsentiert demnach in den meisten Fällen die Schicht zwischen libX11 und der eigentlichen GUI Toolkit-Library.
libav-9.17/media-video/gentoo {media-player}{audio}{music}{runtime utility library}: Tools und Libraries für Wiedergabe, Aufnahme und Konvertierung von Audio-/Video. Konkurrent und Fork von von media-video/ffmpeg, der aufgrund von Animositäten innerhalb des Projekts zustande kam. Die Maintainer von libav hassen ffmpeg und würden es am liebsten vertilgen, was sich so äußert dass sie das Originalprojekt und dessen Fortschritte größtenteils ignorieren. Dafür haben sie höhere Qualitätsmaßstäbe und erzwingen Code Reviews von jeder Änderung. Die Maintainer des ffmpeg-Projekts hingegen entwickeln sowohl ihr Projekt weiter, als auch übernehmen sie die meisten Änderungen des libav-Projekts bei Merges alle paar Tage. Es ist auch leichter für Entwickler Code ans ffmpeg-Projekt zu senden, da dieses neue Patches rasch ohne große Kontrollen aufnimmt. Dadurch bietet FFMpeg mehr experimentelle und neue Features und stellt durch seine häufigen Merges de facto ein Superset von libav dar, während letzteres mehr Wert auf Qualität, Stabilität und Sicherheit legt. FFMpeg bietet mehr Codecs, aber diese sind häufig buggy und von schlechter Qualität, so dass avlib sie vorsätzlich nicht übernommen hat. Außerdem muss man sich fragen, in wie fern man diverse exotische Codecs überhaupt braucht. Denn alle wichtigen, weithin verwendeten Codecs werden von beiden Libraries gleichermaßen unterstützt. Derzeit scheint mir avlib daher eher die bessere Wahl zu sein. Allerdings mag die Zukunft auf Seiten von FFmpeg liegen, denn die libav-Entwickler sind größtenteils eine abgeschlossene Gruppe die einander persönlich kennt, während FFmpeg zwar nur aus einem Kern-Entwickler besteht, dieser aber von unzähligen Leuten Patches entgegen nimmt und integriert. Wenn dieser eine Entwickler ausfällt, kann jemand anderer die Integrationstätigkeiten übernehmen. Wenn hingegen der enge Kern der libav-Entwickler ausfällt mit ihren strengen selbstgesetzten Qualitätssicherungs-Methoden, ist fraglich ob das so einfach neue Leute übernehmen würden. Wahrscheinlicher ist eher, dass das Projekt dann eingestellt würde, zumal FFMpeg ja ohnehin alle bisherigen Änderungen bereits übernommen hat. Da libav sich aber umgekehrt nicht um FFMpeg kümmert und höhere Hürden für das Einreichen von Patches stellt, würden die bisherigen FFMpeg-Patch-Contributoren wohl eher einen neuen Patch-Integrator suchen der das FFMpeg-Projekt weiterführt, als auch avlib zu wechseln. Und was die höhere Qualität der libav abgeht, darf man nicht vergessen dass diese Patches ja ebenfalls ins derzeitige FFMpeg eingehen. Nur wenn man die exotischen Codecs von FFMpeg benutzt, läuft man Gefahr ein Opfer von deren Bugs und Security Leaks zu werden. Weiters gibt es mehr existierende Scripts welche das ffmpeg-Kommandozeilentool verwenden als avconv, und beide Tools verwenden eine unterschiedliche Argument-Syntax. Gleichwohl liefert ffmpeg ein Kompatibilitäts-Wrapper-Tool für avconv mit, während dies umgekehrt nicht der Fall ist.
libcairo2-1.16.0-5/libs/debian cairo-1.8.10/x11-libs/gentoo {graphics drawing}{runtime utility library}: Geräteunabhängige Cross-Platform Library für Anti-Aliased und 2D Rendering. Vektor-basiert. Unterstützt auch Details wie strichlierte Linien, Strichstärken, Form der Linien-Enden, Form des Verbindungspunkts wenn 2 unterschiedliche Linien an einander anschließen. Gradient-Support. Große Überschneidunng zu x11-libs/agg, doch cairo steht unter der LGPL womit man es neben OpenSource-Projekten auch für bezahlte closed-source Auftragsarbeiten verwenden darf. Vielleicht auch deshalb ist Cairo sehr viel beliebter und verbreiter als AGG. Außerdem ist Cairo in C geschrieben und hat Bindings zu den meisten beliebten Programmiersprachen, während AGG auf C++ fixiert ist. Cairo kann sowohl direkt in normale On-Screen-Fenster rendern, als auch in PNG, SVG oder PDF-Dateien. Überdies kann es mittels DirectFB ausgeben, womit man auch ohne X11-Server direkt in eine Linux Framebuffer-Console rendern kann. Ein (noch unerreichtes) Entwurfsziel von Cairo ist es, die gesamte Grafikfunktionalität des PDF 1.4 Standards als Zeichenoperationen für alle Ausgabeziele zur Verfügung zu stellen. Entsprechend sind die Cairo-Funktionen den Postscript-Grafikoperatoren in der Anwendung und vom Konzept her sehr ähnlich. Als Nebeneffekt ist es in Cairo sehr einfach, Grafiken als hochwertige PDF-Dokumente auszugeben. Cairo ist sehr populär weil man damit plattformunabhängig hochqualitative Render-Qualität erzielen kann. Ein mögliches Problem von Cairo ist dass sein API nahezu überall auf "double" Fließkommazahlen basiert. Intern mag das anders sein, aber es ist ärgerlich dass man Integer-Koordinaten als Fließkommazahlen übergeben muss. Auf einer CPU ohne FPU dürften andere, integer-basierte Grafik-Libraries performanter sein. Fehler in den Library-Funktionen werden ähnlich wie NaNs in Berechnungen gehandhabt. Die Grafikobjekte werden in einen Fehlerzustand versetzt, dürfen aber nach wie vor in Aufrufen verwendet werden welche dann typischer Weise nichts tun, oder den Fehlerzustand auf andere Objekte ausweiten. Man kann aber jederzeit von jedem Objekt den Fehlerstatus abfragen. Das führt zu einem Programmierstil wo Fehler nur z. B. nach dem kompletten Rendern einer Szene geprüft werden, während die Grafikoperationen innerhalb der Szene Fehler ignorieren.
libgd3-2.3.3-9/libs/raspbian {graphics drawing}: Eine in C geschriebene Bibliothek für das Zeichnen von Grafiken in einem RAM-Puffer, die danach als Bilddatei abgespeichert werden können. Verfügbare Grafik-Primitives sind Linien, Kreisbögen, Text (via libfreetype), Flood Fill, Ausschnitte von anderen Bildern einfügen. Unterstützung für die folgenden Bildformate ist direkt enthalten: BMP, GIF, TGA, WBMP (ein sehr simples Monochrom-Bitmapformat das noch einfacher zu parsen ist als PBM). Optionaler Support für die folgenden Bildformate ist mit externen Libraries vorhanden: AVIF, JPEG, HEIF, PNG, TIFF, WebP, XPM. Es gibt Wrapper für einige andere Programmiersprachen, wie Perl und PHP. Vor allen PHP macht angeblich häufig Gebrauch von libgd, um auf Webseiten Thumbnail-Bilder, Diagramme, Symbol-Icons und dergleichen dynamisch zu erzeugen. Vermutlich hat libgd einen geringen Ressourcenverbrauch, was es für solche Anwendungsfälle sympathisch macht. Das Fehlerbehandlungs-Konzept ist "klassisch": Der Return-Wert gibt an ob die Funktion erfolgreich war, und wird in der Regel vom Aufrufer ignoriert. Was die Performance angeht, verwenden die meisten APIs zwar Ganzzahlen als Koordinaten. Innerhalb der Funktionen wird jedoch fröhlich von Fließkomma-Arithmetik und teuren Operationen wie Division oder Arcustangens Gebrauch gemacht. Zwar bemüht sich der Code sichtlich in den innersten Schleifen mit Integers zu arbeiten, aber das gelingt erstens nicht überall und außerhalb der innersten Schleifen bemüht sich der Code nicht einmal diese teuren Operationen zu vermeiden. Vielleicht hat diese Strategie auch damit zu tun, dass von den Routinen auch Antialiasing und Alpha-Blending unterstützt wird, wo man mit Integer-Operationen vermutlich nicht weit kommt. Dennoch sollte man wohl besser eine FPU haben, wenn man diese Libary benutzen möchte. Es stellt sich auch die Frage, ob dieses ständige interne Umwandeln zwischen Ganzzahlen und Fließkommazahlen nicht sogar langsamer ist, als wenn man wie in "cairo" gleich alle Maßangaben im API als Fließkommazahlen angeben muss. Andererseits ist der Code der cairo-Library ungefähr um den Faktor 10 größer als jener der gd-Library. Außerdem konstruiert man in Cairo Vektorgrafikobjekte die sich am Ende auf Wunsch auch in Rastergrafik konvertieren lassen, während die Befehle der libgd einfach direkt in eine Rastergrafik-Zeichenfläche rendern. Die Lizenz der libgd ist BSD-artig; auch kommerzielle Verwendung ist kostenlos erlaubt.
libggi/media-libs/gentoo {graphics drawing}{runtime utility library}: GGI ist eine Bibliothek, um (2D-) Grafik auf einem Computer zu abstrahieren. Ein mit GGI arbeitendes Programm kann dann beispielsweise ohne Recompilierung sowohl unter X11 als auch in der Framebuffer-Konsole oder gar direkten Zugriff mittels Lowlevel-Grafiktreiber funktionieren. Aber auch auf Quelltextebene werden so etwa Windows- und Linux-Programme austauschbar. So gesehen ähnliche Features wie SDL, allerdings ist GGI nur auf 2D-Grafik beschränkt und nicht für Spiele gedacht, sondern für "ernsthafte" Anwendungen.
libgnome-keyring-2.32.0/gnome-base/gentoo {security}{runtime utility library}: Das API für gnome-base/gnome-keyring und app-crypt/seahorse. Das Ziel des Projektes ist es, ein einheitliches API für alle möglichen Arten von Crypto-Tools zur Verfügung zu stellen. Dabei wird versucht das ganze Spektrum kryptografischer Anwendungen abzudecken, von der Schlüsselverwaltung über Passphrase-Caching bis hin zur eigentlichen Verschlüsselung, Digitalen Signaturen, Zertifikats- und Smartcard-Verwaltung. libgnome-keyring ist dabei nur das API als Library; das ganze System erfordert auch noch gnome-base/gnome-keyring als Backend und optional app-crypt/seahorse als grafisches Front-End. Leider konkurriert diese Library mit einem anderen Standard zu diesem Zweck, und zwar dem DBUS "Secret Service". Derzeit ist libgnome-keyring nichts als ein Front-End und greift im Hintergrund auf das Secret Service API zu. Eventuell wird später eine bessere Library kommen. Das Name "gsecrets" ist dafür bereits vorgesehen. Bis dahin mag es zukunftsweisender sein direkt über das DBUS-API auf den gnome-keyring zuzugreifen anstatt über diese Library. Allerdings ist der Zugriff über die Library simpler für Applikationen. Sobald gsecrets entwickelt wurde, ist jedenfalls geplant dass libgnome-keyring deprecated werden soll.
libgpg-error-1.7/dev-libs/gentoo {runtime utility library}: Dies ist nicht, wie man vielleicht glauben könnte, eine großartige allgemein verwendbare Library für Fehlerbehandlung in C-Programmen. Vielmehr ist es einfach eine Sammlung von enums und #defines für Fehler-Codes, welche von unterschiedlichen Komponenten der GPG-Suite intern gemeinsam verwendet werden. Wertlos für andere Projekte die nicht im Zusammenhang mit GPG stehen.
libice 1.0.9-1/extra/archlinux {runtime utility library}: Die X11 Inter-Client Exchange library stellt ein API zur Benutzung des Inter-Client Exchange (ICE) Protocols zur Verfügung. ICE erlaubt es X11-Applikationen mit einander zu kommunizieren, die ein gemeinsames Custom-Protokoll, "Subprotocol" genannt, sprechen das auf ICE basiert. Beliebige Subprotocols können in der ICE Library registriert und dann von den Clients benutzt werden. ICE nimmt den Autoren der Subprotocols dabei Arbeiten ab, welche unterschiedliche Protokolle gemeinsam haben. Das sind Authentisierung, Aushandeln von Protokoll-Versionen, Verbindungsaufbau und Verbindungsabbau. Ebenso kümmert es sich um die Übertragung der Subprotocol-Messages, wobei ICE jeden Datentransport benutzen kann der einen Byteübertragung zur Verfügung stellt. Also beispielsweise auf TCP. ICE kümmert sich auch um das "Mashalling" von ICE-internen Verwaltungs-Messages inklusive Byte-Order-Konvertierungen, so dass ICE-Clients auf unterschiedlichen Hardware-Plattformen mit einander kommunizieren können. ICE implementiert dazu das interne "Marshalling" folgender Datentypen, das auch Subprotocols nutzen können falls sie wollen: 8, 16 und 32-Bit vorzeichenlose Ganzzahlen, Boolean, ASCII-Zeichen, ASCII-Zeichenkette, Versionsummern (bestehend aus "Major" und "Minor"-Teil, jeweils vorzeichenlose 16-Bit Ganzzahlen). ICE-Messages können bis zu 4 GiB Subprotocol-Nutzdaten transportieren. Weiters definiert ICE auch Fehlermeldungs-Codes für die Transport-Schicht. Es ist wichtig zu verstehen, dass die zuvor genannten Datentypen für die internen Belange des ICE selbst vorhanden sind, damit es Aufgaben wie Autorisierung, Verbindungsaufbau, Message-Versand etc. abwickeln kann. Die Nutzdaten der Subprotokolle sind aber nicht auf diese Datentypen beschränkt oder angewiesen. Statt dessen registrieren sie einfach Callback-Routinen, die von der ICE-Library aufgerufen werden sobald eine Message das Subprotokolls eintrifft. Sie erhalten dabei einen Handle zum Lesen der Nutzdaten, die Länge der Nutzdaten sowie ein Boolean ob die Message von einem Absender stammt der eine andere Endian-ness verwendet, so dass der Callback gegebenenfalls Byte-Swapping vornehmen soll (falls die Nutzdaten nicht endian-neutral gespeichert sind). Der Callback kann den übergeben Handle benutzen, um entweder Nutzdaten fixer Länge oder variabler Länge (welche vom Subprotocol berechnet wird) in einen Puffer zu lesen, oder aber die Nutzdaten inkrementell (etwa in einer Schleife) einzulesen. Weiters können Messages beantwortet werden, aber das ist nicht zwingend nötig. Das ICE-Protokoll selbst ist bis auf Byte-Ebene hinunter exakt spezifiziert. Für eigentliche Überprüfen der Authorisation werden ebenfalls Callbacks genutzt, so dass im Grunde jede Art der Authorisierung denkbar ist. Allerdings verschlüsselt ICE selbst nichts, und benutzt auch keine Prüfsummen, so dass dies entweder der Authorisierungs-Callback übernehmen muss, oder das Basisprotokoll auf dem ICE aufsetzt muss bereits ausreichend sicher sein. Eine gemeine Frage welche man sich bei ICE stellen könnte ist, wozu man es eigentlich noch braucht wenn die Subprotokolle doch ohnehin schon so ziemlich alles was wirklich Arbeit macht mittels Callbacks selbst implementieren müssen. Auch stellt sich die Frage, ob die Beschränkung auf Major/Minor-Versionsnummern in Zeiten von Google's Protocol Buffers noch zeitgemäß sind.
libimlib2-1.10.0-4+deb12u1/libs/raspbian {runtime utility library}: Kann viele verschiedene Bildformate zumindest laden, anzeigen und teilweise auch speichern. Darunter zumindest auch alle relevanten klassischen Formate sowie die meisten hippen neuen Formate: TIFF, GIF, PNG, JPEG, WebP, JPEG-XL, HEIF, JPEG 2000, SVG, PostScript. Nur AVIF scheint von den hippen Neuen (noch, Stand 2023-12) zu fehlen. Möglicherweise noch ein paar Legacy-Formate zusätzlich, welche die Kern-Bibliotheken von X11 direkt beherrschen und keine zusätzliche Library-Abhängigkeit darstellen. Auf jedenfall beherrscht jede Applikation welche sich dieser Library bedient die meisten relevanten Bildformate.
libjpeg-turbo-progs-1 {bitmap image editor}{runtime utility library}: 1.5.2-2+deb10u1/graphics/debian: Enthält programme zum Manipulieren von JPEG-Dateien. Es handelt sich dabei um Referenz-Implementierungen von den Entwicklern des JPEG-Standards. Die relevantesten im Paket enthaltenen Utilities sind: "cjpeg" konvertiert eines der folgenden Bildformate in eine JPEG-Datei: PPM, PGM, BMP, TGA und RLE (Utah Raster Toolkit format). "djpeg" tut das exakte Gegenteil. "jpegtran" erlaubt verlustloses Rotieren in 90-Grad Schritten, sowie das Spiegeln aller Pixel an einer Achse welche durch den Bildmittelpunkt geht und in 45-Grad Schritten rotierbar ist. "rdjpgcom" liest das aktuelle JPEG-Kommentarfeld aus. "wrjpgcom" beschreibt es neu. "jpegexiforient" zeigt die 90-Grad-Rotation an um welche des Bild für die Anzeige rotiert werden soll, oder überschreibt sie durch einen gegebenen Wert. "exifautotran": Rotiert das Bild verlustlos so dass es der gespeicherten 90-Grad-Rotation entspricht und das Bild daher genau so angezeigt werden kann wie es decodiert wurde.
libleptonica-dev-1.79.0-1.1/libdevel/debian {runtime utility library}: C-API zur Nutzung der libleptonica, einer der Hauptabhängigkeiten der Tesseract OCR. Im folgenden eine unvollständige Liste, die besonders interessante Funktionen der Library auflistet: Dateiformate lesen/schreiben (BMP, GIF, PNG, TIFF, PDF, JPEG, PNM, WEBP), Dateiformate nur lesen (JPEG-2000), Decoder für etliche 1D Barcodes, JBIG2-Umwandlung, Page Segmentation, Halftone Region Extraction, eine Implementierung des "Bilateral Filter", Fein-Rotation mittels Shearing (Pixel werden nur im Ganzen verschoben) oder Linear Interpolation (mit Anti-Aliasing), Allgemeine Affine Matrix-Transformationen für Pixmaps, Scaling, Flood Fill, S/W-Konverterung mit Local Adaptive Quantization, Otsu und Sauvola, Approximate Color Matching, etliche wichtige Bildverarbeitungsfilter (Median, Gauss, Edge Detection, allgemeine Faltungsmatrix), Low-Level Pixmap Operations (Maskierung, Boolean), Umwandlung zwischen Integer- und Fließkomma-Farbwerten, allgemeine Datenstrukturen (RB-Trees, Queues, Heaps, Stacks, dynamische Arrays gebräuchlicher Datentypen, dynamische Puffer, dynamische Hashtables). Es gibt keinen direkten Support für Graphik-Primitives wie Polygone, allerdings ist ein Wrapper für GNU Plot zu diesem Zweck enthalten.
liblinebreak-2.1/dev-libs/gentoo {runtime utility library}: Implementiert den Standard-UNICODE-Algorithmus zum Erkennen der Stellen in einem UNICODE-Text an dem Zeilenumbrüche vornehmen könnte. Wird als Basis für Word-Wrapping von UNICODE-Text benötigt.
libnetpbm-dev-2:11.01.00-2/libdevel/debian {runtime utility library}: Entwicklungspaket für die Hilfsbibliothek zum Umgang mit den diversen "Portable Bitmap" ("PNM") Formaten (PBM, PGM, PPM, PAM). Ein großes Ärgernis ist das Fehlen jeder Dokumentation. Diese muss man sich angeblich von der Webseite des Projekts im HTML-Format herunterladen wenn man sie lokal haben will. Immerhin werden für die offizielle Benutzung der Dokumentation Anleitungen für das Herunterladen dieser Dokumentation und auch Konvertieren in andere Formate wie etwa "man" angeboten. Wie zum Hohn sind all diese HTML-Seiten aber zumindest unter Debian dennoch im Quelltextbaum der Bibliothek im "userguide"-Unterordner "userguide" enthalten; sie werden lediglich nicht ins gebaute Paket aufgenommen bzw. installiert. Vielleicht aus Lizenzgründen? Es fällt auch auf dass der Name des Quelltext-Ordners das Wort "free" enthält, woraus man schließen kann dass nicht alles gebotene unter einer freien Lizenz steht. Ein weiteres Ärgernis zumindest der Debian-Version dieser Library ist, dass im Quelltextbaum auch alle möglichen tollen Konverter-Tools und Bitmap-Manipulations-Tools enthalten sind. Sie werden sogar alle automatisch gebaut wenn man das Paket mit "debuild" aus dem Quelltext bauen lässt. Doch diese schönen Utilities waren in der Debian-Version sämtlich nicht installiert! Dadurch fehlen auch die eigentlich enthaltenen Konverter zwischen den PNM-Formaten und vielen populären Dateiformaten wie GIF, JPEG, PNG, JPEG2000 und sogar SVG. Ebenso gäbe es Konverter für viele alte Dateiformate von historischen Homecomputern wie der Amiga. Weiter gäbe es diverse Grafikfilter-Utilities wie Faltungsmatrix, Gammakorrektur, schärfen, beschneiden, Dithering, verrauschen, deinterlace, Morphing usw. Auch Hilfsprogramme wie das Erzeugen von Übersichtsbildern einer Bildkollektion oder für das Zusammennähen von Fotos zu einem "Panoramabild" wären enthalten. Und schließlich gäbe es auch noch etliche Analyse-Utilities, die alle möglichen Informationen und Metriken wie PSNR aus Bitmap-Dateien ermitteln können. Doch all diese Programme werden schlicht nicht installiert. Am besten installiert man sich die Quelltexte mit "apt-get source" selbst, baut das Paket danach mit "debuild", und installiert dann manuell was man haben will jedoch von den erzeugten Debian-Paketen nicht installiert wird. Besonders nützlich erscheint mir "pnmstitch", das zuvor erwähnte Program zum Zusammennähen von Fotos. Obwohl in der Anleitung von "Panorama" die Rede ist, sind hier keine 3D-Projektionen für ein 360-Grad Panorama gemeint. Sondern es werden einfach zwei überlappenden Fotos zu einem kombinierten Bild verschmolzen. Dabei unterstützt der Programm nur die Anordnung aus linkem und rechtem Foto. Man kann durch das ebenfalls enthaltene Utility "pamflip" Bilder aber in 90-Grad-Schritten Grad drehen, so dass man auf diesem Umweg sämtliche Anordnungen vernähen kann. Da keine 3D-Komponente im Spiel ist, sollte auch das Zusammenfügen von eingescannten Teilen eines großen Papiers möglich sein, welches nicht als Ganzes in den Scanner passte. Es ist mit "pnmcat" auch möglich, Bilder pixelexakt an einander angrenzend zu verbinden. In diesem Fall dürfen die Bilder sich jedoch nicht überlappen.
libnettle6/libdevel/debian {security}{runtime utility library}: Implementiert diverse symmetrische Verschlüsselungsalgorithmen und kryptografishe Hash-Funktionen. Anthält absichtlich nur die Low-Level-Funktionen zu diesem Zweck, und weder Memory Management noch I/O-Funktionen. Halbwegs schlank: 200 kB Download, 370 kB installiert. Hängt nur von der libc ab. Die folgenden Algorithmen sind implementiert: AES-128, AES-192, AES-256, ARCFOUR-128, ARCTWO-128, ARCTWO-40, ARCTWO-64, base16 (ASCII armor, not an encryption), base64, BLOWFISH (key sizes up to 448 bits, optionally checks for weak keys), CAMELLIA-128, CAMELLIA-192, CAMELLIA-256, CAST-128, CAST-5, CBC, CCM, CCM-AES-128, CCM-AES-192, CCM-AES-256, ChaCha, ChaCha-Poly1305, CTR, DES, EAX, EAX-AES-128, GCM, GCM-AES-128, GCM-AES-192, GCM-AES-256, GCM-CAMELLIA-128, GCM-CAMELLIA-256, GOSTHASH-94, HMAC-MD5, HMAC-RIPEMD-160, HMAC-SHA-1, HMAC-SHA2-224, HMAC-SHA2-256, HMAC-SHA2-384, HMAC-SHA2-512, HMAC (with caller-provided hash function), Knuth's "Lagged Fibonacci" PRNG (kein CPRNG, scheint eine subtraktive Variante des "Additive RNG" zu sein, die allerdings andere Konstanten verwendet und deshalb den Rest einer Division durch 100 berechnen muss), MD2, MD4, MD5, memeql_sec (side-channel silent memory comparison), memxor3 (XOR two blocks into a third), memxor (XOR memory blocks), PBKDF2-HMAC-SHA1, PBKDF2-HMAC-SHA256, PBKDF2 (with caller-provided PRF), Poly1305-AES, RIPEMD-160, SALSA20-128, SALSA20-256, SALSA20-R12, SERPENT-128, SERPENT-192, SERPENT-256, SHA1, SHA2-224, SHA2-256, SHA2-384, SHA2-512, SHA2-512-224 (truncated to 224 bits), SHA2-512-256, SHA3-224, SHA3-256, SHA3-384, SHA3-512, TripleDES, TWOFISH-128, TWOFISH-192, TWOFISH-256, UMAC-128, UMAC-32, UMAC-64, UMAC-96, YARROW-256 (mit Design-Entscheidungen der Nettle-Autoren, da YARROW nicht vollständig spezifiziert ist). Das zugehörige -dev-Paket implementiert allerdings auch Public-Key Algorithmen, wozu dann allerdings zusätzlich gegen die Libraries libgmp und libhogweed gelinkt werden muss: RSA, DSA, ECC (ECDSA und EdDSA von D. J. Bernstein mit Curve 25519 aus RFC 7748). Das enthält auch Schlüsselerzeugung. Die ECC-Funktionen von libhogweed sind "side-channel silent". Leider gibt es keine Aussage dazu für die anderen Algorithmen. Leider implementiert libhogweed nur ECC-Signaturen, keine PKI-Verschlüsselung. Allerdings stellt es ECC-Primitives bereit, mit denen man vermutlich Verschlüsselung implementieren kann.
libnih-1.0.3/sys-libs/gentoo {runtime utility library}: Eine Hilfsbibliothek die C um objektorientierte Features erweitert, sehr ähnlich wie die glib, jedoch wesentlich schlanker. Allerdings wird dies damit erkauft, dass gcc-spezifische non-Standard spezial-Builtins verwendet werden, die auf keinem andern C-Compiler verfügbar sind. Code welcher libnih verwendet mag daher schlank und toll sein, erfordert aber den gcc als Compiler. Unbrauchbar daher wenn andere C-Compiler wie clang zum Einsatz kommen könnten. [Update 2017-05: Stimmt dies wirklich? Bei einer erneuten Überprüfung wurde ich nicht sofort fündig. Möglicherweise habe ich diese "non-Standard-Features" einfach mit C99-Features verwechselt, die zwar auch nicht jeder C-Compiler unterstützt, aber inzwischen doch zumindest die allermeisten.] Weiters hängt libnih wiederum von der dbus-Library und dem expat-XML-Parser ab - zwei weitere Abhängigkeiten, die mich nicht gerade mit Begeisterung für eine "schlanke" Library erfüllen.
libopenjp2-tools-2.4.0-3/graphics/debian {runtime utility library}: Stellt Kommandozeilenprogramme für den Umgang mit JPEG2000-Dateien zur Verfügung. "opj_compress" komprimiert vorhandene Grafikdateien vom Typ .bmp, .pgm, .pgx, .png, .pnm, .ppm, .raw, .tga und .tif (man beachte das Fehlen von .jpg) in JPEG2000 Ausgangsdateien .j2k bzw. jp2. "opj_decompress" tut das Gegenteil und wandelt JPEG2000-Dateien wieder zurück in die anderen erwähnten Grafikdateiformate. "opj_dump" gibt technische Details über den Aufbau und die Parameter eine JPEG2000 Datei aus. Besonders interessant erscheint die Nutzung von "opj_compress" in Kombination mit "img2pdf", um Grafiken JPEG2000-komprimiert in PDF-Dateien einzubetten. Ein großes praktisches Problem mit diesen Utilities ist, dass die für die Komprimierung verfügbaren Parameter vielfältig, komplex, und viele davon nirgends erklärt werden (nicht einmal die erlaubten Wertebereiche). So lässt sich "opj_compress" einfach verwenden indem man nur einen "Quality"-Parameter angibt, was jedoch nur für verlustfreie Komprimierung möglich ist. Wenn man verlustbehaftete Komprimierung, muss man unterschiedliche Parameter für unterschiedliche Phasen der Komprimierung angeben, welche offenbar bis zu 100 sein können. Bislang fand ich noch keine vernünftige Erkläerung nach welchen Kriterien man die Parameter-Werte auswählen sollte. Ein paar Beispiele verwenden fixe Werte ohne jede Erläuterung wie man darauf kommt.
libpdfbox2-java-2.0.27-2/java/raspbian {PDF}: Entgegen der Erwartung enthält dieses Paket auch Kommandozeilen-Tools zur Bearbeitung von PDF-Dateien. Allerdings sind sie reichlich umständlich aufzurufen und keine Hilfe dazu liegt bei. Der Aufruf lautet "java -cp :/usr/share/java/* org.apache.pdfbox.${TOOL}" wobei anstatt ${TOOL} einer der folgenden Applet-Namen eingesetzt werden muss: Decrypt, Encrypt, ExtractImages, ExtractText, OverlayPDF, PDFDebugger, PDFMerger, PDFToImage, PrintPDF, TextToPDF, WriteDecodedDoc. Auf anderen Plattformen existiert ein Wrapper-Script "pdfbox" zu diesem Zweck.
libpodofo-utils-0.9.7+dfsg-2/libdevel/debian {runtime utility library}: Kommandozeilen-Utilities welche intern die C++ Library "libpodofo" zur Manipulation von PDF-Dokumenten verwenden. podofobox (setzt die "media"-, "crop"-, "bleed"-, "trim" und "art"-Boxen für alle Seiten eines PDF-Dokuments), podofocolor (umwandeln von Farben in Graustufen oder mit einem Lua-Script), podofocountpages (zeigt die Anzahl von Seiten in PDF-Dokumenten an), podofocrop (beschneidet alle Seiten in einem PDF-Dokument, benötigt ein installiertes ghostscript), podofoencrypt (ändert den Zustand von PDF-Verschlüsselung), podofogc (entfernt alle unerreichbaren Objekte aus einer PDF-Datei), podofoimg2pdf (kann JPEG-, PNG- und TIFF-Dateien in Seiten eines PDF-Dokuments umwandeln), podofoimgextract (extrahiert alle enthaltenenen Bilder), podofoimpose (ordnet mehrere Einzelseiten auf kombinierten Seiten an), podofoincrementalupdates (kann die Anzahl inkrementeller Updates eines PDF-Dokuments ausgeben oder eine bestimmte Revision des Dokuments extrahieren), podofomerge (hängt mehere PDF-Dateien zusammen), podofonooc (undokumentiert, scheint irgend etwas namens OC_* zu entfernen), podofopages (verschiebt oder löscht Seiten), podofopdfinfo (zeigt diverse Informationen und Metadatem des Dokuments an), podofosign (kann eine X.509-basierte digitale Signatur anbringen sowie einer zugehörigen Textanmerkung und Grafikanmerkung um die Signatur optisch sichtbar zu machen; allerdings ist unklar ob diese Signatur irgend einem Standard entspricht), podofotxt2pdf (wandelt CP-1252 oder UTF-8 kodierten Text in eine PDF-Datei um), podofotxtextract (extrahiert den Text aus einer PDF-Datei), podofouncompress (entfernt die Komprimierung einer PDF-Datei so dass sie danach unkomprimiert ist), podofoxmp (extrahiert, entfernt oder ersetzt alle XML-codierten XMP Metadaten einer PDF-Datei).
librecad-20120614_git_81d4eb50/media-gfx/gentoo {2D}{CAD}: Ein fantastisch komfortables Konstruktionsprogramm für technisch orientierte 2D-Vektorgrafiken, wobei eine 3. Dimension in sehr begrenztem Maß durch die Unterstützung über einander liegender "Folien" realisierbar ist (wie etwa mehrere über einander liegende Stockwerke in einem Gebäudeplan). Es ist sehr intuitiv zu bedienen und die meisten Buttons tun genau das was man erwarten würde. Außerdem sieht die Qt-Oberfläche sehr hübsch und aufgeräumt aus. Der große Unterschied zwischen diesem Programm und anderen Vektor-Zeichenprogrammen ist die Ausrichtung auf exakte (leider gibt es hier ein Problem, siehe weiter unten) Zahlenangaben und Ausrichtung der geometrischen Objekte in Relation zu einander. Wo man bei anderen Zeichenprogrammen "mit der Hand einen Kreis aufzieht" der dann "in etwa" dort ist wo er sein soll, definiert man in LibreCAD einen Mittelpunkt und Radius in konkreten Zahlenwerten. Alternativ "snappt" man Mittelpunkt des Kreises und einen Randpunkt exakt an anderen bereits bestehenden Objekten an, wobei das Gitterraster nur eines von vielen möglichen Objektpunkten ist an die "gesnappt" werden kann. Eckpunkte, Tangentialpunkte, Mittelpunkte und Schnittpunkte mit verschiedener Objekte dienen ebenso als "Snap"-Punkte. Weiters kann man die Einheiten von Nanometern bis zu Lichtjahren frei einstellen, und so seiner Zeichnung maßstabsgetreuen Charakter geben. Das Programm speichert seine Zeichnungen im bekannten AutoCAD .dxf-Format (bzw. einem Subset davon), was sich wiederum in andere Programme zur Weiterbearbeitung importieren lässt. LibreOffice Draw kann etwa solche .dxf-Dateien importieren, wo man dann "Behübschung" betreiben kann wie 3D-Effekte und "Materialen" aufzutragen, während es in LibreCAD selbst nicht viel mehr als Schraffurmuster und Linienstärken gibt. Zeichnungen im LibreCAD werden normalerweise aus geometrischen Grundprimitiven wie Kreisen, Linien, Bogen und dergleichen zusammengesetzt, die auch oft nur temporär als Konstruktionshilfen dienen und danach wieder entfernt werden. LibreCAD ist besonders dort sinnvoll, wo es ums möglichst exakte Verarbeiten von vorliegenden Maßen und Koordinaten geht, wie in Konstruktions-, Gebäude- und Wohnungsplänen. Fürs "künstlerische Gestalten mit freier Hand" ist es hingegen wenig geeignet; da ist man mit InkScape oder LibreOffice Draw besser bedient. Der größte offensichtliche Mangel von LibreCAD ist das Fehlen jeglicher 3D-Funktionalität, von den "Folien" abgesehen. Das macht dieses Programm etwa ungeeignet, um damit Levels für moderne 3D-Spiele zu designen. Gleichwohl kann man mit LibreCAD die Konstruktion solcher Levels beginnen um einen maßstabsgetreuen Ausgangspunkt zu haben, und diese dann in echte 3D-Programme wie Blender importieren wo 3D-spezifische Erweiterungen hinzu gefügt werden, die selbst aber wenig Hilfen für exakte Konstruktion bieten. Der größte praktische Mangel von LibreCAD, der es praktisch leider unbrauchbar macht, ist der Umstand dass die ganzen schönen "Snap"-Funktionalitäten keine echten Verbindungen zwischen den beteiligten Objekten herstellen welche auch in den Datenstrukturen des Programms gespeichert würden. Sondern offensichtlich berechnen diese Funktionen nur die Koordinaten der entsprechenden Endpunkte. Der Unterschied wird rasch ersichtlich wenn man tiefer hinein zoomt: Durch die Ungenauigkeiten der Fließkommazahlen liegen Tangenten dann plötzlich nicht mehr am Kreis an, sondern enden nur irgendwo in der Nähe des Kreises. Entsprechend können sich durch die diversen geometrischen Transformationen diese Rundungsfehler auch akkumulieren, bis sie irgendwann auch mit freiem Auge und ohne besonders tiefen Zoom offenbar werden. Dieser Mangel ist sehr schade, denn die Bedienung und Benutzerfreundlichkeit des Programms ist ansonsten "top".
librep-0.17-r2/dev-libs/gentoo {programming language}{runtime utility library}: Vom Installationsbedarf her sehr kleiner LISP-Dialekt, der viele Vorzüge von Common LISP und Scheme zu kombinieren versucht. Im Gegensatz zu Minmallösungen wie TinyScheme hat es einen vergleichsweise reichhaltigen Runtime-Support, wie Perl-ähnliche regular Expressions, inexakte (double) und exakte Arithmetik (verwendet GNU-MP), String-Support und Hashes. Des weiteren unterstützt es CALL/CC. Es enthält auch einen optional verwendbaren Bytecode-Compiler (mit Peephole-Optimizer) und -Interpreter. Alles soweit ganz toll. Jedoch: CALL/CC ist genau so schwachsinnig implementiert wie in GNU GUILE, d. h. der Stack wird durch die Gegend kopiert. Daher Fazit: UNBRAUCHBAR. Ich will ein *effizientes* CALL/CC für meine Generator-Funktionen und benutzerimplementierte Coroutinen!
libsdl2-gfx-1.0-0-1.0.4+dfsg-4/libs/raspbian {graphics drawing}{runtime utility library}: Stellt grundlegende geometrische Grafik-Funktionen für das SDL-Framework zur Verfügung. Es gibt Funktionen zum Setzen einzelner Pixel; gerundete und normale Rechtecke; horizontale, vertikale und beliebige Linien; dicke Linien, Kreise, Ellipsen, kuchendiagrammförmige Objekte, Dreiecke, Polygone, Bezierkurven, Textausgabe. Viele der Primitiven stehen in mehreren Varianten zur Verfügung, z. B. mit oder ohne Anti-Aliasing, nur als Umrandung, oder gefüllt. Als Farben werden allgemein als RGBA-Werte direkt als Argumente übergeben; es gibt also keine separaten Funktionen zum Setzen der Zeichenfarbe. Koordinaten werden als vorzeichenbehaftete 16-Bit-Werte übergeben, Farben wahlweise als 4 separate Kanal-Komponenten oder als gepackter 32-Bit RGBA-Wert. Weiters werden einige grundlegende Filter angeboten, etwa für Boole'sche Operationen, sowie Funktionen zum Anwenden von Faltungsmatrizen der fixen Größen 3x3, 5x5, 7x7 und 9x9. Viele nicht explizit angebotene Filter wie Blur oder Sharpening kann man dadurch realisieren, indem man geeignete Faltungsmatrizen definiert und diese anwendet. Schließlich gibt es noch Funktionen zum Rotieren, Zoomen und natürlich Kopieren von Bildausschnitten. Leider scheinen (laut Dokumentation) die meisten der Filter-Funktionen nur auf CPU-Plattformen zu funktionieren welche MMX-Instruktionen bereit stellen; jene Funktionen sind daher wohl nur für die x86-Plattform verfügbar und somit nicht portabel.
libsm 1.2.2-2/extra/archlinux {runtime utility library}: Die X11 Session Management library stellt ein Framework bereit, welches uralte X11-Programme benutzten, ihren aktuellen Zustand beim Abmelden speichern zu können wenn sie davor dessen noch nicht beendet waren. Beim späteren Wieder-Anmelden konnten so die Applikationen erneut gestartet werden, und ihren gespeicherten internen Zustand wieder laden. Damit dies funktioniert, muss die Applikation von den Funktionen von libsm Gebrauch machen, und zusätzlich muss noch ein mit diesem Protokoll kompatibler Session-Manager laufen. So interessant das alles auch klingt, in der Praxis hat es leider so gut wie nie funktioniert. Außerdem haben große DTEs wie GNOME oder KDE ihre eigenen Erweiterungen des SM-Protokolls, was es noch unwahrscheinlicher macht dass jede Kombination von Client-Applikation und installiertem Session-Manager mit einander "können". Kurzum, libsm ist im wesentlichen eine Altlast, die niemals so richtig funktioniert hat und eher zu Problemen führt, wenn man es heute noch zu unterstützen versucht.
libsndfile1-1.2.0-1/libs/raspbian libsndfile-1.0.25/media-libs/gentoo {audio}{runtime utility library}: Eine Bibliothek zum Laden, Speichern und (dabei) On-The-Fly Konvertierung zwischen vielen verbreiteten Sound-Sample-Formaten. Version 1.2.0 unterstützt unter Debian (einige sind beim Paketbau konfigurationsabhängig) die nachfolgend aufgelisteten Formate. Dateiformate: Microsoft WAV, MP3, OGG/Opus, SGI / Apple AIFF / AIFC, Sun / DEC / NeXT AU / SND, Headerless RAW, Paris Audio File PAF, Commodore Amiga IFF / SVX, Sphere Nist WAV, IRCAM SF, Creative VOC, Soundforge W64, GNU Octave 2.0 MAT4, GNU Octave 2.1 MAT5, Portable Voice Format PVF, Fasttracker 2 XI, HMM Tool Kit HTK, Apple CAF, Sound Designer II SD2, Free Lossless Audio Codec FLAC. Codecs (soweit auch das jeweilige Dateiformat diese unterstützt): Unsigned sowie signed 8 bit; signed 16, 24 und 32 bit, 32/64 bit float, A-Law und µ-Law, IMA+MD ADPCM, GSM 6.10, G721 ADPCM @ 32 kbps, G723 ADPCM @ 24/40 kpbs, 12/16/24 bit DWVW, Ok Dialogic ADPCM, 8/16 bit DPCM. All diese Formate können sowohl gelesen als auch geschrieben werden. Oder anders formuliert, alle modernen weit verbreiteten Formate werden unterstützt, außer Matroska, AAC, AC-3 und E-AC-3.
libtiff-tools-4.2.0-1+deb11u1/graphics/debian {runtime utility library}: Mehrere Kommandozeilen-Utilities für Analyse und Bearbeitung von TIFF-Dateien. "fax2ps" (Postscript-Konvertierung von Fax-Dateien im TIFF-Format zum Zweck das Ausdruckens), "fax2tiff" (TIFF-Datei aus Fax-Rohdatenformat erzeugen), "pal2rgb" (konvertiert ein paletten-basiertes TIFF in ein 24 oder 48 Bit RGB TIFF), "ppm2tiff" (wandelt jedes PNM-Format in eine TIFF-Datei um), "raw2tiff" (TIFF-Datei aus binärem Rohformat erzeugen, binäres Pixelformat mittels Kommandozeilen-Optionen angegeben), "tiff2bw" (wandelt Farb-TIFF in Graustufen), "tiff2pdf" (erzeugt ein PDF-Dokument aus einer optional mehrseitigen TIFF-Datei), "tiff2ps" (wandelt eine TIFF-Datei in PS oder EPS um), "tiff2rgba" (Umwandlung in TIFF mit Alpha-Kanal), "tiffcmp" (zeigt Unterschiede in Bilddaten aber auch Metadaten an), "tiffcp" (kopiert und/oder konvertiert eine TIFF-Datei), "tiffcrop" (beschneidet oder transformiert TIFF-Dateien), "tiffdither" (Graustufen zu S/W Konvertierung mit Dithering), "tiffdump" (Low-Level-Infos über eine TIFF-Datei), "tiffinfo" (High-Level Infos über eine TIFF-Datei), "tiffmedian" (einen "median-cut" filter anwenden), "tiffset" (Datenfelder im TIFF-Header setzen oder löschen), "tiffsplit" (mehrseitige TIFF-Dateien in mehrere einseitige zerlegen).
libtracker-sparql 1.6.1-3/extra/archlinux {audio}{music}{runtime utility library}: Zwar behauptet die Paketbeschreibung dass dieses Paket auch ein "search tool" enthalten würde, tatsächlich enthält es aber nur eine Bibliothek welche besagte Funktionalität unterstützt. Wenn man gewillt ist eine Front-End-Applikation dafür zu schreiben, am besten in VALA da nur Bindings dafür sowie aber auch für das glib-Framework mitgeliefert werden, ist diese Bibliothek vermutlich ganz brauchbar. Der eigentliche Datenbank-Kern scheint auf SQLite aufzubauen. Da es auch von der ICU und PRCE-Library abhängt, darf man sich vermutlich UNICODE-Unterstützung und die Verwendbarkeit mächtiger Regular Expressions in SPARQL-Abfragen erwarten.
libx11 1.6.3-1/extra/archlinux {runtime utility library}: Die "X11 client-side library" ist die unterste aller Basis-Bibliotheken des klassischen X11. Sie implementiert ein API, um das X11 Protokoll benutzen zu können, mit dem X11 server und X11 clients mit einander kommunizieren und Befehle bzw. Ergebnisse austauschen. Diese Bibliothek hat einige historisch bedingte Einschränkungen; neue Anwendungen sollten besser die libxcb nutzen.
libxau 1.0.8-2/extra/archlinux {runtime utility library}: Die X11 authorisation library bietet alle Funktionen zum Erzeugen, Verwalten und Verifizieren von X11 Session Cookies. Sie stellt die Funktionen zur Verfügung, auf denen Utilities wie "xauth" und "xdm" aufbauen.
libxaw 1.0.13-1/extra/archlinux {runtime utility library}: Die X11 Athena Widget library ist ein X11 "Toolkit", d. h. sie stellt Buttons, Schieberegler und andere GUI-Basiskomponenten zur Verfügung, genau wie Qt oder GTK+. AW ist (neben dem kommerziellen Konkurrenten Motif) für das nach heutigen Maßstäben unendlich hässliche und Würgereflexe herauf beschwörende Aussehen uralter X11-Applikationen verantwortlich. Auf der anderen Seite haben derartige Applikationen auch sehr geringe Ressourcen-Anforderungen, verglichen mit modernen Anwendungen. AW-Widgets stehen generell unter der Kontrolle von Geometrie-Managern. Es gibt "Box" zum vertikalen oder horizontalen Stapeln von Widgets, "Tree" zum Anordnen in einer aufklappbaren baumförmigen Liste, "Porthole" für Karteireiter-Registerkarten, "Paned" für vertikale oder horizontale Listen, die in der jeweils anderen Dimension aufgefüllt werden sobald der Platz der ersten Spalte oder Reihe aufgebraucht ist, "Viewport" als durch Scrollbalken verschiebbaren Ausschnitt aus einer "inneren" Anordnung von Widgets, "Form" wo jedes Widgets beliebige Abstände von einer der Seiten eines anderen Widgets oder Ankerpunktes festlegen kann, die beim Resizen relativ erhalten bleiben. Fast alle Eigenschaften des Aussehens aller Widgets wie Farben, Schriftarten etc. lassen sich, soweit sie nicht direkt von der Applikation angegeben werden, über X11 RESOURCES anpassen, wie sie von "xrdb" geladen werden. Leider muss man, um die Namen der vefügaren RESOURCES zu erfahren, die Anleitung von AW lesen, was kaum ein User jemals tun wird. Die Maintainer von linxaw empfehlen, es nicht mehr für moderne Applikationen zu verwenden.
libxcb 1.11.1-1/extra/archlinux {runtime utility library}: Diese neuere Version der "X11 client-side library" ist die unterste aller Basis-Bibliotheken des klassischen X11. Sie implementiert ein API, um das X11 Protokoll benutzen zu können, mit dem X11 server und X11 clients mit einander kommunizieren und Befehle bzw. Ergebnisse austauschen. Diese Bibliothek bietet dieselbe Funktionalität wie die historische libX11, arbeitet jedoch effizienter und hat weniger Einschränkungen. Neue Anwendungen sollten besser diese Bibliothek statt der historischen nutzen.
libxext 1.3.3-1/extra/archlinux {runtime utility library}: Die X11 miscellaneous extensions library stellt APIs für mehrere X11-"Standard"-Extensions zur Verfügung. Konkret: DBE (Double Buffering sowie Stereo Extension), DPMS ("Display Power Management Signaling" - Stromsparmodus des Bildschirms), XShm (Shared Memory Extensions), EVI (Extended Visual Information extension), XShape (Nonrectangular Window Shape Extension), SYNC (Synchronization Extension, zur strikten Serialisierung der eigentlich asynchron event-basiert ablaufenden Interaktion zwischen X11 Clients und Servern - typischerweise beim Debugging von GUI-Anwendungen hilfreich), XTEST (Aufzeichnen und Synthetisieren von Eingabe-Events, etwa zur Testautomatisierung).
libxmu 1.1.2-1/extra/archlinux {runtime utility library}: Die X11 miscellaneous micro-utility library enthält allgemeine Hilfsfunktionen unterschiedlichster Art, die von der Athena Widget Library benötigt werden. Umgekehrt hängt libxmu aber auch von Athena Widgets ab. Warum diese beiden Libraries getrennt sind, weiß wohl niemand. Vermutlich nur deshalb weil verschiedene Entwickler daran arbeiteten. libxmu enthält Funktionen zum Atom-Management, eine portable snprintf()-Implementation (mit anderem Namen) bevor diese mit C99 standardisiert wurde, Hilfsfunktionen fürs Fenster- und Cursor-Management, zusätzliche Grafikfunktionen wie etwa für Rechtecke mit gerundeten Ecken, Konvertierung von X SELECTION-Datentypen, Umzandlung zwischen Text und Datentypen wie Farben oder Bitmap-Daten, -Icons und -Cursors, veraltete nicht UNICODE-fähige Funktionen für Zeichensatzumwandlungen und Tastatur-Events, Farbpaletten-Funktionen, API für das EditRes-Protokoll uralter X11-Applikationen.
libxpm 3.5.11-1/extra/archlinux {runtime utility library}: Die X11 pixmap library enthält Routinen zum Lesen und Schreiben von *.xpm-Dateien, einem textbasierten Bitmap-Datenformat das mangels Komprimierung und sehr ineffizientem Speicherformat nur für kleinere Bildgrößen sinnvoll ist. Etwa für (kleine) Icons oder Cursor-Formen. Das Paket enthält auch Utilities zum Anzeigen und Konvertieren von XPM-Dateien. Der größte Vorteil vom xpm-Dateien ist es, dass man sie auch ohne jedes Grafikprogramm alleine mit einem Texteditor bearbeiten oder anzeigen kann. Da ein Pixel oft als zwei Zeichen dargestellt wird, eignet sich das Format kaum für Breiten die wesentlich über 40 bis 64 Pixel hinaus gehen, da man die Datei dann nicht mehr vernünftig ohne Zeilenubruch im Editor anzeigen kann. XPM-Dateien sind grundsätzlich Paletten-orientiert, auch wenn die Palette beliebig groß sein kann, und man daher theoretisch für jedes Pixel einen eigenen Paletten-Eintrag definieren könnte. Es gibt verschiedene Format-Varianten von XPM, wobei vor allem diejenige bekannt ist welche ein kompilierfähiges C-Programm (-fragment) darstellt. Andere Varianten haben Ähnlichkeit mit der PNM-Formatfamilie (Portable "Any"-Map), welche aber wesentlich beliebter (da simpler aufgebaut - keine Farbpaletten) ist.
libxt 1.1.5-1/extra/archlinux {runtime utility library}: Diese sogenannte "X11 toolkit intrinsics library" implementiert das Basis-Framework, auf dem klassische X11-Toolkits wie Athena Widgets aufbauen. Es bietet ein Framework für Widget-Klassen, Geometrie-Manager, Event-Handling, X Resources - implementiert aber selbst nichts davon (außer gemeinsame Basisklassen zum späteren Ableiten). Mit anderen Worten, es stellt den Kern klassischer X11-Anwendungen dar, steuert aber nur administrative Funktionen bei, und kaum welche die für sich selbst genommen etwas sinnvolles tun. Diese Library wird daher normalerweise nur von anderen Toolkit-Libraries verwendet, während der Anwendungsprogrammierer kaum damit in Berührung kommt. Außer er will sich eigene Widgets implementieren.
licq-1.3.8-r1/net-im/gentoo: Ein Qt4-basierter Instant-Messager, rund 10 MB gepacktes Quelltext-Archiv. Macht einen sehr netten Eindruck und beherrscht ICQ, AIM (Protokoll OSCAR) und MSN (per Plugin). Großer Nachteil: Es scheint keinen freien Server für diese Protokolle zu geben, nur proprietäre. Dort kann man sich zwar kostenlos anmelden, aber zumindet offiziell ist die Nutzung von alternativen Clients wie eben licq mit diesen Servern nicht gestattet. Das hält zwar vermutlich niemanden auf, aber es hinterläßt ein in rechtlicher Hinsicht ungutes Gefühl.
lincity/games-simulation/gentoo {game}: Ein nett nachprogrammiertes SimCity. Leider versteift es sich auf ein 640 x 480 Fenster und ist auch nicht in der Lage diese Auflösung eingenständig einzuschalten bzw. einen Fullscreen-Modus anzubieten. Daher auf aktuellen Rechnern eher sinnlos bzw. zu mühsam wenn man selbst die Auflösung umschalten muss. (Und bei einem LCD grundsätzlich problematisch.)
lineakd-0.9.0-r1/x11-misc/gentoo: Noch ein Daemon für die Auswertung von Multimedia-Tasten auf diversen Eingabegeräten. Ich habe das Programm nicht weiter getestet nachdem ich bereits zuvor eine Lösung mit xmodmap gefunden hatte. Was mir allerdings auffiel war dass in der man-Page ein grafisches GUI-Tool zur Konfiguration angepriesen wird, aber keines der lineak-basierten Pakete implementiert so ein Programm. Allerdings mag das auch daran liegen dass ich nicht alle USE-Flags gesetzt habe. Grundsätzlich dürfte das Programm etwas taugen; falls man mit x11-misc/keytouch nicht glücklich wird kann man sich dieses Programm als nächstes ansehen.
linux-raspberrypi 4.1.10-2/core/archlinux: Dieses Paket enthält sowohl das auf den Raspberry Pi abgestimmte Linux-Kernel "kernel.img" samt Kernel-Modulen als auch die Default-Konfigurationsdateien "cmdline.txt" und "config.txt". Kurzum, es ist das wichtigste aller Pakete von Arch Linux ARM. Schließlich enthält es auch noch die binären Device-Tree-Overlay-Dateien (*.dtb), die in zum größten Teil in /boot/overlay abgelegt werden. Um die Quelltext-Versionen dieser Dateien zu dekompilieren, ist ein Tool aus dem Paket alarm/dtc-overlay erforderlich.
linux-raspberrypi-headers 4.1.10-2/core/archlinux: Diese Paket enthält die Header-Files des Linux-Kernels, die benötigt werden um externe Kernel-Module auf der lokalen Maschine bauen zu können, obwohl man nicht den Quelltext des gesamten Kernels installiert hat.
linuxinfo-1.1.8-44/utils/debian: Zeigt kaum mehr an als "uname -a" und "cat /proc/cpuinfo". Jämmerlich. Ein völlig unnötiges Tool.
lisa/kde-base/gentoo: A KDE-specific network file transfer / sharing protocol much like SAMBA, NFS, FTP etc. Can only connect between different KDE sessions across the network. Not a standard protocol at all. However, nicely integrated into konqueror and the GUI via kioslaves. Not especially good for anything, but might save you the burden of installing and configuring a *real* network client/service like NFS.
literki-0.0.0+20100113.git1da40724-1/embedded/debian: Ein mit 3 MB Installationsumfang noch erträglich großes Onscreen-Keyboard. Ist auch über Konfigurationsdateien anpassbar. Leider stürzt es zumindest am Raspberry Pi sofort mit einem Speicherzugriffsfehler ab. Spätere Versionen erneut evaluieren.
lives-1.4.6/media-video/gentoo {video-editor}: Ein in Perl, Python und C geschriebener nicht-linearer Video Editor. Hat eigenartige Ansprüche ans Audio-Backend - Pulseaudio, JACK oder SOX (wtf?) - ALSA alleine genügt jedenfalls nicht. Verwendet den mplayer im Hintergrund, um importierte Videoformate zu dekomprimieren. Kann optional das libvisual-Framework für Audio-Visualisierung verwenden. Weiters muss man ein spezielles Verzeichnis für Temporärdateien angeben - das Programm legt diese nicht einfach im Arbeitsverzeichnis an. Das Programm preist seine Resistenz gegen Datenverlust an; vermutlich speichert es irgendwie inkrementell. Laut einem Testbericht aus 2013 funktioniert lives einigermaßen, hat aber die irre Idee alle importierten videoclips in Einzelbilder zu zerlegen und jeden einzelnen Frame als Datei zu speichern. Wenn das stimmt wäre es völlig irre vom Platzbedarf her. LiVES arbeitet Auflösungs- und Framerate-unabhängig, ist in vielen Sprachen und Linux-Distributionen verfügbar. LiVES wird auch als "VJ-Tool" betitelt, weil es auch Realtime-Mixing (dann aber mit reduzierter Qualität) beherrscht. In meinem Test machte LiVES zwar einen guten Eindruck was die Fülle der Funktionen in den Menüs betrifft; offenbar ist es kein simples Programm für schlichte Ansprüche. Allerdings war bereits der Preferences-Dialog so buggy, dass das Dialog-Fenster ständig so stark am Bildschirm herumwabbelte, so dass man nicht erkennen geschweige denn etwas eingeben konnte. Derzeit daher unbrauchbar, macht aber einen guten Eindruck.
lm_sensors/sys-apps/gentoo {resource monitor}: Backend for LM Sensors motherboard hardware sensor framework. Surely useful. But not without correct configuration.
lmdb-utils-0.9.18-5/database/devuan: Command line utilities for the Lightning Memory-Mapped Database (LMDB). LMDB ist a super-fast lightweigt key-value store, but it has some limitations: Max key size (MDB_MAXKEYSIZE = 511 bytes). This is a compile-time option, and can't be changed at runtime. Records are grouped into pages matching the operating system’s VM page size, which is usually 4096 bytes. Each page must contain at least 2 records, in addition to 8 bytes per record and a 16 byte header. Once the environment is full (default as 10 MB), once, following writes will fail. There also limits on the number of databases (default 5), the maximum number of readers (default 126) and transactions must not perform "too many" writes or they will fail.
lmms-0.4.10/media-sound/proaudio/gentoo {audio}{music}: Linux Multimedia Studio ist eine freie Nachahmung des kommerziellen Fruity Loops und ähnlicher Systeme. Es handelt sich um eine vollständige integrierte grafische Umgebung für das Erstellen vom Musik. Es enthält dazu sowohl Komponenten zum Erstellen der abzuspielenden Noten, als auch Module zum Synthetisieren der einzelnen Instrumentenklänge inklusive Drum-Kits und Effekt-Geräte. Eine Besonderheit dieses Programms ist der Umstand dass es zwar Plugins für die Einbindung externer Musikgeräte gibt (etwa MIDI-Keyboards oder -Synthesizer), aber im Kern benötigt dieses Programm nichts weiter als eine primitive Soundkarte die Stereo PC-Sound ausgeben kann, und erledigt alles andere mit der CPU in Software. Selbst der billigste Büro-PC kann so zur Sound-Maschine werden. Und eigentlich braucht der PC überhaupt keine Soundkarte, da man die erzeugte Musik auch als Audio-Datei speichern kann ohne sie lokal. wiederzugeben. GUI mit zahlreichen zuschaltbaren Editor-Fenstern. Unzählige einstellbare Effekte, Instrumenten-Parameter und Plug-Ins. Grundsätzlich ist es eine lineare Abfolge von Noten bzw. Effekt-Settings, aber insbesondere für Drum-Sections gibt es auch Patterns die man wiederholen lassen kann. Piano-Roll-Editor und Pattern Editor sind die hauptsächlichen Eingabe-Editoren, es gibt aber noch zahlreiche weitere Editoren für diverse Effekte. Unabhängig von den Song- und Instrument-bezogenen Editoren gibt es noch ein Effect Rack für globale Effekte (Reverb-, Echo-, Delay-, Stereo-Effekte etc). Durchaus beeindruckend.
lp-solve-5.5.2.5-2/math/debian {math}: Programm zur Optimierung einer linearen Zielfunktion (beliebiger Dimension) mit Nebenbedingungen welche sowohl Gleichungen als auch Ungleichungen sein können, oder die Bedingung dass bestimmte Variablen ganzzahlige Werte einnehmen müssen. Die Eingabe erfolgt in normaler Texform, welche vom Programm geparst wird.
lpsolve-5.5.2.0/sci-mathematics/gentoo: Eine LGPL-Bibliothek sowie ein Kommandozeilentool zum Lösen linearer Optimierungsprobleme mit Unterstützung bedingter Ganzzahligkeit. Für letzteres Tool formuliert man das Problem einfach als Text in Form mehrerer Ungleichungen und Nebenbedingungen, und das Tool druckt die Lösung aus. Ein Vorteil dieses Pakets gegenüber anderen ist der Umstand dass es vom Solver der LibreOffice-Tabellenkalkulation benötigt wird, und daher mit hoher Wahrscheinlichkeit bereits installiert ist.
lrzip-0.631+git180528-1/utils/debian {compression}: Eine "Long-Range"-Variante eines "Zip"-ähnlichen Programms. Obwohl die einzige Ähnlichkeit mit dem bekannten Zip-Dateiformat wohl daher stammt dass beide Programme komprimieren können. Tatsächlich gehört das von diesem Paket bereit gestellte "lrzip"-Utility zu den leistungsstärksten Komprimierungsprogrammen, insbesondere wenn es mit den Optionen "lrzip -L9 -z -U -q" aufgerufen wird (das "-q" ist dabei optional und verhindert nur die Fortschrittsanzeige beim Packvorgang, was vor allem über SSH-Verbindungen vorteilhaft sein kann). Allerdings erkauft lrzip seine Effizienz mit riesigem Speicherplatzbedarf sowohl beim Dekomprimieren aber auch beim Komprimieren. Man sollte zumindest so viel RAM haben wie die zu komprimierende Datei groß ist, und am besten noch deutlich mehr. Auf heutigen Rechnern mit Dutzenden GB RAM zwar selten ein Problem, aber es gibt ja auch Minirechner mit nur wenig RAM die dann solche Archive nicht einmal auspacken können. In solchen Fällen sollte man die "-U"-Option weglassen wodurch die Effizienz sich zwar mindert, aber auch der Speicherplatzbedarf sinkt. Überdies kann man mit anderen Optionen auf einen konkreten Maximalen RAM-Verbrauch festlegen; die Stärke der Komprimierung sinkt dann entsprechend ab. Aber auch ohne die oben erwähnten Extrem-Optionen erzeugt lrzip häufig immer noch kleinere Dateien als alle anderen Komprimierungsprogramme. Ohne die Extrem-Optionen wird zudem sowohl das Komprimieren als auch das Dekomprimieren deutlich schneller. Die Grundidee von lrzip ist es, ein riesiges "Fenster" von zumindest mehreren MB (bzw. der gesamten Dateigröße wenn sie kleiner ist) für die Komprimierung zu benutzen, was die meisten anderen Komprimierungsprogramme aus Furcht zu viel RAM zu verbrauchen in der Regel nicht tun. Dadurch erkennt lrzip viel mehr identische Bytefolgen als die anderen Programme, da sie weiter von einander entfernt liegen können, und nutzt dies bei der Komprimierung aus. lrzip selbst leistet auch nur diese "Vorarbeit", für die eigentliche Komprimierung der bereits deduplizierten Bytefolgen nutzt es dann andere Programme bzw. deren Komprimierungs-Algorithmen. lrzip ist also im Grunde nur ein Präprozessor für altbekannte Komprimierungs-Algorithmen, allerdings ein sehr wirkungsvoller Präprozessor. Dieser preprocessing-Algorithmus wird von lrzip selbst als "rzip" betitelt, darüber hinaus bietet es über Optionen wählbar unterschiedliche Standard-Kompressionsalgorithmen für die Backend-Komprimierung an (diese Algorithmen komprimieren also die Ausgabe des "rzip"-Präprozessors noch weiter). An Backend-Algorithmen stehen folgende zur Verfügung: "gzip" für sehr hohe Geschwindigkeit (fürs Backend, "rzip" allein braucht schon einige Zeit), "bzip2" (vor allem bei reinen Texten eine gute Wahl und dann auch deutlich effektiver als "gzip" obwohl immer noch sehr schnell), "lzo" für höchste Geschwindigkeit (aber lausige zusätzliche Kompression, angeblich jedoch immer noch vergleichbar mit bzip2 auch wenn ich das für eine Lüge halte), "no compress" um das Backend komplett abzuschalten und nur mit "rzip" zu komprimieren, "zpaq" für die stärkste Kompression aber auch riesigen Zeitbedarf (Stunden bei Multi-Gigabytedateien, bei kleineren Dateien aber in der Regel noch erträglich) sowie "lzma" als Default-Komprimierung (die zweitstärkste Komprimierung nach zpaq jedoch sehr viel schneller) wenn man keine spezielle Backend-Komprimierung auswählt. Per Default (abschaltbar) wird im Falle der "zpaq" und "lzma"-Backend zunächst getestet ob "lzo" die Daten komprimieren könnte; ist dies nicht der Fall wird davon ausgegangen dass es sich um nicht weiter komprimierbare Daten handelt und die Backend-Kompression wird übersprungen. So vermeidet man sinnlosen Rechenaufwand für lzma und zpaq zu vergeuden wenn eine Datei bereits offensichtlich komprimiert ist (etwa Videodateien). lrzip nützt standardmäßig alle CPU-Kerne die es vorfindet um die Bearbeitung zu beschleunigen; dies lässt sich aber über Optionen einschränken oder abschalten. lrzip kann ähnlich wie gzip nur eine einzige Datei komprimieren. Es werden jedoch die Wrapper-Utilties "lrztar" und "lrzuntar" mitgeliefert, welche als Argumente spezifizierte Dateien und Verzeichnisse (samt Inhalt inklusive Unterverzeichnisse) zunächst temporär in ein TAR-Archiv verpacken und erst dieses dann mit lrzip komprimieren. Es sind auch weitere Wrapper enthalten, nämlich "lrunzip" welches lrzip mit den Optionen zum Dekomprimieren aufruft sowie "lrzcat" welches eine lrzip-komprimierte *.lrz-Datei temporär dekomprimiert und das Ergebnis in die Standardausgabe schreibt. Schließlich bietet lrzip noch ein Option um alle Dateien in einem Verzeichnisbaum rekursiv mit lrzip zu packen, genau so wie man auch mehr als eine Datei direkt auf der Kommandozeile zum Packen angeben kann. Doch diese Dateien werden dann immer einzeln gepackt oder entpackt (was mittels der "-d"-Option genau so möglich ist). Diese Möglichkeit mehrere Dateien mit einem Aufruf zu komprimieren oder entpacken unterscheidet lrzip von ansonsten konzeptionell ähnlichen gzip (technisch besteht allerdings ein Riesenunterschied, lrzip packt um Größenordnungen besser). Es wird allerdings noch ein letzter Wrapper "lrz" mitgeliefert, der aufrufkompatibel zu gzip ist jedoch mit dem *.lrz Dateiformat von lrzip arbeitet. Standardmäßig enthält jede .lrz-Datei eine MD5-Prüfsumme um Korruption zu erkennen; man kann dies allerdings abschalten um noch ein paar Bytes mehr zu sparen wenn man dabei einen Rekord aufstellen möchte. lrzip arbeitet weiters per Default so als hätte man es mit "nice -n 19 lrzip" aufgerufen, und überlässt daher anderen laufenden Prozesse die Rechenzeit wenn diese sie brauchen. Natürlich lässt sich auch das anpassen. lrzip bietet weiters optionale AES-128 Verschlüsselung an, wobei das anzugebende Passwort bis zu 500 Zeichen lang sei darf und mit SHA-512 in den eigentlich zu verwendenden Schlüssel gehashed wird. Überdies wird ein zufälliges Salt automatisch hinzu gefügt, so dass diese Verschlüsselung eigentlich sehr sicher sein sollte. Oder zumindest so sicher wie man AES selbst als Algorithmus vertrauen möchte, dessen Sicherheit ständig von der NSA gepriesen wird dass jeder es verwenden möge obwohl sie für eigene Zwecke interessanter Weise lieber andere Algorithmen wie etwa RC6 zu benutzen scheint, wie geleakte Angriffswerkzeuge verraten. Dennoch, gegen Angreifer abseits der NSA dürfte die lrzip-Verschlüsselung sehr sicher sein. lrzip ist ein Nachfolger des früheren Programms "rzip", welches denselben preprocessing-Algorithmus verwendete, jedoch immer nur bzip2 als Back-End, und vermutlich auch beim Preprocessing-Algorithmus gab es die eine oder andere Verbesserung. In Summe ist lrzip jedenfalls das leistungsstärkste mir bislang bekannte Komprimierungsprogramm welches auch weithin implementiert und verfügbar ist, insbesondere bei Nutzung des zpaq-Backends, was wegen der exorbitanten Rechenleistungs-Erfordernis aber nur bei relativ keinen Dateien bis zu ein paar Dutzend MB größe sinnvoll ist. Darüber hinaus fährte man mit den Default-Optionen besser, und bei sehr großen Dateien kann "lzo" am besten sein. Trotz aller Vorteile hat lrzip unabhängig von Backend den Nachteil, dass es nicht "rsync-freundlich" ist. Das bedeutet, man kann im Falle von Updates weder mit rsync noch xdelta3 noch zsync Transfer-Volumen einsparen. Obwohl lrzip im Falle von Komplettdownloads von Dateisystem-Abbildern den kleinsten komprimierten Download erzeugen kann, kann es daher sinnvoll sein für jene Anwender welche bereits eine ältere Version der Abbilddatei besitzen zusätzlich eine lediglich .gz-komprimierte Version des Abbilds zum Download anzubieten, welche mit der "--rsyncable"-Option von "gzip" erstellt wurde. So können die Besitzer einer älteren Version der Abbild-Dateien nur deren Änderungen herunterladen und daraus die neue Datei rekonstruieren, anstatt die ganze neue Datei herunterladen zu müssen. Allerdings erfordert dies den Betrieb eines rsync-Dienstes am Download-Server. Dies kann man vermeiden indem man zusätzlich eine *.zsync-Datei für die *.gz-Datei zum Download anbietet, wodurch Downloader mit dem zsync-Utility ähnlich wie bei rsync nur die Unterschiede herunter laden können, wobei dann ein "dummer" Webserver ausreicht und kein rsync-Server mehr vonnöten ist.
lsat-0.9.7.1-r1/app-admin/gentoo: Prüft anhand etlicher integrierter Module auf einzelne Aspekte, die bei einem normalen UNIX-System der Fall sein sollten. So prüft es beispielsweise dass alle Dateien in /usr nur "root" gehören, dass /tmp die richtigen Berechtigungen hat, ob sich Netzwerk-Interfaces im Promiscuous-Modus befinden und andere verdächtige Aktivitäten. Sicherlich kann man das alles ganz toll konfigurieren, aber mich nervte in der Default-Konfiguration dass das Prüfen der Zugriffsrechte in /usr "ewig" dauerte, und dann begann er auch noch MD5-Prüfsummen aller Dateien zu erzeugen - keine sehr gute Idee bei einer 3 TB-Platte. Daher wieder deinstalliert, den Schrott. Sicherlich nützlich und sinnvoll auf einem Rechner wo man Einbrüche und Hacker erwartet; etwas Overkill auf von Haus aus relativ sicheren Systemen auf denen nur wenige Dienste laufen.
lsdvd-0.16-r1/media-video/gentoo: Kann diverse Informationen über die Streams, Cells und Chapters einer DVD auslesen und in einem menschenlesbaren oder in für mehrere Programmiersprachen verwendbaren Quelltext-Formaten ausgeben.
lsh-client-2.1-12/net/debian: lsh-server-2.1-12/net/debian: lsh-utils-2.1-12/net/debian: lsh ist eine alternative und ältere SSH-Implementation als OpenSSH. Es unterstützt nur die "klassischen" Algorithmen früherer openssh-Versionen sowie als neuestes AES-256. RSA aber natürlich ebenfalls. Kein elliptischer Kurven-Kram. Dafür "The SRP Authentication and Key Exchange System" (RFC 2945). Der Server hat kein Konfigurationsfile; alle erforderlichen Optionen welche von den Defaults abweichen müssen ausnahmslos über die Kommandozeile angegeben werden. lsh kann in einem Gateway-Modus arbeiten der Connection-Sharing erlaubt. lsh kann auch als SOCKS-Proxy agieren um SOCKS-Verbindungen durch einen SSH-Tunnel zu leiten. Kerberos ist geplant, wird jedoch noch nicht unterstützt. RSA-Schlüssel werden unterstützt. TCP-und X11-Forwarding wird unterstützt. lsh holt benötigte Zufallszahlen aus einem Seed-File welches man vor der ersten Nutzung anlegen muss. Die Umsetzung geschieht mit dem YARROW-256 Algorithmus der libnettle. Die Präsentation der Fehlermeldungen könnte besser sein: In einigen Fällen stürzte ein Utility einfach mit einem Segfault ab - und erst im Debugger sah ich dann, dass *vor* der Segfault-Meldung eigentlich ohnehin eine aussagekräftige Fehlermeldung angezeigt worden war. Weiters haben einige Utilities geistesgestörte Optionen, wie etwa das Passwort direkt in der Kommandozeile anzugeben. (Zum Glück nur optional.)
ltpanel-0.2-5/x11/debian {desktop panel}: Zeigt eine sehr minimalistische Task-Liste der laufenden GUI-Programme für noch minimalistischere Fenster-Manager an, die nicht über die Möglichkeit verfügen selbst eine Task-Liste anzuzueigen. Weitere Funktionalität, wie benutzerdefinierbare Buttons oder gar ein "Startmenü", gibt es nicht. Die Task-Liste besteht aus einem 2-dimensionalen Gitter aus länglichen Buttons, welche die einzelnen laufenden GUI-Programme repräsentieren. Anzahl der Zeilen und Spalten im Gitter lassen sich konfigurieren, ebenso die Position wo am Bildschirm die Task-Leiste angezeigt werden soll. Links an der Leiste befindet sich noch ein Griff als könnte man sie damit verschieben, doch er hat keinerlei Funktion. Das Programm scheint auch keine Konfigurationsdatei zu benutzen. Die Mausknöpfe lösen in der Liste fix definierte Aktionen aus, wie das Fenster zu aktivieren oder zu minimieren. Für solch ein primitives Programm sieht es optisch nicht einmal schlecht aus, auch wenn man natürlich keinen Support für Outline-Fonts erwarten darf. Dass das Programm trotz seiner minimalen Funktionalität dennoch 18 KB lang ist, liegt offenbar daran dass einige Bitmaps im XPM-Textformat im Executable eingebettet zu sein scheinen.
lua-lgi 0.9.0-1/extra/archlinux: Ein GTK+-wrapper für Lua 5.3, der auf GTK+s "gobject-introspection" aufbaut, und daher theoretisch hochportabel (wenn auch nicht sonderlich effizient) funktionieren sollte und ABI-Abhängigkeiten auf ein Minimum reduzieren. In der Praxis versagt allerdings bereits gut die Hälfte der mitgelieferten Demo-Scripts, indem sie mit einem "Stack Overflow"-Fehler abstürzen. Vermutlich sind noch fehlende Anpassungen an das neue Lua-C-API an den Problemen schuld, und werden hoffentlich irgendwann behoben werden. Nichts desto trotz, zumindest derzeit ist diese LGI nahezu unbrauchbar.
luajit-2.0.2/dev-lang/gentoo: Ein JIT-Compiler für die Lua Scriptsprache. Kann als Drop-In-Replacement für das normale Lua Interpreter-Front-End verwendet werden. Allerdings leider nur als die 5.1-Version von Lua, wobei gerade 5.3 aktuell ist und es darin doch deutliche Verbesserungen seit 5.1 gab. Meinen Messungen zufolge war die JIT-Version ca. 15 x so schnell wie der Interpreter und schaffte eine Milliarde Additionen in 1,8 Sekunden während das normale Lua dazu 26,6 Sekunden benötigte. Als wirklich langsam kann man das aber ebenfalls nicht bezeichnen. Zum Vergleich: Ein unoptimiertes C-Programm benötigte 6,4 Sekunden, ein optimiertes 2,6 Sekunden. Es war somit deutlich *langsamer* als Luajit! Als ich das C-Programm dann auf Ganzzahlen umstellte (Lua 5.1 kennt ja nur Fließkommazahlen), benötigte es 3,9 Sekunden unoptimiert und 1,7 Sekunden optimiert und war damit nur um eine Winzigkeit schneller als Luajit. Auf meinem Athlon64 Prozessor ist 64-Bit Fließkomma-Arithmetik somit samt allgemeinem Overhead des Programms darum herum rund 2,5 x so langsam wie 64-Bit-Integer-Arithmetik. Luajit kann demzufolge unnötige Fließkommaarithmetik offenbar intern bei nur sehr geringem zusätzlichem Zeitaufwand durch Ganzzahlarithmetik austauschen, und ist insgesamt fast genau so schnell wie optimierter C-Code. Andererseits war mein Testprogramm ein gefundenes Fressen für jeden JIT-Compiler da es nur aus einer kleinen sehr häufig durchlaufenen Schleife bestand, und es stellt sich die Frage wie gut diese Messungen bei umfangreicheren Programmen skalieren würden. Aber dennoch sehr beeindruckend. Sollte Luajit einst den Lua 5.3 Sprachstandard unterstützen, wäre es möglicherweise eine praktikable Alternative zu C. Mit dem veralteten 5.1-Standard will ich mich allerdings nicht mehr weiter beschäftigen müssen.
luola-1.3.2-10+b1/games/devuan {game}: Bis zu 4 Spieler spielen auf einem geviertelten Bildschirm ein "Thrust"-ähnliches Spiel; allerdings gegeneinander. Also Schub geben und dabei gegen die Schwerkraft ankämpfen während man sich gegenseitig abballert. Grafisch nicht sonderlich aufwändig, kann aber für eine Weile Spaß machen. Allerdings durch das wenig abwechslungsreiche Spielprinzip keine sonderliche Langzeitmotivation. Vor allem ist es uninteressant alleine zu spielen, da es keine Computergegner gibt. Die Steuerung erinnert ein wenig an "Space Taxi", mit dem Unterschied dass Kollisionen selten tödlich sind bzw. nur mit ganz bestimmten Hindernissen. Anders als im Original sind nur die Schiffe und Schüsse Vektorgrafik, die Hintergründe hingegen solide Bitmap-Grafiken welche in den meisten Leveln störend viel Platz einnehmen so dass man dauernd dagegen ankämpft gegen sie zu krachen. Andererseits dienen sie auch als Deckung.
lxdm 0.5.2-2/community/archlinux: Ein sehr leichtgewichtiger grafischer Login-Manager, der annähernd gleich wenige Ressourcen verbraucht wie der xorg-xdm, jedoch grafisch 100 x hübscher aussieht. Und das beste: Er kommt auch genau so wie der xdm ohne systemd & Co aus! Allerdings haben mir ein paar Kleinigkeiten die Freude am lxdm verdorben, wie dass er das Umschalten auf virtuelle Konsolen deaktiviert. Und ich fand keine Einstellungen um das zu ändern. Außerdem startet er den X-Server nicht auf tty7 "wie es sich gehört", sondern am ersten freien Terminal. Das Handling des Eingabefokus im Login-Dialog ist suboptimal. Alles in allem keine wirklich schlimmen Defizite, aber ich verwendete dann doch lieber xorg-xdm welches einen noch eine um die Hälfte kleineren Installationsumfang (ca. 370 KB) hat.
lxmusic 0.4.6-1/community/archlinux {audio}{music}: Ein grafischer Client für das XMMS2-Framework zur Musikwiedergabe. Rund 500 KB Installationsumfang. Unterstützt auch den Import von Musikstücken. Dauerhaft gespeichert werden diese aber nicht im Client, sondern im XMMS2-Backend; genau wie Playlists. Tracks die keine ID3-Tags enthalten werden als Dateinamen angezeigt, bei denen alle Leerzeichen gegen "+"-Zeichen ersetzt wurden, was ziemlich gräßlich aussieht. Lxmusic kann mehrere Wiedergabelisten verwalten. Ein bisschen erschütternd ist allerdings, dass man die Wiedergabeliste zwar filtern kann, nicht jedoch anhand unterschiedlicher Kriterien sortieren - sie scheint immer nach dem (allerdings nicht angezeigten wo ID3-Tags verfügbar sind) - Dateinamen sortiert zu sein. Dafür arbeitet Lxmusic nett mit dem xmms2-Commandline-Client zusammen: Man dieselben Wiedergabelisten gleichzeitig von beiden Clients aus steuern. Man kann mit dem Kommandozeilen-Client auch die Playlist umsortieren, aber eben leider nur mit diesem.
lxmusic-0.4.5/media-sound/gentoo {media-player}: Ein grafischer Client für XMMS2. Zwar klein, bietet jedoch auch nahezu keine Funktionalität die über das hinaus ginge was die Playlisten von smplayer oder VLC Player von Haus aus können. Nur sinnvoll daher in Fällen wo weder VLC noch smplayer installiert sind und besondere Platzbeschränkung herrscht. Doch selbst dann ist zu bedenken, dass man ja noch XMMS2 zusätzlich installieren muss, und dieses (4 MB) ist auch bereits ungefähr halb so fett wie mplayer.
lxpanel-0.9.3-1+rpi1/x11/debian {desktop panel}: Das Panel des LXDE Desktop-Environments. Kann aber auch ohne dieses verwendet werden, und ist funktional sehr ähnlich seinem Nachfolger/Fork lxqt-panel. Leider stürzte es ab als ich es testen wollte so dass ich derzeit keine genaueren Aussagen dazu machen kann. Vor allem der RAM-Verbrauch im Vergleich zu xfce4-panel sowie lxqt-panel wäre interessant. lxpanel erfordert 5 weitere Pakete an spezifischen Abhängigkeiten, zusammen 1,6 MB an Downloads und nachfolgend 5,6 MB Installationsumfang. Eventuell auf einer anderen Plattform erneut ansehen!
lxqt-panel-0.11.1-1/x11/debian {desktop panel}: Ein mit 50 MB RAM-Bedarf nicht gerade ressourcen-schonendes Panel. Es scheint eine Reimplementation oder Nachfolger von lxpanel zu sein, und bringt vergleichbare Features mit. Ähnlich wie xfce4-panel erlaubt es beliebig viele Leisten anzulegen und diese mit Plugin-Elementen zu füllen. Es ist auch ebenso komplett übers GUI konfigurierbar. Es bringt in der Grundausstattung die folgenden Plugins mit: Anwendungsmenü (freedesktop.org-kompatibles, automatisch aufgebautes "Startmenü"), Anwendungsverwalter (Taskleiste der laufenden GUI-Programme), Arbeitsfläche anzeigen (Fenster vorübergehend ausblenden so dass man den Desktop-Hintergrund sehen kann), Arbeitsflächenumschalter (für den Wechsel zwischen virtuellen Desktops), Benachrichtigungsfläche (kann Benachrichtigungen anderer Programme gemäß dem System Tray Protocol anzeigen), Farbwähler (Pipette zur Farbauswahl), Lautstärkeregler, Leiste DOM-Baum (sinnlos, nur zum Debugging des Panels), Netzwerk-Monitor, Ordnermenü, CPU-Auslastung, Schnellstarter (benutzerdefinierte Buttons zum Starten von Applikationen), Sensoren (zeigt diverse Werte an), Spacer (Trennelement), Statusbenachrichtigungen (vermutlich allgemeine Meldungen anderer Programme hier gesammelt), System-Statistiken, Tastatur-Modus-Anzeige, Uhr und Kalender, Datenträgerverwaltung, Weltzeituhr). Im Vergleich zum xfce4-panel fällt auf dass es optisch etwas schlichter wirkt und mir einen geringfügig weniger komfortablen Eindruck macht, obwohl es funktionell sehr ähnliches bietet. Dafür verbrät es allerdings deutlich mehr RAM (zumindest wenn man nicht zu viele exotische Plug-Ins im Xfce-Panel verwendet). Ein Vorteil von lxqt-panel ist jedoch dass es bereits in der Standard-Ausstattung ohne zusätzliche Plugin-Pakete deutlich mehr Plugins mitliefert. Außerdem kann es mehrere Instanzen der Applikation automatisch in der Task-Leiste als vertikales und beim Überstreichen automatisch aufklappendes Menü gruppieren. Das ist praktisch zum gezielten Wechseln. Dafür kann der Arbeitsflächenumschalter allerdings keine Miniatur-Ansicht darstellen. Auch das Ordnermenü ist schwächer als das von Xfce, da es kein Terminal starten kann. Was es an RAM verprasst, spart es aber scheinbar beim Platzbedarf ein: Es benötigt 6 zusätzliche zugehörige Bibliotheken als Abhängigkeiten, zusammen mit dem Hauptpaket nur 700 kB Download und danach 2,6 MB Installationsumfang.
lxtask-0.1.8-1/x11/raspbian {resource monitor}: Der eine Zeit lang beste Task-Manager wenn geringer Ressourcen-Bedarf wichtig war, ohne aber Abstriche in der wesentlichen Funktionalität machen zu müssen. Oben sind 2 Balkendiagramme welche die aktuelle CPU- und Speicherauslastung angibt, darunter die Listenfenster mit den Prozessen. Die Spalten sind fix vorgegeben und lassen sich auch nicht ändern: Befehl, Benutzer, CPU %, RSS und PID. Auch die Reihenfolge der Spalten ist fix. Allerdings lässt sich festlegen nach welcher Spalte auf- oder absteigend. sortiert werden soll. Die aktuelle Sortierspalte wird überdies farblich hervorgehoben. Dafür gibt es allerdings keine alternierende Zeilenfärbung zwischen benachbarten Zeilen. Die Konfigurationsmöglichkeiten sind gering: Neben der Aktualisierungsgeschwindigkeit (in ganzen Sekunden) kann man nur noch ganze 4 Optionen: 3 davon aktivieren die Anzeige bestimmter Prozesstypen (eigene, System, fremde User), und die letzte legt fest ob als Cache verwendeter Speicher als freier Speicher angezeigt werden soll (was meist sinnvoll ist). Trotz dieser geringen Möglichkeiten der Anpassung sind die fixen Einstellungen aber (zumindest meiner Auffassung nach) so sinnvoll, dass man normalerweise gar keine anderen Settings möchte. Und die wenigen Optionen sind ohnehin die einzigen Dinge welche man hier und da vielleicht ändern möchte. Das allereinzige was man vielleicht vermisst ist eine Baumdarstellung der Prozesse um Vater-/Kindbeziehungen darstellen zu können. Ich persönlich fand lxtask den bis dato besten Task-Manager nach gnome-system-monitor. lxtask ist der Standard-Taskmanager von LXDE, hat aber keine besonderen Abhängigkeiten davon. Leider hat sich dies inzwischen entweder verschlechtert oder es war mir früher nicht aufgefallen. Aber es nervt sehr dass lxtask sich die Spaltenbreiten nicht merkt. Man muss jedes Mal nachdem man ihn gestartet hat erneut die Breite der Spalten anpassen. Das nervte mich so sehr, dass ich ihn gegen den annähernd gleich großen XFCE-Taskmanager ersetzt habe. Außerdem zeigte einer der Ressourcen-Auslastungsbalken (glaube CPU, vielleicht aber auch RAM) immer nur noch "inf" an.
lxterminal-0.1.7/lxde-base/gentoo {terminal emulator}{GTK+}: Grundsätzlich netter Terminal-Emulator für X11, der leider von den GTK+ Libraries abhängig ist und keine Redefinition der Terminalfarben erlaubt. Konkretes Problem: Das dünklere Blau ist so dunkel, dass es kaum zu erkennen ist. Ansonsten aber ein sehr nettes Programm: Tab-Support, optional blinkender Cursor, Einstellungsdialog mit Wahl des Fonts, kein Problem mit UTF-8, Scrollback-Buffer, Vorder- und Hintergrundfarbe definierbar (aber leider eben nur diese). lxterminal ist zudem das Default-Terminal des LXDE Desktop Environments. Keine Optionen zum temporären Zoomen der Schriftgröße vorhanden.
lynx/www-client/gentoo {www-browser}{text-terminal IO}: Ein guter und schlanker Textmodus Web-Browser für die Konsole. Beherrscht auch SSL und UNICODE. Gut genug für normale Webseiten, jedoch unbrauchbar wo JavaScript benötigt wird. Bricht überbreite Seiten um, Links-Rechts-Scroll wird nicht unterstützt. Tabellen werden nicht direkt dargestellt sondern in eingerückte Ansätze konvertiert. Im Prinzip wäre elinks besser als Lynx, aber da nur Lynx fehlerfrei genug ist, bleibt Lynx der Textmode-Browser der Wahl.
lyx-2.0.4/app-office/gentoo: GUI Front-End für LaTeX. Hatte früher einen lausigen UTF-8 support - unklar ob das noch stimmt. Optisch wirkt es freundlich; das Arbeiten dürfte leicht von der Hand gehen. Man kann auch bestehende LaTeX-Dokumente importieren und dann als .lyx-Dateien speichern. Leider fällt einem dabei ein immenser Größenzuwachs auf. Lyx-Dateien sind zwar immer noch textbasiert und LaTeX-ähnlich, aber sie sind sehr mit XML-ähnlicher Meta-Information zugebloatet so dass das ganze eher nicht mehr menschenverständlich ist. Im Vergleich zu einem "echten" Office-Dokument mag es immer noch schlank sein; doch im Vergleich zu handgeschriebenem LaTeX sieht es entsetzlich fett aus. Allerdings erlaubt einem Lyx, mit TeX zu arbeiten und somit potenziell professioneller aussehende Endprodukte zu erstellen.
lz4-1.8.3-1/utils/debian {compression}: Enthält die gzip-ähnliche Komprimierungs-Utilitiy lz4c (sowie die Wrapper lz4cat und unlz4), welche erforderlich sind um .lz4-Dateien zu entpacken welche zumindest 2020 von Debian für komprimierte "Contents"-Dateien (z. B. für apt-file benötigt) benutzt werden.
lzma-9.22-2.1/utils/debian {compression}: Ein sehr leistungsfähiges Komprimierungs-Utility. Ähnlich wie gzip kann es nur einzelne Dateien kopieren, so dass man häufig zuerst mehrere Dateien in ein nicht komprimiertes Archivformat wie .tar oder .cpio archiviert und erst das Ergebnis mit lzma komprimiert. Die Komprimierung mit lzma ist um Größenordnungen langsamer als die "Klassiker" gzip und bzip2, komprimiert aber auch deutlich besser. Es wird üblicherweise nur noch von lrzip in der Komprimierungs-Effizienz übertroffen, welches aber sogar noch langsamer arbeitet und überdies deutlich mehr RAM benötigt.
maelstrom-1.4.3-L3.0.6+main-8/games/devuan {game}: Das "Asteroid"-Urgestein. Da passt einfach alles - Grafik, Sound, Power-Ups. Mit einer Ausnahme: Das Spiel verwendet Pixel-Grafik in einer fixen, sehr geringen Auflösung, und läuft daher in einen kleinen Fenster. Wenn man die Auflösung des Bildschirms umschaltet mag sie wieder bildschirmfüllend werden, aber dann sieht man auch die klotzige Grafik. Ein Spiel das einst sehr toll war, aber mit moderner Display-Hardware einfach nervt. Ca. 2,6 MB Installationsumfang.
maelstrom/games-action/gentoo {game}: Die beste "Asteroids"-Umsetzung für Linux, finde ich. Problem: Läuft nur in einem kleinen Fenster, und auch im Fullscreen-Modus bleibt der Fensterinhalt gleich klein. Einzige Lösung: Umschalten der Grafikauflösung mittels xrandr auf eine sehr geringe während des Spielens. Das Spiel selbst ist nicht in der Lage, seine Grafikausgabe zu skalieren.
maildrop-2.5.4/mail-filter/gentoo: Ein Standalone-Mailfilterprogramm und Alternative zu procmail, das normalerweise durch fetchmail bei neu hereinkommender Mail aufgerufen wird um diese zu filtern und/oder in einer lokalen Mailbox abzulegen. Im Vergleich zu procmail ist das Programm wesentlich mächtiger, aber auch länger und komplexer. Die Syntax der Regeln ist jedoch wesentlich besser lesbar, da sie "C"-ähnlich und imperativ aussieht, statt deklarativ und kryptisch wie procmail. Außerdem kann maildrop komplexere Aufgaben nicht nur von externen Scripten erledigen lassen, sondern stellt der C-ähnlichen Filtersprache auch Support für diverse Datenbanken zur Seite. Dadurch kann man mehr innerhalb von maildrop machen und muss weniger externe Scripte erstellen. Weiters verwendet es PCRE-Regexes zum Vergleich, während man in procmail auf die weniger mächtigen egrep-Regexes zurück greifen muss. maildrop macht einen sehr mächtigen Eindruck; doch muss man sich fragen ob man diese Mächtigkeit in der Praxis tatsächlich braucht. Wenn man nicht gerade riesige Datenmengen zu filtern hat oder ungewöhnlich komplexe Regeln hat, scheint mir der Einsatz des 5-mal kürzeren und simpleren procmail sinnvoller zu sein. maildrop spricht mit seiner C-ähnlichen Syntax eher allgemeine Programmierer unter den Admins an, und procmail mit seiner von "ed" und "troff"-Files inspirierten Syntax mehr den Hardcore UNIX-Admin. maildrop ist in C++ geschrieben und benötigt im Unterschied zu procmail daher die C++ Runtime-Libraries. Es speichert große Mail-Messages in Temporärdateien während procmail diese immer komplett in den Hauptspeicher lädt; dadurch arbeitet es bei sehr großen Mails ressourcenschonender als procmail. Ein Vorteil von maildrop gegenüber procmail ist dass es aktiv weiter entwickelt wird.
mailutils-2.2/net-mail/gentoo: Eine Menge an Utilities zur Bearbeitung aller möglichen Aspekte rund um e-Mail, darunter nicht nur Mail-Clients sondern sogar auch ein POP3 und IMAP Daemon. Ersetzt auch "mail" und "mailx". Die Tools können mit mbox und maildir-Formaten umgehen, Mails aus solchen Containern anzeigen, erstellen, beantworten, extrahieren, filtern etc. Die Tools verwenden alle auf einer zentralen Library welche diese Dinge kann, und diese Library kann daher auch von eigenen Programmen angesteuert werden. (Allerdings zwingt man dann den Anwender, ebenfalls mailutils zu installieren, obwohl er vielleicht einen anderen "mailx"-Client bevorzugt hätte.) Weiters benötigt diese gar tolle Library, obwohl sich doch angeblich so viel kann, immer noch ein externes sendmail Programm zum eigentlichen Versenden der Mails.
mailx-8.1.2.20050715-r6/mail-client/gentoo: Ist ein Drop-In Replacement des originalen UNIX "mail"-Kommandos mit ein paar kleinen Erweiterungen. Es stellt das "mailx"-Kommando und Alias "mail" zur Verfügung. Ein eher kleines Paket mit 410 KiB Installationsumfang. Man kann damit Mail von lokalen Mailspool-Verzeichnis lesen, beantworten und neue Mails erstellen. Es lässt sich auch aus Scripten heraus einfach aufrufen. Zum Versenden benötigt es allerdings ein installiertes sendmail-Programm; selbst falls man nur lokale Zustellung wünscht. Es beherrscht nur das mbox-Format, maildir wird nicht unterstützt. Eben sowenig hat das Programm eine Ahnung von POP3 oder gar IMAP. Derartige Mails müssen erst von einem anderen Programm ins lokale Mailspool-Verzeichnis übertragen werden, wie etwa von fetchmail.
man2html-1.6g-9/doc/devuan {text-formatting}: Filter der nroff/troff-Quelltexte für "man"-Seiten in HTML-Quelltext umwandelt. Unterstützt dabei Anweisungen für den "tbl"-Präprozessor (für Tabellen), nicht jedoch für "eqn" (für mathematische Formeln). Kann auch als CGI-Backend benutzt werden um seine eigenen erzeugten Hyperlinks (auf andere "man"-Pages) nachzuverfolgen. Alternativ kann das Programm auch als Backend für den "lynx"-Textmode-Webbrowser dienen, damit dieser allfälligen generierten Hyperlinks folgen kann.
mapivi-0.9.7/media-gfx/gentoo {graphics image viewer}: Ein Konverter und Editor für verschiedene Kommentar-Formate die alle in JPEG-Bildern gespeichert sein können: XMP, IPTC, EXIF und direkte JPEG-Kommentare. Auch Bild-Bewertungen ("Anzahl der Sterne") die in diesen Standards vorgesehen sind können editiert werden. In Perl-Tk geschrieben, daher zwar einerseits plattformneutral (soweit es Perl und die benötigten Module dort gibt), zum anderen aber kotzhässlich. Das Programm kann auch als Bildbetrachter dienen und unterstützt verlustlose JPEG-Rotation und Beschneidung. Es gibt auch Stapelverarbeitungsfeatures für Umbenennung und Bildverarbeitungsfilter. Von letzteren gibt es zwar nicht viele, aber dafür gibt es immerhin eine "vorher-nachher"-Anzeige - könnte gelegentlich hilfreich sein. Es gibt eine nützlich klingende Funktion zum Vergleichen zweier Bilder, welche diese (als Farbdifferenz) über einander blendet. Man kann auch ganze Verzeichnisse mit Bildern vergleiche, wo dann diverse Attribute (vor allem natürlich Kommentare) in Spalten dargestellt werden. Eine Duplikatsuche existiert auch, jedoch kann man hier nur Dateiname, Datum und Dateigröße als Kriterien wählen und nicht die Ähnlichkeit des Dateiinhaltes (das kann dafür Geeqie). Ein Mangel: In der Dateilistendarstellung wird UTF-8 fehlinterpretiert.
mapnik-utils-3.1.0+ds-1/utils/debian {GIS}: Nutzt die Library des Mapnik-Toolkits für GIS-Operationen um die folgenden Kommandos zur Verfügung zu stellen: mapnik-index (erzeugt .index-Dateien für existierende CSV- und GeoJSON-Dateien), mapnik-render (rendert Karten-Kacheln aus Mapnik XML oder Cascadenik MML Dateien) und shapeindex (erzeugt .index-Dateien aus ESRI Shapedateien).
marble-4.14.3/kde-base/gentoo: Ein Kartenbetrachtungsprogramm, das sowohl spärische (Weltkugel) als auch rechteckig projizierte Karten darstellen kann. Kann Kartenmaterial aus allen möglichen Quellen beziehen und bietet sogar eher sinnlose Karten wie vom Mond, Mars, Venus etc. Es kann auch Karten von OpenStreetMap.org benutzen und sogar offline speichern. Soweit das gute und schöne an diesem Programm. Der riesige Nachteil ist, dass es keine Vektorkarten darstellen kann, sondern nur vorgerenderte Pixelkarten, die es als Kacheln von den diversen Servern herunterlädt und nur dann auch für den Offline-Betrieb speichern kann. Das ist mehr oder weniger dieselbe Art und Weise wie Google Maps arbeitet, nur mit mehr Freiheiten bei den Servern und Offline-Fähigkeit. Aber kachelbasierte Grafik bedeutet riesige Datenmengen die heruntergeladen werden müssen, und außerdem muss man alle Kacheln für jede mögliche Zoomstufe die man verwenden möchte separat herunter laden. Flüssiger Zoom würde bedeuten, dass man das ganze Kachelmaterial in Dutzenden wenn nicht hunderten von Versionen herunterladen müsste. Fazit: Praktisch unbrauchbar für Offline-Betrieb, es sei denn man kombiniert es mit einem lokal installierten Offline-Kartenrender-Service aus irgend einem anderen Paket. Solche Lösungen soll es zwar geben, aber das Setup wäre mühsam da man den lokalen Server dann jedesmal starten und stoppen müsste. Und außerdem verbliebe immer noch das Problem dass die Kacheln vorhanden wären und Speicherplatz verschwenden. Daher: Besser vergessen und gleich direkt Google Maps verwenden. Für sinnvollen Offline-Betrieb ist ein vektorbasiertes Anzeigeprogramm vonnöten. Leider benötigt der derzeitige (2015-04) Ebuild von DigiKam Marble als Abhängigkeit, so dass es in diesem Fall zwangsinstalliert wird.
marco-1.16.1-1/x11/debian {window manager}{GTK+}: Der Fenster-Manager des "Mate" Desktop Environments. Seine Stärke ist besonders benutzerfreundliches Verschieben und manuelles Anordnen von Fenstern. Dies stammt daher dass er "Kantenwiderstand" anstatt "einschnappen" an anderen Fenstern benutzt, überdies gibt es mehr Zonen (praktisch: Alle die Sinn machen) an denen der Kantenwiderstand "einrastet". Er beherrscht das automatische Ziehen und Ablegen von Fenstern an den linken, rechten und oberen Bildschirmrand: Links und rechts ordnet das Fenster als Bildschirmhälfte an, der obere Rand maximiert es. Er hat auch ein Fenster-Kontextmenü, welches allerdings nur wirklich grundlegende Operationen enthält. Wenn man einmal davon absieht dass er mehr als den 3-fachen RAM-Bedarf (ca 30 MB) der Fluxbox hat, macht er auf den ersten Blick einen recht guten und bedienungsfreundlichen Eindruck. Wenn man marco jedoch *ohne* Mate benutzt, kommt man recht schnell drauf dass das Programm ansonsten nahezu nichts kann: Alle anderen Komponenten welche man vielleicht erwarten würde, wie Panels, Task-Leiste, Uhrzeit, "Startmenü" - sind nicht Teil vom Marco und müssten zusätzlich installiert werden. Wenn man allerdings das Paket mate-panel installiert, kommen gleich 20 MB Download zusätzlich dazu, und 50 MB Installationsbedarf. Ein weiteres Problem von Marco ist dass er keinerlei Konfigurations-Dateien verwendet, sondern das dconf-Settings-System, welches eine frappierende Ähnlichkeit mit der "Registry" von Microsoft Windows hat. Allerdings unterscheidet es sich von dieser insofern, als die Schlüssel wenigstens eine Beschreibung haben. Dafür kann man aber auch nur solche Schlüssel editieren, für welche zuvor XML-Dateien mit den entsprechenden Definitionen und Beschreibungen installiert sind. Erschwerend kommt hinzu, dass marco einige Settings benutzen möchte, etwa für benutzerdefinierte Tastatur-Kürzel, für die er keine XML-Definitionen mitbringt. Offensichtlich entstammen diese anderen GNOME-Komponenten - und natürlich weiß man nicht, von welchen. Allerdings könnte man ein XML-Schema auch per Hand anlegen. Dann jedoch stößt man schnell auf das Problem dass dies eigentlich nur für systemweit installierte Pakete vorgesehen ist - wenn man als Benutzer XML-Dateien zu dconf hinzu fügen will, muss man den ganzen marco mit einer gesetzten Umgebungsvariable starten, wo dconf nach zusätzlichen XML-Dateien suchen soll. Direkt vorgesehen sind pro-Benutzer-Dateien von dconf nämlich nicht. Davon abgesehen ist das Bearbeiten der dconf-Einträge mit dem textbasierten "gesettings"-Tool mühsam - man installiert sich besser den grafischen "dconf-editor". Der hat allerdings seine eigenen Probleme mit dem Bedienungsfluss. Ohne eigene XML-Dateien kann man mit marco jedenfalls nur Tastenkürzel für vordefinierte Funktionen des Fenstermanagers definieren, sowie dessen allgemeine Einstellungen. Trotz des "tollen Komforts" von dconf gibt es aber keinesfalls für alles was man erwarten würde Einstellungen. So lässt sich nicht einmal der Name des Terminalprogramms festlegen, welches durch ein entsprechedes Tastenkürzel gestartet werden kann. Sondern ist offenbar hardcoded. Daher bleibt das Ergebnis, dass Macro nichts abseits der grundlegenden Fenster-Manager-Funktionen bezüglich des Anordnen von Fenstern kann. Benutzerdefinierte Tastaturkommandos scheitern an fehlenden XML-Schemas, und das einzige was er sonst noch kann ist bei irgendwelchen bestimmten Fenster-Aktionen einen dämlichen Sound abzuspielen. Für das alles ca 8 MB an Downloads für Macro und seine grundlegendsten Abhängigkeiten? Eher nicht! Zumal man mangels weiterer Funktionen von marco selbst alle weitere erwünschte Funktionalität durch zusätzliche externe Panel-Applikationen wie "fbpanel" ergänzen muss. Wenn man keine Ressourcen zu sparen braucht kann das immer noch ein vernünftiger Weg sein, da die Bedienungsfreundlichkeit von marcos Grundfunktionen unstrittig ist. Aber wenn es einem darum geht RAM zu sparen, sollte man diese Lösung besser vergessen.
markdown-1.0.1-7/web/debian {text-formatting}: Eine simple reintextbasierte Sprache zum Formatieren von Text und dessen Ausgabe als HTML. Die Syntax von markdown ist allgemein etwas hübscher und einfacher zu benutzen als die von ASCIIDOC, mit einer Ausnahme: In spitze Klammern eingeschlossene Textliterale wie "<argument>" müssen fürchterlich umständlich escaped werden, da markdown neben seinem eigenen Markup auch vereinfachten HTML-Text in seinem Quelltext akzeptiert. Allerdings kommt das nicht von ungefähr: Im Gegensatz zu anderen textbasierten Auszeichnungsformaten wie asciidoc oder reStructuredText ist es *nicht* das Ziel von markdown HTML zu ersetzen. Es versteht sich im Gegenteil sogar explizit als Front-End zum händischen Erzeugen von HTML, das einen von den lästigsten und menschenfeindlichsten Aspekten vom HTML verschont. Jedoch ist es erklärtes Ziel, dass man alle HTML-Möglichkeiten nach wie vor voll nutzen kann wenn man will bzw. es braucht. Man sollte Markdown daher eher als "Makrosprache" verstehen um leichter HTML erzeugen zu können, und nicht als Alternative dazu. Markdown kann daher vieles seltener gebrauchte nicht was die Konkurrenten können, da man statt dessen jederzeit direkt auf die bereits vorhandenen HTML-Konstrukte zurückgreifen kann. Im Gegenzug ist die markdown-Installation um einiges schlanker. Markdown ist eine gute Wahl wenn man eigentlich direkt HTML schreiben will aber dazu zu faul ist bzw. einen die umständliche Syntax nervt. Ein Nachteil von markdown ist dass es sehr spezielle Anforderung an den Benutzung von Whitespace stellt. So müssen vorformatierte Zeilen mit entweder einem horizontalen Tabulatorzeichen oder exakt 4 Leerzeichen eingerückt werden. Aber noch schlimmer, wenn man einen Zeilenumbruch im laufenden Absatz erzwingen möchte, muss man zwei oder mehr Leerzeichen am Ende der Zeile eingeben. Viele Editoren würden dies beim Speichern oder nach dem Laden kommentarlos einfach wieder entfernen. Markdown wurde vor allem durch den Umstand populär, dass Github Markdown-Dateien automatisch eine HTML-Seite für README.md generiert die in dort gehosteten Repositories enthalten sind, so dass man eine "Einstiegs"-Webseite für sein Projekt erhält ohne dazu etwas speziell auf Github konfigurieren zu müssen.
matchbox-keyboard-0.1+svn20080916-9/embedded/debian: Ein installationsmäßig sehr kleines Onscreen-Keyboard, dessen Layout auch sehr schön per XML-Dateien definiert werden kann. Leider sind die mitgelieferten für eine deutsche Tastatur unbrauchbar, so dass man selbst Hand anlegen müsste. Es gibt im Internet zwar deutsche Layouts, aber nicht alle Tastensymbole darauf werden angezeigt. Außerdem ist die Tastatur viel zu sehr vergrößert, so dass nicht einmal bei Full-HD-Auflösung alle Tasten sichtbar sind. Weiters ist es etwas unschön dass das Programm nur in /usr/share nach Layout-Dateien sucht; es scheint micht möglich in /etc angepasste Dateien zu hinterlegen. Immerhin ist es möglich in ~/.matchbox/keyboard.xml eine benutzerspezifische Datei zu hinterlegen.
matchbox-panel-0.9.3-9/embedded/debian {desktop panel}: Ein simpler Panel-Manager, welcher insofern den Tiefpunkt aller bislang beobachteten darstellt, als er nicht einmal in der Lage zu sein scheint eine Taskleiste der laufenden GUI-Programme anzuzeigen. Aus Fehlermeldungen beim Start kann man zwar schließen dass er *versucht* freedesktop.org-kompatibel ein Menü aufzubauen, jedoch kommt er dabei offensichtlich nicht weit und das Menü enthält nur eine kümmerliche Hand voll Einträge, während der Großteil offensichtlich fehlt. Es gibt einen tollen "Panel-Manager" den man als separates Paket installieren muss, doch dieser scheint nicht mehr zu können als die Reihenfolge der Plug-ins am Panel zu verändern. Hinzufügen kann man Einträge indem man entsprechende Menü-Einträge wählt, nicht einmal Entfernen kann man welche mit dem Panel-Manager. Es scheint zudem nur folgende Plugins zu geben: App-Launcher ("Startmenü"), Battery Monitor, CPU/Mem-Monitor, Clock, Wireless-Monitor. Sonst nichts! Eine recht eigenartige Auswahl. Mit einem RAM-Bedarf von 8 MB für das eigentliche Panel gehört er zwar zu den schlanken Panels, allein für das Clock-Applet kommen aber nochmals 8 MB hinzu, ebenso wie für das Startmenü. Es läppert sich daher. Wenn es schon kaum etwas kann, ist es dafür aber auch nicht groß: Mit 4 abhängigen Paketen (inklusive dem optionalen Panel-Manager) sind es zusammen mit dem Hauptpaket ca. 150 kB Downloads und nachfolgend 450 kB Installationsumfang. Wenn das Ding nur eine Task-Leiste hätte, könnte man es unter Umständen empfehlen. So ist es aber nur ein Witz. Allerdings kann ich nicht ausschließen dass ein Taskleisten-Plugin nur deshalb nicht zur Auswahl stand, wurde weil es beim Parsen der Menü-Einträge ständig Fehlermeldungen gab. Eventuell auf einer anderen Plattform erneut ansehen!
mate-1.8.0/mate-base/gentoo: Ein Fork des ehemaligen GNOME-2, um dessen beliebtes Look-And-Feel auch auch zeitgemäßen Linux-Distributionen weiter verwenden zu können, anstatt das gewöhnungsbedürftige GNOME-3 verwenden zu müssen. Zu diesem Zweck wurden zahlreiche ehemalige GNOME-Bestandteile umbenannt: Aus dem Dateimanager Nautilus wurde Caja, aus dem Texteditor Gedit wurde Pluma (und er unterstützt im Gegensatz zum Original auch Tabs), aus dem Fenstermanager Metacity wurde Marco, der Menü-Editor heißt nun Mozo, aus dem Archiv-Manager für gepackte Dateien "File Roller" wurde Engrampa, aus dem Dokumentbetrachter Evince wurde Atril, aus dem Bildbetrachter Eye-Of-Gnome ("eog") wurde Eye-Of-Mate ("eom"), und alle "gnome-"-Präfixe in den Namen anderer Zusatzprogramme (wie etwa vom Taschenrechner) wurden gegen "mate-" ersetzt. Auch viele der für GNOME-2 verfügbaren Panel-Applets wurden portiert; insgesamt eine sehr runde Sache. Eine besonderer Stärke von Mate ist dass man ihn im Gegensatz zu manch anderen DTEs nicht langwierig zu konfigurieren braucht um sinnvoll damit arbeiten zu können - die Default-Einstellungen der meisten Tools sind so sinnvoll gewählt, zumindest nach meinem Geschmack, dass man sofort drauf los arbeiten kann. Besonderes Lob verdient dabei das Standard-Verhalten des Fenstermanagers, der einfach alles so macht wie man es sich erwartet bzw. "wie es sich gehört". So hat er etwa standardmäßig Widerstand an den Kanten statt dem eher geistesgestörten Snapping eingestellt, und kann Fensteroperationen wie verschieben oder Größe ändern die Ränder anderer Fenster in der Umgebung als Einrastzonen verwenden. Man kann allenfalls monieren dass ihm, wohl dem Alter der Konzepte geschuldet auf denen er basiert, moderne Funktionen fehlen, wie etwa Fenster zu Tab-Gruppen zusammen schließen zu können, oder Fenster automatisch als Bildschirmhälften anordnen zu können. Seltsam auch, dass man in Panels zwar Trennstriche, aber keine Abstandshalter einfügen kann. Doch davon abgesehen funktioniert Mate wirklich ganz ausgezeichnet, und ist derzeit meiner Ansicht nach das am angenehmsten verwendbare vollwertige DTE auch ohne spezielle Anpassungen vornehmen zu müssen. Unter Gentoo kann man Mate auch ohne systemd-Erfordernis installieren, unter Debian muss systemd zwar aufgrund von Abhängigkeiten installiert werden, braucht aber nicht gestartet zu werden. (Leider lässt sich jedoch die Verwendung von upower und udisks nicht vermeiden, zwei weiteren bei mir wenig geliebten lästigen Diensten aus dem Umfeld der systemd-Entwickler.) Bei allem grundsätzlichem Lob bleibt aber festzuhalten, dass Mate zu den "großen" DTEs gehört und somit relativ fett und umfangreich ist (45 Mate-spezifische abhängige Pakete ohne auch von anderen Programmen genutzte wie etwa GTK mit zu zählen, alles in allem 165 MiB gepackte Quelltexte an Downloads unter Gentoo). Allerdings scheint mir Mate subjektiv immer noch um einiges schlanker als GNOME3 oder KDE4 zu sein.
mate-utils-gtk3 1.10.3-1/community/archlinux: Enthält die folgenden Tools des "Mate" Desktops: Wörterbuch, Diskbelegungs-Analyse, Bildschirm-Schnappschuss, Logdatei-Betrachter, Dateisuch-Werkzeug. Doch zumindest letzteres funktioniert leider nicht ohne installierten Mate Desktop, obwohl dieser nicht als Paketabhängigkeit angeführt ist. Daher ist davon abzuraten dieses Paket zu installieren, wenn man ein anderes DTE als den Mate Desktop verwendet.
mathomatic 16.0.5-2/community/archlinux: Ein simples Kommandozeilen-Computeralgebrasystem, das gegenüber mächtigeren CAS wie Maxima, Axiom, Reduce oder Yacas viele Defizite aufweist. So kann es beispielsweise keine Gleichungen höheren Grades als quadratische symbolisch lösen. Schlimmer noch, es beherrscht keine mehrfachgenaue Arithmetik und rechnet mit Fließkommazahlen. Dafür punktet es in Sachen einfacherer Bedienung, da es "libreadline"-Editierfunktionen für die Kommandozeile bereit stellt. Zweitens verwendet es Farben für die Ausgabe in Terminal, und "pretty-printed" Brüche. Vor allem punktet es aber mit seinem Debug-Modus, in welchem es die einzelnen Unformungsschritte erklärt, die es vornimmt. Überdies kann man manuell eingreifen, und dieselbe Operation mit beiden Seiten einer Gleichung befehlen. Das Programm ist daher vor allem dann praktisch, wenn man bei Aufgaben welche die eingebauten Fähigkeiten des Programms überfordern manuelle Umformungsschritte wünscht, die man das Programm dann ausführen lassen kann, ohne dies selbst berechnen zu müssen. Der Umstand dass es mit Fließkommazahlen rechnet, bedeutet aber nicht dass es grundsätzlich mit inexakten Werten rechnet. Konstanten wie Pi, Brüche oder irrationale Wurzeln behandelt es sehr wohl symbolisch, zumindest solange es bei den Berechnungen keine arithmetischen Überläufe gibt. Erst dann ersetzt es Teilausdrücke durch inexakte Fließkommazahlen. Vor allem für einfaches Umformen und Lösen von "Alltags-Gleichungen" ist das Programm gut geeignet. Das Programm beherrscht das Rechnen mit komplexen Zahlen eben so wie das mit Ausdrücken in Polynomform und Brüchen. Negativ ist dass es keine Funktionen beherrscht, weder benutzerdefinierbare noch Standard-Funktionen wie Sinus etc. Zumindest alle trigonometrischen Funktionen können allerdings durch Formeln mit der eulerschen Zahl sowie der imaginären Einheit ersetzt werden. Zu diesem Zweck liegen M4-Makropakete bei, und man kann die Eingabe des Programms durch den M4 Makroprozessor laufen lassen bevor es beim Programm ankommt. Dadurch lassen sich außerdem benutzerdefinierte Funktionen ohne die Mitwirkung des Programms realisieren. Der schwerste Mangel des Programms ist das Fehlen jedweder Logarithmus-Funktion. Allerdings beherrscht das Programm den Logarithmus intern bei Umformungen und Vereinfachungen sehr wohl; er kann lediglich nicht symbolisch dargestellt werden. Von sich aus kann das Programm zwar nur einzelne Variablen in einer Gleichung isolieren, aber mit dem "eliminate"-Befehl kann man schrittweise mit Hilfe anderer Gleichungen weitere Variablen eliminieren, bis man auf diesem Weg - etwas umständlich - auch Gleichungssysteme lösen kann. Man kann mit "eliminate" effektiv auch Variablen substituieren, und kann auf diesem Weg den Effekt der fehlenden benutzerdefinierter Funktionen auch ohne M4-Makroprozessor durch Formel-Gleichungen nachbilden. Trotz des Fehlens fest eingebauter Standardfunktionen Funktionen kann das Programm dennoch Integrieren, Differenzieren oder Extrem- oder Grenzwerte für Ausdrücke finden, solange das Endergebnis mit den verfügbaren Operatoren auskommt. Das Programm kann zudem auch numerisch integrieren. Zum Erzeugen von Taylor-Reihen und Laplace-Transformationen gibt es eingebaute Kommandos. Überdies kann es optional ein etwaiges installiertes gnuplot zum Plotten verwenden. Recht hilfreich ist auch dass es seine Ausdrücke für C, Java oder Ganzzahlarithmetik anzeigen kann, sowie mit dem Redirection-Operator leicht in Dateien exportieren oder von solchen einlesen. Als echter CAS-Ersatz taugt das Programm nicht, aber man kann es in vielen einfacheren Anwendungsfällen anstatt einem CAS verwenden und dann komfortabler und mit geringeren Einlernaufwand arbeiten. Ich konnte das Programm jedenfalls eher dazu bringen genau das zu tun was ich wollte, als die mächtigeren CAS die alles auf ihre eigene Weise machen und sich dabei nicht dreinreden lassen. Es hat überdies noch einen recht kleinen Funktionsumfang von 820 KB (installiert), wo die HTML-Dokumentation bereits enthalten ist. Die braucht man oft aber gar nicht, da das eingebaute "help"-Kommando oft ausreichend ist.
maxima/sci-mathematics/gentoo {symbolic calculation}{programming language}: Der Klassiker unter den symbolischen Rechenprogrammen. Der direkte Nachfahre von MACSYMA. Groß, fett und in LISP geschrieben. Dafür aber vergleichsweise konventionell in der Bedienung und nicht zu kompliziert. Leider braucht es ziemlich viel Speicher und startet auch nicht gerade rasant. Es bringt optional auch ein ausreichend angenehm zu bedienendes X11-Frontend mit, welches die Hilfsdokumentation in der unteren Fensterhälfte browserartig aufbereitet darstellt, während man in der oberen Fensterhälfte die Berechnungen anstellt. Das X11-GUI kann auch Funktionen plotten.
mc-4.7.0.1/app-misc/gentoo {file manager}{text-terminal IO}{text-diff}{no-soft-line-wrap}{text-merge}: ncursed-based Norton-Commander-style 2-pane file manager for the text console. No support for multiple display pane tabs, but otherwise very useful. The best file manager for Linux in text mode so far. Features an integrated text editor, text viewer, hex viewer, text file difference viewer with merge capability (only 2-way merge and differences of whole physical lines).
md5deep-1.12/app-crypt/gentoo {security}: Ein rekursives md5sum. Erlaubt auch das einfache Suchen nach gegebenen Hashes. Ausserdem kann es neben MD5 auch SHA1 und andere Hash-Funktionen.
mdbtools-0.9.1-1/database/debian: Enthält zahlreiche Kommandozeilenwerkzeuge sowie zugehörige Bash-Completion snippets um auf Micrsoft Access Datenbanken zugreifen zu können. mdb-array (emit C source code, representing table data as an array), mdb-count (display number of rows in a table), mdb-export (export database table as CSV), mdb-header (emit C source files describing names and types of tables and columns in a database), mdb-hexdump (hex-dump of database with charset conversion), mdb-import (add CSV data to existing table), mdb-json (like mdb-export, but generates JSON output), mdb-parsecsv (convert CSV table to C source file implementing an initialized array), mdb-prop (display property list of database), mdb-queries (displays SQL of stored queries), mdb-schema (create DDL output for re-creating an empty database using the same schema), mdb-sql (use a limited subset of SQL to query an *.mdb database), mdb-tables (list tables in a database suitable for use in shell scripts), mdb-ver (identify format version of *.mdb database).
mdf2iso-0.3.1-2/otherosfs/debian: Kann mit dem kommerziellen Windows-Programm "Alcohol 120 %" gerippte CD-Abbild-Dateien (*.mdf-Dateien) in gebräuchlichere und von anderen Programmen verwendete *.iso, *.cue und *.toc-Dateien umwandeln.
mecab-0.97-r1/app-text/gentoo: Da die Dokumentation nur auf japanisch verfügbar ist, ist es etwas unklar was dieses Tool genau tut. Irgendwie scheint es aber aus einem gegebenen Testbestand an Dokumenten Analysen über Wort- und Buchstabenhäufigkeiten sowie die Wahrscheinlichkeiten kurzer Buchstabenfolgen zu analysieren. Unklar ist aber, was das Programm mit den solchermaßen gefundenen Ergebnissen tut. Irgendwie scheint es ein Filter zu sein, welches rohen Eingabetext in "indizierungsfreundlicheren" umwandelt, indem "irrelevante" Worte entfernt werden, verschiedene Wortformen in eine "normalisierte" Form übergeführt werden, und ähnliches. Aber ob das wirklich stimmt ist eine andere Frage. Grundsätzlich ist so ein Tool sicherlich hilfreich als Unterstützung jeder Volltext-Suchmaschine, und zumindest app-text/hyperestraier hat Support dafür.
medit/app-editors/gentoo: Sehr netter X11 Texteditor ("Moo-Edit") mit den meisten Features von "kate"; aber nicht von KDE abhängig. Tabs, Syntax-Highlighting Regular Expression Search/Replace, Win32-ähnliche Bedienung, UNICODE, in Python, Lua und Shell scriptbar, Lesezeichen, weicher Textumbruch, Druckdialog, "Als PDF exportieren", anpassbare Tastenkürzel, "Find in Files", Optionale Zeilennummern-Anzeige links in jeder Zeile. Die einzigen fehlenden Features von kate sind Folding und Keyword/Identifier Completion.
meld 3.14.2-1/extra/archlinux {text-diff}{text-merge}: Ein in Python/GTK+ geschriebenes grafisches Diff/Merge-Tool. Unterstützt auch Diffs der Arbeitsversion gegenüber historischen Versionen in Versionskontrollsystemen. Ein eher lahmes Tool (von der Geschwindigkeit her) mit etwa demselben Installationsumfang (und vermutlich geringerem Funktionsumfang) wie kdiff3, jedoch benötigt meld dafür keine KDE-Libraries. Meld ist ein vermutlich einigermaßen brauchbarer Ersatz für kdiff3 auf Systemen wo KDE-Abhängigkeiten vermieden werden sollen.
memcached-1.4.33-1+deb9u1/web/devuan: Ein In-Memory Caching-Daemon der komplett im RAM arbeitet. Kann mittels TCP, UDP und UNIX Domain Sockets mit seinen Clients kommunizieren. Total auf Performance getrimmt: Viele Connections gleichzeitig, Multithreading, Cluster-fähig und alle Tricks. Wird hauptsächlich von Web-Servern eingesetzt, damit häufig benötigte Ressourcen nicht ständig von der Disk nachgeladen werden müssen. Kann aber auch benutzt werden um Schreibzugriffe auf die Disk zu vermeiden, etwa bei Zählern. Im Grunde ist memcached ein Key-Value-Store mit optionalem Verfallsdatum der Einträge. Allerdings kann man Values nicht nur einfach setzen, sondern auch neue Daten anhängen oder sogar davor hängen. Eine Ringpuffer-Funktionalität fehlt jedoch. Beim Setzen kann man wiederum wählen ob der Schlüssel bereits existieren kann, nicht darf, oder muss. Simple Transaktionen der folgenden Form werden unterstützt: Ein Update des Values nur unter der Bedingung dass er sich nicht geändert hat seit man ihn das letzte Mal gelesen hat. Für das Addieren/Subtrahieren zu/von Values welche 64-Bit unsigned Integers darstellen gibt es spezielle Kommandos. Etwas seltsam dabei: Das Subtrahieren ist gesättigt (wird nicht kleiner als 0), beim Addieren kann der Wert hingegen überlaufen bzw. verhält sich gemäß modularer Arithmetik. Weitere Kommandos ermitteln Statistiken oder verschieben Speicher intern zwischen verschiedenen Speicherpools (es gibt verschiedene Pools für Objekte ähnlicher Größe). Das Protokoll zur Kommunikation mit mcached-Serverprozessen ist textbasiert für die Befehlsübermittlung und allfällige Befehls-Rückmeldungen. Die eigentlichen Values werden aber binär übergeben. Außerdem gibt es zahlreiche zusätzliche Software-Pakete, welche das Protokoll für bestimmte Programmiersprachen oder Dienste (insbesondere Webserver) kapseln. Trotzdem das Programm die eigentlichen Daten nur In-Memory speichert, kann es dennoch auf Wunsch jede Menge Logging betreiben.
menulibre-13.01.4/x11-misc/gentoo {installed applications menu editing}: Is meant to be a freedesktop.org compliant GUI menu editor. It is the default menu editor of Unity. However, it does not seem to work at all under a simple Fluxbox session without dbus running. Maybe it provides a better integration of automatically detected and manually edited menu entries than x11-misc/denu does. Needs to be tested again running under a more powerful WM.
menumaker-0.17/x11-misc/gentoo {installed applications menu editing}: MenuMaker is utility written in Python that is capable of finding installed programs and generating menus for several supported X window managers. Currently supported WMs: Deskmenu (Oroborus), FluxBox, IceWM, OpenBox, OpenBox3, Window Maker, XFce, XFce4. I have tested it with Fluxbox and liked the results. The only caveat is that all menu entries are generated in English only; any available translations for other languages will be ignored.
mercurial-0.9.4/dev-util/gentoo {version control}: Wie ein verteiltes RCS mit Unterstützung von Unterverzeichnissen. Einfach, aber ausreichend mächtig. Jede Datei wird separat getrackt. Aber keine Probleme mit Text/Binärdateien - es gibt nur letztere. Komplett verteilt. Besonders einfach zu erlernen und zu bedienen. Effizientes binäres Deltaformat. Unterstützt allerdings standardmäßig keine Symlinks oder Keyword Expansion. Gut erweiterbar - in Python geschrieben. Umbenennen und verschieben wird als Löschen und Neuerstellen interpretiert, ist unelegant, funktioniert aber eindeutig besser als bei CVS. Keine Wartung notwendig. Auf vielen Plattformen lauffähig, wegen der Beschränkung auf nur-binär-Interpretation aber nur sinnvoll wenn sich alle Projektteilnehmer sich über die Art der Codierung von Textdateien (Zeichensatz, Zeilenendkonvention) einig sind. War 2007 das schnellste System nach git.
mergerfs-2.33.5-1/utils/raspbian {FUSE}: Ein Overlay-Dateisystem ähnlich wie UnionFS welches wenige Features von unionfs-FUSE mit allen von mhddfs kombiniert. Der Sinn dieses Dateisystems ist es, den kombinierten freien Speicherplatz mehrerer unabhängiger darunter liegender Dateisysteme zum Beschreiben zur Verfügung zu haben. Primär ist es ein erweiterter Ersatz für mhddfs, ist aber ungleich komplizierter zu verstehen und zu konfigurieren da es viele Policies und Optionen zur Auswahl gibt. Dadurch ist es jedoch auch flexibler und mächtiger als mhddfs. Als besonderes Highlight kann es Symlinks, Hardlinks, ACLs und EAs unterstützen bzw. durchreichen. Es synthetisiert seine eigenen inodes mittels Hashing, wobei verschiedene Strategien zu diesem Zweck zur Auswahl stehen. Eine weitere Spezialität ist, dass es Symlinks (optional) folgen kann. D. h. die Symlinks werden dann als jene Dateien dargestellt, auf welche sie verweisen. Ähnlich wie in mhddfs können neue Dateien in verschiedene darunterliegende Dateisysteme geschrieben werden, aber Dateien die von nur-lesbaren darunterliegenden Dateisystemen stammen können weder gelöscht noch umbenannt werden. Anders als mhddfs können bei mergerfs darunterliegende Dateisysteme explizit anstatt als read-write auch als read-only deklariert werden, egal wie viel freier Speicherplatz auf ihnen vorhanden ist. Zusätzlich können darunterliegende Dateisysteme auch als "no-create" deklariert werden. Neue Dateien werden dort dann nicht angelegt, aber bereits bestehende können gelöscht und verändert werden. Wegen der viel simpleren Handhabung würde ich empfehlen, mergerfs nur dann zu benutzen wenn man die zusätzlichen Features auch tatsächlich braucht, und ansonsten lieber das wesentlich simplere mhddfs zu benutzen. Außerdem scheint mergerfs eher dazu gedacht zu sein vom Administrator gemountet zu werden, während mhddfs eher für Endbenutzer gedacht zu sein scheint die mehrere USB-Sticks gleichzeitig befüllen wollen.
merkaartor-0.18.4+ds-5+b2/science/debian {GIS}: Ein in C++ geschriebener interaktiver Qt-basierter Editor für OpenStreetMap (OSM) Daten. Kann auch GPS-Dateien im GPX-Format importieren. Kann OSM-Daten vom Internet sowohl herunterladen als auch hochladen. Karten können aber auch lokal gespeichert werden. Von den expliziten OSM-Datenformaten können nur die platzverschwendenden XML-Formate *.osm (Vektorkarten) und *.osc (Updates von .osm Dateien) direkt importiert werden.
meson-0.37.1-1/devel/devuan {software build system}: Ein in Python3 implementiertes Meta-Buildsystem, welches temporäre Projektdateien (welche aufgrund spezifischer Details der lokalen Installation nicht für die Auslieferung geeignet sind) primär für das Ninja-Buildsystem generieren kann. Es unterstützt allerdings nicht beliebige Programmiersprachen sondern derzeit (Stand 2018-08) nur Projekte die in C, C++, C#, D, Fortran, Java, Objective C, Objective C++, Rust oder Vala geschrieben sind. Es unterstützt dabei die Betriebssysteme Linux, OSX, iOS, Microsoft Windows (nativ oder auch mit CygWin), Haiku, FreeBSD (und davon abgeleitete Betriebssysteme), DragonFly BSD und NetBSD. Dabei werden die folgenden Hardware-Plattformen unterstützt: 32/64 Bit x86, Itanium, 32/64 bit ARM, 32/64 Bit MIPS, 32/64 Bit POWER PC, MCST Elbrus, HP PA-RISC, 32/64 Bit RISC-V, 32/64 Bit SPARC. Zumindest scheinen das Mindestgarantien zu sein, denn es wird darauf hingewiesen dass für in dieser Liste fehlende Prozessorfamilien nicht garantiert wird dass sie zukünftig "stabil" unterstützt werden. Woraus man wohl folgern kann dass auch alle anderen CPU-Plattformen zumindest möglicherweise unterstützt werden. Aber nur die oben genannten Programmiersprachen, Betriebssysteme und Hardware-Plattformen können Meson-Buildscripte mittels vordefinierter Konstanten abfragen und darauf basierend plattformspezifische Entscheidungen treffen. Angeblich kann es auch Abhängigkeiten von distributions-spezifischen Paketsystemem in seine Abhängigkeitsberechnungen einbeziehen, wobei die Frage offen bleibt welche Paketsysteme konkret unterstützt werden. Meson unterstützt grundsätzlich auch Cross-Compilation in ähnlicher Weise wie GNU-Autotools, aber natürlich nur dann wenn auch alle abhängigen Unterprojekte Cross-compilier-fähig sind. Meson unterstützt von sich aus grundsätzlich "Reproducible Builds", allerdings nur wenn auch die tatsächlich verwendeten Backend-Compiler und anderen Low-Level-Build-Tools dies unterstützen. Negativ fiel mir auch auf dass keine offline-Anleitung verfügbar zu sein scheint - man muss ständig die Projekthomepage benutzen, was natürlich problematisch ist falls man gerade keine Internet-Verbindung herstellen kann. Noch dazu macht die Dokumentation von JavaScript im Browser Gebrauch, auch wenn sie sich ohne dieses zumindest grundsätzlich anzeigen lässt (jedoch mit eingeschränkten Navigationsmöglichkeiten). Immerhin gelang es mir zumindest mir wget diese Dokumentation doch noch herunter zu laden, die dann einen Umfang von rund 4,5 MB (Stand 2018-08) hatte und auch die erforderlichen JavaScripts enthielt. Allerdings weist die Dokumentation bereits in ihrem ersten Absatz darauf hin dass sie nur für die jeweils neueste Version von meson gilt und auf ältere Versionen nur teilweise zutrifft. Es stellt sich dabei die Frage ob das nur für neue Features gilt, oder ob es auch mit der Rückwärts-Kompatibilität zu älteren Meson-Installationen nicht all zu weit her ist. Ähnlich wie automake und cmake unterscheidet meson zwischen zischen einer "configure"-Phase (bei Meson "setup" genannt) und "build"-Phase (bei Meson "compile" genannt). Meson erzwingt zudem anders als die meisten anderen Build-Systeme eine strikte Trennung zwischen Quelltext- und Build-Verzeichnissen, was bei großen Projekten sicherlich eine gute Idee ist, bei kleinen Projekten aber als organisatorischer Overkill wahrgenommen werden mag. Immerhin wird wenigstens erlaubt, dass das Build-Verzeichnis ein Unterverzeichnis des Quelltextverzeichnisbaums sein darf und nicht notwendiger Weise komplett woanders (sprich außerhalb davon, etwa parallel dazu) liegen muss. Ähnlich wie cmake definiert meson mehrere "Build-Types" wie "debug" und "release" vor. Neben Ninja werden noch wenige weitere Build-Systeme als Backends unterstützt, derzeit (Stand 2018-08) sind dies Visual Studio 2010 und -2015 (Microsoft Windows) sowie Xcode (MacOS). Auf jeden Fall wird *kein* "make" als Backend unterstützt. Beim Ninja-Backend unterstützt meson zudem noch eine "Install"-Phase, wo es auch eine Angabe von --prefix und $DESTDIR wie von den GNU autotools her gewohnt unterstützt. Tatsächlich unterstützt es sogar noch viel mehr (vermutlich die meisten) der automake-Optionen, wie etwa --libdir, --bindir, --sysconfdir, so dass sich die lokale Installation zumindest recht maßgeschneidert anpassen lässt ohne dazu die mit einem Projekt mitgelieferte meson-Projektdateien anpassen zu müssen. Es werden sogar äußerst Build-Tool-spezifische Optionen wie GNU-ld "--as-needed", der GCC "Code Sanitizer" und GCC "Link Time Optimizations" unterstützt, auch wenn die Portabilität solcher Optionen sehr zweifelhaft ist. Es gibt allgemeinen Support für Multithreading, wobei allerdings unklar ist welche Thread-Implementation verwendet wird wenn mehrere Alternativen verfügbar sind. Bei C++ lässt sich der verwendete Sprachstandard, STL debug Modus und Exception-Handling-Style einstellen. Auch präkompilierte Headers werden grundsätzlich unterstützt, obgleich man dazu wohl noch zusätzliche Vorkehrungen treffen wird müssen damit sie funktionieren können. Die Projektdateien von Meson benutzen eine simple, optisch Python-ähnliche Syntax mit Zuweisungen, runden und eckigen Klammern. Konkret lässt die genauere Beschreibung den Verdacht aufkommen, dass der Python-Interpreter rekursiv (meson selbst ist ja ebenfalls in Python geschrieben) zum Auswerten einzelner Statements der Beschreibungssprache aufgerufen wird. Allerdings übernimmt Meson dabei nicht die Einrückungs-spezifische Syntax von Python sondern definiert diese traditionell mit Schlüsselworten zum Begrenzen der einzelnen Bestandteile von Kontrollstrukturen wie "if". Außerdem beschränkt Meson die verfügbaren Funktionen (etwa zur Stringbearbeitung) auf ein Subset dessen was Python bereit stellt. Es gibt 3 Arten von Build-Targets: Executables, statische und dynamische Bibliotheken. Meson hat integrierten Support für "unity builds", einer Technik welche alle Quelltexte eines Projekts mit #include zu einem einzigen zusammen fasst, womit sich ähnliche Vorteile wie bei den "Link Time Optimizations" (LTO) des GCC verwirklichen lassen. Allerdings verhindern solche Unity Builds natürlich (zumindest auf Target-Ebene) incremental Builds. Meson hat weiters eingebauten Support für GNU gettext, Unit Tests und Code Coverage Tests. Meson-Projektdateien müssen allerdings alle verwendeten Source-Files explizit auflisten, und eben so deren Zuordnung zu einem bestimmten Build-Target. Sie können insbesondere keine Joker-Ausdrücke wie *.c verwenden. Allerdings gibt es die Möglichkeit externe Kommandos auszuführen, und diese können auch Dateilisten zur weiteren Verarbeitung durch Meson zurück liefern. Man kann somit beispielsweise die Shell oder den Python-Interpreter aufrufen um eine Liste aller *.c Dateien zu liefern, auch wenn man damit das Meson-Projekt abhängig vom Namen des externen Kommandos bzw. der konkret benutzten Script-Sprache macht. Meson hat ab Version 0.45 hat ein Kommando zur Erzeugung neuer Projektbeschreibungsdateien aus eingebauten Vorlagen, wobei aus mehreren Varianten gewählt werden kann. Weiters wäre zu Erwähnen dass Meson sehr wohl Kommandos zum Hinzufügen neuer Programmiersprachen (die nicht von Haus aus unterstützt werden) besitzt, doch offensichtlich ist dies so umständlich oder aufwändig dass man normalerweise besser davon Abstand nimmt. Insbesondere ist unklar wie solche neu hinzugefügten Sprachen dann Abhängigkeiten zwischen ihren Quelltexten automatisch erkennen sollen.
metadot/www-apps/gentoo: CMS in Ruby On Rails geschrieben. Wer sich nicht graust Ruby zu installieren, bitte sehr.
metalog-3-r1/app-admin/gentoo: Ein Syslog-Daemon, der durch seinen geringen Ressourcenbedarf, seinen geringen Installationsumfang und seine kurzen man-Pages begeistert. Er ist auch durchaus nicht unbrauchbar; man kann sowohl das Datumsformat frei anpassen als auch Perl-kompatible RegExes zum Filtern verwenden. Er kann seine Logs auch noch selbst rotieren und beherrscht optional das verzögerte Schreiben von Log-Einträgen in Dateien, um den Datenträger zu schonen (sprich bei Flash-Dateisystemen). Doch leider gibt es auch einige Mängel, die mir das Programm unbrauchar erscheinen ließen: Als erstes bildet es sich ein, unbedingt selbst seine Log-Dateien rotieren zu wollen. Das bringt einem wenig wenn man logrotate verwendet. Doch dies geht so weit dass man überhaupt keinen Dateinamen für Logdateien angeben kann, sondern nur ein Verzeichnis. Und darin benennt und rotiert Metalog seine Dateien dann wie es seinem Autor gefällt. Aber nicht anpassbar, außer dass man die Anzahl der rotierten Logdateien auf Eins setzen kann und sie dann alleine in ihrem Verzeichnis sind. Das zweite Problem ist dass das Verzögerte Zurückschreiben zwar zwar sehr praktisch ist, doch leider gibt es keinerlei Einstellungen dafür. Das Programm entscheidet selbst wie lange und wie viel es zwischenpuffert. Schlimmer jedoch ist, dass es keine andere Möglichkeit gibt zu erfahren was es gerade für zwischengepufferte Log-Einträge gibt, als das Zwischenpuffern abzuschalten. Das kann man zwar erreichen indem man ein SIGUSR1 an Metalog schickt - doch es gibt kein anderes Signal, mit dem man dies danach wieder rückgängig machen könnte, so dass es wieder in den Normalmodus zurück schaltet. Nur ein Neustart des Dienstes hilft, doch dann verliert man natürlich alle während dessen eingehenden Log-Einträge weshalb man dies vermeiden will. Alles in allem ein tolles Programm, bei dem es leider an den Details scheitert, und das wohl nur in sehr speziellen Szenarien Sinn macht.
mhddfs-0.1.39+nmu2/utils/raspbian {FUSE}: Ein Overlay-Dateisystem ähnlich wie UnionFS, nur dass neue Dateien automatisch auf dem ersten darunter liegenden Dateisystem abgelegt werden, welches noch ausreichend freier Speicherplatz hat. Man kann dabei ein Limit angeben, was als "noch ausreichend freier Speicherplatz" angesehen werden soll. Hat keines der Dateisysteme mehr so viel freien Platz, werden neue Dateien einfach in jenes Dateisystem geschrieben das am meisten freien Platz hat. Der Sinn dieses Dateisystems scheint es zu sein, die Speicherkapazität mehrerer getrennter Dateisysteme (etwa mehrere gemountete USB-Sticks mit simplen Dateisystemen wie FAT) fürs Schreiben von neuen Dateien zu kombinieren, ohne dass man sich darum kümmern muss welche Datei auf welchem Datenträger landet. Bei den meisten anderen Overlay-Dateisystemen kann zwar ebenfalls von mehreren Datenträgern gelesen werden, geschrieben wird allerdings immer nur auf einen klar definierten Datenträger (oder in ein temporäres RAM-Dateisystem) gemäß einer vorab festgelegten Priorität. Mit einem RAID-0 oder LVM2 könnte man vergleichbare Effekte erzielen wie mit mhddfs, allerdings ist das Setup viel komplizierter und man braucht Administrator-Rechte. Außerdem braucht man mhddfs nicht zum Lesen der Dateien vom den Datenträgern. Man kann z. B. auch ohne mhddfs einfach alle Dateien von allen Datenträgern auf einen neuen größeren zusammen kopieren. Ein weiterer Vorteil vom mhddfs ist es, dass man es nachträglich einsetzen kann sobald ein Datenträger voll geworden ist auf den noch mehr drauf gespeichert werden soll. Man fügt dann einen weiteren Datenträger für die zusätzlichen Dateien hinzu und kombiniert beide Datenträger mit mhddfs zu einem virtuellen neuen - ohne dass man dazu die bereits bestehenden Dateien vom alten Datenträger irgendwie umkopieren müsste. Nachdem man genug Dateien vom kombinierten Dateisystem gelöscht hat so dass alles wieder auf einen Datenträger passt, kann man mhddfs wieder unmounten und alle Dateien von den anderen Datenträgern wo weniger drauf ist auf jenen mit dem meisten Inhalt verschieben, womit man wieder alles auf einem Datenträger hat und die anderen nicht mehr braucht. mhddfs unterscheidet sich von unionfs-FUSE darin, dass es kein Copy-On-Write beherrscht. Alle beteiligten Datenträger müssen beschreibbar sein, außer die nur-beschreibbaren Datenträger haben keinen freien Platz und würden daher ohnehin niemals als Schreibziele ausgewählt werden. Das sollte z. B. bei CD-ROM Dateisystemen oder SquashFS der Fall sein. Allerdings kann man in diesem Fall keine Dateien von den Read-Only Datenträgern löschen oder umbenennen. Man kann mhddfs komplett durch mergerfs ersetzen, allerdings macht das nur Sinn wenn man mit den oben beschriebenen Features nicht auskommt und zusätzliche benötigt (wie Hard Links oder ACLs). Weil allein das Lesen der viel längeren man-Page von mergerfs sollte man sich nicht ohne Not antun. Ich empfehle daher, mhddfs für simple Dateisysteme wie VFAT, ISO-9660 und ExFAT zu benutzen, die keine speziellen Features wie Symlinks, Hardlinks, ACLs etwa besitzen. Für komplexere Dateisysteme wie ext4 ist hingegen OverlayFS oder mergerfs besser geeignet.
mhwaveedit-1.4.14/media-sound/gentoo {audio}: Simpler GTK-basierter Single-Track Audio-Editor. Aber angenehm zu bedienen und sieht auch optisch etwas ansprechender aus als etwa Audacity. "wav" ist sein natives Format, doch durch das Verwenden der "libsndfile" kann er auch alle von dieser Library unterstützten Formate lesen und schreiben. Er unterstützt bis zu 8-Kanalsound. Als Besonderheit kann er mplayer zum Audio-Import verwenden, und kann somit etwa AC3-Sounds aus Movies direkt laden obwohl die libsndfile dieses Format nicht unterstützt. (Exportieren geht jedoch nicht auf diese Art.) Dieses Programm kann daher sehr hilfreich beim Nachsynchronisieren von Untertiteln in Movie-Dateien sein. Unterstützt alle wichtigen Sound-Formate und Sound-Server. Kann unkomprimierte Sounddateien direkt aus der Datei abspielen ohne sie erst "laden" zu müssen (Änderungen ohne "Speichern" sind aber trotzdem nicht-destruktiv). Unterstützt LADSPA-Plugins.
micropolis/games-simulation/gentoo {game}: Ja, das gute alte SIMCITY. Die Original-Adaption für X11. Nutzt zwar die volle Auflösung des Bildschirms, jedoch nur um die Karte größer zu machen. Die Icons bleiben winzig.
midori-0.4.3/www-client/gentoo midori-7.0-2.1/web/debian midori-7.0-2.1/web/raspbian {www-browser}{GTK+}: Ein auf WebKit und GTK+ basierender schlanker Web-Browser. Nur 2,5 MiB Installationsumfang inklusive der benötigten Library dev-libs/libunique - jedoch kommt dann noch net-libs/webkit-gtk mit rund 35 MiB dazu. Alles in allem also rund 38 MiB Installationsumfang. Startet aber flott und hat einen eigentlich ganz passablen Funktionsumfang. JAVA und JavaScript werden unterstützt; ebenso Tabs, SVG-Grafiken, Mausgesten, Tastaturkürzel und es gibt sogar Erweiterungen wie einen AdBlocker (nicht weiter untersucht). Weiters hat er einen komplexen Objekt-Inspektor, welcher durchaus mit dem des Firefox zu vergleichen ist (vermutlich durch webkit-gtk automatisch mitgeliefert, denn das Inspektor wirkt zu aufwändig um in nur 2,5 MB Code untergebracht sein zu können). Was mir gefällt ist eine zuschaltbare Leiste, wo man mit einem Button-Click Bilder, Scripte und Erweiterungen an- oder abschalten kann. Es lassen sich beliebig viele Suchmaschinen konfigurieren, die ähnlich wie bei Firefox auch mit einem Kürzel aus der URL-Leiste heraus aufgerufen werden können. Das Verfallsdatum von Cookies kann auf 1 Stunde, Tag, Woche, Monat oder Jahr begrenzt werden. Es gibt auch einen Side-Bar, in dem man Lesezeichen, History, Downloads oder Cookies verwalten kann. Die Font-Größen lassen sich mit Default- und Minimalgrößen einstellen, des weiteren gibt es einen Vergrößerungsfaktor den man jederzeit in einem Toolbar dynamisch ändern kann. Nun zu den Dingen welche mich nach einigen Tagen Tests störten: Wenn das Fenster schmaler wird, wird das URL-Feld ausgeblendet, so dass man nicht mit mit Strg-L hinspringen kann um die URL in die Zwischenablage zu kopieren oder von dort einzufügen. Man muss statt dessen zuvor das Fenster wieder vergrößern. Noch ärgerlicher ist dass man Tabs zwar mit Mittelklick öffnen kann, dann aber automatisch zu diesem Tab gewechselt wird. Somit ist das Verfahren untauglich um mehrere interessante Links im Hintergrund als Tabs zu öffnen. Ein weiteres Problem ist der Umstand dass optisch nicht klar erkennbar ist welcher Tab der aktuelle ist. Schon öfter als einmal habe ich irrtümlich einen falschen Tab geschlossen. Wenn man Hyperlinks zu anderen Textstellen innerhalb desselben Dokuments folgt, funktioniert der "Zurück"-Button nicht mehr - allerdings gibt es im Kontextmenü einen Punkt "Zurück" der das gewünschte tut. Außerdem startet es zwar flott, aber auch nicht schneller als Konqueror oder gar Dillo. Ein weiteres Ärgernis: Wenn man Texte markiert und in die Zwischenablage kopiert welche geschützte Leerzeichen zur Formatierung enthielten, bleiben dieser erhalten und werden *nicht* in normale Leerzeichen gewandelt wie der Firefox es tut. Man kann solche Texte dann nicht mehr reformatieren ohne die geschützten Leerzeichen irgendwie zu entfernen, was auf jeden Fall einen Zusatzaufwand darstellt. Die Konsequenz aus diesen kleinen aber ärgerlichen Mängeln ist dass man nicht sinnvoll umfangreich mit dem Programm surfen kann, obwohl es ansonsten einen recht guten Eindruck macht. Gut geeignet ist Midori jedoch als voreingestelltes Programm zum Öffnen lokaler *.html-Dateien. Hier hat er gegenüber Dillo den Vorteil dass er auch Pfeile anzeigen kann und er merkt sich beim Neuladen einer Webseite oder Datei die aktuelle Scroll-Position der Ansicht. Gegenüber Netsurf (welcher deutlich schneller startet) als auch Dillo hat er den Vorteil dass er Tabellen mit internen Gitterlinien anzeigen kann, anstatt nur deren äußere Umrandungslinien. Das erhöht die Übersicht enorm. Außerdem lässt sich Text vom Browser-Fenster direkt in ein xterm kopieren was netsurf ebensowenig kann. Leider hat zumindest die oben genannte Raspbian-Version einen schweren Bug: Sie zeigt immer nur ein leeres Fenster an. Ich vermute der Fensterinhalt wird zwar geladen, aber aus irgend einem Grund nicht dargestellt. Wie auch immer - unbenutzbar bis das behoben ist.
milkytracker-0.90.80/media-sound/gentoo {audio}{music}: "MOD"-Tracker application for pattern-oriented music composition and playback. A worthy successof of cheesetracker. Provides ALSA, SDL and JACK playback. Very nice done. Reads and writes many of the old FastTracker and ProTracker formats from the Commodore AMIGA era, such as the .mod and .xm file formats.
minetest-0.4.17.1+repack-1+b1/games/debian {game}: Das OpenSource-Gegenstück zum beliebten kommerziellen Multiplayer-Spiel "Minecraft", welches durch seine Lego-artige Klötzchengrafik bald Kultstatus erreichte. Diese Grafik gibt es auch bei Minetest, nur vom Kultstatus merkt man bislang nicht viel. Dabei dürfte Minetest aus technischer Sicht leistungsfähiger als Minecraft sein, da es in C++ verfasst ist und letzteres nur in JAVA. Das Spiel besteht aus einer Vielzahl von Paketen von denen dieses hier nur das Hauptpaket ist; insgesamt sind derzeit ca. 8 MB an Downloads (37 MB installiert) für verfügbare Pakete (bei Debian 10) vorhanden. Dabei gibt es neben dem eigentlichen Client auch Netzwerk-Server, Mods mit Grafikerweiterungen etc. Es können sowohl vorgefertigte Welten geladen werden, als auch algorithmisch generierte Welten erkundet werden. Das ganze ist zwar im Grunde sehr toll, leidet jedoch darunter dass es scheinbar nichts in den Welten zu tun gibt außer sie zu erforschen und umzugraben wenn man das möchte. Weder gibt es Gegner noch Ziele oder Missionen. Vermutlich ist das über Mods irgendwie möglich, genau wie Crafting. Aber dazu muss man sich vermutlich Online-Spielen anschließen, denn zumindest in den Offline verfügbaren Spielwelten habe ich noch nichts davon gemerkt. Daher ist dieses "Spiel" leider praktisch sehr langweilig weil es einfach nichts zu tun gibt. Dennoch entbehrt es nicht eines gewissen Reizes, die algorithmisch generierten Welten ein wenig zu erforschen, auch wenn diese nicht besonders groß sind sondern nur einen recht überschaubaren Umfang haben.
mirage-0.11.1-1+b14/graphics/raspbian {graphics image viewer}: Ein in Python und GTK+ implementierter Bildbetrachter. Vom Code-Umfang her sehr schlank: unter 200 kB installiert. Daher auf Live-Systemen sehr beliebt. Der RAM-Bedarf dürfte hingegen, Python-bedingt, eher größer als bei anderen Bildbetrachtern sein. Ein "kleines Problem" (2025-09): Das Programm stürzte beim Start mit einem Speicherzugriffsfehler ab. Daher konnte ich es leider nicht weiter testen. Angeblich unterstützt es aber zumindest die folgenden Grafikdateiformate: png, jpg, svg, xpm, gif, bmp und tiff.
mirrormagic-2.0.2.0deb1-11/games/debian {game}: A game based on the "Rocks'n Diamonds" game engine. Mirrors in fixed locations must be rotated into positions such that a beam is reflected in order to hit target objects. There are other objects which heat up the beam cannon and must be avoided. Although not really a bad game and levels can be hard to solve, I find it somewhat boring. Despite of some interactive elements like constantly-rotating beam deflectors and -blockers, it always boils down to find the right combination of rotation positions for all the mirrors, which is somewhat lame. There is also a time limit, making the harder levels stressful to play, without providing any benefit to gameplay.
mit-krb5-1.9.2-r2/app-crypt/gentoo {security}: Die MIT-Implementation des Kerberos-5 Single-SignOn-Systems. Alles sehr super, alles sehr schön. Doch leider sind die einzigen Crypto-Algorithmen die unterstützt werden: DES, TripleDES, AES und Arc4. Wenn man AES-256 verwendet, ist die HMAC aber auf 96 Bit beschränkt. Nur TripleDES gibt es mit voller SHA-1, aber mit 112 Bit effektiver Schlüsselstärke ist TripleDES auch nicht übermäßig überzeugend. Es missfällt mir, die Sicherheit meines Logins nur auf TripleDES-Verschlüsselung aufbauen zu müssen (aber dem traue ich zumindest mehr als AES). Daher werde ich mit-krb5 *nicht* verwenden, bevor es nicht eine breitere Auswahl an Algorithmen und Modes gibt.
mixer_app-1.8.0/x11-misc/gentoo {WM Dock}{audio}: Eine "Window Maker" Dock-App, die einen grafische Sound-Mixer App für X11 bietet.
mksh-59c-9+b2/shells/debian: Die Korn Shell (ksh). Eine von der interaktiven Bedienung her der Bash sehr ähnliche Shell und ebenfalls POSIX-kompatibel. Allerdings ist die ksh deutlich schlanker, vor allem im RAM-Verbrauch der nur geringfügig höher als jener der dash ist. Dennoch bietet die ksh Commandline-Completion, History Search etc genau wie die Bash. Auch die wichtigsten Bash-Extensions wie arrays, "pushd"/"popd" und "time" beherrscht sie, allerdings nicht viel mehr als dies. Insbesondere fehlt das "eingebaute netcat" der bash, also Pseudo-Redirections der Form "/dev/tcp". Soweit man die restlichen Bash-Erweiterungen normalerweise nicht verwendet, kann man die ksh relativ problemlos als RAM-sparendes Drop-In-Replacement für die bash verwenden. Ein kleiner Nachteil der ksh ist dass ihre Arithmetic Expansion nur 32 Bit Integers verwendet, während die Bash mit 64 Bit Integers rechnet. Das macht einen Unterschied wenn man mit $(( ... ))) Berechnungen mit Dateigrößen anstellt, die häufig auch größer als 4 GiB sind. Während die ksh unter Linux nur eine Alternative ist, ist sie unter NetBSD die interaktive Hauptshell. Eine Android-Variante das ksh scheint es auch zu geben, und sie dürfte auch auf vielen Android-Geräten bereits vorinstalliert sein. Es ist überlegenswert auf Rechnern mit wenig RAM (sagen wir 0,5 GiB oder weniger) die ksh anstatt der bash als Login-Shell zu verwenden. Vor allem wenn viele solche Shells gleichzeitig geöffnet sein werden.
mlocate-1.1.18-1/utils/debian: Ab Debian-12 wird mlocate nicht mehr unterstützt und nur als Übergangspaket für plocate installiert. Davor war mlocate die Standard-Implementation des "locate"-Kommandozeilen-Werkzeugs. Es legte einen Suchindex aller Pfadnamen im System an (2021 bei meinem System: Umfang 45 MB) und erlaubte es dann, darin eine schnelle Suche nach Pfadnamen oder Teilen davon durchzuführen. Man kann auch Shell-Joker verwenden, oder Regular Expressions mittels Optionen. Weiters kann man den Suchbereich auch auf Dateinamen anstatt Pfadnamen beschränken. Obwohl der Suchindex alle Dateien umfasst, bekommt jeder User nur Suchtreffer für solche Pfade, die er selbst einsehen kann. D. h. man erfährt nichts, das man nicht auch mit "find" - nur viel langsamer - finden würde. mlocate ist in C geschrieben und hat keine Abhängigkeiten außer von der Standard C-Runtime Bibliothek. Es ist ein SUID-Programm, da es auf den nur von User "root" lesbaren Suchindex zugreifen muss. Aber da es seit Jahren erprobt ist, bezweifle ich dass noch viele sicherheitskritische Schwächen im Programm enthalten sein können.
mlterm-2.9.4-r4/x11-terms/gentoo {terminal emulator}{GUI}{X11}: Terminal-Emulator für X11 mit besonderer Betonung von Mehrsprachigkeit. Sieht nach dem Start ähnlich schlicht wie xterm aus, und bietet auch xterm-ähnliche Aufrufe für Einstellungen (Strg+Mausknöpfe). Diese Aufrufe öffnen aber wenigstens Dialoge mit etlichen Einstellungsmöglichkeiten. Dort kann man auch Fontgrößen auswählen; temporärer Font-Zoom ist ebenfalls vorhanden. Tabs gibt es zwar keine, aber eine annähernde Nachbildung durch mehrere Pseudo-Terminals die man öffnen kann und welche dasselbe Terminal-Fenster verwenden; mittels des Strg+Links Menüs kann eines der Pseudo-Terminals aktiviert werden so dass es im Fenster zu sehen ist. Wie zu erwarten, gibt es etliche Features zum Zeichensatz-Mapping und für asiatische Sonderzeichen. Voller UTF-8 Support und verschiedene Input-Methods. Verlaufsspeicher, Scrollbalken, Vorder- und Hintergrundfarben lassen sich ebenso anpassen. Farbthemen oder benutzerdefinierte andere Terminalfarben fand ich aber zumindest im Menü nicht. Dafür gibt es eher sinnlose Spielereien wie Hintergrundbild, Transparenz, Anti-Aliasing und Gammakorrektur. Interessant auch dass es zwar zahlreiche Möglichkeiten gibt die Größe und Darstellungsart des Fonts einzustellen, nicht aber den Font selbst. Zumindest nicht übers Menü.
moinmoin/www-apps/gentoo {wiki}{text-formatting}: Ein Wiki in Python. Kann eigentlich alles, hat nur ein Problem (aus meiner Sicht): Die verschiedenen Versionen der Dokumente werden nicht als Deltas gespeichert, sondern alle im Volltext. Überdies verwendet das Ding keine (erkennbare) Datenbank - alles wird als einzelne Datei gespeichert. Das mag OK sein für ReiserFS, aber wird sicherlich teuer für ext2/3/4. CamelCase wird standardmäßig für Links verwendet, mit umständlicherer Syntax können aber auch Hyperlinks ohne CamelCase angelegt werden. Falls man CamelCase verwendet, werden die Hyperlinks allerdings auch genau so angezeigt soweit man keinen expliziten Ersatztext angibt. Das ist gräßlich. Wenigstens gibt es eine Option, die bei der Darstellung Leerzeichen zwischen die CamelCase-Silben einfügt. Dennoch sieht es immer noch seltsam aus wenn nicht-Substantive in Hyperlinks ohne erkennbaren Grund groß geschrieben werden. Ein definitiver Nachteil von moinmoin ist seine Größe: 85 MiB für das Kernpaket, obwohl in Python geschrieben. Hinzu kommen noch weitere Zusatz-Libraries für Abhängigkeiten, die aber klein sind verglichen mit dem Hauptpaket. Obwohl alles recht fein funktioniert, fragt man sich ob ein solch simples System wirklich einen derartigen Implementationsumfang rechtfertigt. Andererseits mag ein Gutteil der Größe auch der vielfachen Mehrsprachigkeit geschuldet sein, so das unzählige Templates für alles mögliche in vielen Sprachen mitgeliefert werden. Ein Vorteil wiederum ist die Eigenständigkeit: Man braucht keine Datenbank, PHP oder andere Tools - nur einen vorgeschalteten Webserver, und selbst den kann man bei kleineren Installationen weglassen und moinmoin direkt als Webserver benutzen. Das Wiki bietet online-Editieren mit und ohne JavaScript-GUI-Editor an, ebenso Versionsgeschichte aller Seiten mit "diff"-Funktionalität. Es gibt Support für die Synchronisation zwischen Wikis, aber es ist mir aus der Erklärung unklar wie das Mergen im Fall von Konflikten funktioniert. Eben so unklar ist die Sicherheit solcher Synchronisation (oder allgemein die Sicherheit von Remote-Edits) - da sie auf XMLRPC basiert, wird sie vermutlich nur so "sicher" sein wie TLS es erlaubt. moinmoin unterstützt Plugins für alles mögliche, darunter auch solche für unterschiedliche Markup-Formate. Das mitgelieferte bzw. "native" Markup-Format ist "ReStructured Text". Xapian wird zur Volltextsuche eingesetzt. Attachments können Wiki-Seiten beigelegt werden. ACLs können Rechte auf Wiki-Seiten einschränken.
monit-1 {service manager}: 5.4-2/admin/debian: Ein Service-Monitoring-System, das Dienste nicht nur überwachen sondern auch unter Berücksichtigung von Abhängigkeiten starten und stoppen kann. Es ist allerdings nicht als Ersatz für init gedacht, sondern sollte am besten direkt von diesem ausgeführt werden. Es kann alle möglichen Systemressourcen überwachen, etwa Dateien, Sockets, Erreichbarkeit von Servern, CPU-Verbrauch usw. Dazu werden in fixen Intervallen Überprüfungen vorgenommen, und dazu Regeln wie "wenn Dienst sowieso in 5 Prüfungen mehr als 2 mal nicht mehr lief und neu gestartet werden musste, schicke eine Mail". Monit kann auch bestimmte Netzwerk-Protokolle auf Verbindungen überprüfen, und dies ist in gewissen Grenzen sogar frei erweiterbar. Monit wird durch eine einzige Konfigurationsdatei gesteuert (natürlich pro laufender Instanz), die nicht nur normale Settings sondern auf die Regeln in Form einer simplen Programmiersprache enthält. Dies hat den Vorteil dass man diese Datei leicht versionieren kann; jedoch auch den Nachteil dass sie unübersichtlich lang werden könnte wenn es viele Dienste mit komplexen Start-Anweisungen gibt. Ein Vorteil ist, dass man daher nicht auf notorisch zu Fehlern neigende Shell-Scripte zurück greifen muss. Ferner wird der Parsing- und Startup-Overhead der Shell eingespart - zumindest solange man innerhalb der Regeln keine Scripte aufruft, was durchaus möglich ist. Das Abhängigkeits-System ist simpel, scheint aber solide und durchdacht zu sein. So werden etwa beim Absturz eines Dienstes nicht nur dieser neu gestartet, sondern zuvor auch alle von ihm abhängigen anderen Dienste zuerst beendet, und nach dem Neustart des Dienstes dann ebenfalls neu gestartet. Im Falle von Alarmmeldungen können diese in eine Wartschlange gestellt werden, wenn das Versenden momentan nicht funktioniert, um dies später nachzuholen. Der Installationsumfang von monit ist mit etwa einem 3/4 MB akzeptabel, und es hängt nur von häufig benutzten Bibliotheken (libc, SSL, libgcc etc) ab. Ein Nachteil von monit ist dass Dienste nicht anders geprüft werden als andere Ressourcen, also nur in diskreten zeitlichen Abständen (typischerweise einige wenige Minuten). Wenn ein überwachter Dienst abstürzt, wird er daher zwar neugestartet, aber das kann ein paar Minuten dauern. Dieser Daemon läuft daher zwar die ganze Zeit und verbraucht Ressourcen, schläft aber die meiste Zeit davon genau wie cron. Deshalb kann man runit statt dessen auch durch cron starten lassen. Weiters macht der Support für einen eingenauten Webserver, diverse Protokolle und das Monitoring im Allgmeinen monit zu einem relativen Overkill, wenn man das alles eigentlich nicht braucht und nur Services damit managen möchte. Auch die man-page ist dann aus demselben Grund umfangreicher als nötig. Richtigen Support für Runlevels gibt es auch nicht, obgleich man eventuell Service-Gruppen dafür missbrauchen könnte. Und großartigere Dinge wie Socket Activation und Ähnliches kann monit schon gar nicht.
monit-5.9/app-admin/gentoo {service manager}: Ein ziemlich kompaktes (1 MB) in C geschriebener System-Monitoring-Dienst, der aus einem einzigen Executable besteht (kein wildes Sammelsurium an Scripten und Prozessen wie leider so oft in anderen Fällen). Er kann zahlreiche Betriebsparameter überwachen und Alarm schlagen wenn diese definierte Grenzen verlassen. Bietet auch ein Web-Interface.
monster-masher-1.8.1-8/games/debian {game}: Ein GNOME2-basiertes Spiel in dem man irgendwelche Monster zerquetschen muss - vielleicht eine Abart von Sokoban oder so etwas ähnliches. Könnte vielleicht interessant sein. Die hier genannte Version hat allerdings das Problem dass beim Start nur eine Fehlermeldung wegen irgendwelcher angeblich nicht gefundener Dateien erscheint, und das war es dann mit dem Spielvergnügen. Mit anderen Worten: Funktioniert zur Zeit einfach nicht. Vielleicht in ein paar Jahren noch einmal testen.
moon-lander-1 {game}: 1.0-7/games/debian: Eine Art "Jupiter Lander"-Klon. Nur dass man hier - angeblich - auf dem Mond landet. Der Grafik nach sieht es eher wie der Saturn oder sonstwo aus, aber nie nach dem Mond. Egal. Grundsätzlich dasselbe Spiel: Man muss mit der Rakete sicher landen bevor einem der Treibstoff ausgeht. Dabei muss man am Düsenstrahl reiten und darf weder gegen die Kraterwände knallen als auch nur zu fest aufzusetzen. Dann explodiert man und verliert ein Leben. Eigentlich mag ich solche Spiele ja, aber dieses gefällt mir grafisch irgendwie nicht. Ich kann nicht einmal sagen woran genau es liegt, da die Grafik durchaus hoch aufgelöst und nicht direkt hässlich ist. Aber dennoch - irgendwie missfällt mir diese Implementation des alten Klassikers.
moria/games-roguelike/gentoo {game}: Ein Character-Mode Dungeon Exploration Game. Ein weiteres Nethack/Rogue. Besteht nur aus ASCII-Zeichen. Grafisch entsprechend primitiv, aber nett gemacht. Eher uninteressant unter X11, aber vielleicht nicht schlecht wenn man nur die Character-Mode Konsole zur Verfügung hat. Allerdings gibt es mit calcrogue einen Konkurrenten der mir noch besser gefällt. Allerdings ist calcrogue nicht im Debian Repository enthalten sondern man muss es sich selbst kompileren. Zudem ist moria ein komplexeres Spiel; es gibt nicht nur zufällig generierte Maps, sondern auch vorprogrammierte Städte mit Handelsgeschäften, Häusern etc. Ein grafischer Konkurrent für diese Art von Spiel ist "Powder", welches aber genau so wenig in Debian verfügbar ist und man muss es sich daher ebenfalls selbst kompilieren. So gesehen bleibt moria eine der besten stets verfügbaren und nicht erst mühsam selbst zu kompilierenden "rogue"-Alternativen für Debian.
motif-2.3.4-r3/x11-libs/gentoo: X11-GUI-toolkit from the good 'ol times. But most importantly, contains "mwm", the Motif window manager. This is the most primitive windows manager which can still be used by a normal person without going totally crazy after a few minutes. This WM features nearly nothing, but at least it can display the running application at the bottom of the display and allows changing them also with the tabulation key. On the other hand, mwm is larger than jwm, and jwm is even easier to use. Also, mwm depends on the Mofif libraries, whereas jwm has no such dependencies. Some time in the past, this package was named "openmotif".
motor/dev-util/gentoo: Bad UTF-8 support
mousepad-0.5.2-1/xfce/raspbian {text-editor}{GTK+}: Mousepad ist der Standard-Texteditor der XFCE Desktop-Umgebung, benutzt aber keine Bibliotheken von XFCE als Abhängigkeiten sondern basiert direkt auf GTK+. Von den Features her bietet er mehr als Leafpad und weniger als Kwrite. Mousepad ist ein Fork von Leafpad, daher bieten beide Programme identische Grundfunktionen wie anpassbare Schriftart, optionaler weicher Zeilenumbruch, optional links von der Zeile eingeblendete Zeilennummer. Mousepad kann zusätzlich: Einfügen von Text aus einem "Verlaufs-Speicher", Einfügen von Text als rechteckige Spalte, beliebig viele Dateien pro Instanz öffnen, Tab-Support, Historie der zuletzt geöffneten Dateien, optionaler Button-Bar, Druck-Funktion mit Druck-Vorschau, Syntax-Highlighting für eine Hand voll Quelltext-Dateitypen, anpassbare Tabulator-Weite, optional Leerzeichen anstatt Tabulator-Steuerzeichen einfügen, Umwandeln zwischen Tabulator und Leerzeichen, Umwandeln zwischen Großschrift, Kleinschrift, "Title Case" und Case Inversion, drei wählbare Newline-Sequenzen, optionales UNICODE-BOM, automatische Einrückung, ein- und Ausrückung von Zeilenblöcken sowie Verschieben dieser, Funktion zum Entfernen von Leerzeichen an Zeilenenden, Vollbildmodus, Sprung zu Zeile+Spalte. Der größte Nachteil dieses Programmes, die mich halb in den Wahnsinn trieb, ist die schwachsinnige Suchfunktion. Leider arbeitet sie ausschließlich inkrementell, wodurch sie bei längeren Texten schweinelangsam wird. Doch schlimmer noch ist der Umstand dass sie vielen Einstellungen gehorcht, die dort gar nicht auswählbar sind. Dadurch findet sie oft den gesuchten Text nicht, etwa wenn die Suche gerade auf vollständigen Worte beschränkt ist, man jedoch nur einen Wortteil eingegeben hat. Daher sollte man die Suchfunktion nicht benutzen, oder nur zusätzlich, sondern statt dessen die Ersetzungsfunktion. Die kann nämlich genau so suchen, nur dass man dort alle Optionen angezeigt bekommt und auch umschalten kann. Man kann dort z. B. zwischen simpler Textsuche und RegEx-Suche umschalten, ebenso Groß-/Klein-Unterscheidung oder dass nur vollständige Wörter gefunden werden sollen. Leider wird die schwachsinnige inkrementelle Suche auch bei der Ersetzen-Funktion angewendet, obwohl diese (im Gegensatz zur Nur-Suchen-Funktion) in einem normalen Dialogfenster stattfindet. Auch Copy/Paste ins Suchfeld und Ersetzen-Dialog wird wegen der inkrementellen Suche zum Nervenspiel, und der Eingabefokus ist häufig im falschen Feld. Alles zusammen ist die Suchfunktion des Programms extrem nervig und weitaus unkomfortabler als beim Vorgänger "Leafpad". Leider braucht dieser Editor auch noch ziemlich lange zum Starten. Sobald er dann aber erst einmal läuft, gibt es zumindest auf einem RPi3 keine weiteren Performance-Probleme mehr. Und im Gegensatz zu Leafpad hat er nicht den nervigen Bug dass das Fenster nach dem Schließen manchmal "als Leiche" offen zurück bleibt, bis man eine neue Instanz des Editors gestartet hat. Man kann in der Konfiguration wählen ob das Programm (beim Aufruf von außen bzw. über den Dateimanager) Dateien standardmäßig als neue Karteireiter existierender Fenster des Programms oder als neue Fenster öffnet. Weiters lassen sich Fenster auch mit der Maus in andere Fenster ziehen, wodurch sie dort zu Karteireitern werden. Ebenso kann man auch Karteireiter aus dem Fenster ziehen, wodurch sie zu individuellen Fenstern werden. Diese Funktion ist ähnlich wie die Gruppierungsfunktionen von "Tabbing"-Fenstermanagern, funktioniert jedoch programmintern und unabhängig vom Fenstermanager. Leider hat die oben erwähnte Raspbian-Version einen schweren Bug: Die im "Ersetzen"-Dialog verfügbare Funktion um alle Suchtreffer auf einen Schlag und ohne individuelle Nachfrage ersetzen, wird *immer* verwendet - egal ob sie ein- oder ausgeschaltet ist. Ein katastrophaler Bug, der diesen Editor gemeingefährlich und somit praktisch unbenutzbar macht bis er behoben wurde.
mp-3.3.17/app-editors/gentoo {text-editor}{text-terminal IO}: Nice easy-to-use text editor with syntax highlighting. Can be run as both a console and an X11 application. Unfortunately it does not support UTF-8.
mp3info-0.8.5a-3/sound/debian: Ein MP3 Tag-Editor der wahlweise über Kommandozeilenoptionen oder ein ncurses Textmode-Userinterface bedient werden kann. Allerdings ist die CLI-Bedienung sehr spezifisch: Man muss exakt spezifizieren welche Felder man ausgeben oder setzen will. Kein Import-/Export aller Tags wie ich es gebraucht hätte. Noch dazu versteht es offenbar wirklich nur MP3-Tags; nicht einmal die von AAC Dateien verstand es. Geschweige denn OGG-Dateien.
mpfr-3.0.1_p4/dev-libs/gentoo: Eine auf gmp aufbauende Bibliothek für beliebig genaue Fließkommazahlen, die im Gegensatz zum originalen gmp besonderen Wert auf korrekte Rundung verwendet. Alle 4 Rundungsmodi von IEEE-754 werden unterstützt. Außerdem unterstützt sie neben "echten" Zahlen wie in gmp auch vorzeichenbehaftete Null, "Unendlich" und Not-A-Number. LGPL-lizensiert und daher problemlos auch für kommerzielle Anwendungen. Die vermutlich beste Library wenn es darum geht, Fließkommaberechnungen mit definierter Genauigkeit durchzuführen.
mpi-default-bin-1.13/libdevel/debian: Provides the default implementation of the message-passing interface (MPI) framework.
mplayer/media-video/gentoo {media-player}: Media Player for Linux. Command-line and GUI. Very similar to VLC, but less buggy (at least on my box). It excels in some areas (memory footprint and stability) where VLC excels in others (has more postprocessing options). Best to install them both.
mpsolve-3.2.1-2+b1/science/debian {math}: Bestimmt die Nullstellen eines gegebenen Polynoms numerisch mit beliebiger Genauigkeit. Bietet verschiedene numerische Algorithmen zur Auswahl für die Lösung an. Wahrscheinlich das beste allgemein verwendbare Programm für das Finden von Wurzeln von Polynomen. Was dieses Programm hingegen nicht ist (obwohl ich dies hoffte als ich es installierte), ist ein Werkzeug zum Approximieren von unbekannten Funktionen aufgrund gegebener Funktionswerte.
mscgen-0.20-4/devel/debian: Ein mit nicht einmal 100 kB Installationsumfang erfreulich schlankes in C implementiertes Utility, welches grafische Diagramme des zeitlichen Ablaufs von Konversationen mehrerer Teilnehmer in den Formaten SVG, PNG oder EPS erstellt. Das Paket devel/doxygen stellt einen optional benutzbaren Befehl zur Verfügung, mit dem mscgen aus doxygen-Dokumentations-Kommentaren heraus aufgerufen und das erzeugte Diagramm in die erzeugte Dokumentation integriert werden kann. Weiters gibt es ein Plug-In für das Paket text/asciidoc, mit der man den Quelltext von mscgen-Diagrammen direkt in asciidoc-Dokumente einbetten kann. mscgen-Diagramme werden aus einer Quelltext-Sprache generiert, welche ähnlich simpel wie jene von graphics/graphviz ist. Letzteres Paket ist allerdings um ein Vielfaches fetter.
msv-20050627-r2/dev-java/gentoo: Ein von Sun entwickelter XML-Validator aus der Urzeit. Unterstützt weder XML Namespaces korrekt noch die volle W3C DTD Spezifikation. Als es 2001 heraus kam war es wohl toll, heute für allgemeine Validierung unbrauchbar.
mtpaint-3.40-15/community/archlinux {bitmap image editor}: Ein weiteres auf Pixelgrafik spezialisiertes Malprogramm, das eher nicht zur Fotobearbeitung gedacht ist. Dennoch lässt es sich auch dafür verwenden. Werkzeuge: Stift, Farbkübel, Gerade Linie, Verwischen, Klonpinsel, Farbverlauf, Text, Auswahl (Lasso, rechteckig, freihändig/Polygon). Aus einer Rechteck-Auswahl kann eine Ellipse gerendert werden. Es werden mehrere Kanäle (für Masken und Transparenz) unterstützt. Ebenso mehrere Ebenen, welche im Falle einer GIF-Animation dann die einzelnen Frame-Bilder aufnehmen. Unterstützte Grafikformate ab Version 3.40: BMP, GIF, LSS16 (SysLinux SplashScreen Format), PCX, PNG, TGA, TIFF (speichern nur unkomprimiert), XPM, JPEG, PAM, PPM, JPEG-2000, und ASCII-Art (nur speichern). Ab Version 3.50 zusätzlich: "LBM" (AMIGA ILBM), WebP und TIFF auch mit komprimiertem Speichern (Subformate: FAX Group3, FAX Group 4, PackBits, LZW, ZIP, LZMA2, ZSTD, JPEG, WebP, JPEG-2000). Im Gegensatz zu grafx2 kann es aber zumindest auch TrueColor Bilder bearbeiten, und bringt auch die wichtigsten dafür zu erwartenden Effektfilter mit. Gleichwohl setzt es wie grafx2 den Schwerpunkt auf die Bearbeitung von palettenbasierte Bilder. Auch bei der Bearbeitung von TrueColor Bildern werden Paletten zur Farbauswahl benutzt, nur dass man sie jederzeit redefinieren kann und dies keine Auswirkungen auf die bereits im Bild vorhandenen Farben hat. Es beherrscht neben Ebenen (die auch für Einzelbilder bei Animationen genutzt werden) noch Kanäle, inklusive Alpha-Kanal. Das Programm scheint deutlich mächtiger zu sein als grafx2, erfordert aber auch eine längere Einarbeitungszeit. Ein Nachteil gegenüber grafx2 ist die fehlende Script-fähigkeit. Mit 1,5 MB ist es eine um knapp die Hälfte größere Installation als grafx2, aber immer noch sehr kompakt verglichen etwa mit "The GIMP". Eine ausführliche Anleitung ist von der Homepage herunterladbar. Alles in allem eine gute Wahl für ein Malprogramm, wenn einem GIMP zu umfangreich oder zu komplex in der Bedienung ist. Jedoch fehlen viele der mächtigeren Funktionen zur Fotoretusche, die man von Foto-Editoren gewöhnt ist, oder sie sind nur in rudimentärer Form vorhanden.
mu-editor-1.0.2+dfsg-3/python/debian {development_environment}: Eine wie für kleine Kinder oder extrem blutige Anfänger optisch aufbereitete primitiv-IDE für Python. Im wesentlichen nur ein netter Code-Editor mit Syntax-Highlighting und integrierter Anzeige für Fehlermeldungen des Python-Interpreters. Enthält jedoch auch einen integrierten grafischen Debugger samt Anzeige von Variableninhalten. Nicht direkt schlecht, aber es ist mit Ausnahme des grafischen Debuggers kein rechter Mehrwert gegenüber der Nutzung eines beliebigen Text-Editors mit Python-Support erkennbar.
multistrap/admin/devuan: Soll grundsätzlich dasselbe tun wie "debootstrap", nämlich ein entpackbares lauffähiges Minimalsystem einer Debian-basierten Distro generieren. Allerdings ist es in Perl geschrieben und hat viel mehr Abhängigkeiten als debootstrap, darunter auch solche die das Script selbst nur auf einer Debian-basierten System lauffähig machen. Ein Vorteil von Multistrap ist jedoch, dass man mehr als ein Repository als Quelle für die ins Mininmalsystem aufzunehmenden Pakete angeben kann. Ein Bug-Report aus dem Jahr 2014 behauptet jedoch, dass ein damit generiertes Minimalsystem für den Raspberry Pi nur begrenzt lauffähig sei und bald danach mit einer Kernel Panic einfrieren würde. Außerdem ist der Aufruf von multistrap nicht so einfach wie der von debootstrap, man muss zuerst umständlicher Weise ein Konfigurations-File anlegen. Andererseits war multistrap im Gegensatz zu debootstrap *überhaupt* in der Lage, seine Operation erfolgreich abzuschließen. Und der genannte Bug-Report könnte auch auf Inkompetenz bei der Paketauswahl zurück zu führen sein. multistrap beherrscht leider nicht das "--exclude"-Feature von debootstrap, so dass unter Umständen mehr Pakete als gewünscht inkludiert werden.
mumble-1.2.18-1/sound/devuan {chat}: Eines der wenigen voIP-Programme, die überhaupt irgendwie funktionieren. Taugt nicht nur zum Voice-Chat, sondern hat auch einen eingebauten Text-Chat. Die Übertragung erfolgt verschlüsselt, den in Lua implementierten Server ("murmur", separates Paket) kann man auch selbst aufsetzen. Leider hat das Programm insgesamt recht fett obwohl es für seine Klasse geradezu schlank ist, und verbraucht auch mehr Hintergrund-Datenvolumen als man mit einem Volumens-limitierten Datenvertrag vielleicht aufbringen möchte. Das Datenvolumen während der eigentlichen Telefonate hält sich dank effizienter Codecs aber in Grenzen. Das Programm ist vor allem zur Kommunikation in Online-Spielen beliebt und wird dort von vielen Plattformen unterstützt. Es ist aber auch völlig unabhängig davon nutzbar. Ein ewiges Ärgernis mit diesem (wie auch allen anderen VoIP-Programmen die ich bislang testete) ist das Kalibrieren der Lautstärke-Settings, wo man teilweise einen langen Kampf gegen verschiedene Audio-Mixer Frameworks führen muss welche sich beständig einmischen und die Kalibration behindern.
mupdf-1.8/app-text/gentoo {document viewer}{PDF}: Sehr simpler und einfach zu bedienender PDF-Viewer. Kann auch eBooks im EPUB-Format anzeigen, allerdings braucht man dazu gute Nerven weil es unglaublich langsam startet (scheint beim Öffnen das ganze eBook in eine Temporärdatei mit einem internen Format zu konvertieren). Hat keinerlei Buttons; komplett über Tastatur, Maus und Mausrad (blättern, scrollen oder Text selektieren) bedienbar. Startet dafür aber blitzschnell. Als Notfall-Ersatz für die fetten Viewer sinnvoll. Suchfunktion und Sprung zu Seitennummer sind verfügbar. Ungewöhnliches Feature: Man kann Farb-Negativdarstellung einschalten. Ebenso kann man Farben auf Graustufen bzw. S/W reduzieren lassen. Kann nicht nur um 90, sondern auch um 18 Grad rotieren. Vollbildmodus wird unterstützt. Ein Diashow-Modus ist enthalten der zeitverzögert vorwärts blättert. 16 Zoomstufen werden unterstützt. Anpassung der Fenstergröße an die Seitengröße ist ebenso möglich wie Anpassung des Seitenzooms an die Breite oder Höhe des Fensters. Kann 10 Lesezeichen für Seiten setzen und diese anspringen. PDF-Passwort und anfängliche Zoomstufe können als Aufrufargumente spezifiziert werden. Mit SIGHUP kann zusätzklich von außen ein Neuladen des Dokuments erzwungen werden.
music-applet-2.5.1/gnome-extra/gentoo {audio}{music}: An applet for the GNOME desktop which provided Desktop-GUI control for the following audio media players: Amarok, Audacious, Banshee, Exaile, Libet, MPD, Muine, Rhythmbox, VLC, XMMS, XMMS2.
mypaint-2.0.1-2/graphics/debian: Ein pixelbasiertes Malprogramm. Primär für Grafiktabletts, aber auch für die Maus geeignet. Der Fokus liegt nicht auf Pixel Art, sondern auf der Verwendung zahlreicher mitgelieferten Pinsel für Kohlestift-Effekte oder ähnliches "Künstlerisches". Erinnerte mich an "krita", nur deutlich schlanker als dieses. Allerdings kann "krita" auch viel mehr. Das Programm ist offensichtlich nicht zum Bearbeiten von Fotos gedacht, sondern um selber welche zu zeichnen. Kaum geeignet ist es hingegen für simple grafische Notizen ("Sketchnotes") - es gibt nicht einmal Funktionen um Ausschnitte zu markieren um sie zu löschen oder zu verschieben. Dafür zig Feineinstellungen des Pinsels und anderer kalligrafischer Feinheiten. Ebenen werden ebenfalls unterstützt. Ungewöhnliches Feature: Standardmäßig hat eine Zeichnung keinen Rand. Man kann in jeder Richtung endlos weiter zeichnen. Allerdings kann man mit einer Spezialfunktion solch einen Rand hinzu fügen, wenn man z. B. ein bestimmtes Papierformat bearbeiten will. Ein ca. 3 MB großer Download.
myrepos-1.20160123/vcs/debian {version control}: Stellt ein Kommando "mr" zur Verfügung, welches bestimmte VCS-Kommandos wie "commit", "push" etc. für eine ganze Gruppe von versionskontrollierten Repositories durchführt. Dabei unterstützt es die folgenden Arten von Repositories bzw. Check-outs: git, svn (Subversion), hg (Mercurial), bzr (Bazaar-NG), darcs, cvs, vcsh, fossil und veracity. Es ist angeblich auch einfach um weitere Typen von Versionskontrollsystemen erweiterbar. "mr" besitzt auch einen Offline-Modus, wo alle Aktionen welche eine Remote-Konnektivität erfordern müssen unterbleiben und statt dessen aufgezeichnet werden. Sobald die Online-Konnektivität später wieder vorhanden ist, können diese aufgezeichneten Aktionen dann nachgeholt werden. Des weiteren können diverse Hook-Scripte für alle möglichen Aktionen definiert werden, beispielsweise indem Dateisystemberechtigungen nach dem Auschecken angepasst werden oder dergleichen. Weiters gibt es ein "bootstrap"-Kommando, mit dem man auf einem neuen Rechner eine Konfigurationsdatei für mr von einem anderen Rechner herunterladen kann, und in dieser sind dann Repository-URLs zum Klonen bzw. auschecken vorhanden. Soweit alles sehr nett. Allerdings scheint mr keine Gruppen-Definitionen zu kennen. Operation von mr scheint ausschließlich in Form von Unterverzeichnissen zu funktionieren: Man kann also in einem übergeordneten Verzeichnis ein "mr"-Kommando absetzen, und dieses wird dann für alle Repositories oder Check-outs in Unterverzeichnissen durchgeführt. Zumindest wenn diese zuvor für die Administration durch "mr" registriert wurden. Es scheint aber keine Möglichkeit zu geben, völlig willkürlich im Dateisystem verstreute Repositories als gemeinsame Gruppe zu handhaben. Es wäre allerdings noch auszuprobieren, in wie fern dies mittels Symlinks emuliert werden kann. "mr" scheint sich seltsamer Weise irgendwie an den Remote-URLs der Repositories zu orientieren. Es war mir nicht möglich ein Repository zu registrieren welches nur lokal existierte - und das obwohl sehr wohl ein Remote konfiguriert war, wenn auch nur ein anderes eben so lokales Directory. Auf jeden Fall war es "mr" nicht gut genug und es weigerte sich zu arbeiten. Mir kommt das etwas seltsam vor: Was, wenn es viele Remotes für ein Repository gibt? Woran orientiert sich "mr" dann? Ich fand in der Anleitung keinen Hinweis für einen solchen Fall. Was, wenn das Remote eine URI (wie etwa "tag:") statt einer URL hat? Git unterstützt schließlich auch Custom Protocol handlers. Auf jeden Fall scheint das Tool daher zumindest für meine Zwecke unbrauchbar zu sein, wenn es solche Ansprüche stellt mit URLs hantieren zu können und ihm nur-lokale Repositories nicht gut genug sind, auch wenn diese genau so von einer Batch-Operation profitieren könnten. Schade.
myrescue-0.9.8-3/utils/raspbian: Ein Datenrettungs-Tool ähnlich wie dd_rescue, welches allerdings den Vorteil hat dass es in mehreren Phasen arbeiten kann. Dabei kann man zunächst einen "Skip Modus" aktivieren der so schnell wie möglich (durch exponenzielle Sprungweiten-Steigerung) fehlerhafte Bereiche überspringt um gesunde Bereiche als erstes zu kopieren. Danach kann man dann die übersprungenen Bereiche im Normalmodus erneut zu kopieren versuchen um auch die restlichen gesunden Blöcke zu kopieren. Weiters können auch fehlerhafte Blöcke mehrmals zu lesen versucht werden bevor man aufgibt. Problem: Die man-page führt in der Dokumentation als Fehler an, dass die vom Programm verwaltete Bitmap-Datei nicht mehr als 127 Lesefehler "zählen" könne. Es bleibt unklar was das bedeutet. Sollte dies bedeuten dass eine Disk nicht mehr als 127 Lesefehler enthalten kann oder sie werden nicht als solche erkannt, wäre dies katastrophal! Bis ich näheres weiß, werde ich dieses Tool sicher nicht zur Datenrettung einsetzen!
myspell-de/app-dicts/gentoo: German dictionaries for hunspell (and myspell).
myspell-en/app-dicts/gentoo: English dictionaries for hunspell (and myspell).
nail-12.4-r2/mail-client/gentoo: Das die erweiterte "Heirloom"-Edition des UNIX "mail"-Kommandos, welche als erweitertes Drop-In-Replacement für den "mailx"-Befehl konzipiert ist. Im Vergleich zu mail-client/mailx unterstützt es auch die Protokolle POP3, IMAP und SMTP direkt. Letzteres bedeutet dass es auch ohne installiertes sendmail auskommt, obgleich es dieses benutzen kann falls vorhanden. Doch leider gilt dies nur für das Versenden von Mail an andere Rechner: Wenn man lokale Mail (übers Mailspool-Verzeichnis) versenden will, braucht man ebenfalls ein sendmail. Das Programm unterstützt weiter UTF-8, MIME types und Attachments. Für IMAP wird lokales caching und disconnected operation unterstützt. Unterstützt auch STARTTLS und SMTPS (via OpenSSL) und S/MIME. Enthält auch einen bayesischen Junk-Filter. Kurzum, in jeder Hinsicht dem originalen mailx überlegen, aber auch rund doppelt so großer Installationsumfang (rund 800 KiB).
nano-2.3.1-r2/app-editors/gentoo {text-editor}{text-terminal IO}: Nano ist als kleinster noch halbwegs komfortabel/"normal" bedienbarer Editor bekannt. Mit 234 K ist sein Executable auch in der Tat am kleisten. Zusammen mit DLL-Abhängigkeiten (ohne Standard-Runtime-Libraries) ist er allerdings 912 KB groß und somit nur um 24 KB kleiner als "joe" - der ihn in der Funktionalität aber um Längen schlägt. Andererseits sind die besagten zusätzlichen Abhängigkeiten keine besonderen Exoten, und es ist daher durchaus möglich dass sie ohnehin installiert sein müssen. Und das eigentliche Executable von nano ist nur halb so groß wie das von joe. Als zwangsinstallierter Default-Editor taugt nano daher immer noch am besten, da die Platzverschwendung nicht schmerzt wenn man ihn nicht verwendet. Wen man allerdings die Wahl hat, wurde ich "ne" klar dem "nano" vorziehen.
nasm-2.09.04/dev-lang/gentoo: Ein netter, kleiner aber mächtiger x86 Macro-Assembler, der so ziemlich alle denkbaren Object-Output-Formate generieren kann, die für die verschiedenen Plattformen der x86-Welt bekannt sind. Neben 16-, 32-und 64-Bit Windows- und Linux-Plattformen deckt dies auch Motorola S-Records ab, sowie weiters DJGPP for DOS, Intel Hex, a.out, Win16, MacOS X, x86 Real Mode, DOS 16/32-Bit OMF Object Files, MS-DOS COM and SYS files, das portable RDOFF-Format, etc. Für viele dieser Targets werden auch Debugging-Formate unterstützt. Verfügt über TASM-Kompatibilitäts-Modus. Optionale Multipass Branch-Optimierung. Source-Syntax nicht kompatibel zu MASM oder GAS. Enthält auch einen Disassembler, Tools zum Erzeugen von COM, INTEL-Hex, SREC, RDOFF und ähnlicher Formate welche der Linker nicht direkt erzeugen kann. Für das RDOFF-Format liegt eine Library bei sowie ein Tool zum Laden und Ausführen solcher Dateien. Allerdings ist RDOFF eine NASM-spezifische Eigenentwicklung. Ein Loader für dieses Format kann allerdings in rund 110 Zeilen Assembler-Quelltext und unter 100 Bytes Maschinencode implementiert werden und mag daher für Embedded Systeme durchaus als Binary-Format interessant sein.
nautilus-2.32.2.1-r1/gnome-base/gentoo {file manager}{GTK+}: Der Standard-Dateimanager des GNOME Desktop-Environments. Wenn man ihn (ohne GNOME) startet, muss man leider einige Einstellungen mit dem gconf-editor vornehmen damit er sich "wie ein normales Programm" benimmt. Ansonsten versucht er den gesamten Desktop-Hintergrund zu übernehmen, terminiert nicht wenn man das Fenster schließt etc, mountet wie ein Geistesgestörter alle Einträge der /etc/fstab inklusive solcher welche das noauto-Flag gesetzt haben, und anderes mehr. Aber man *kann* diese Dinge zumindest einstellen, und danach ist nautilus ein recht brauchbarer und nicht zu aufgeblähter Dateimanager. Funktional erscheint er wie eine Mischung aus xfe und pcmanfm; allerdings kann man ihn deutlich mehr anpassen als die beiden anderen Programme. Nautilus bietet sowohl Tabs als auch eine optionale 2-Fenster-Ansicht (mit separaten Tabs). Zusätzlich hat er eine Seitenleiste welche per Default genau wie die von pcmanfm funktioniert, wo also Mount-Points und Bookmarks angezeigt werden. Man kann die Seitenleiste aber auch auf andere Informationen umschalten, wie ein Directory-Baum zum Navigieren, Detailinfos zur selektierten Datei, eine Directory-History und mehr. Ansichtsmodi hat er nur drei, aber vernünftige: Symbolansicht (Zeigt Symbole oder falls möglich Previews an, darunter zentrierter Text der in der Breite beschränkt ist und mehrzeilig umgebrochen ist, notfalls auch brutal umgebrochen, die Anzahl der dadurch entstehenden Zeilen kann man optional beschränken, Vertikalscroll), Listenansicht (die klassische Detailansicht mit Name, Größe, Datum usw., Zeilen alternierend unterschiedlich gefärbt, Vertikalscroll, mit Aufklappmöglichkeit von Unterordnern in derselben Ansicht) und Kompakte Ansicht (kleine Symbole ohne Preview, rechts daneben der Name, mehrspaltig mit Horizonalscroll). Eine besondere Stärke des Nautilus ist seine deutlich höherer Konfigurierbarkeit im Vergleich zu xfe und pcmanfm. So kann man etwa für die verschiedenen Ansichten zahlreiche Optionen wählen. Darunter Dinge wie ob die Spalten in der Kompaktansicht alle dieselben Breite haben sollen (wobei dann überlange Einträge mit Auslassungszeichen abgeschnitten werden) oder man immer die vollen Namen sehen möchte und die Spaltenbreiten angepasst werden sollen, oder ob Ordner immer vor Dateien angezeigt werden sollen. Trotz all dieser schönen Eigenschaften hat dieser Dateinanager ein Problem das mich davon abhält ihn einzusetzen: Seine Tastatur-Anpassungen gehen nicht weit genug, dass man eine ausreichend "Total-Commander"-kompatible Tastaturbelegung realisieren könnte. Besonders störend empfinde ich das Fehlen der Möglichkeit, mit F3 jederzeit eine Datei betrachten und mit F4 bearbeiten zu können. Der Weg über das Kontextmenü ist bei vielen Dateien für einen schnellen Blick zu mühsam. Der XFE kann das. Daher bleibe ich beim XFE.
navit/app-misc/gentoo: Ein Navigationssystem fürs Auto, inklusive Routing-Fähigkeit sowie Sprachausgabe in verschiedenen Sprachen. Keine allgemeine Kartenanzeige-Software, da es immer nur die Gegend um den aktuellen Aufenthaltsort auf der Karte anzeigt. Dieser wird normalerweise aus einem GPS-Empfänger ausgelesen, kann aber auch in einem Konfigurationsfile angegeben werden - jedoch nicht dynamisch in der Applikation ausgewählt.
nbd-client-1: 3.15.2-3/admin/devuan: Ein Client, mit dem man eine Verbindung zu einem NBD ("Network Block Device") Server herstellen kann. Leider hat NBD das Problem, dass es zu Kernel-Deadlocks führen kann, wenn man ein Swap-Device direkt oder indirekt auf einem NBD-Device aktiviert. Zwar gibt es eine Option -swap um dies unwahrscheinlicher zu machen, aber unter Speicher-Stress wird das System trotzdem ziemlich sicher früher oder später abstürzen. Daher lässt man dies lieber bleiben, obwohl gerade das eine fantastische Anwendung für NBD wäre. Ein weiteres Problem ist, dass es eine alte und eine neue Version des NBD-Protokolls gibt, und dieser Client "spricht" seit Version 3.11 nur noch die neue. Ich habe aber einen NBD-Server unter Windows, der nur das alte Protokoll spricht: Pech gehabt. Außerdem scheint die aktuelle Version des Clients schlicht überhaupt nicht mehr zu funktionieren - ich bekomme immer nur "Negotiation: ..Error: Read failed: End of file". Was für ein Schrott! Es gibt noch eine BusyBox-Version des nbd-clients, aber diese funktioniert sogar noch schlechter, weil sie hängt und nichts tut. Oder ist vielleicht doch alles die Schuld des aktuellen nbd-server und gar nicht der Clients? Davon abgesehen sind die neuen Versionen auch aus einem anderen Grund unbrauchbar, und zwar weil man nun zwingend eine Konfigurationdatei für "exports" anlegen muss, anstatt wie bisher alles in der Kommandozeile angeben zu können. Bis dies geklärt ist bzw. verbessert wurde, empfehle ich überhaupt keinen aktuellen nbd-client mehr zu installieren, sondern statt dessen eine ältere Version des Pakets.
nbd-server-1: 3.15.2-3/admin/debian: Ein Server, der den Inhalt eines Blockgeräts via TCP übers Netzwerk anbieten ("Network Block Device") kann. Früher einmal eine kinderleichte Bedienung in einer einzigen Kommandozeile, nun mit einer entsetzlich umständlichen Bedienung mit Konfigurationsverzeichnissen, export-Dateien usw. Gottseidank kann man die alte Methode immer noch verwenden, obgleich eine "fürchterliche Warnung" angezeigt wird. Leider gibt es bei NBD ein altes und ein neues Protokoll, und seit der Version 3.11 wird das alte Protokoll nicht mehr von diesem Paket unterstützt. Pech wenn man noch irgendwo Clients installiert hat, die nur da ältere Protokoll "sprechen". Wenn man wie ich auf das neue Protokoll pfeift, kann man sich die Installation des nbd-server Pakets ersparen wenn man das Paket qemu-utils installieren welches unter anderem ein Programm qemu-nbd enthält, welches der alten Funktionalität des nbd-server entspricht.
nbsmtp/mail-mta/gentoo: Similar to mail-mta/ssmtp. Can forward locally-originated mail to a real SMTP relay server, but cannot do local delivery (sending from one local user to another one). So its for real outbound Internet mail only.
ncdu-1.8-1/admin/debian: Konsolenbasierte Disk-Usage-Anzeige. Klein, aber auch langweilig: Zeigt einfach eine vertikale Liste der Verzeichnisse an, absteigend nach Größe des Inhalts sortiert, und zeigt dabei auch den Prozentsatz des Verzeichnisses im Vergleich zum belegten Gesamtplatz sowohl als Text als auch als "Grafik" (Balkendiagramm aus '#'-Symbolen) an. Kann wahlweise auch den "tatsächlich" belegten Platz (vermutlich Anzahl der Disk-Blocks laut "stat") als auch den scheinbaren Platzbedarf (Dateilängen laut "stat") anzeigen. Wenn man keine grafische Version solch eines Tools hat - warum nicht. Ansonsten eher sinnlos.
ne-3.1.2-1/editors/debian {text-editor}{text-terminal IO}: Das "ne" steht für "nice editor", und hat nichts mit dem unter X11 bekannten "nedit" zu tun. ne ist ein weiterer Texteditor fürs Terminal, und schlanker als "joe". Er hat relativ normal aussehende Drop-Down-Menüs, doch interessanter Weise keinerlei Mausunterstützung für diese. Er wird komplett per Tastatur bedient, inklusive der Menüs. Er kann beliebig viele Dateien gleichzeitig geöffnet haben. Fast alle Limits (Maximale Anzahl der Zeilen, Größe der Dateien) sind 64-Bit groß und somit praktisch unbeschränkt. ne kann auch Dateien bearbeiten die größer als der verfügbare RAM sind. Ein Highlight im Vergleich zu vielen anderen Textmodus-Editoren (inklusive joe) von ne ist es, relativ GUI-artige Tasten für das Markieren und bearbeiten von Blöcken zu haben. Konkret hat er ein ein Clipboard genau wie unter modernen GUIs, und [Ctrl]+[c], [Ctrl]+[x] und [Ctrl]+[v] tun das von GUI-Benutzern erwartete. Einzig das Aufziehen der Markierung unterscheidet sich: Hierzu drückt man [Ctrl]+[b] um den Anfang der Markierung festzulegen, anstatt dies mit den Shift-Tasten zu tun. Doch auch das ist immer noch recht komfortabel, insbesondere im Vergleich mit den [Ctrl]+[k]-Tastenkombinationen von Wordstar-ähnlichen Editoren wie "joe", die man vor allem im Dunkeln leicht falsch betätigen kann. Außerdem kann ne auch noch mit spaltenbasierten Blocks arbeiten, nicht nur mit den normalen zeilenbasierten. Man kann das Clipboard zudem auch in eigene Dateien speichern oder von dort laden. Des weiteren gibt es beliebig viele Clipboards, aber nur eines davon ist (umschaltbar) das jeweils aktuelle auf welche sich alle Befehle beziehen. ne macht auch Gebrauch von den Funktionstasten, wenngleich es stets noch eine zusätzliche Möglichkeit gibt die Funktion auszulösen für den Fall dass das Terminal keine Funktionstasten unterstützt. Anders als joe unterstützt ne normale Extended Regular Expressions (ohne Perl-Erweiterungen) für Suche/Ersetzen. Zusätzlich gibt es es auch noch eine Suchfunktion für reinen Text - sehr angenehm, um sich das Escapen/Quoten von RegExen in vielen Fällen zu ersparen. Eine interessante Eigenheit von ne ist der Umstand, dass die Such- und Replace-Funktionen zusammenarbeiten: Man benutzt auch zum Ersetzen zunächst die Suchfunktion, und gibt bei der Replace-Funktion lediglich den Ersatztext an (inklusive Capture-Referenzen falls man eine RegEx-Suche ausführte). Simple Makros mit Aufzeichnungsfunktion sind ebenfalls vorhanden, und sogar einfacher anzuwenden als bei joe. Überdies lassen sich die Makros auch speichern und wieder laden. Die Makro-Dateien enthalten zudem nur Textkommandos, und lassen sich daher mit ne selbst editieren falls für Korrekturen erforderlich. Es gibt zudem einen recht komfortablen Hilfemodus, wo man für alle von Editor verstandenen Befehle (wie sie etwa in dem Makros verwendet werden eine Erklärung bekommt. Überdies gibt es in einem separaten Paket eine sehr ausführliche Anleitung im HTML-Format, doch die sollte man im Alltag nicht brauchen sondern eher zum vertieften Erlernen der Funktionen bzw. zum Klären von sehr speziellen Detailfragen. Dieselben Kommandos die man in Makro-Dateien verwenden kann kommen aber tatsächlich überall im Editor vor: Man kann die Tastaturbelegung anpassen indem man einen Kommandosequenz an eine Taste bindet. Ebenso lassen sich die Menüs anpassen, indem man Befehlssequenzen an Menüeinträge bindet. Und schließlich gibt es ein Kommando zum Speichern des aktuellen Zustandes (der diversen Modi und Einstellungen des Editors), die ebenfalls als Kommandos gespeichert werden welche den aktuellen Zustand später erneut herstellen. ne hat einen "FreeForm"-Modus, der dem "Picture"-Modus von "joe" entspricht. ne kann nur normales Word-Wrapping und keine "Soft line breaks". Eben so wenig beherrscht er den "flowed"-Modus von joe der innerhalb eines Absatzes ein Leerzeichen vor dem Zeilenende einfügt, um einen "Soft line break"-Indikator" vor dem Zeilenumbruch zu signalisieren. Die Reformatier-Funktion beherrscht aber immerhin Auto-Indent, e-Mail Quoting und Shell- und "C"-Comments. Für komplexere Formatierungen kann man einen externen Reformatter aufrufen, da ne auch die für mich wichtige Funktion beherrscht, einen markierten Block durch ein externes Kommando filtern zu können. Beim normalen Editieren kann man Word-Wrapping, Overtype-Modus und Autoindent-Modus separat umschalten. Für das Word-Wrapping kann man entweder einen bestimmten rechten Rand einstellen, oder 0 für die aktuelle Breite des Terminals. ne beherrscht Syntax-Highlighting und kann bestimmte Settings abhängig vom Dateityp laden. (Das ist abschaltbar.) Wird der Dateityp dabei nicht erkannt, werden statt dessen Settings aus einer Default-Datei geladen. Man kann eigene Dateitypen festlegen, die entweder anhand der Datei-Erweiterung oder anhand eines RegEx-Searches (mit einschränkbarer Reichweite) innerhalb des Datei-Inhalts erkannt werden. Man kann sowohl neue Dateitypen hinzu fügen, vorhandene editieren, als auch eigenes Syntax-Highlighting definieren (auch wenn letzteres das wohl nur für Experten machbar sein dürfte). Normalerweise verwendet ne UNIX-newlines als Zeilentrenner, doch es gibt Optionen dies auf MS-DOS/Windows-Trenner umzuschalten, oder vorhandene CR zwar zu ignorieren jedoch beizubehalten. Schließlich beherrscht ne noch Bookmarks. Das war es im Wesentlichen - alle Kommandos des Editors finden in der Hilfe auf einer Seite Platz ohne dass man Scrollen muss, zumindest in einem 80 x 40 Zeichen Terminal. Der Funktionsumfang ist daher sinnvoll, aber zugleich noch überschaubar - anders als bei joe der *zu* viel kann, so dass man vieles davon regelmäßig vergisst. ne kann UTF-8 bearbeiten, stellt sich dabei aber sogar noch dümmer an als joe in dem Fall dass der Text als NFD normalisiert ist. Andererseits, solcher Text kommt unter Linux kaum je vor, und man kann ihn leicht nach NFC umwandeln womit joe und ne keine Probleme haben. Multibyte-UTF-8 Zeichen werden in Regular-Expression Ranges nicht unterstützt - man muss dies mit dem ODER-Operator emulieren. Nur Single-Byte Zeichen können in RegEx-Ranges verwendet werden. ne beherrscht dafür eine Spezialität: Man kann jederzeit mitten im Betrieb den UTF-8 Modus ein- und ausschalten - im letzteren Fall wird das Text dann als LATIN-1 interpretiert. Zusammen mit dem optionalen Feature dass ne immer den Hex-Zeichencode des Zeichens unter den Cursor anzeigt, kann man so die UTF-8 Codierung "raw" bearbeiten wenn man will. Etwas schwachbrüstig sind die Reformatierungsfunktionen: Sie wirken nicht auf den markierten Block, sondern nur auf den nächsten Absatz oder das nächste Wort. Zwar kann man einen Zähler angeben der den Bereich der Reformatierung auf mehrere Absätze oder Worte erweitert, aber woher soll man wissen wie viele Worte/Absätze der Bereich des Interesses groß ist? Angeboten werden folgende Reformatierungs-Funktionen: Absatz neu umbrechen, Zeilen zentrieren, Worte in Groß- und Kleinschrift oder "Titlecase" umwandeln. Weiters kann ne Dateien in einem "Binary"-Modus laden und speichern, bei denen Null-Bytes als Zeilenschaltungen interpretiert werden und normale Zeilenschaltungen als druckbare Zeichen angezeigt werden (wenn auch als Fragezeichen da nicht darstellbar). Dieser Modus ist durchaus geeignet, Texte in Binärdateien zu editieren oder zu begutachten. Schließlich gibt es noch einen Read-Only-Modus, der verhindert dass man den Inhalt von Dateien irrtümlich ändern kann. Dieser Modus wird zudem automatisch gesetzt wenn man keine Schreiberlaubnis auf eine Datei hat. Mein Fazit: Sehr gut! Sowohl für Einsteiger als auch Fortgeschrittene geeignet, und nur durch das Fehlen einiger Funktionen wie den erwähnten "flowed"- oder Hex-Modus dem "joe" unterlegen. Download 263,1 kB, installiert 912,4 kB. Das Executable ist 500 kB groß, und hängt nur von der ncurses-Library und der "C"-Laufzeitbibliothek (inklusive libm) an. Anders als der joe benötigt ne keinerlei externe Dateien außer einer terminfo-Datei; alle Hilfetexte und Menüs sind offensichtlich Teil des Executables. In einem Root-Jail erfordert ne samt sämtlicher Abhängigkeiten inklusive C-Runtime 3,7 MB Installationsumfang, während es bei joe 4,2 MB sind und überdies noch seine Hilfetexte hinzu kommen.
nedit-1:5.7-3/editors/raspbian: Ein extrem altertümlicher, aber auch erfrischend schlanker, mächtiger (z. B. auch Makrofähig, weicher Zeilenumbruch auch kein Problem) und schneller Texteditor auch für große Dateien. Leider hat er zwei große Probleme: Uralter MOTIF-Look dass einem leicht das Kotzen kommt. Wesentlich schlimmer jedoch: Er kennt nicht nur weder UNICODE noch UTF-8, sondern überhaupt nur LATIN-1 als einzigen Zeichensatz! Damit kann man zwar nahezu alle Dokumente editieren da LATIN-1 für jeden Bytewert ein Zeichen hat. Aber alle Umlaute werden völlig falsch und als mehrere kryptische Zeichen dargestellt. Damit kann man nedit für die meisten normalen Dokumente wohl vergessen. Dennoch, wenn man Quelltexte oder numerische CSV-Dateien editiert in denen ohnehin keine Umlaute vorkommen, eine sehr interessante Wahl.
nedit/app-editors/gentoo {text-editor}{GUI}{X11}: Der einzige annähernd normale Editor (im Gegensatz zu Vi und Emacs), der nicht speziell auf eine der großen Desktop-Umgebungen oder GUI-Toolkits zugeschnitten wird. Er sieht entsprechend kotzig aus, verrichtet aber seine Arbeit im großen und ganzen brauchbar. Beherrscht weichen Zeilenumbruch und Syntax Highlighting und ist ressourcenschonend. Nur das würgende Gefühl in der Magengegend und seine nicht gerade überragende Bedienungsfreundlichkeit kann einen davon abhalten, dieses Ding ständig einzusetzen. Wer ein KDE und kwrite installiert hat, bekommt annähernd dasselbe auch als weitaus schöneres Programm (nur sicherlich weniger ressourcenschonend). Allerdings gibt es ein großes Manko: nedit beherrscht kein UTF-8, und laut Autor ist auch nicht vorgesehen dies je zu ändern (Stand: 2017).
netbeans-8.1+dfsg3-2/java/raspbian {development_environment}{GUI}{X11}: Nette JAVA-IDE. Alles was man so zum JAVA-Entwickeln braucht. Inklusive GUI-Builder für das SWING und AWT Toolkit. Download-Bedarf für die Installation (bei bereits installierten JDK) rund 100 MB. Bei einem geöffneten "Hello world"-Winzprojekt benötigt die IDE ca. 490 MB virtuellen Speicher, davon 305 MB RAM. (Wohlgemerkt nachdem bereits einige unnötige Plugins deaktiviert wurden). Schlank ist die IDE daher nicht gerade, läuft aber gerade noch auf dem RPi3. Und sie verbraucht wenigstens auch keine Rechenzeit bloß weil sie geöffnet ist. Theoretisch gäbe es auch Plugins für C/C++ Entwicklung, aber offensichtlich nicht mehr für diese alte Version auf den aktuellen Download-Servern. Das integrierte Build-System basiert per Default auf Ant. Man kann das Projekt dann auch ohne die IDE anderswo mittels eines installierten Ant bauen. Die IDE legt aber zusätzliche Informationen für den Eigenbedarf in mehreren ".properties"- und XML-Dateien ab; wenigstens sind alles Textdateien. Nette Integration der JDK-Dokumentation. Weitere Funktionen: Editor, Symbol-Browser, Projekt-Manager, Debugger, Refactor (unter anderem intelligentes Umbenennen von Bezeichnern mit Vorschau), Bookmarks, Spell-checker, Team-Funktionen (Git, Mercurial, Subversion), SQL-Editor, SQL-Database-Browser, Extrahieren von Dokumentation aus speziellen Kommentaren mittels javadoc.
netcat6-1.0-r2/net-analyzer/gentoo: Wie "cat", nur dass die Ein- und Ausgabe auf TCP oder UDP umgeleitet werden kann. netcat-6 ("nc6") kann bei TCP auch ein "listen" durchführen, d. h. darauf warten dass jemand anderer die Verbindung herstellt. nc6 verfügt im Gegensatz zum originalen netcat über IPv4 und IPv6 support und beherrscht neben dem Vollduplex- auch einen Halbduplex-Modus. Das ist hilfreich wenn eine Verbindung nur zum Senden oder Empfangen aber nicht für beides (protokollinterne Bestätigungen ausgenommen) verwendet wird. In diesem Fall kann nc6 den jeweils unnötigen Kanal schließen, was Wartezeiten nach dem Ende der Verbindung vermeidet. Installationsumfang 0,4 MB.
netkit-talk/net-misc/gentoo: Schreibt wie per "write" eine Message auf das Terminal eines anderen Users, dass dieser das "talk"-Programm aufrufen soll da man mit ihm kommunizieren will. Tut er das, öffnet sich ein zweigeteilter Bildschirm in dem beide tippen können - jeder nur in seinem Bereich. Der zur Koordinierung nötige Daemon kann von inetd aus gestartet werden. Angeblich. Bei mir funktionierte es nicht. Ausserdem ist das Protokoll sehr unsicher bis hin zur Ausführung von Befehlen im Kontext des Gesprächspartners.
netsurf-gtk-3.10-1+b1/web/debian netsurf-gtk-3.10-1+b1/web/raspbian {www-browser}{GUI}{X11}{GTK+}: Ein netter und schlanker Web-Browser, der sehr viel weniger Ressourcen verbrät als Firefox, aber ebenfalls das ehrgeizige Ziel verfolgt, ein vollwertiger HTML5-fähiger Browser zu werden. JavaScript wird unterstützt. Nicht allerdings SVG-Grafiken, für welche nur Ersatz-Bitmaps in oft mangelhafter Auflösung angezeigt werden (soweit die Webseite sie bereit stellt). Für Rechner mit wenig RAM ist Netsurf eine echte Bereicherung, da er mehr Seiten darstellen kann als Dillo, aber um Welten schneller startet und weniger Ressourcen frisst als Firefox. Allerdings benutzt Websurf keine bekannte Browser-Engine wie etwa Webkit, sondern wurde von Grund auf eigenständig programmiert. Man darf sich daher nicht dieselbe Abdeckung von HTML-Features erwarten wie von Firefox oder Webkit-basierten Browsern. Auch als voreingestelltes Programm zum Öffnen lokaler *.html-Dateien macht er eine gute Figur, da er schnell startet. Anders als Dillo kann er auch Pfeile und andere Spezialzeichen anzeigen, und eine geöffnete Datei merkt sich beim Neuladen den aktuelle Scroll-Position der Ansicht. Allerdings hat er denselben Mangel wie Dillo bei der Anzeige von Tabellen, wo er immer nur die äußeren Umrandungslinien und nie interne Gitterlinien anzeigt. Außerdem hat er die extrem ärgerliche Beschränkung, zwar die X11 Zwischenablage, nicht jedoch die X11 Mouse Selection zu unterstützen. Man kann Text daher nicht direkt wie gewohnt mit der Maus aus dem netsurf in ein xterm-Fenster kopieren. Sondern man muss den Text statt dessen zuvor über die Zwischenablage in ein Editor-Fenster kopieren und erst von dort mit der Maus nach xterm. Auch in solchen Fällen wird man Midori daher vermutlich vorziehen.
netwmpager-1.11-r1/x11-misc/gentoo: Zeigt eine verkleinerte Sicht aller Workspaces an und gibt Informationen über die Namen der dargestellten Fenster. Man kann die Fenster über die verkleinerte Übersicht auch aktivieren und sogar verschieben. Allerdings ist er nicht in der Lage minimierte Fenster zu sehen; d. h. es ist kein Ersatz für eine "Fensterliste". Vorteil: Es arbeitet unabhängig von einem bestimmten Fenstermanager. Sinnvoll für Fenstermanager welche so ein Feature nicht fix eingebaut haben, wie etwa die von Blackbox abgeleiteten (Fluxbox, Openbox). Nachteil: Man muss alles statisch konfigurieren. netwmpager ignoriert das dynamische Hinzufügen neuer Workspaces nachdem es gestartet wurde. Ja schlimmer noch, es unterbindet dieses Anlegen neuer Workspaces durch den WM sogar! Geeignet somit nur für Konfigurationen mit einer fixen Anzahl an Workspaces. Außerdem scheint wmnetpager ein rechter "CPU-Hog" zu sein, denn - zumindest in einer XVnc-Instanz laufend - verbrauchte es permanent gute 60 % Last in einer CPU, unabhängig davon ob ein VNC Viewer lief.
neverball-1.6.0-7/games/devuan {game}: Man bewegt ein Spielbrett in 3D, auf dem sich ein Level aus Absperrungen, Hindernissen oder freien Flächen befindet, um dadurch einen Ball rollen zu lassen. Ziel jedes Levels ist es, alle Münzen die im Level verteilt sind so schnell wie möglich aufzusammeln. Sieht schlicht aber OK aus, jedoch trieb mich die Steuerung in den Wahnsinn die nie tat was ich wollte. Außerdem fand ich die Levels - soweit ich sie sah - eher langweilig. Trotz 3D scheint die zugrunde liegende Karte immer nur flaches 2D-Design zu besitzen. (Obwohl, vielleicht ändert sich das bei höheren Leveln ja. Aber ich bezweifle es.) Trotz immer kniffligeren Hindernissen wie Eis oder Abgrund-Löchern daher kein "Marble Madness". Rund 116 MB Installationsumfang.
nexuiz/games-fps/gentoo {game}: Grafisch hübsch gemachtes Quake-1 basiertes Deathmatch-Game. Leider keine Single-Player Missions. Crasht außerdem gerne mit weniger stabilen Grafikkarten-Treibern.
nighthawk/games-action/gentoo {game}: Wirklich gut gemachter "Paradroid"-Clone. Übernimm der Reihe nach immer mächtigere Roboter, die an Bord eines großen Raumschiffs mit vielen Räumen herumwandern. Riesiger Nachteil dieser Implementation: Kein Fullscreen-Modus und nur briefmarkengroßes Fenster auf modernen Schirmen.
ninja-build-1.10.1-1/devel/debian {software build system}: Ninja ist ein in C++ implementiertes Build-System welches ähnlich dem POSIX-"make" ist, jedoch sehr viel primitiver und vor allem keine "bereits eingebauten" Regeln hat. Es hat keine Abhängigkeiten abseits der C++ Standard-Laufzeitbibliothek. Es hat gegenüber "make" und anderen populären Build-Systemen den Vorteil dass es viel schneller ist, was es primär seiner Primitivität verdankt. Ninja wird beispielsweise bei der "Chrome"-Entwicklung verwendet, wo es Abhängigkeiten zwischen 30.000 Dateien in einer Sekunde analysiert, für welche die anderen Build-Systeme zumindest 10 Sekunden brauchen. Abgesehen von einem installierten Python als Laufzeitabhängigkeit ist Ninja mit nur 400 kB Installationsumfang sehr schlank und schlägt dabei sogar GNU Make. Ninja arbeitet immer per Default parallel, und erkennt automatisch wie viele CPUs bzw. CPU-Kerne zur Verfügung stehen. GNU make beherrscht zwar auch parallele Builds, doch ist dies erstens eine GNU-Erweiterung, und zweitens erkennt es nicht selbst wie viele parallele Prozesse es verwenden soll sondern man muss dies explizit angeben. Nina-Projektdateien sind nicht dazu gedacht mit der Hand geschrieben zu werden, obwohl es möglich ist. Statt dessen sollen sie mit Generator-Programmen aus menschenfreundlicheren Projektbeschreibungs-Sprachen erzeugt werden. Konkret kann CMake Ninja-Projektdateien als Ausgabe erzeugen. Nativ wurde Ninja ursprünglich nur durch das "gyp"-Buildsystem unterstützt, welches das "Chromium"-Projekt verwendet, inzwischen können aber zumindest auch cmake und meson Ninja-Projektdateien generieren. Weitere unterschiede zu "make" sind: Externe Tools welche Abhängigkeiten erkennen wie "gcc -M" können direkt in Ninja-Regeln eingebunden werden, um die erzeugten Abhängigkeiten dann anzuwenden. Im Gegensatz zu Make führt jedwede Änderung der Kommandozeile zu einem Rebuild des entsprechenden Targets, also wenn sich beispielsweise CFLAGs oder Suchpfade geändert haben. Ninja-Dateien sind statisch; es ist nicht vorgesehen ihr Verhalten über redefinierte Variablen in der Kommandozeile zu modifizieren wie das in "make" Gang und Gäbe ist. Statt dessen soll in so einem Fall die Ninja-Datei durch den entsprechenden Generator neu erzeugt werden. Kurzum: Ninja-Projektdateien sind normalerweise nur vorübergehend existierende Dateien die von Generatoren erzeugt werden, und werden normalerweise nicht als Teil des Projekts ausgeliefert. Doch aus diesem Verzicht auf Flexibilität kommt auch ein Großteil des Geschwindigkeits-Zuwachses - komplexe Entscheidungen werden vom Generator getroffen, welcher die Ninja-Projektdateien generiert. Die Ninja-Projektdateien selbst sind nur das Endergebnis wo alle Entscheidungen außer die Timestamp- und Existenz-Vergleiche der Dateien bereits ausgeführt werden. Es macht kaum Sinn Ninja für kleine Projekte einzusetzen wo "make" & Co schnell genug sind. Außer in Fällen wo die Komplexität von Make zu groß wurde, und das Projekt von der simpleren Struktur von Ninja-Projektdateien profitieren könnte. Ninja-Dateien *sind* Textdateien und könnten mit der Hand geschrieben werden, aber normalerweise tut das niemand wegen zu spezifischen Angaben wie konkreten Compiler-Flags die man normalerweise nicht mit zusammen mit den Quelltexten verteilen will. Neuere Versionen von Ninja können vorab berechnete Abhängigkeiten und ähnliche interne Metadaten auch in bereits vorverarbeiteter Form in Binärdateien speichern, um den Build noch mehr zu beschleunigen. Ein Vorteil von Ninja gegenüber make ist auch die kürzere Anleitung - der gesamte Text welche alle Details der Projektdateien erklärt ist nur rund 10 kB lang, während allein die POSIX-Version der Makefile-Syntax (inklusive der Erklärung der "eingebauten" bzw. vordefinierten Regeln und Variablen) 26 KB lang ist. Wenn man nicht CMake sondern direkt "gyp" als Generator für Ninja verwenden will, muss man zunächst einmal feststellen dass mit Stand 2017-01 "gyp" noch nicht einmal unter Portage verfügbar ist. Fazit: Derzeit würde ich Ninja-Dateien im Bedarfsfall lieber selber generieren, als "gyp" oder gar CMake (das ich ebenfalls schrecklich finde) zu verwenden! Eine Kleinigkeit die mich stört ist dass Ninja speziellen Support für Kommandozeilen-Syntax-Eigenheiten des MSVC-Compilers direkt eingebaut hat. Freilich hat dies keine Auswirkungen wenn man keinen Gebrauch davon macht. Aber es ist eine ärgerliche "Extrawurst" für Microsoft.
nmap-0.9.7.1-r1/net-analyzer/gentoo: Ein tolles Netzwerk-Scanner-Programm. Die derzeitige (2015-05) Version funktioniert aber nicht, zumindest nicht mit PPP-Netzwerkzugängen, da es unfähig ist eine Liste an Interfaces zu bekommen - daher findet es auch kein ppp0, und weitert sich dann zu laufen. Irgendwann später wieder checken, ob der Fehler behoben ist. Bis dahin tut ein "busybox pscan" es zur Not auch.
nnn-2.2-2/misc/debian {file manager}{text-terminal IO}: Ein extrem schlanker allerdings auch extrem minimalistischer Dateimanager für die Terminalkonsole. Besteht im wesentlichen aus einem einzelnen rund  90 kB großen C-Quelltext und hängt nur von den ncurses-Bibliotheken zusätzlich zur C-Runtime ab. Unterstützt offenbar nicht nur Linux, sondern auch BSD, GNU Hurd, CygWin, Android und ein nicht näher bezeichnetes AppleOS. Zumindest die i386- und ARM-Plattform wird in #includes unterschieden. Grundsätzlich funktioniert das Programm ähnlich wie mc, jedoch ohne grafische Fensterelemente (keine Menüs, Buttons etc.) und es wird ausschließlich mit der Tastatur bedient. Es bietet bis zu 4 "Fensterhälften", von denen tatsächlich aber immer nur eine einzige angezeigt wird. Tatsächlich sind es daher eher bis zu 4 Directories zwischen denen schnell gewechselt werden kann. Zusätzlich kann noch schnell zwischen dem anfänglichen Verzeichnis, dem HOME-Verzeichnis und dem zuletzt besuchten Verzeichnis gewechselt werden. Ferner kann man ein weiteres einzelnes Verzeichnis mit einer "pinning"-Funktion markieren und dann auch zu diesem schnell springen. Über die "?"-Taste erhält man eine Liste aller Tastenbefehle welche sich auf einer 2-spaltigen Bildschirmseite ausgeht. Etwas eigentümlich funktioniert das Selektieren von Dateien. Anstatt die selektierten Dateien irgendwie mit einem Marker zu versehen gibt es einen Selektions-Modus in dem die absoluten Pfadnamen alle per Tastenbefehl markierten Dateien in eine Temporärdatei geschrieben werden. Den Inhalt dieser Datei kann man sich dann zwar anzeigen lassen, an der regulären Anzeige der Dateiliste ändert sich jedoch nichts. Innerhalb des Selektions-Modus kann man entweder beliebige einzelne Dateien selektieren, oder einen einzelnen Bereich von Dateien gemäß der aktuellen Sortierung der Dateiliste. Alternativ zum Selektionsmodus kann man auch stets eine einzelne Datei/Verzeichnis auswählen. Es gibt kein Verändern der Selektion nachdem diese bereits vorgenommen wurde; jede neue Selektion ersetzt eine frühere immer komplett. Mit drei Befehlen kann man dann die selektierten Dateien löschen oder ins aktuelle Verzeichnis verschieben oder Kopieren. Einzig für das Löschen gibt es eine zusätzliche Funktion welche auf den gerade aktuellen Eintrag der Dateiliste anstatt auf eine Selektion angewendet wird. Ein Vorteil für diese eigenartige Implementation der Selektion ist es, dass die selektieren Dateien über beliebige Verzeichnisse vertreut sein können. Man kann ferner neue Verzeichnisse oder leere Dateien anlegen. Existierende Dateien können im $PAGER (Default: less) oder aktuellen $EDITOR bearbeitet werden. Die Dateiliste kann nach Name (Default, nur aufsteigend), Größe (immer nur absteigend) sowie Modifikationsdatum (neueste zuerst) sortiert werden. Verzeichnisse werden allerdings immer vor Dateien angezeigt; dies lässt sich nicht abschalten. Man kann die Dateiliste per RegEx filtern lassen, allerdings nur zur Navigation/Selektion und nicht zur dauerhaften Anzeige einer gefilterten Liste. Primitives Umbenennen ist möglich, jedoch nur durch komplette Angabe eines neuen Namens. Wenn allerdings das Helper Perl-Script "vidir" installiert ist, können damit auf komfortable Weise beliebige Umbenennungen sowie Löschungen aller Dateien und Unterverzeichnisse vorgenommen werden, indem das gesamte Directory-Listing im $EDITOR editiert wird, und das Script diese Änderungen dann real nachzieht. Ausführbare Dateien können mit einer speziellen Tastenkombination direkt gestartet werden, oder mit einer anderen unter Zuhilfenahme eines auszuwählenden Programms. Überdies kann die Datei mittels des xdg-open Frameworks geöffnet werden, falls dieses installiert ist. Details einer Datei können ebenso angezeigt werden (ruft im wesentlichen "stat" auf und zeigt die Ergebnisse in $PAGER an) oder mittels "media-info". Natürlich kann man auch eine Shell temporär spawnen. In der Dateiliste wird normalerweise bei Unververzeichnissen keine Größe angezeigt. Jedoch gibt es einen disk-usage Mode, wo das Programm sich ähnlich verhält wie bei "ncdu" (jedoch braucht es bei großen Unterverzeichnissen länger zum Einlesen der Informationen) und dann als Größe der Verzeichnisse deren kumulierte Größe (wie bei "du") anzeigt. Es gibt eine zeilenweise 3-spaltige (Datum/Zeit, Größe, Name) Detailansicht der Dateiliste (Default) und eine spaltenweise kurze wo nur der Name angezeigt wird. Mittels zusätzlicher optionaler Helper-Scripte ist auch das Auflisten, Extrahieren oder erzeugen von gepackten Archiven möglich. Man kann umschalten ob versteckte Dateien angezeigt werden sollen oder nicht. Aufgrund seines Minimalismus ist das Programm weitaus weniger komfortabel als der mc, jedoch deutlich besser für extrem beschränkte Systeme wie initramfs, Pre-boot-Umgebungen, unfähige Shells (ohne brauchbare Kommandozeilen-Editierfunktionen) und Embedded-Geräte geeignet. Dort könnte auch eine Kombination mit "dtach" sinnvoll sein, da nnn seinen Bildschirminhalt regenerieren kann (in dem man die Hilfe-Funktion aufruft und dann wieder verlässt).
noatun/kde-base/gentoo {audio}{music}: Abgemagerte Version von kde-base/juk: Kann nur Audiodateien wiedergeben, hat nur eine einzige Playliste. Vermutlich ressourcenschonender als juk wenn nur wenige Musikdateien vorhanden sind. Bietet auch diverse Klangeffekte und einen simplen Equalizer.
normalize-audio-0.7.7-14/sound/raspbian: Genau das Tool das man braucht, um zu leisen Audio-Tracks eine peppige Lautstärke zu verpassen. Kann WAV- oder MP3-Dateien inplace modifizieren. Empfehlung: Erst mit -n --fractions den Track analysieren, dann dann in einem 2. Durchlauf den doppelten angezeigten Wert für -g zum Verstärken verwenden.
ntfs-3g-1 {FUSE}: 2017.3.23AR.3-3/otherosfs/debian: Ein FUSE-basierter Linux-Treiber für das NTFS-Dateisystem von Microsoft. Lesender und eingeschränkt auch schreibender Zugriff. Nützlich um von einem Linux-System aus auf NTFS-Dateisysteme zugreifen zu können, etwa auf Dual-Boot-Installationen oder für Rettungszwecke.
ntp-4.2.8-r1/net-misc/gentoo: Jahrelang hat diese NTP-Implementation gut Dienste geleistet. Doch im Summer 2015 funktionierte der Daemon plötzlich nicht mehr; hing mit 100 % Rechenleistung und tat nichts mehr. Darauf hin stieg ich auf openntpd um. Außerdem ist ntp ein deutlich fetteres Paket: Ca. 4 MB. Allerdings bringt es dafür auch mehr als nur einen ntpd mit, beispielsweise das sehr nützliche ntpdate bzw. sntp (via "openntpd" USE-Flag), um die Systemzeit *sofort* via NTP zu beziehen. Dies fehlt wiederum openntpd. Daher sollte man wohl beide Pakete installieren, dabei den Daemon von net-misc/openntpd verwenden aber die restlichen Tools von net-misc/ntp.
ntpclient-2010.365/net-misc/gentoo: Ein NTP-Client, der dazu gedacht ist die Systemzeit *sofort* und einmalig via NTP zu setzen, und dies nicht wie ntpd mittels Beschleunigung oder Abbremsung der Systemuhr zu erreichen. Ergänzt sich gut mit net-misc/openntpd, welchem genau diese Funktionalität fehlt. Allerdings fehlt diesem Programm leider ein sehr wichtiges Feature, welches der ntp-Client aus dem net-misc/ntp-Paket bietet: Man kann kein Limit für die Zeitkorrektur setzen, bei dessen Überschreiten davon ausgegangen wird dass der NTP-Server lügt und einem eine falsche Zeit unterschieben will. Damit würde ich es als unbrauchbar bezeichnen, denn wer will schon einem fremden NTP-Server bedingungslos trauen? Zudem hat das Programm noch ein weiteres Problem, nämlich dass es im Gegensatz zu net-misc/ntp nicht mittels Runlevel-Scripten ins System integriert ist. Man müsste dies daher selbst tun.
nudoku-1.0.0-1/games/debian: Ein sudoku fürs Terminal. Benutzt ncurses und Farben. Nur 11 kB Download. Hat Komfort-Funktionen wie Überprüfung der Gültigkeit des aktuellen Spielfeld-Inhalts. Weiters kann man automatisch alle anderen identischen Ziffern am Spielfeld aufleuchten lassen, wenn im aktuellen Feld eine gesetzt ist. Man kann weiters die Lösung anzeigen lassen, oder nur ein weiteres Feld als Hilfestellung korrekt ausfüllen lassen. Was fehlt, ist eine optische unterscheidbarkeit zwischen fix vorgegebenen und selbst ausgefüllten Feldern. Das Spielfeld wird größer als bei "sudoku" dargestellt, da auch innerhalb der 3x3 Quadrate (ASCII-) Trennlinien verwendet werden. Insgesamt scheint mir diese Programm wegen seiner Komfortfunktionen vor allem für Anfänger geeignet zu sein.
nullmailer/mail-mta/gentoo: Similar to mail-mta/nbsmtp but maintains a system-wide queue for mail to be relayed and needs a local daemon to service that queue. It might therefore be more efficient to use than ssmtp or nbsmtp to use in a multiuser-scenario with many local users because the system-wide queue will schedule things somewhat, but it imposes the overhead of running a local daemon.
nurpawiki-1.2.3-10+b2/web/devuan {wiki}: Ein in OCaml implementiertes Wiki mit integrierter To-Do-Liste und einem "Scheduler". Vermutung: Zeigt an wann das nächste Event fällig wird. Nicht gerade super-schlank: 47,46 MB installiert. Kann - offenbar optional - seine Daten auch in einer PostgreSQL-Datenbank ablegen. Es gibt keine richtige Homepage vom Projekt und scheinbar nur den Code. Primär scheint das Ding eher als Personal Information Manager denn als Wiki gedacht zu sein.
oathtool-2.6.6-3/devel/debian: Provides the "oathtool" command line tool which can generate and verify "HOTP" (RFC 4226) and "TOTP" (RFC 6238) one-time passwords (OTPs) which can be used by client tools such as the FreeOTP Android app. HTOP OTPs are "event-based", i.e. depend on a counter value which is incremented after every use. TOTP OTPs are time-based and depend on the current time. HOTP-based OTPs are always based on SHA-1, while TOTP-based OTPs also support SHA-2 (256 and 512 bit variants) for OTP calculations. The counter for HOTP must be and the "current time" for TOTP may also be provided by command line options, rather than using the current date and time as the basis for verification-code generation or verification. Supported sizes for the verification codes are 6 (default), 7 or 8 decimal digits. The installation requirements for "oathtool" are modest - one binary executable and one support library, about 250 kB of code total (in addition to the standard C runtime library).
obexfs-0.11-2+b1/comm/debian {FUSE}: Erlaubt es nicht-privilegierten Benutzern, das OBEX-Protokoll als virtuelles Dateisystem zu mounten. OBEX kommt in erster Linie bei Bluetooth-Geräten zum Einsatz, welche damit Dateien, Kalendereinträge oder Adressbucheinträge versenden oder empfangen. Manche Geräte bieten OBEX aber auch über USB-Kabel oder IrDA (Infrarot-Schnittstelle) an.
obnam-1.21-1/python/devuan {backup}: Ein leider (oder gottseidank?) nicht mehr weiter entwickeltes Backup-Programm, welches Deduplikation über Dateien und sogar Backup-Generationen hinweg unterstützt. Unterstützt PGP-Verschlüsselung. Kann mittels des das SFTP-Protokolls von SSH auch Remote-Backups durchführen, wobei man die Wahl zwischen "push"- (Programm läuft nur am Client) und "pull"-Betrieb (Programm läuft nur am Server) hat. Leider scheint die Deduplikation von obname sehr dumm zu sein, da sie eine fixe Blockgröße benutzt und daher Duplikate nicht mehr erkennt wenn sich diese anders als ausgerechnet um ein Vielfaches der Blockgröße innerhalb ihrer Dateien verschoben haben.
ocrad-0.24-1/graphics/devuan {OCR}: ocrad ist noch 3 x schneller als gocr, und teilweise dramatisch unfähig allgemeinen Text zu erkennen. Selbst zwischen Groß- und Kleinbuchstaben kann es häufig nicht korrekt unterscheiden. Eine besondere Stärke von ocrad ist, dass es sich von in der Scan-Vorlage enthaltenen Grafiken besonders wenig irritieren lässt. Außerdem ist es sehr schnell. Bei ocrad kann man leider *nicht* direkt einschränken, welchen Zeichenvorrat es erkennen soll. Man kann nur ein Postprocessing aktivieren, das Zeichen mappt. Sagt man ihm, man möchte bevorzugt Ziffern scannen, so macht er aus einem "A" eine "4", sagt man ihm, man möchte bevorzugt Großbuchstaben, dann wird z. B. aus einer "5" ein "S". Es gibt zwar einen Modus "Großbuchstaben und Ziffern, der arbeitet aber so, dass er zunächst mal alles versucht in Großbuchstaben zu wandeln (auch Ziffern) und erst dann alle übriggebliebenen Zeichen versucht auf Ziffern abzubilden. Die Zahl "22.500" wird in diesem Modus auf "ZZ.SOO" abgebildet. Besonders problematisch: beliebiger Leerraum wird durch ein einzelnes Leerzeichen ersetzt. Besonders lästig ist, dass ocrad gerne aus "11" "I I" macht! Man muss schon fast eine KI nachschalten, um die Ergebnisse wieder in korrekte Werte zu wandeln.
ocrmypdf-10.3.1+dfsg-1/graphics/debian {PDF}: Ein Wrapper um tesseract, der PDF-Dateien mit einem OCR-Layer auszustatten. Dies klappt sehr gut und teilweise sogar besser als mit den Original-Tools von Adobe welche den Wahn haben die gescannten Seiten gelegentlich um 90 Grad zu drehen und dann natürlich nichts mehr darauf zu erkennen. Beim ocrmypdf ist mir dies bislang noch nie untergekommen, beim Acrobat hingegen schon öfter. Doch ocrmypdf hat auch Vorteile gegenüber der direkten Verwendung von tesseract: Zwar kann auch dieses PDF-Dokumente mit einem OCR-Overlay ausstatten. Aber bislang funktioniert dies nur fehlerhaft, da die Character-Boxen zu niedrig sind die dabei erzeugt werden. Das hat dann den Effekt dass man beim Markieren mit der Maus den Text nur auf halber Höhe markiert, was zwar nichts am korrekten Funktionieren der Kopierfunktion ändert, jedoch hässlich und unprofessionell aussieht. ocrmypdf macht diesen Fehler nicht oder korrigiert ihn irgendwie; jedenfalls sehen danach markierte Texte in damit erzeugten Dokumenten so aus wie man es sich erwarten würde. Weiters tut ocrmypdf noch mehr als Tesseract: Es versucht nicht nur, Text in Bitmap-Dateien in der PDF-Datei zu erkennen. Sondern es rendert die PDF-Datei zuerst intern temporär, und wendet die tesseract OCR-Software dann erst auf auf die solchermaßen gerenderte Ergebnis an. Der Unterschied ist, dass auf diese Weise auch Text erkannt wird der nicht in Bitmap-Form vorliegt. Das ist besonders bedeutsam bei mit schlechtem Tooling erstellte LaTeX-Dateien, in denen man ansonsten keinen Text markieren oder kopieren könnte - doch auch Tesseract würde darin nichts finden, da diese Dokumente keine Bitmaps erhalten sondern nur unbrauchbar codierten Text. Jedenfalls, ocrmypdf kann auch jene benutzerunfreundlichen PDF-Dokumente zu durchsuchbaren PDFs machen aus denen man auch wieder Text markieren und heraus kopieren kann. Weiters kann man bei myocr auch wählen ob das neu erzeugte PDF mit dem OCR Layer versuchen soll die Seiten des Original-Dokuments neu zu komprimieren oder nicht. Das ist sehr wichtig, da die meisten Linux-Tools bislang die besten PDF-Komprimierungsformate JBIG2 und JPEG2000 nur dekomprimieren, aber nicht komprimieren können. Würde man versuchen entsprechend komprimierte Seiten aus einer Original-PDF-Datei neu zu komprimieren würde sie dadurch deutlich größer werden als das ursprünglich der Fall war. Doch indem man diese Rekomprimierung auch abwählen kann, ist die neue PDF-Datei nur minimal größer (nur um den Platzbedarf des zusätzlichen Layers für den OCR-erkannten Text). Mit ocrmypdf erzeugte PDF-Dateien lassen sich danach problemlos mit Tools wie dem pdfarranger weiter verarbeiten, oder man kann den Text mit "pdftotext -layout" (aus den poppler-utils) extrahieren.
ocrodjvu-0.7.18-1/text/devuan: ocrodjvu ist ein Python-script welches installierte OCR-Programme (Tesseract, Cuneiform, ocrad oder gocr) benutzen kann, um OCR auf djvu-Dokumente anzuwenden um den in Bitmap-Seitengrafik enthaltenen Text zu extrahieren. Es ist unklar ob (aber anzunehmen dass) eine Möglichkeit besteht, den erkannten Text als unsichtbares Overlay zwecks Durchsuchbarkeit und Copy/Past in djvu-Dateien einzubetten. Von besonderem Wert ist hingegen das ebenfalls enthaltene Utility djvu2hocr, welches es erlaubt solchen bereits vorhandenen Overlay-Text in Form von XML-basierten hOCR-Dateien zu extrahieren. Indem man ein PDF-Dokument zuvor nach djvu umwandelt, kann man somit auch aus diesen hOCR-Dateien extrahieren.
octave/sci-mathematics/gentoo: "MatLab"-Clone der aber nur für UNIX verbreitet ist, da die Windows-Version schwierig zu bauen oder installieren sein soll. Dafür hat es eine angeblich bessere Kompatibilität zu MatLab als Scilab. Wie das proprietäre MatLab ist Octave eine Programmiersprache für numerische Berechnungen und Signalanalyse, in der die Matrix der wesentlichste Datentyp ist. Octave ist ein reines Kommandozeilenprogramm und verwendet gnuplot zur Grafikausgabe.
ogmtools-1.5-r2/media-sound/gentoo {audio}: Tools for splitting, merging, demuxing and appending OGM-based files, such as "*.ogg"-Files. There is also a tool for extracting chapter information from a DVD or DVD image file. The latter tool can be used as part of the process of importing the DVD chapter list into an .mkv video file.
okular-4 {document viewer}{PDF}: 20.12.3-2/graphics/debian okular-4.11.2/kde-base/gentoo: Der Dokument-Betrachter von KDE. Gegenstück zum Evince von GNOME, jedoch mächtiger. Kann je nach USE-Flags die folgenden Formate anzeigen: chm (Microsoft Help Files), djvu, ebook (epub-Dateien - leider ein pixeliges unscharfes Schriftbild - FBReader zeigt es deutlich hübscher an), jpeg (inklusive .cbr Comic Book Dateien), mobi (Mobipocket Dateien), pdf, postscript und tiff. Im Vergleich zu Evince schneidet Okular nahezu in allen Punkten besser ab, außer was den "Bloat"-Faktor betrifft. Allerdings startet auch Okular mit noch akzeptabler Verzögerung. Ein Vorteil von Evince gegenüber Okular ist einfachere Textauswahl zum Kopieren. Dafür punktet der Okular mit einem speziellen Markierungsmodus für Tabellen. Als PDF-Viewer sticht Okular dadurch hervor, dass er PDF-Kommentare erzeugen und editieren kann. Okular kann EPUB-Dateien besser anzeigen als fbreader. Aktuelle Versionen von Okular können PDF-Dokumente nicht nur anzeigen sondern auch mit Anmerkungen versehen und diese bearbeiten, PDF-Signaturen überprüfen, in der Datei enthaltene PDF-Anhänge anzeigen und abspeichern (nicht aber hinzu fügen, das muss man extern mit dem Befehl "pdfattach" aus den "poppler-utils" erledigen). Weiters kann okular auch enthaltene PDF-Formulare anzeigen, ausfüllen und mit dem ausgefüllten Inhalt ausdrucken und/oder wieder abspeichern. Weiters kann man sich bei okular aussuchen, ob man DRM-Beschränkungen in PDF-Dokumenten beherzigen oder ignorieren will. Auch verschlüsselte und passwortgeschützte PDFs werden entsprechend unterstützt.
oolite-1.84-1/games/devuan {game}: A OpenGL game similar to "Elite". It is a space trading and combat simulator. Did not work on Raspberry Pi - complained about some missing symbol in one of the GNUStep libraries. The package itself consumes about 13 MB of disk space, and another 9 MiB for the GNUStep Runtime. That runtime even dares to install a system daemon which listens on all interfaces, port 538! Some CORBA Broker, I guess. Also it required the jackd audio server to be running. A lot of requirements for the game! On the other hand, it seems to be quite popular and has decent 3D graphics, at least when installing additional texture packs.
open-cobol-1.0/dev-lang/gentoo: Ein COBOL-Compiler; Installationsumfang nur ca. 1 MB. Verwendet den GCC als Backend. Der Compiler "cobc" erzeugt aus dem COBOL-Quelltext eine .so-Datei, welche dann mit dem Launcher-Tool "cobcrun" ausgeführt werden kann. Als Storage-Backend kann (optional) berkdb verwendet werden. Mein "Hello world" funktionierte ohne Probleme. Und für mehr brauche ich COBOL nicht! :-)
open-invaders-0.3-3.2/games/debian {game}: 6 MB just for a Space Invaders? It seems cheaper to install a C-64 emulator and play the game on it.
open-vcdiff-0.8.4/dev-util/gentoo {binary-diff}{deduplication}: Ein binäres Diff/Patch-Programm, welches im Gegensatz zu anderen derartigen Tools einen (mehr oder weniger) Standard implementiert - in diesem Fall VCDIFF (RFC 3284). Bei Verwendung der Option -target_matches sowie einer Windows-Größe welche größer als die beteiligten Dateien sind, erzeugt dieses Tool kleinere Deltas als bdelta. xdelta3 schlägt beide, aber nur weil es die Deltas offensichtlich intern noch zusätzlich komprimiert. Komprimiert man all diese Deltas dann hingegen, ist bdelta wieder das kleinste, obwohl vcdiff mit geringem Abstand folgt. xdelta3 ist dann hingegen das größte. Insgesamt entsteht der Eindruck, dass bdelta und vcdiff ähnlich gut komprimieren, wobei das erste minimal besser ist. Beide schlagen hingegen xdelta3, allerdings nur wenn die Deltas nach der Erzeugung komprimiert werden. xdelta3 hingegen ist einfacher zu benutzen da die erzeugten Deltas sofort "verandfertig" (jedoch etwas größer als nötig) sind. Wenn man dabei aber bedenkt dass vcdiff ein stabiles und offenes Format ist, während bei bdelta nach wie vor Änderungen im Format möglich sind, dürfte vcdiff die derzeit beste Lösung zur Langzeitarchivierung von binären Deltas sein. Ein Nachteil von vcdiff ist die non-standard Kommandozeilen-Optionens-Syntax und die verwirrend Terminologie, wo die alte Datei als "Dictionary" bezeichnet wird, während die neue Datei noch halbwegs sinnvoll als "Target" bezeichnet wird. Für weitere Verwirrung sorgt dass man statt "diff" auch "encode" und statt "patch" auch "decode" verwenden werden kann.
openal-1.13/media-libs/gentoo {audio}: Eine weit verbreitete Crossplatform-Library für 3D-Sound. Unter Gentoo wird OSS, Portaudio, Pulseaudio und natürlich ALSA als Backend unterstützt. Man kann beliebig viele einzelne Sound-Quellen (Mono oder Stereo) an beliebigen 3D-Positionen erstellen und jeder Soundquelle eine Richtung und Geschwindigkeit zuordnen. Letztere wird allerdings nur für die Berechnung des Doppel-Effektes verwendet und hat keine weiteren Auswirkungen, auch nicht auf die 3D-Position der Soundquelle. Die Library hat auch Funktionen für Aufnahme, nicht nur Wiedergabe. Nur Mono-Soundquellen fließen in 3D-Berechnung ein; Stereo-Quellen werden einfach nur gleichmäßig zur Ausgabe dazugemixt und dienen normalerweise nur als Hintergrundmusik. Die Sample-Daten werden immer mittels Puffern übergeben, deren Größe, Anzahl, Loop-/Recyclingverhalten usw. sich aber weitgehend frei festlegen lässt. Es können beliebig viele Audio-Kontexte der Libraries erstellt werden, jeder mit beliebig vielen Quellen aber nur einem "Zuhörer". Allerdings gibt es pro Thread immer nur einen aktuellen Kontext der implizit für alle API-Funktionen verwendet wird. Man kann diesen Kontext aber umschalten, und verschiedene Threads können entweder unterschiedliche aktuelle Kontexte haben oder welche mit anderen Threads teilen. Jeder Kontext ist immer an ein bestimmtes Ausgabegerät gebunden. Der Standard spezifiziert nicht wie man Stereo- oder 6-Kanalausgabe mit diesem Modell erzeugt, aber die Linux-Implementierung stellt Ausgabegeräte für Dummygerät, Mono, Stereo, 5.1, 6.1 und 7.1 Sound bereit sowie das Kommando "openal-info" um sich die verfügbaren Geräte und ihre Features anzeigen zu lassen (das API dafür ist als Extension ausgeführt). Der Quelltext unterstützt auch ein wav-Output-Gerät, das unter Gentoo aber nicht kompiliert wird. OpenAL ist ähnlich wie OpenGL durch Extensions erweiterbar und besitzt ein API zum Ermitteln der verfügbaren Extensions. Quellen aller Kontexte teilen sich dieselben Sample-Buffer, aber jeder Kontext hat seine eigenen Quellen. Die Library rendert das ganze dann zu einem einzigen einzelnen 8- oder 16-Bit Ausgabepuffer für einen einzelnen Hörer zusammen. Will man Mehrkanalausgabe, erzeugt man einen Kontext für jeden Ausgabekanal. Sowohl die Quellen als auch der Hörbereich des (immer einzelnen) Hörers haben nicht nur eine 3D-Position, sondern auch eine kegelförmige Lausch- bzw. Ausstrahlrichtung. Vorteilhaft ist dass von Seiten des Programmierers nur wenig Aufwand nötig ist, um openal in eine OpenGL-Applikation einzubauen.
openbox-3.4.11.1/x11-wm/gentoo {window manager}{GUI}{X11}: Sehr netter Windows-Manager mit gutem Standard-Support. Leider fehlen ihm ein paar Dinge: Keine Panels, keine Taskleiste, keine Uhr, kein permanent sichtbares Startmenü, kein Workspace-Pager. Programm- und Workspace-Umschaltung sind zwar verfügbar, aber nur via Alt-Tab oder Kontextmenüs wenn man mit dem rechten oder mittleren Mausknopf irgendwo auf den Desktop-Hintergrund klickt. Somit kann man zwar grundsätzlich alles mit openbox machen, aber man vermisst rasch die von Windows her gewohnte Funktionalität eines fixen Panels. Es gibt aber zahlreiche Fremdpanels welche man zu diesem Zweck verwenden kann, wie tint2, bmpanel oder fbpanel. tint2 ist dazu besonders prädestiniert, da es fast dieselben Laufzeitbibliotheken wie Openbox selbst benutzt und somit nahezu keinen zusätzlichen Overhead zur Folge hat. Ein nettes Feature von openbox sind jederzeit dynamisch hinzufügbare und entfernbare Desktops. Weiters basiert sein Verschieben und Größenänderungen von Fenstern auf Edge Resistance (Kantenwiderstand) anstatt auf Snapping. Das bieten leider nur eine Handvoll WMs, obwohl es die einzig "richtige" Methode ist. Außerdem sind die Verschieben/Größenänderungs-Befehle aus dem Fenstermenü komfortabel: Man verschiebt bzw. veränder die Fenstergröße danach einfach indem man die Maus bewegt bis die richtige Position gefunden wurde. Kein ständiges Festhalten mit der Maustaste während dessen nötig. Ausführliche Dokumentation im HTML-Format wird mitgeliefert. Openbox hängt zwar nicht direkt von GTK+ ab; verwendet aber einige der Basis-DLLs von GTK+ wie etwa die glib - alles in allem ca. 2 MB an derartigen DLL-Abhängigkeiten. RAM-Bedarf: rund 30 MB. Da aber auch PekWM Kantenwiderstand und ähnliche Features bietet aber dabei viel schlanker als Openbox ist (17 MB RAM-Bedarf), ist mir ersteres als Zweit-WM lieber. Auch Openbox beherrscht ein Kommando, um einen anderen Fenstermanager zu starten und von diesem abgelöst zu werden. Man kann daher einfach zwischen Openbox und einem anderen WM hin- und her wechseln, ohne dazu die laufende X11-Sitzung unterbrechen zu müssen. Außerdem wird PekWM von xdgmenumaker unterstützt, openbox hingegen nicht. Allerdings erzeugen Debian-spezifische Scripte ausreichend gute Menüeinträge für das Startmenü von openbox, so dass dies zumindest unter Debian weniger ein Problem ist. Außerdem gibt es dort ein Paket "openbox-menu", welches ein automatisch generiertes Startmenü in openbox einbaut. Überdies können zwar Openbox und PekWM einige ähnliche Dinge; im Detail sieht aber das meiste bei openbox etwas besser aus. Vor allem scheint OpenBox stabiler zu sein, PekWM stürzte mir schon häufiger ab.
openntpd-4.0_pre20080406/net-misc/gentoo: Ein NTP-Daemon, der sowohl NTP (Network Time Protocal) als auch SNTP (die "simple"-Variante) beherrscht. Ein Vorteil dieses Pakets gegenüber net-misc/ntp ist sein geringerer Umfang - nur 300 KB vs. mehrere MB. Vor allem aber: Es funktioniert, und hängt sich nicht sofort beim Start auf! (Problem von net-misc/ntp im Sommer 2015.) Openntpd kann zwar auch als NTP-Server fungieren zu dem sich andere Computer synchronisieren können, per Default ist es aber ein reiner Client-Daemon. Das hat vor allem den Vorteil dass es an keinem Port lauschen muss, und diesbezügliche Sicherheitsbedenken daher eliminiert. Weiters ist die Konfiguration wesentlich simpler als die von net-misc/ntp, wo man etliche sicherheitsrelevante  Settings festlegen musste, die unzureichend erklärt waren. Aber sogar wenn man openntpd als NTP-Server betreibt gibt es wenig Troubles, da dieser im Gegensatz zu net-misc/ntp keine potenziell gefährlichen Kommandos von außen akzeptiert und einfach nur die Zeitanfragen beantwortet. Ein Nachteil von openntp ist, dass es nicht einschränken kann aus welchen IP-Adressbereichen Anfragen erlaubt sind wenn er als NTP-Server läuft: Wer den Server erreicht, kann ihn auch benutzen und gegebenenfalls daher auch mittels Exploits missbrauchen .
openoffice-3.2.0/app-office/gentoo: Jeder kennt es. Daher will ich hier nur auf jene Punkte eingehen, die es von anderen ähnlichen Paketen unterscheiden oder besondere Features bzw. Schwachpunkte darstellen. OOo Draw: Einer der größtem Nachteile von OOo Draw ist es, dass eine grundsätzliche Unterscheidung zwischen Verbindern und normalen Elementen gemacht wird. Die normalen Elemente sind teils sehr mächtig; können aber leider nicht als Verbinder genutzt werden. Dafür gibt es zwar viele Verbinder-Typen, die aber nur Permutationen weniger sehr simpler Grundtypen sind und allesamt das Problem haben, dass sie nur wenige Freiheitsgrade aufweisen. Der Bezier-Verbinder etwa hat nur einen einzigen Kontrollpunkt, und der lässt sich zudem nur in eine Richtung verschieben. Somit kann man nur einfacher, annähernd gerade under einheitlich gerundete Verbinder erstellen. Das ist weit von dem entfernt was eine Bezier/Polyline mit vielen Kontrollpunkten könnte. Ein Vorteil ist dafür, dass man für jedes Objekt beliebig viele eigene Klebepunkte definieren kann; zusätzlich zu den Standard-Klebepunkten aller Objekttypen. Weiters nett, dass die meisten Objekte einen integrierten Text zur Beschreibung unterstützen. Was allerdings fehlt, ist ein Verbinder-Element für beschriftete Kanten. Dieses muss man sich selbst zusammen basteln, wobei das Problem hinzu kommt dass Verbinder selbst keine Klebepunkte aufweisen sondern nur normale Objekte. Man kann also nicht einen Verbinder als Kante nehmen und ein Textelement dran kleben. Zumindest im Default-GUI fehlen einfache Toogle-Buttons zum Umschalten von Gitter- und Objekt-Einrastung; man muss hier ständige Tastaturkombinationen bemühen. Sehr nett ist hingegen das Bezier-Spline-Objekt, bei dem man nicht nur Kontollpunkte hinzufügen/verschieben kann, sondern auch Constraints definieren wie "glatt" oder "symmetrisch" was einen von zwei symmetrischen Kontrollpunkt-Partnern entsprechend an den jeweils anderen Partner anpasst. War OOo Draw fehlt, ist eine einfache Möglichkeit den Maßstab einer Zeichnung einzustellen. Es gibt zwar ein derartiges Setting, es ist jedoch tief in den Eingeweiden der allgemeinen Konfigurations-Einstellungen vergraben, und ist zudem nicht per Folie separat konfigurierbar. Es fehlen Elemente, um in DAGs Kanten sinnvoll zu beschriften. Zwar kann man Verbinder mit einer Beschriftung versehen, diese wir dann vom Verbinder direkt durchkreuzt. Weiters fehlt eine Möglichkeit, bei Verbindern einen Abstand zum Ziel bzw. vom Herkunftsobjekt definieren zu können, so dass die Verbinder zwar auf die Elemente verweisen, diese aber nicht berühren.
openresolv-3.8.0-1~bpo8+1/net/devuan: Ein Script-Framework, um die Datei /etc/resolv.conf zu aktualisieren, wenn verschiedene Dienste Nameserver bereit stellen, und andere solche benötigen. Ist als drop-in Replacement für das ältere Paket "resolvconf" gedacht welches eine Reihe von Nachteilen gegenüber openresolv aufweist, und installiert auch seine Utilities und man-Pages unter dem Namen des Originals. Meiner Ansicht nach ist openresolv allerdings fürchterlich umständlich, und dann auch noch mit D-BUS und systemd-Aufrufen verseucht. Besser man verzichtet darauf - wenn man kann. openresolv kann entweder eine einzige zentrale DNS-Konfiguration in /etc/resolv.conf dynamisch generieren. Oder es kann eine Reihe von unterstützten DNS-Servern wie insbesondere dnsmasq als lokale Resolver zu diesem Zweck verwenden, was den Vorteil hat dass dann in verschiedenen Subnetzen unterschiedliche DNS-Server zur selben Zeit im Einsatz sein können.
openscad-2014.03+dfsg-1/graphics/devuan {3D}{CAD}: Ein ungewöhnliches 3D-CAD Programm mit geringem Installationsumfang. Es ist mehr eine IDE für eine 3D-Programmiersprache als ein interaktives CAD-Programm. Das GUI ist 3-geteilt und besteht aus Quelltext-Editor-Fenster, 3D-Renderansicht, und Meldungsfenster für die Compilermeldungen. Man bearbeitet den Quelltext, lässt ihn per Tastendruck kompilieren, und kann dann im 3D-Fenster das gerenderte Modell betrachten, zoomen, rotieren und verschieben. Allerdings sind diese interaktiven Möglichkeiten rein auf die virtuelle Kamera bezogen; man kann das 3D-Modell dadurch nicht verändern. Immerhin gibt es die Möglichkeit, die numerischen Details der momentanen Kamera-Position in die Zwischenablage zu kopieren, so dass man diese Daten dann irgendwo im Quelltext verwenden kann. Das Programm hat starke Ähnlichkeit mit kpovray, nur dass der Schwerpunkt hier auf den geometrischen Formen liegt und weniger darauf abzielt etwas besonders hübsches zu rendern. Das Programm zielt auf die numerisch exakte Konstruktion von 3D-Modellen ab, und nicht auf die Erstellung hübscher Bilder oder gar Animationsfilmen. (Obwohl es sehr wohl die Möglichkeit gibt auch 3D-Animationen zu erzeugen, allerdings gibt es keinen entsprechenden Editor oder Preview, und alles spielt sich nur im Quelltext ab.) Ein bisschen ärgerlich ist, dass das GUI nicht einmal Möglichkeiten bietet Elemente der Programmiersprache einzufügen oder die Parameter zu erklären; man braucht daher immer einen offenen Browser mit der Anleitung zur Programmiersprache bzw. zu den Funktionen der 3D-Bibliothek, soweit man sich nicht alles auswendig merkt. Wenn man entsprechende Einarbeitsungszeit investiert, kann man mit OpenSCAD vermutlich tolle und auch numerisch exakte Modelle erstellen. De facto ist es aber eine Programmiersprache und kein interaktiver Editor. Der Komfort ist daher nicht im entferntesten mit dem zu vergleichen, was man von anderen CAD-Programmen mit ihren Toolbars, Grafik-Editoren und endlosen Menüs gewohnt ist. Davon abgesehen frage ich mich, wie man in einer komplexen 3D-Szene mit diesem Programm den Überblick behalten will, welche Elemente in Quelltext welchen in der 3D-Ansicht entsprechen. Vermutlich wird man sich OpenSCAD daher nur "antun wollen", wenn man entweder wirklich sehr viel Zeit investieren will, oder wenn man schwächere Hardware hat die durch Blender oder FreeCAD überfordert wird. Auch wenig Speicherplatz ist kein Problem für OpenSCAD, das voll installiert nur vielleicht 5 oder 6 MB belegt. Eventuell kann OpenSCAD zur Datenkonvertierung genutzt werden, dann es kann einige 2D- und 3D-Formate importieren und exporieren - darunter auch das AutoCAD DXF-Format. Andererseits, Blender kann das vermutlich erst recht.
openshot-1.4.3/media-video/gentoo openshot-2.5.1+dfsg1-1/video/debian {video-editor}: Ein in Python geschriebener und auf GTK+ aufbauender nicht-linearer Video Editor. Scheint simpler in der Einrichtung als LiVES zu sein. Laut einem Artikel von 2013 sei openshot unzuverlässig wegen zahlreicher Bugs und wurde gar als Alpha-Qualität tituliert. Auch Datenverlust wegen verstümmelter Projekte bei fehlerhaften Speichern sollen schon vorgekommen sein. 2022 scheinen diese Probleme ausgeräumt zu sein. Openshot ist 2022 auf Platz 6 der beliebtesten nichtlinearen Video-Editoren (auf slant.co). 2022 ist der RAM-Bedarf direkt nach dem Start 249 MB RAM. Vorteile 2022: Einfach zu erlernendes GUI, GPU-Rendering funktioniert bereits gut obwohl erst Beta-Release. Simple Dinge gehen einfach, doch weniger simple oft nur schrecklich umständlich. Clips die kürzer als 8 Sekunden können nur sehr mühsam in der Zeitlinie selektiert und manipuliert werden. Das Bearbeiten von Effekt-Einstellungen ist nicht-intuitiv - man muss sich mit lauter numerischen Parametern herumärgern. Kein Überlagern von mehreren Zeitlinien vorgesehen.
openssh-6.9_p1-r2/net-misc/gentoo: Der "große" Programm für ziemlich sichere Datenübertragung. Optional können "HPN"-Patches beim Bauen verwendet werden, welche folgende "Vorteile" bringen: Eine "None"-Cipher für völlig unverschlüsselte Übertragung, eine Multithreading-Implementation für die "sichere" AES-Cipher, das Hinzufügen einer Spitzenwert-Anzeige für die Download-Anzeige sowie das dynamische Verändern der Empfangspuffergröße. Diese Features scheinen mir alle relativ sinnlos oder sogar kontraproduktiv für normale Anwendungsfälle, und haben wohl nur im Server-Bereich mit extra-starker Hardware und riesiger Bandbreite irgend einen Nutzen.
orage-4.8.1/app-office/gentoo {PIM}{reminder}: Eine nette Kalender-Anwendung für XCFE4. Beherrscht auch ical Import/Export und kann Alarme anzeigen. Durchaus brauchbar, wenn einem die "fetten" Lösungen der großen DTEs zu ressourcenverschwendend sind. Allerdings ist Orage nur für einzelne User gedacht und der Kalender lässt sich nicht über irgend einen Groupware-Server automatisch mit anderen Usern synchronisieren. Orage erlaubt auch Wiederholungstermine und kann innerhalb dieser einzelne zutreffende Tage explizit ausnehmen oder aber den Regeln widersprechende Tage hinzufügen. Auch Regeln wie "letzter Mittwoch des Monats" sind möglich. Orage kann allgemein .ics Dateien importieren und exportieren; er speichert auch seine eigenen Termine intern in diesem Format. Leider sind die häufig versandten von Outlook exportierten .ics-Dateien nur teilweise dem Standard entsprechend und können daher oft nicht ohne Änderungen an der Syntax in Orage importiert werden (Outlook schafft es nicht einmal die Datums/Zeitabgaben standardkonform zu formulieren). Außerdem kann man .ics-Dateien nicht einfach per Drag und Drop oder Kommandozeilenargument importieren, sondern nur vergleichsweise umständlich über einen Import/Export Dialog. Orage unterstützt neben dem Importieren und Exportieren auch das direkte verwenden von fremden .ics Dateien; in diesem Fällen werden die Einträge beim Starten des Programms direkt aus diesen Dateien gelesen anstatt aus der internen Datei. Orage kann auch .ics-Dateien importieren welche es nicht komplett parsen kann; diese sind dann mit speziellen Erweiterungsmarkierungen versehen Teil der internen .ics-Datei; die Einträge sind allerdings im Kalender unsichtbar wenn essenzielle Felder wie das Anfangsdatum nicht geparsed werden können. Aber immer noch besser als dass sie verloren gingen. Das oben genannte Outlook-Parsing-Problem sorgt etwa dafür dass Outlook-Termine zwar importiert werden können, danach aber nicht angezeigt werden. Bei Alarmen erlaubt Orage sowohl die Anzeige eines eigenen Fensters, das Abspielen eines Sounds, oder das Anzeigen einer Meldung mittels libnotify. Auch das Ausführen eines externen Kommandos ist möglich. Ferner ist es möglich versäumte Termine (da das Programm zu diesem Zeitpunkt nicht lief) beim nächsten Programmstart nachzuholen. Beim Anlegen von Terminen ist es möglich sich auszusuchen ob der Termin den Time-Slot exklusiv belegt, oder on andere Termine denselben Slot belegen dürfen. Neben normalen Terminen (ganztägig oder mit Anfang und Endzeit) gibt es auch "Aufgaben", die Anfangs- und Fälligkeitszeitpunkt haben und durch das Eintragen einer "Erledigt"-Zeit abgeschlossen werden und denen eine von 10 Prioritätsstufen zugeordnet ist. Zudem gibt es noch "Protokoll"-Einträge welche nur einen Zeitpunkt, Titel und Kommentar unterstützen, nicht aber Wiederholung oder Länge/Endzeitpunkt. Was Orage fehlt, ist eine allgemeine "To-Do-List" deren Einträge an kein bestimmtes Datum gebunden sind. Orage enthält auch eine Zusatzapplikation zur Anzeige der aktuellen Zeit in beliebig vielen Zeitzonen. Wenn das Orage-Fenster geschlossen wird läuft die Applikationen als Traybar-Symbol weiter (kann dort über das Kontextmenü aber auch komplett beendet werden). Ein Problem von Orage ist, dass er nicht fähig ist importierte Texte im "Beschreibung"-Feld automatisch mehrzeilig umzubrechen: Er scheint nur harte Zeilenvorschübe zu verstehen. Das größte Problem von Orage ist, dass es keine Datenbank benutzt und seine Termine ausschließlich in großen .ics-Dateien speichert. Das bedeutet dass alle Einträge ständig im RAM sein müssen, und bei jeder Änderung die ganze ICS-Datei komplett neu geschrieben werden muss. Eine unintelligente Weise, viele Daten zu verwalten. Ich werde aus diesem Grund das Programm nicht verwenden, da ich meine Flash-Disk nicht sinnlos "zu Tode schreiben" will.
orc-0.4.11/dev-lang/gentoo: Ein hybriges Compiler/Runtime-System welches aus architekturneutralem Quelltext SIMD- und special-Purpose Instructions für unterstützte CPUs erzeugt. Unterstützte Ziel-Instruction Sets sind unter anderem SSE, NEON und Altivec. Wenn eine bestimmte Quelltext-Instruktion auf der Zielplattform nicht zur Verfügung steht, kann statt dessen C-Quelltext einer C-Funktion zur Emulation erzeugt werden. Orc kann grunsätzlich in 3 Modi betrieben werden: Erstens als reines Runtime-System, so die Ziel-Instructions dynamisch zur Laufzeit erzeugt und ausgeführt werden. Dazu wird das API der orc-Library verwendet. Zweitens kann man die Instructions in der primitiven assembler-ähnlichen portablen Programmiersprache "Oil" verfassen, diesen in Bytecode kompilieren lassen, und den Byte-Code direkt ins C-Programm aufnehmen (etwa als initialisierte "char"-Arrays). Drittens kann man den "Oil"-Quelltext direkt in Assembler- bzw. C-Quelltext umwandeln lassen, diesen dann assemblieren bzw. compilieren, und die resultierenden Object Files direkt zum Programm hinzu linken. Orc ist durch eigene Konfigurationsdateien jederzeit um weitere CPU-Instructions oder "Oil"-Instructions erweiterbar ohne deswegen die Library oder dem Compiler selbst modifizieren zu müssen.
ori-0.8.1+ds1-3/utils/debian {version control}{FUSE}: Ein FUSE-basiertes replizierendes und offline-fähiges Remote-Dateisystem mit eingebauter Versionierung und Deduplikation auf Datei und Sub-Datei-Ebene (mit datenabhängigen Blockgrenzen). Kann aber auch lokal zur Replikation und Deduplikation eingesetzt werden. Hat viele konzeptionelle Ähnlichkeiten mit Git, ohne aber davon abzuhängen. Die Replikation kann entweder automatisch oder manuell erfolgen. Die automatische Replikation kann mehrere Repositories periodisch auf die Erreichbarkeit von Repositories prüfen und dann auch synchronisieren. Remote-Repositories können entweder manuell definiert werden, oder mittels mDNS/Zeroconf entdeckt werden. Als Transport stehen zumindest SSH und HTTP zur Verfügung. OriFS lässt sich aber auch ganz ohne Replikation als Git-ähnliches Versionskontrollsystem benutzen. Die Granularität der Replikation und Versionierung sind Snapshots. Diese lassen sich sowohl manuell erstellen, als auch automatisch in periodischen Abständen soweit sich etwas geändert hat. Angeblich soll man oriFS auch ohne den FUSE-Treiber wie ein konventionelles DVCS benutzen können. Allerdings scheint das in dieser Version noch nicht implementiert zu sein. Überhaupt scheint diese Version noch etwas unfertig zu sein - es gibt nur eine ganz knappe man-Page die kaum etwas erklärt, und auch die online-Hilfe ist nur sehr knapp. oriFS hat ähnlich wie cryFs sehr viel Potenzial und wirkt auch sehr interessant, jedoch scheint mir der Entwicklungs-Stand noch zu früh zu sein, um ihm wertvolle Daten anzuvertrauen. Empfehlung: In 1 oder 2 Jahren (Stand: 2017) noch einmal ansehen.
osmctools-0.9-3/utils/debian {GIS}: Enthält Kommandozeilen-Utilities für die Konvertierung von OpenSteetMap Dateien. "osmconvert" liest Dateien in einem der Formaten .osm .osc .osc.gz .osh .o5m .o5c .pbf und schreibt sie in ein anderes dieser Formate mit Ausnahme von .osc.gz. Kann weiters auch Deltas zwischen OSM Dateien ermitteln und als .osc Dateien ausgeben, oder diese Änderungen auf bestehende OSM Dateien anwenden. Weiters kann es auch sämtliche Übereinstimmungen zweier OSM Dateien aus einer davon entfernen. Es kann auch den Inhalt einer OSM-Datei durch eine Bounding Polygon filtern, wobei diese Filterung optional keine zusammengehörigen Objekte zerschneidet (also dennoch immer zur Gänze inkludiert). Kann auch ausgewählte Metadaten löschen. "osmfilter" ist ein experimentelles (Stand 2022) Programm zum Filtern vorhandener OSM-Daten aufgrund von Attributen als auch Geometrie. Es interpretiert zu diesem Zweck komplexe Filterausdrücke und benötigt Random-Access auf die Eingabedatei. Im Vergleich zu den Filtermöglichkeiten von osmconvert können hier vor allem Metadaten anhand von Typ und Wertebereichen gefiltert werden. "osmupdate" kann  OSM Change Files (*.osc, *.osc.gz) von "planet.openstreetmap.org herunter laden mit denen vorhandene OSM-Dateien aktualisiert werden können. Alternativ kann es diese Aktualisierungen auch gleich auf die lokal vorhandene Kartendaten anwenden und sie dadurch aktualisieren. Für die Aktualisierung werden alle Änderungen seit einem gegebenen Datum heruntergeladen, per Default wird der Timestamp der Eingabedatei dazu verwendet.
osmo 0.2.14-3/community/archlinux {PIM}{reminder}: Eine in Personal-Organizer-Anwendung (GTK+ GUI). Kalender: Titel, Datum, Kategorie, Priorität, Beschreibung, Alarm (Sound bei Erreichen, Dialog bei Erreichen öffnen, benutzerdefinierter Alarm-Befehl, Alarm-Warnung Tage/Stunden/Minuten, Zeit verschieben um Minuten), Wiederholungen (Zeitspanne: Von HHMM, bis HHMM, Intervall HHMM. Tagesspanne: Tage, Monate, Wiederholungen. Wochentage markierbar. Optional ob versäumte Wiederholungen nachgeholt werden sollen). Aufgaben: Wie Kalender, nur dass erledigte Einträge in einer Liste abgehakt werden können und das Datum optional ist. Kontakte: Eine lange Liste fix vordefinierter Felder (was allerdings fehlt sind die Felder "Titel" und "Funktion", dafür gibt es fixe Felder für eine willkürliche Auswahl einzelner Instant Messenger-Identitäten), inklusive Foto und allgemeine Notizen. Bestimmte Felder wie Telefonnummer oder e-Mail-Adresse können beliebig oft wiederholt werden. Es gibt allerdings keine benutzerdefinierbaren Felder. Notizen: Titel, Kategorie und Inhaltstext. Cursor-Position kann optional mitgespeichert werden. Jeder Eintrag kann optional verschlüsselt werden - mit einem separaten Passwort pro Eintrag (auch wenn einem natürlich niemand verbieten kann für alle Einträge das selbe zu nehmen.) Verschlüsselungsalgorithmen können hingegen nur global festgelegt werden: Serpent, AES, Twofisch, weitere - alles vorhanden. Auch Kompressionsverfahren und Hash-Algorithmus für die Verschlüsselung können nur global festgelegt werden. Wirkt alles ein bisschen nach Overkill, zumal *nur* Notizen auf diese Weise geschützt werden können! Weder Aufgaben noch Termine oder Kontakte. Alle Module haben eine Backup/Restore-Funktion, wo in ein privates Datenformat exportiert/importiert werden kann. Diese Dateien sind verschlüsselt und ein Passwort muss vergeben werden. Neben den oben erwähnten Grundmodulen gibt es noch ein paar Hilfsfunktionen: Jahreskalender, Datumsrechner (Differenz zwischen zwei Zeitpunkten berechnen, Intervall zu einem Zeitpunkt addieren/subtrahieren), Geburtstage anzeigen, Position eines Kontakts auf der Karte anzeigen (Google Maps, Bing, OSM), Kontakte als CSV importieren/exportieren, Kalender und Aufgaben als ics-Datei exportieren (importieren scheint man sie nicht zu können, aber man kann offenbar externe Kalenderdateien einbinden). In den meisten Kommentarfelder lassen sich Text-Teile individuell mit Farben und Schrifteffekten formatieren. Wirkt alles in allem optisch recht nett und bietet was man erwarten sollte, aber wenig darüber hinaus. Osmo scheint alle Daten in XML-Dateien abzuspeichern und jedesmal beim Starten des Programms komplett in den RAM zu laden. Es scheint keine Datenbank benutzt zu werden. Das lässt Skalierungsprobleme befürchten wenn die Einträge mit er Zeit immer mehr werden, und außerdem muss jedesmal beim Speichern die ganze XML-Datei neu geschrieben werden. Nur Notizen scheinen in separaten Dateien gespeichert zu werden. Eine etwas unintelligente Methode viele Daten zu verwalten! Ich werde aus diesem Grund das Programm nicht verwenden, obwohl es ansonsten einen netten Eindruck macht.
ossp-uuid-1.6.2-r4/dev-libs/gentoo: Stellt ein Utility "uuid" bereit, welches dieselben Funktionen bietet wie "uuidgen". Darüber hinaus kann es aber auch noch "Name-based" UUIDs erzeugen, eine konkrete UUID-ID-Typvariante auswählen, sowie bereits erzeugte UUIDs decodieren und die decodierten Bestandteils-Informationen anzeigen. Wenn man das Erstellungsdatum einer Time-Based UUID wissen will, ist dies das richtige Tool dazu.
ostree 2016.5-2/extra/archlinux: Ein weiteres Tool aus dem Umfeld der systemd-Autoren. Es versucht klassische Paket-Management-Systeme dadurch zu ersetzen, dass die Dateien welche früher in Paketen ausgeliefert wurden nun in Git-ähnlicher Manier irgendwo unterhalb des Verzeichnisses /ostree ausgechecked werden. Dies geschieht auf 2 Ebenen: Zum einen werden auf der unteren Ebene Dateien basierend auf ihrer Hash-ID (und vermutlich auch so benannt) in einem Repository-Unterverzeichnisbaum abgelegt. Dadurch ergibt sich automatisch eine Deduplikation identischer Datei-Inhalte. Auf der oberen Ebene werden in einem anderen Unververzeichnisbaum von /ostree sogenannte "Deployments" abgelegt, deren Inhalte jeweils einem kompletten Dateisystem-Snapshopt entspricht, in das man beim Booten mit chroot wechseln und das System damit hochfahren kann. Diese Deployments enthalten nur Unterverzeichnisse und Hard-Links auf Repository-Dateien, aber keine eigenständigen (nicht hard-gelinkten) Dateien. Die Pfadnamen der Deployment-Verzeichnisse basieren auf einer vom Menschen vergebenen Bezeichnung der Betriebssystem-Variante als eine der äußeren Pfadkomponenten, sowie auf einer Hash-ID des enthaltenen Datei-Baums als innerste Pfadkomponente. Die Idee der Nutzung von ostree besteht nun darin, dass beim Booten ein chroot in eines der Deployment-Verzeichnisse durchgeführt wird, und dieses dann bis zum nächsten Reboot als Wurzeldateisystem agiert welches den Inhalt von /usr, /opt etc. enthält. Kurzum, alle Dateien welche früher in Form von Installationsarchiven ausgeliefert wurden. Alles was nicht zu den "Paketdateien" gehört, wie /home, muss als separate Dateisysteme dazu gemountet werden. Dabei wird /var allerdings speziell behandelt: Hiervon gibt es im Deployment-Verzeichnisbaum nur eine Instanz pro OS-Variante, die von allen Deployments (mit unterschiedlichen Hash-IDs) dieser OS-Variante gemeinsam via "--bind"-Mounts genutzt wird. /etc wird ebenfalls speziell behandelt; "Pakete" sollen ihre Dateien in /usr/etc anstatt /etc ablegen; osdir mischt diese "Default"-Inhalte dann mit früheren Anpassungen und lokalen Änderungen irgendwie zusammen wenn ein Deployment gebootet wird. Weiters werden auch Kernel- und Initrd-Dateien speziell gehandhabt, und müssen exakt festgelegte Dateinamen verwenden, deren Name die Hash-ID des Deployments beinhaltet. Die Kontrolle von /boot geschieht über "The Boot Loader Specification" von freedesktop.org die auf einem VFAT-Dateisystem-Layout mit Beschreibungsdateien basiert. Vermutlich repliziert bzw. kopiert ostree die entsprechenden Dateien von /ostree nach /boot, anstatt Hardlinks zu erstellen. ostree bezeichnet sich selbst auch als "Git for operating systems". Als logische Konsequenz seiner Funktionsweise zementiert dieses Tool den Zwang alle Dateien von /usr, /bin, /sbin und /opt im selben Dateisystem wie /ostree unterzubringen, da es nicht möglich ist Hard-Links über Dateisystem-Grenzen hinweg zu verwenden. Auch wenn ostree auf sehr ähnlichen Konzepten wie git basiert, ist es eine gänzlich inkompatible Implementation, die auf SHA-256 anstatt auf SHA-1 basiert und zusätzliche Metadaten wie UID, GID und EAs. Ein weiterer Unterschied zwischen Git und ostree besteht darin, dass ostree keine "Packs" kennt, sondern jedes Repository nur in 2 Varianten vorliegen kann: Als einzelne Dateien oder als "z2"-Archiv. Erstere Variante wird auf Clients verwendet, da nur diese Variante direkte Hardlinks auf Dateien im Repository erlaubt. Die Archiv-Variante ist für Deployment-Server gedacht, welche die Archivdateien via HTTP "ausliefern". Eine weitere logische Konsequenz ist, dass neu installierte oder aktualisierte Pakete immer noch nach einem Neustart zur Verfügung stehen, da sie sich (allein schon aufgrund der geänderten Hash-ID durch die neuen Inhalte) in einem anderen Deployment befinden müssen.
ostree-2016.15-5/admin/debian {version control}{FUSE}: Ein Git-ähnliches simples Versionskontrollsystem, das anstelle eines Working-Trees eine Directory-Struktur aus Hard-Links in Dateien im Repository "auscheckt". Diese sind Read-Only und dürfen nicht verändert werden. Ein solches Checkout kann auch ein bootfähiges Wurzeldateisystem implementieren. Als Hilfe um das Verändern der besagten Hardlinks zu verhindern ist auch ein FUSE-Dateisystem enthalten, welches Verzeichnisse als beschreibbar durchzureichen scheint, existierende Dateien jedoch als Read-Only darstellt. (Sehr seltsam, wozu soll das gut sein?) ostree ist primär dafür gedacht, zahlreichen Linux-Containern eine Auswahl an bootfähigen Wurzeldateisystemen zur Verfügung zu stellen, ohne dafür viele identische Kopien von Dateien pro Container abspeichern zu müssen. Allerdings taugt ostree nur für nicht veränderliche Dateien wie typischerweise denen in /bin, /lib, /usr, etc. So schön das auch alles klingt, hat ostree den Nachteil dass einige sehr eigenwillige Konventionen fix einkompiliert sind, die man nur beim Bauen des Pakets noch hätte anpassen können. So können die Dateisystem-Snapshots beispielsweise nur unterhalb von /ostree/deploy/ ausgecheckt werden. Signaturschlüssel müssen zwingend in einem Verzeichnis unterhalb von /usr/share hinterlegt werden, obwohl /var/lib wohl ein angemessener Ort für solche Dinge wäre. ostree-Repositories müssen unter /ostree/repo angelegt werden. Und so geht es weiter: Alles muss in fix definierten Verzeichnissen abgelegt werden was nicht angepasst werden kann. Außerdem widersprechen die meisten der Verzeichnisse dem Linux FHS (Filesystem Hierarchy Standard). Alle Verzeichnisse sind nur für privilegierte User zugänglich, weshalb ostree für normale User komplett unbrauchbar wird. Des weiteren kommt ostree trotz der oben beschriebenen grundsätzlichen Simplizität mit nicht weniger als 40 man-pages daher, welche das "einfache" System beschreiben. Obwohl ostree keinerlei Abhängigkeit von systemd oder udev zu haben scheint, scheint es mir sehr viel vom "Geiste systemds" mit zu bringen, und macht daher einen negativen, aufgeblähten und überfrachteten Eindruck auf mich. Allerdings täuscht dies; es hat tatsächlich nur 1,2 MB Installationsumfang und besteht aus lediglich zwei Binaries und einer Shared Library. Die man-pages Dokumentieren allesamt nur unterschiedliche Kommandos desselben Tools. Am Problem der unveränderbaren fix einkompilierten Pfade die einem in Grunde völlig sinnlos aufgedrängt werden ändert das allerdings auch nichts.
outguess-1:0.2.2-5/utils/raspbian: Kann ein oder zwei Nachrichten durch Manpipulation von niedrigwertigsten Bits von Bildformaten speichern oder auslesen. Dies erlaubt es eine Fake-Nachricht sowie eine echte Nachricht in derselben Datei zu speichern, und bei Zwang nur den Schlüssel für die Fake-Nachricht heraus zu geben. Unterstützt werden PPM, PNM und JPEG. Da man die ersten beiden Formate in jedes andere verlustfreie umwandeln kann, sind indirekt auch PNG, GIF etc. unterstützt. Anders als steghide scheint das Programm JPEG-Bilder neu zu komprimieren, da man eine JPEG-Qualität angeben muss bzw. kann. Dafür kann man bei outguess den Seed für den Zufallsgenerator angeben welcher die Bits auswählt die manipuliert werden, während steghide das "irgendwie" macht. Ansonsten scheint mir die Bedienung von steghide deutlich einfacher zu sein, während outguess alle möglichen abstrusen Parameter hat die zum Teil nur rudimentär und nicht wirklich verständlich erklärt werden.
oxine-0.7.1-r1/media-video/gentoo {media-player}: Ein weiteres xine-lib Front-End, das sich grundsätzlich in Form eines bildschirmfüllenden Menüs presentiert, ähnlich wie das OSD eines Fernsehers/DVD-Players. Vielleicht toll... aber ich war nicht in der Lage mit der Tastatur oder Maus auch nur irgend etwas mit diesem Ding zu tun. Dennoch mag dieses Ding möglicherweise auf PDAs oder Smartphones als Media-Player sinnvoll sein, wo Display-Platz beschränkt ist.
p7zip-full-16.02+dfsg-6/utils/debian {compression}: Eine Weiterenwicklung des berühmten "Zip"-Archivierungsprogramms. Stellt die Utilities "7z" bzw. "7zip" zur Verfügung, welches ein eigenes Dateiformat (*.7z) mitbringt, aber auch herkömmliche *.zip-Dateien lesen und erzeugen kann. Neben diesen beiden Archiv-Formaten kann es überdies auch noch mit den folgenden weiteren Archivformaten arbeiten: *.gz, *.bz2, *.xz, *.wim. Weiters kann es noch die viele andere Dateiformate lesen bzw. ihren Inhalt auflisten und Dateien daraus extrahieren. Hier eine insgesamte Liste, wobei nur die anfangs erwähnten Dateiformate auch erzeugt bzw. geschrieben werden können. Die zusätzlichen nur hier genannten Formate können lediglich gelesen werden. In Klammern sind für jedes Archivformat die von 7z unterstützten bzw. damit üblicherweise verbundenen Dateinamen-Erweiterungen angegeben: 7z (*.7z), BZIP2 (*.bz2, *.bzip2, *.tbz2, *.tbz), GZIP (*.gz, *.gzip, *.tgz), TAR (*.tar), WIM (*.wim, *.swm), XZ (*.xz, *.txz), ZIP (*.zip, *.zipx, *.jar, *.xpi, *.odt, *.ods, *.docx, *.xlsx, *.epub), APM (*.apm), AR (*.ar, *.a, *.deb, *.lib), ARJ (*.arj), CAB (*.cab), CHM (*.chm, *.chw, *.chi, *.chq), COMPOUND (*.msi, *.msp, *.doc, *.xls, *.ppt), CPIO (*.cpio), CramFS (*.cramfs), DMG (*.dmg), Ext (*.ext, *.ext2, *.ext3, *.ext4, *.img), FAT (*.fat, *.img), HFS (*.hfs, *.hfsx), HXS (*.hxs, *.hxi, *.hxr, *.hxq, *.hxw, *.lit), iHEX (*.ihex), ISO (*.iso, *.img), LZH (*.lzh, *.lha), LZMA (*.lzma), MBR (*.mbr), MsLZ (*.mslz), Mub (*.mub), NSIS (*.nsis), NTFS (*.ntfs, *.img), MBR (*.mbr), RAR (*.rar, *.r00 - nur mit externem zusätzlichem Plugin unterstützt), RPM (*.rpm), PPMD (*.ppmd), QCOW2 (*.qcow, *.qcow2, *.qcow2c), SPLIT (*.001, *.002, *....), SquashFS (*.squashfs), UDF (*.udf, *.iso, *.img), UEFIc (*.scap), UEFIs (*.uefif), VDI (*.vdi), VHD (*.vhd), VMDK (*.vmdk), WIM (*.wim, *.esd), XAR (*.xar, *.pkg), Z (*.z, *.taz). Die meisten (alle?) Komprimierungsmethoden welche diese Archivformate kennen kann es überdies im eigenen *.7z Archivformat einsetzen (standardmäßig wird hierbei das Komprimierungsverfahren von *.xz-Dateien verwendet). 7z unterstützt zahlreiche Optionen zum Fein-Tuning der Komprimierungs-Algorithmen. Es sind auch viele Optionen zur Unterstützung von Spezialitäten diverser Window-Dateisysteme vorhanden, wie Lange Dateinamen unter VFAT, NTFS Security-Identifiers, NTFS Alternate Date Steams und dergleichen. Zum Ausgleich kann es unter UNIX nicht einmal Benutzer und Gruppe des Dateibesitzers mitspeichern. Ebensowenig erkennt es symbolische oder harte Verknüpfungen (im ersten Fall speichert es das Ziel des Symlinks als Inhalt einer normalen Datei, im zweiten Fall erstellt es einfach mehrere Kopien desselben Dateiinhalts im Archiv). Von ACLs, Extended Attributes oder Sparseness in Dateien ganz zu schweigen. Immerhin kann es wenigstens die normalen UNIX-Zugriffsrechte mitspeichern. Für komplette Dateisystem-Backups ist es aber aufgrund dieser Beschränkungen dennoch nicht zu gebrauchen. Nicht alle Archivformate unterstützen dabei alle Möglichkeiten. Die besonders NTFS-affinen Features wie Alternate Data Streams werden beispielsweise nur bei der Nutzung des *.wim-Archivformats unterstützt. Eine Besonderheit von 7z im Zusammenhang mit dem *.zip-Dateiformat ist es, dass es dabei nicht nur wie das "zip"-Utility den kryptografisch sehr schwachen und unsicheren Original-Verschlüsselungsalgorithmus unterstützt, sondern darüber hinaus auch noch AES-Verschlüsselung mit 128, 192 und 256 Bit Schlüsselstärke. Das originale ZIP unterstützt diese zusätzlichen Methoden zwar nicht, aber zahlreiche Archiv-Browser bzw. grafische Archivbearbeitungsprogramme unterstützen sie. Als Nebenfunktion kann 7z überdies noch Hash- und Prüfsummenfunktionen für normale Dateien (also keine Archivinhalte) errechnen welche in der Kommandozeile angegeben wurden. Die folgenden Verfahren werden dabei momentan (2021) unterstützt: CRC-32, CRC-64, SHA-1, SHA2-256, BLAKE2sp. Die Vorgabemethode ist dabei CRC-32. Das 7z-Dateiformat kann ähnlich wie *.zip, aber anders als *.gz und viele weitere Kompressionsformate, mehrere Dateien und Unterverzeichnisse speichern. Jede Datei kann dabei bei Bedarf mit unterschiedlichen Kompressionsalgorithmen komprimiert werden, inklusive der Option überhaupt nicht komprimiert zu werden. Ebenso können einzelne Dateien verschlüsselt werden, und diese wiederum mit (bei Bedarf) unterschiedlichen Passwörtern. 7z kann Archive in selbstextrahierende, ausführbare Programme konvertieren. Dabei kann sogar eine extrem simple Scriptsprache genutzt werden, um nach dem Entpacken Meldungen anzuzeigen und ein soeben entpacktes Installationsprogramm zu starten. Offensichtlich ist so etwas brandgefährlich im Hinblick auf Malware, aber es ist zumindest möglich. Dabei stehen verschiedene Module zur Auswahl, für die Konsole oder mit Fenster in einer grafischen Oberfläche. Letzteres scheint derzeit nur Microsoft Windows unterstützt zu werden, ob ersteres auch unter Linux ausführbar wäre ist unklar. Anders als das *.zip Format welches maximal 2 GB lange Dateien und Archive unterstützt, gibt es beim 7z-Format keine solchen Einschränkungen. Sowohl Dateien als auch Archive können beliebig lange werden, oder zumindest 64-Bit Dateigrößen erlangen. 7z erlaubt es einzelne Dateien sowohl von der Standareingabe zu lesen als auch dorthin zu schreiben; in beiden Fällen ist es möglich anzugeben welche Datei im Archiv dabei erstellt bzw. ausgelesen werden soll. Die von 7z in den Archiven gespeicherten Zeitangaben sind von den Archivformaten abhängig, das *.7z-Format speichert sie als UTC-Zeitstempel mit Sekundenauflösung. Das *.7z Format unterstützt darüber hinaus auch "solid" Archives, d.h. man kann auswählen ob die Dateien im Archiv unabhängig von einander gespeichert werden sollen, oder alle als ein einziger Komprimierungs-Datenstrom. Letzteres erzielt in der Regel deutlich stärkere Komprimierungsergebnisse, zumindest bei kleinen und zahlreichen enthaltenen Dateien. Dafür haben "solid" Archives allerdings den Nachteil dass man nicht mehr schnell einzelne Dateien extrahieren kann. Zwar ändert sich dabei nichts an den Kommandozeilenoptionen zum Extrahieren, jedoch muss intern das ganze Archiv dekomprimiert werden was bei großen Archiven zu deutlichen Verzögerungen bei der Extraktion führen kann. Die Komprimierungsfähigkeit von 7z kann zwar nicht ganz mit der von sehr spezialisierten Kompressoren wie lrzip oder lzma mithalten (teils auch nur aufgrund von höherem Metadaten-Overhead), aber es spielt in einer ähnlichen Liga wie das "xz"-Utility mit und erzeugt daher im allgemeinen auch sehr gut komprimierte Dateien. Insbesondere für *.pdf-Dateien hat es sich als effektivstes Archivierungsformat erwiesen. Aber auch allgemein machte es fast immer eine gute Figur, und wo es doch schlechter als andere Komprimierungs-Utiltities komprimiert dann ist der Größenunterschied meist nur ein geringer. Nachteilig ist die sehr mühselig zu findende Dokumentation, die zwar vorhanden ist aber auf zahlreiche HTML-Dateien verteilt, während die man-Page nur einen Teil der Optionen auflistet, und daher nicht einmal als Nachschlagewerk etwas taugt. Außerdem folgt das Programm nicht den UNIX-üblichen Konventionen wie Optionen und Parameter anzugeben sind, sondern verwendet seine eigenen. Das ist wohl zwar der Multi-Plattformunterstützung des Programms geschuldet, macht den Umgang damit deswegen aber nicht angenehmer.
pacman-10-17/games/debian {game}: Pac-Man using shitty, low-resolution graphics in a small window. The Pac-Man and the Ghosts also do not move smoothly, but rather jump from grid point to grid point as if it were a character-mode application (which it isn't). Controls also don't work smoothly... forget it.
pacman4console-1.2-2/games/debian {game}: If one thinks "pacman/games/debian" was bad, one has not seen this sucker. It "simulates" a character-mode pac-man with ridiculous inappropriate aspect ratio within a tall but narrow window which occupies most of the height, but only about 1/3rd of the screen width. Pac-Man and the ghosts are represented by ASCII-characters. Very funny. Maybe it would have been cute, if the aspect ratio were sane. But it isn't. Forget it also. As an unusual property for Pac-Man style games, this game features a level-editor (as a separate executable). Of course, this cannot save the game from its ridiculous remaining flaws.
paludis/sys-apps/gentoo: From [http://bugs.gentoo.org/show_bug.cgi?id=233301]: "Just for the record, I tried to use paludis for a while and although it has some interesting features especially in the way it can manage overlay settings, it lack some compatibility with portage (gcc-4.3 was the last issue I had before switching back to portage). It also does not support cross toolchains, as this part is unmaintained. It does not support digesting ebuilds, nor digest check (major security issue). It does not support binary packages (quickpkg) as its author knows more than anyone of how to manage complex network. I had to tweak it so I could simulate ebuild phases, as its author forces developer to use blackbox QA only. I also found that its hooks interface is inconsistence. It also does not support external USE flags specification, this is required for many packages that have stages. I had to tweak some more hooks in order to allow this. If an ebuild is changed in overlay it does not sync the changes, and always use the installed ebuild as a reference, causing a lot of issues with dependency change. Its query and user interface are much more complex than portage, it is very difficult for users (even my-self) to work with it. EAPI should also include the user interface. And above all, it looks like it has a single know-all do-all maintainer that maybe cooperate with exherbo developers but I could not see a cooperation with anyone else. There are more issues, I am back in portage now."
pandoc-1.9.4.2-2/text/debian {text-formatting}{PDF}: Ein in Haskell geschriebener (was man an 35 MB Installationsumfang bemerkt) Konverter zwischen verschiedenen Text-Markup-Sprachen bzw. -formaten. Eingabeformate: markdown und eine Untermenge von reStructuredText, HTML, LaTeX und DocBook XML. Ausgabeformate: Reintext, markdown, reStructuredText, XHTML, HTML 5, LaTeX, ConTeXt, RTF, DocBook, XML, OpenDocument XML, ODT, Word docx, GNU Texinfo, MediaWiki markup, EPUB, Textile, groff man pages, Emacs Org-Mode, AsciiDoc, Slidy, Slideous, DZSlides, or S5 HTML slide shows. Wenn LaTeX installiert wird kann es auch PDF erzeugen. Das Tool kann daher auch als (fetter) Ersatz für markdown verwendet werden, und unterstützt dabei (abschaltbare) Erweiterungen dieser Auszeichnungssprache die das Original nicht beherrscht. Da asciidoc auch DocBook-Ausgabe generieren kann, besteht durch pandoc eine Umwandlungsmöglichkeit zwischen markdown und asciidoc.
paperwork-0.2.2/app-text/gentoo {PDF}: Eine Art in Python geschriebenes Personal CMS für eingescannte Dokumente. Dazu benutzt es zum Scannen andere Linux-Tools welche einzelne Seiten oder auch von einem automatischen Dokumenteneinzug einscannen können. Kann auch bereits vorhandene Bilddateien und mehrseitige PDF-Dokumente importieren. Die importierten Dokumente werden mittels OCR erkannt und Volltext-indiziert. Dadurch kann auch die Drehung (in 90 Grad Schritten) erkannt und korrigiert werden kann. Für die OCR wird Tesseract und pyocr verwendet, für den Volltextindex Woosh. Levenshtein wird für die fehlertolerante Suche benutzt. Die Darstellung basiert hierarchisch in 3 Ebenen: Die erste Seite des Dokuments verkleinert, eine verkleinerte Ansicht aller Seiten im Dokument, die Seitenansicht der gewählten Seite. Man kann jedem Dokument beliebige viele selbst vergebene Schlagwörter (samt individueller Farbe) zuweisen. Alle bekannten Schlagwörter werden immer in einer linearen Liste angezeigt und können bei den Dokumenten angekreuzt werden. Mit anderen Worten: Nur für überschaubare Mengen an Schlagworten geeignet. Danach kann man in einem Textfeld eine Suche nach Schlagwort, (OCR-erkanntes) Text-Inhaltswort oder Datumsbereich ausführen, wobei Operatoren wie implizites UND, ODER und NOT verfügbar sind. Man braucht dabei keine kompletten Worte eingeben; Wortanfänge reichen auch. Außerdem gibt es angeblich eine Wortergänzung per Kombinationsfeld-Eingabe. Die Anzeige der Dokumente wird dann auf die zutreffende Untermenge gefiltert. Es gibt auch eine Druckfunktion. Grundsätzlich wäre das Programm vielleicht nicht so schlecht, wenn es nicht folgende Probleme hätte: Als erstes funktioniert die OCR-Erkennung so gut wie nicht. Oder ist es der Volltext-Index? Jedenfalls fand es nur Schlagworte. Auch die anderen Programmfunktionen tun oft nicht was sie sollten. Wirkt noch sehr nach Alpha-Qualität. Zweitens legt das Programm seine Dateien extrem primitiv an: In einem Arbeitsordner wird für jedes Dokument ein Unververzeichnis angelegt, welches eine Kopie des Dokuments sowie Thumbnail-Dateien für jede einzelne Seite des Dokuments enthält. Schlagwörter werden ebenfalls in einzelnen Textdateien abgelegt. Von einer Datenbank ist zumindest dort nichts zu sehen, obgleich es irgendwo wohl eine geben wird. Auf jeden Fall eine recht platzverschwendende und ineffiziente Methode um viele Dokumente auf diese Weise zu verwalten. Es ist wohl einfacher die PDF-Dokumente direkt mit OCR-Text zu ergänzen und dann von einer lokalen Volltextsuchmaschine indizieren zu lassen. Nur auf die Schlagwörter und das spezialisierte (aber nicht übermäßig mächtige) GUI von Paperwork muss man auf diese Weise natürlich verzichten. Vielleicht wird das Programm in einer späteren Version noch einmal nützlich sein - derzeit ist die Qualität noch zu gering.
par-1.53.0-2/text/raspbian {text-formatting}: Sehr schlanker, in C geschriebener Re-Formatter für hart (echte anstatt synthetische "weiche" Zeilenvorschübe) umgebrochenen Text. Er kann allerdings auch weich bzw. nicht umgebrochenen Text in umgebrochenen umwandeln. Er funktioniert als typischer UNIX Filter. Es können Prä- und Postfixe wie "/* " und " */" definiert werden, welche während der Reformatierung temporär entfernt werden. Dadurch kann man auch Kommentare in Programmiersprachen reformatieren. Ein riesiger Nachteil ist dass er mit UNICODE oder UTF-8 nicht zurecht kommt. Zwar hat er kein Problem auch solche Texte zu reformatieren, aber die Zeilenlänge wird dann nicht korrekt beachtet. Daher nur für ASCII-Texte zu empfehlen.
parallel-20140622/sys-process/gentoo: GNU parallel ist ein in Perl verfasstes Script um ein Kommando parallel mit einem Argument aus einer Liste von Argumenten auszführen. Klingt grundsätzlich sinnvoll, leidet jedoch eindeutig an Featuritis und scheint so unfasslich komplex in der Bedienung zu sein welche an xargs angelehnt ist, dass es einfacher sein dürfte sich ein eigenes Tool zu programmieren als die längliche Anleitung und die beiliegenden Tutorials durchzuackern.
parcellite-1.1.9-1/misc/devuan {clipboard manager}{GTK+}: Ein schlanker in C und GTK+ verfasster Clipboard-Manager. Ressourcenbedarf sind 38 MB virtuell und 19 MB tatsächlicher RAM-Verbrauch (RSS). (Direkt nach dem Start benötigt er sogar noch weniger, doch dies steigt rasch an und pendelt sich bei den genannten Werten ein.) Er benötigt auch keinen DBUS-Session-Daemon. Somit ist er mit voll aktivierten Features minimal schlanker als clipit, selbst wenn dieses in den Offline-Modus geschaltet wurde. Parcellite bietet ein Traybar-Icon und grafische Konfiguration. Er hat allerdings kein Plug-in-System. Es bietet einen Traybar-Icon mit grafischer Konfiguration samit Menüpunkt zum Beenden von parcellite. Man kann separat auswählen, ob das Clipboard und die primäre Maus-Selektion vom Programm kontrolliert werden sollen, sowie ob die beiden Quellen mit einander synchronisiert werden sollen. In beiden Fällen werden jedoch Daten von beiden Quellen in denselben Verlauf aufgenommen werden, und wenn man einen Eintrag des Verlaufs auswählt, wird dieser in beide Quellen (dann wohl eher Senken) geschrieben. Es gibt eine Option, ob der Verlauf beim Beenden des Programms gespeichert werden soll. (Und anders als bei diodon-1.0.3 wird dies auch beherzigt.) Unabhängig davon gibt es einen Menüpunkt zum expliziten Speichern des Verlaufs in eine Datei (mit Dateiauswahl-Dialog). parcellite unterstüzt ähnlich wie clipit mehrere redefinierbare (sowie deaktiverbare) Hotkeys für bestimmte Funktionen rund um den Verlauf, sowie benutzerdefinierbare "Aktionen". Ein ungwöhnliches Feature ist, dass man das Pop-Up-Menü welches als Reaktion auf den Hotkey zur Verlaufs-Auswahl erscheint absolut positionieren kann (per Default erscheint es immer unter dem Maus-Cursor). Es gibt ein dubioses "Multiuser"-Feature, das man aber jedenfalls ein- oder ausschalten kann. Parcellite unterscheidet zwischen einem "persistenten" Verlauf welcher (soweit dies aktiviert wurde) abgespeichert wird, und einem normalen der nie abgespeichert wird. Man kann dann übers Kontextmenü Einträge vom normalen Verlauf in den persistenten Verschieben (und umgekehrt). So kann man vom Abspeichern einzelner Einträge Gebrauch machen, ohne deswegen Gefahr zu laufen dass Passworte und dergleichen unerwünscht ebenfalls mitgespeichert werden. Parcellite hat einen Editor, um den aktuellen Inhalt der Zwischenablage zu bearbeiten. Es beherrscht auch inkrementelle Suche in seinem Verlauf. Man kann die Größe des Verlaufs nicht nur bezüglich der Anzahl der Einträge beschränken, sondern auch den maximalen Speicherbedarf in kB festlegen welchen ein einzelner Eintrag sowie die ganze Verlaufs-Liste verwenden darf. Es gibt auch 3 Optionen für automatisches Einfügen wenn man einen Eintrag aus dem Verlauf wählt: Abschalten, mittels Tastatur, oder mittels Maus. Allerdings wird dazu ein zusätzliches externes Paket "xdotool" installiert sein, damit dies funktioniert. (Bei clipit funktionierte das automatische Einfügen auch ohne zusätzliche Pakete auf Anhieb.) Weiters hat parcellite einen Modus, um einen Verlaufseintrag durch simulierte Tastendrücke einzufügen, anstatt mittels Clipboard oder Maus-Auswahl. Das kann bei Non-Standard GUI-Elementen nützlich sein, die weder Maus-Selection noch Clipboard unterstützen, aber sehr wohl Tastatureingaben zulassen. Leider kann man diese Funktion nur global für den Verlauf in den Settings einstellen und nicht bei Bedarf einzeln aufrufen. Auch Parcellite hat genau wie clipit einen Modus, wo er nur URLs in den Verlauf aufnimmt. Von allen Programmen hat parcellite die meisten Einstellungsmöglichkeiten für Details seiner Operation, etwa für Whitespace-Trimming oder das Anzeigen von Steuerzeichen. Ein Nachteil ist jedoch, dass viele der Funktionen des Programms entweder nicht zu funktionieren scheinen, oder dies zumindest nicht so tun wie man es erwarten würde. So konnte ich weder die benutzerdefinierten Aktionen dazu bringen irgend etwas sinnvolles zu tun, noch schien die persistente History korrekt zu funktionieren. Außerdem hat Parcellite weder einen Offline-Modus wie clipit, noch kann man wie bei glipper die Größe des Verlaufs auf 0 setzen, oder eine RegEx "." als Verlaufs-Exklusion eintragen, um denselben Effekt zu erreichen. Es ist somit nicht möglich, den Verlauf gänzlich abzuschalten. Selbst wenn dieser nicht abgespeichert wird, birgt dies die Gefahr dass man vor längerer Zeit über die Zwischenablage kopierte Passworte im Verlauf sieht, während jemand anderer einem später über die Schulter blickt. Es bleibt als Fazit dass Parcellite mächtiger wäre als clipit obwohl es minimal geringeren Ressourcenbedarf hat, dies jedoch daran scheitert dass einiges in Parcellite schlicht nicht zu funktionieren scheint. Parcellite fehlt der Offline-Modus von clipit. Und im Offline-Modus benötigt clipit dann noch weniger Ressourcen als parcellite.
pari-2.3.4-r1/sci-mathematics/gentoo {symbolic calculation}{math}: Ein sicherlich supertolles System für den Zahlentheoretiker. In C geschrieben, daher sehr schnell. Cross-Platform. Dank einer Library auch Einbau in eigene Applikationen möglich. Aber leider GPL - daher nur rein privat oder in OpenSource-Programmen verwendbar. Exakte Arithmetik oder beliebig genaue unexakte Arithmetik. Primzahlen, komplexe Zahlen, rationale Zahlen, Galois-Felder, Serienentwicklungen wie Taylor-Expansions - alles vorhanden. Besonders tolle Module für elliptische Kurven samt zugehörigen Archiven von modularen Polynomen < 500, welche (falls gottlob nur optional installiert) läppische 90 Megabyte Platz belegen. Gleichungssysteme, Vektoren, Matrizen, Listen, Mengen, Polynome, Summen, Produkte, Gruppentheorie - ebenfalls samt unzähligen Unterstützungs-Funktionen im Überfluss vorhanden. Eine simple Programmiersprache mit Funktionen, Schleifenkonstrukten usw. für eigene Scripte fehlt natürlich auch nicht. Dazu ein readline- und Tab-Completion-fähiges Command Line Interface. Und eine sehr gute und ausführliche Dokumentation im TeX, dvi und PDF-Format inklusive Tutorial; alles brav mit Index, Inhaltsverzeichnis und hypergelinkt. Kurzreferenz zum Ausdrucken. Außerdem ist eine Kurzhilfe für jede Funktion direkt im Programm eigebaut, und die zuvor erwähnte Voll-Hilfe für jedes Kommando lässt sich aus der Shell heraus gezielt starten. Eigentlich daher absolut großartig. Allerdings fehlen viele Funktionen für andere Bereiche die man aus CAS-Systemen gewohnt ist: So gibt es etwa keinen Support für symbolisches Integrieren oder Differenzieren; lediglich eine numerische Integration wird unterstützt. Die dafür mit beliebiger Genauigkeit. Denn auch "unexakte" Arithmetik wird in PARI nicht etwa mit der FPU berechnet, sondern ebenfalls mit den mehrfachgenauen Arithmetik-Routinen. Nur ist der Zeitaufaufwand abschätzbarer da immer nur bis zu einer gewissen Genauigkeit gerechnet wird. Bool'sche Algebra ist eben so ein Fremdwort für PARI. Oder das symbolische Lösen von Gleichungen (numerisches Lösen beherrscht es). Dafür kann es aber problemlos gegebene Ausdrücke vereinfachen, solange dazu keine wie der genannten Fähigkeiten erforderlich sind die PARI eben nicht beherrscht. Weiters gibt es noch diverse Möglichkeiten des Plottings. Fazit: Ein wirklich schön gelungenes Paket, das nur kein Normalsterblicher vermutlich jemals für irgend etwas brauchen können wird das er mit allgemeineren Programmen wie Maxima oder Axiom nicht eben so gut könnte. Ein Vorteil könnte allenfalls die Geschwindigkeit sein, denn PARI ist da in C geschrieben bei zeitintensiven Rechenaufgaben vermutlich um Welten schneller als dasselbe in LISP (in dem Maxima und Axiom geschrieben sind). Große Gleichungssysteme numerisch beliebig genau lösen wird PARI daher wohl deutlich schneller können; das Endergebnis wird aber dasselbe sein. Daher werde ich mir PARI wieder deinstallieren, obwohl ich eigentlich einen sehr positiven Eindruck davon gewonnen habe. Aber ich bin eben kein Zahlentheoretiker und kann daher allgemeine Paket wie Qalculate!, Axiom oder Maxima weiter besser gebrauchen.
parley-4.11.5/kde-base/gentoo: Ein Vokabel-Lernprogramm für KDE. Es können aber nicht nur Vokabel damit geübt werden, sondern auch alles andere was Auswendiglernen (oder korrektes ableiten) von Begriffen erfordert. Das Programm beherrscht zu diesem Zweck mehrere Übungsarten, von simpler Texteingabe auf eine Frage über Multiple-Choice-Tests bis hin zu Frage-Antwort-Karten die abwechselnd angezeigt werden und wo man selbst eingeben muss ob man es wusste. Es gibt auch einige Spezialmodi wie Konjugationen die nur bei bestimmten Test-Typen (etwa echten Vokabeln) Sinn machen. Das Programm bietet sowohl einen Editor zum Erstellen und Bearbeiten solcher Tests, als auch dem eigentlichen Übungsmodul zur Benutzung der Test-Dateien. Ein Vorteil ist dass es eine Download-Funktion für bereits fertige Inhalte gibt, mit der man schnell Vokabelsets bzw. Test-Sets zur sofortigen Übung herunterladen kann. Jeder Test kann zudem in Lektionen unterteilt werden, die man separat zum Üben an- oder abwählen kann.
parole-0.2.0.2-r1/media-video/gentoo {media-player}{audio}{music}: Ein ziemlich simpler Media-Player für Xfce4. Kann Videos und Audio-Dateien abspielen. Er bedient sich dazu des gstreamer-Frameworks und kann daher alles abspielen für das dieses Support bietet. Das GUI ist ebenfalls denkbar simpel: Links das Video-Fenster, rechts die Playliste, unten die üblichen Vor-, Zurück-, Stop- und Play/Pause-Tasten sowie ein Lautstärkeregler. Die Playliste hat Buttons zum Ändern der Reihenfolge der Einträge, zum Hinzufügen und Entfernen von Songs sowie zum Speichern der Playliste. Sonst nichts. Keine Shuffle-Funktion. Kein Umordnen der Playlist direkt durch Ziehen der Einträge (Drag und Drop von außerhalb der Applikation geht hingegen, fügt jedoch immer am Ende der Playlist an und spielt dann sofort den ersten hinzugefügten Song/Video). Allerdings gibt es im Menü eine allgemeine Shuffle-Funktion und Playlist-Wiederholungsfunktion. Die Statuszeile zeigt den gespielten Song, seine verstrichende und verbleibende Zeit an. Die Playliste lässt sich verstecken, damit man mehr Platz für Videos hat. Es gibt auch einen Vollbild-Mode. Das Seitenverhältnis von Videos lässt sich entweder fix, frei oder nach den Angaben in der Videodatei setzen. Für die Video-Wiedergabe lässt sich der Bildschirmschoner deaktivieren, auch der Mauscursor wird nach einigen Sekunden versteckt damit er nicht stört. Allerdings funktioniert dies nur wenn in den Vollbildmodus wechselt. Sobald man dort mit der Maus den Positionierungsbalken einblendet, besteht die einzige Möglichkeit diesen und den Mauscursor wieder verschwinden zu lassen scheinbar darin den Vollbildmodus zu verlassen und danach wieder zu betreten. Etwas umständlich, aber kein ernsthaftes Problem. Optisch sieht der Player freundlich und aufgeräumt aus; er passt wie nicht anders zu erwarten gut zu Xfce. Es gibt einige standardmäßig mitgelieferte Plugins für harmlose Funktionen wie die Anzeige einiger Felder aus den ID3-Tags. Auch eine simple Visualisierung ist vorhanden, die aber wegen der geringen Auflösung so erbärmlich aussieht dass man sie am besten gleich wieder abdreht. (Auf dem Display eines älteren Smartphones mag es vielleicht gut aussehen.) Alles in allem ein wirklich einfach zu bedienender Video und Audio-Player, der zwar nicht die Features vom Amarok oder VLC bietet, dafür aber alles was man normalerweise braucht. Das einzig essenzielle das fehlt ist eine Medienbibliothek mit entsprechenden Such- und Filterfunktionen. Solange einem die simple Playliste reicht, ist parole aber ein ausgezeichnetes und auch sehr kurzes Programm - nur 1 MB (aber natürlich macht es von den Xfce-Libraries fürs GUI Gebrauch und erfordert das Gstreamer-Framework). Wesentlich besser als xine-ui geeignet, um als Default-Anwendung mit Audio-Dateien verknüpft zu werden. Für Videos im Grunde auch, aber Parole unterstützt keine Untertitel und Kapitelnavigation und ähnliche Spezialfunktionen so dass man hier zumindest für Spielfilme doch besser zu VLC oder Mplayer greift. Für Musikvideos oder simple AVI-Dateien aber völlig ausreichend. Parole startet auch sehr schnell; allerdings tun das auch VLC und Mplayer.
parsec47-0.2.dfsg1-9/games/debian {game}: Ein abstrakter vorwiegend (aber nicht ausschließlich, einige Gegner haben durchaus eine Farbe) monochromer 3D Gitter-Vektorgrafik-Shooter. Schnell und super und wilder Sound und alles. Nur: Leider spielt sich alles in einem ziemlich kleinen Fenster ab, welches dafür vor lauter Action geradezu überquillt. Obwohl: Das kleine Fenster lässt sich sich eigentlich sehr wohl vergrößern. Aber leider wird dadurch der ursprüngliche Fensterinhalt lediglich hochskaliert, wordurch die Pixel klotzig werden und durchs Glätten der Upsizing-Filter auch noch matschig-verwaschen. Praktisch daher doch nicht so toll wie es vielleicht sein könnte wenn die Grafik besser skalieren würde. Um so ärgerlicher da es sich dabei eigentlich ohnehin um ein Vektorgrafikspiel handelt. Ein anderes Problem ist dass es viel zu schwer ist. Man überlebt selten länger als ein paar Minuten. Zumindest nicht als Anfänger. Von langsamer Steigerung des Schwierigkeitsgrades scheint der Autor jedenfalls nicht viel zu halten.
parsewiki-0.4.3-2/text/devuan {text-formatting}: Entgegen dem Namen ist dies nicht wirklich ein Wiki, sondern eher ein Textprozessor ähnlich wie "asciidoc" (aber weitaus simplmer) welcher HTML-Seiten aus einer Textdatei ableiten kann, aus denen man dann ein Wiki aufbauen kann. In Perl geschrieben. Winzig: 78,85 kB installiert. Es ist unklar und zumindest aus der schwachen Anleitung nicht ersichtlich gibt, ob irgend eine Framework vorhanden ist um daraus wirklich ein Wiki-System zu machen. Scheint alles eher nebulös und wenig dokumentiert zu sein. Noch dazu scheint die Software im Beta-Stadium zu sein.
partimage-0.6.9-10/admin/raspbian {backup}: Kann Backups von Blockgeräten erstellen welche Dateisysteme enthalten, wobei unbenutzer Platz in den Dateisystemen nicht tatsächlich mitkopiert wird. Derzeit unterstützte Dateisysteme am Blockgerät: Ext 2/3, ReiserFS, FAT16/32, HPFS, JFS, XFS, UFS, HFS (beta) NTFS (experimental). Natürlich kann es Blockgeräte auch komplett kopieren, aber das können viele Programme ebenso.
pass-1.7.3-2/admin/debian: Ein Passwort-Manager für die Kommandozeile. (Nennt sich im Original "password-store".) Verwaltet Passwortdateien in einer Verzeichnisstruktur, und stellt Befehle zur Verfügung um neue zu erstellen und vorhandene zu manipulieren. Es gibt auch Befehle um ein Passwort ins Clipboard zu kopieren oder als QR-Code anzuzeigen. Alle Passwortdateien werden dabei mit GnuPG asymmetrisch verschlüsselt. Dazu muss man einen (zuvor erzeugten) privaten PGP Key auswählen, der als "Besitzer" der Passwortdateien fungiert. Dabei wird der GPG-Agent benutzt um zu verhindern, dass man ständig das Schlüssel-Passwort neu eintippen muss. Man kann überdies auch alle Schlüssel signieren lassen, so dass ein möglicher unbemerkter Austausch der Schlüsseldateien verhindert wird. Die Verzeichnisstruktur mit den Schlüsseln kann auch mit git versioniert werden; dazu stehen eigene entsprechende Befehle bereit. Das ganze ist als Bash-Scripte implementiert und bringt auch geeignete Bash-Completions mit welche man benutzen kann. Es werden weiters Integrations-Scripte mitgeliefert, damit man z. B. auch mittels "dmenu" auf die Passworte zugreifen kann. Grundsätzlich scheint die Architektur vernünftig zu sein, wenn man sich nicht daran stört dass neue Passworte aus /dev/urandom generiert werden und man lediglich auf die wenigen unterstützten Verschlüsselungsalgorithmen von GnuPG begrenzt ist. Ein weiteres Problem ist die asymmetrische Verschlüsselung, bedeutet es doch dass alle Passworte geknackt werden können sobald ausreichend dimensionierte Quantencomputer zur Verfügung stehen. Das wäre bei symmetrischer Verschlüsselung mit 256 Bit nicht ebenso gewesen.
pcl/dev-libs/gentoo: Portable Coroutinen in C! Genau das, was ich schon lange suchte. Die de fakto einzige Möglichkeit (neben Threads), Consumer/Producer-Szenarien ohne Zustandsautomaten zu implementieren. Generator-Funktionen wie in Python - allerdings mächtiger: Pythons Generatoren sind keine vollwertigen Coroutinen - diese hier aber schon! Basiert unter Linux auf der getcontext()-Familie, kann aber auch mittels setjmp()/longjmp() auskommen. Angeblich portabel. Simples API - doch vollkommen ausreichend. Leider ist der Aufruf-Overhead einer Coroutine doch um einiges höher als ein simpler Funktionsaufruf. Dennoch - unter C wird man nichts besseres finden; alle anderen mir bekannten Lösungen haben einen noch höheren Overhead.
pcmanfm-1.2.3/x11-misc/gentoo {file manager}{GTK+}: Ein netter und minimalistischer File-Manager nach der "Windows-Explorer"-Philosophie. Einfach zu bedienen, gut für Anfänger geeignet. Nur 500 KB Installationsumfang (freilich ohne die von Programm verwendeten GTK+ Libraries einzurechnen). Implementiert den freedesktop.org-Papierkorb und erlaubt dessen gezielte Umgehung. Den Nachteil der Vorgängerversionen dass er immer alles und jedes dessen er habhaft wird automatisch mountet, wurde dieser Version gottlob ausgetrieben - man kann sich nun aussuchen ob man das haben will. Der Schirm besteht aus einer Leiste links in der oben verfügbare Mountpoints und unten Lesezeichen der GTK-"File"-Dialoge dargestellt werden. Der Rest des Fensters wird vom aktuellen Verzeichnisinhalt ausgefüllt. Es gibt zwar keine anderen grundlegenden Darstellungsvarianten wie etwa einen Directory-Tree. Allerdings kann man beliebig viele Tabs erzeugen welche unterschiedliche Verzeichnisse darstellen und mittels Cut/Copy/Paste Dateien zwischen diesen hin- und herkopieren oder verschieben. Auch die Reihenfolge der Tabs selbst lässt sich mit der Maus verschieben. Es wird für jeden Tab die Gesamtkapazität des Dateisystems und der noch freie Platz angezeigt. Jeder Tab hat seine eigene History mit "Vor", "Zurück" oder Drop-Down-Auswahl. Zumindest ab Version 1.2.3 gibt es zudem einen "Dual-Fenster-Modus" wo 2 Verzeichnisse nebeneinander in Fensterhälften dargestellt werden; die beiden Fensterhälften korrespondieren dann zudem mit 2 der dargestellten Tabs. Das Einlesen auch großer Verzeichnisse geht angenehm schnell. Folgende Ansichten sind verfügbar: Symbolansicht (Große Symbole, Namen zentriert und ungekürzt aber brutal umgebrochen falls zu lang, Vertikalscroll), Miniatur-Vorschaubilder (identisch zur Symbolansicht, nur wesentlich größere Symbole), Listenansicht (kleine Symbole und rechts davon der ungekürzte Name, spaltenweise Anordnung mit Horizontalscroll) und Detailansicht (fix definierte Spalten Name, Dateityp, Größe, Änderungsdatum; Zeilenhintergrund in alternierenden Graustufen eingefärbt, Vertikalscroll). Das Programm kann in der Symbol- und "Miniatur-Vorschaubilder"-Anzeige auch Vorschaugrafiken statt Symbolen anzeigen. Die Extraktion der Vorschaubilder geschieht auch relativ schnell. Allerdings kann sie leider nur global über das Einstellungsmenü ein- oder abgeschaltet werden und nicht schnell per Bedarf umgeschaltet werden. Wenigstens gibt es eine Option, um Vorschaubilder auf lokale Dateien zu beschränken. Die Vorschauen scheinen auch nur intern bei Bedarf erzeugt zu werden; ich konnte keine erzeugten Cache-Dateien finden. Es ist wählbar ob Verzeichnisse immer zusammen am Anfang oder genau wie Dateien sortiert werden sollen. Dateien können nach Name, Änderungsdatum, Dateityp, Dateiendung oder Größe sortiert werden. Weiters kann das Ignorieren von Groß-/Kleinschreibung für die Sortierung festgelegt werden. Man kann die angezeigten Dateien in einem Tab mittels eines simplen Shell-Patterns filtern (Filterausdruck "*" zeigt wieder alles an). Zumal die Funktion über einen Keyboard Shortcut aufrufbar ist. Kaum zu glauben, wie nützlich dieses Feature in der Praxis ist! Und wie sehr es einem etwa bei SpaceFM abgeht der so etwas nicht beherrscht. Drag & Drop verschiebt; zusammen mit der Strg-Taste wird kopiert. Es gibt auch einen Modifier zum Symlinken, doch schien dieser nie etwas zu bewirken. Das Anlegen von Hard-Links wird offenbar gar nicht unterstützt. Aus unerfindlichen Gründen war im Kontextmenü der Datei-Eigenschaften das Gruppenfeld immer ausgegraut, so dass man die Gruppe nie ändern konnte. Die "Umbenennen"-Funktion arbeitet "in-place", d. h. direkt ein Cursor erscheint direkt im angezeigten Namenstext. Das hat sich in der Praxis als angenehmer erwiesen als eine explizites Dialogfenster. Überdies läßt sich konfigurieren, ob der Name dabei ohne die Dateierweiterung markiert werden soll wenn das Umbenennen startet. Auch das hat hohen Praxisnutzen. Das Programm unterstützt einen freedesktop.org kompatiblem Papierkorb und ist sehr stolz auf diese Errungenschaft. Man kann dessen Verwendung aber auch gänzlich (oder nur temporär mittels Umschalt-Taste beim Löschen) deaktivieren. Es gibt ein editierbares Textfeld wo das aktuelle Verzeichnis dargestellt wird. Verborgene Dateien können optional angezeigt werden. Wenn mehrere Dateien selektiert sind, wird deren Anzahl und Gesamtgröße angezeigt. Es gibt Tastenkürzel zum Selektieren aller Dateien und zum Invertieren der Auswahl. Man kann die Pfade der selektierten Dateien in die Zwischenablage kopieren lassen. Es gibt Menübefehle zum expliziten Kopieren oder Verschieben der selektierten Dateien in einen anderen Ordner, der über einen Auswahldialog abgefragt wird und eine History-Funktion der zuletzt benutzten Ordner bietet. Dateiverknüpfungen scheinen über die entsprechenden freedesktop.org-Methoden zu erfolgen. Das Programm hat keine eigenen Themes oder grafischen Darstellungsoptionen, dürfte aber die GTK-Themes mitverwenden. Mankos: Bei der Verwendung des "Dual-Fenster"-Modus ist die inaktive Fensterhälfte immer mit einem so dunklen Farbton "eingegraut", dass sie dadurch tatsächlich auffälliger wirkt als die aktive Fensterhälfte. Auch das Verhalten der Fensterhälften beim Tab-Wechsel ist völlig unintuitiv. Daher meide ich den Dual-Modus in der Praxis. Es gibt keinen Button zum Löschen des Inhalts der Adressleiste (um dort mit der Maus die X11-Selection einzufügen). Tastenkombinationen sind scheinbar fix zugeordnet, ebenso die "Werkzeuge" (Terminal oder Root-Shell im aktuellen Verzeichnis öffnen) oder die Spaltenanordnung und -auswahl in der Detailansicht (letztere kann man aber immerhin für einzelne Ordner definieren, wenn schon nicht als globale Vorgaben). Eigene Werkzeuge oder Menüeinträge lassen sich nicht definieren. Es gibt keine andere Möglichkeit sich Besitzer oder Zugriffsrechte von Dateien anzuzeigen als über das Kontextmenü, und selbst dort sind nur vereinfachte Darstellungen zu finden während Infos wie Sticky Bit, SUID-Bit usw. komplett unterschlagen werden. Das Programm startet zahlreiche Hintergrundprogramme (gvfs-Daemonen, menu-cached) welche es beim Beenden nicht ebenfalls beendet. Falls auch das optionale Paket "libfm-modules" installiert ist, bietet PCManFM (offenbar mit dessen Hilfe) auch einen mächtigen Suchdialog an, der sowohl nach Dateinamen, deren Inhalt, Typ oder Wertebereichen von Datum und Größe suchen kann. Inhalte und Namen können optional Groß-/Kleinschreibungs-sensitiv sowie mit RegExes gesucht werden. Pcmanfm hat mit Thunar das gemeingefährliche Verhalten gemein, die Dateierweiterung von bestimmten Dateitypen (zumindest von ".desktop-Dateien") zu verstecken, und dies lässt sich auch nicht abschalten. PcManFM besitzt keine Warteschlangen-Funktionalität, wenn mehrere Kopiervorgänge zur selben Zeit aktiv sind: Alle laufen parallel, es gibt für jeden laufenden Kopiervorgang ein Fortschrittsfenster. In diesem ist zwar ein Button "Pause", aber dieser scheint nichts zu tun, da auch "pausiert" Kopiervorgänge trotzdem weiter laufen.
pcmanfm-qt 0.9.0-1/community/archlinux {file manager}{Qt}: Die nächste Generation des PcManFM Dateimanagers. Wird vielleicht irgendwann einmal großartig werden; im Moment ist es nur ein erbärmlicher Abklatsch der früheren Version, der viele Dinge noch fehlen. In ein paar Jahren noch einmal ansehen, und bis dahin vergessen.
pd-0.42_p6/puredata-base/pd-overlay/gentoo {audio}{music}: Eine grafische Datenfluss-Programmiersprache zur Generierung von Sounds und Musik für Musiker. Klingt alles echt suptertoll; leider lässt es sich nicht übersetzen sondern verreckt mit mehreren Compiler/Linker-Errors. Vielleicht später einmal.
pdf2djvu-0.7.17-4+deb8u1/text/devuan {PDF}: Wandelt PDF-Dateien in das deutlich weniger stark verbreitete Konkurrenz-Format djvu um. Allerdings kann man, indem man eine PDF-Datei nach djvu umwandelt, danach djvu2hocr aus dem ocrodjvu-Paket verwenden um hOCR-Dateien aus dem PDF zu extrahieren.
pdf2html-1.4/app-text/gentoo {PDF}: Dieses Programm extrahiert nicht etwa den Textinhalt und Bilder aus PDF-Dokumenten um damit eine HTML-Seite zu erzeugen, wie man vielleicht glauben könnte. Sondern es erzeugt Bitmap-Repräsentationen aller Seiten im PDF-Dokument als PNG-Dateien (auch wenn es sich um reine Textseiten handelt), und erzeugt dann ein Gerüst aus HTML-Seiten zur Navigation, welche diese Bitmaps als Bilder anzeigen. Zur Umwandlung der PDF-Datei in PNG-Grafiken wird GhostScript verwendet. Aufgrund des deutlich höheren Speicherplatzverbrauchs von PNG-Dateien gegenüber von Text ist dieses Tool wohl nur in den wenigsten Fällen sinnvoll. Außerdem lassen sich die so erzeugten Bilder natürlich nicht nach Text durchsuchen, oder Text daraus markieren und heraus kopieren. Daher ist dieses Programm weitgehend sinnfrei; allenfalls im Falle sehr komplex formatierter PDFs bei denen eine Umwandlung in Text ohnehin illusorisch wäre mag es in Einzelfällen hilfreich sein.
pdf2htmlex-0.14.6+ds-3/text/debian {PDF}: Ein erstaunliches Programm, welches aus einer PDF-Datei exakt eine HTML-Datei erzeugt - wenn auch mit der ca. 4-fachen Dateigröße. Allerdings: Die HTML-Seite zeigt danach ein verblüffend treffendes Gegenstück der PDF-Datei an, und sogar das Inhaltsverzeichnis (soweit eines im PDF vorhanden war) wurde in Hyperlinks umgesetzt und kann zum Navigieren verwendet werden. Bilder und Seitenstruktur des PDFs bleiben ebenfalls erhalten! Dabei ist es aber nicht so dass etwa das ganze PDF zu Grafikseiten umgewandelt wurden - der Text ist nach wie vor enthalten, inklusive der Positionierungs-Anweisungen vom originalen Drucksatz. Auch benötigt das HTML-Dokument kein JavaScript (zumindest nicht grundsätzlich) und funktioniert sogar mit dem sehr minimalistischen "Dillo"-Browser. Faszinierend!
pdf2oo-20090715/app-text/gentoo {PDF}: Kann PDF-Dokumente angeblich in OpenOffice-Präsentationen umwandeln. Hat allerdings nicht funktioniert als ich es testete. Ist aber auch unerheblich, da LibreOffice inzwischen selbst ein Plugin-besitzt mit dem dies direkt von LibreOffice aus möglich ist (einfach mit installiertem Plug-In in Impress die PDF-Datei ganz normal öffnen). Daher ist pdf2oo obsolet, es sei denn man will LibreOffice nicht installieren. Aber dann hat man immer noch das Problem dass pdf2oo nicht mit jedem PDF-Dokument funktioniert.
pdfarranger-1.6.2-1/graphics/debian {PDF}: Eine GUI-Applikation zum manipulieren von PDF-Dokumenten auf Seitenebene. Es handelt sich offensichtlich um einen Klon, Fork oder Nachfolger von pdfshuffler. Die grundsätzlichen Features sind identisch mit pdfshuffler: Man kann mehrere PDF-Dateien mittels Drag and Drop zu einer einzelnen PDF-Datei zusammen führen, innerhalb der bearbeiteten PDF-Datei die Seitenreihenfolge ändern, Seiten löschen oder Seiten in 90-Grad-Schritten rotieren. Weiter können Seiten nicht-zerstörend zugeschnitten werden, d. h. der weggeschnittene Teil wird nur nicht angezeigt, bleibt jedoch erhalten. Leider ist das Zuschneiden nicht interaktiv sondern nur über einen Dialog möglich wo man Prozentwerte angeben muss - also sehr unkomfortabel. Darüber hinaus kann pdfarranger aber auch Seiten zwischen zwei verschiedenen PDF hin- und her verschieben, welche in zwei separaten laufenden Instanzen des Programms geöffnet sind. Das ist vor allem sehr nützlich bei Dateien mit vielen Seiten, wo man nicht mehr alle am Bildschirm sehen kann. So kann man die Seiten in einem PDF-Dokument gezielt umarrangieren, indem man sie in ein zunächst leeres Fenster einer 2. Instanz von pdfarranger verschiebt bis die originale Datei leer geworden ist. Dann schiebt man das nun richtig sortierte wieder zurück. Ein weiterer Vorteil von pdfarranger ist dass er die PDF-Dateien beim Abspeichern optimiert, so dass sie häufig selbst bei ansonsten unverändertem Inhalt (ein wenig) kleiner sind als vom Acrobat Distiller erzeugte Dateien. Weiters ist auch wichtig anzumerken dass pdfarranger nicht versucht, bereits vorhandene PDF-Seiten zu rekomprimieren wenn man sie verschiebt. Das ist wichtig, da die Linux PDF-Tools im allgemeinen nicht in der Lage sind, JBIG2- oder JPEG2000-Komprimierung zu erzeugen - sie können diese Format nur dekomprimieren. Durch dieses Feature bleiben im PDF enthaltene JBIG2- und JPEG2000-Seiten in der Größe unverändert wenn das Dokument von pdfarranger bearbeitet wird. Weiters bleibt auch ein etwaig vorhandener OCR-Layer in den Seiten erhalten und wird nicht etwa entfernt oder den falschen Seiten zugeordnet. Der einzige Nachteil von pdfarranger ist dass es eine GNOME3-Anwendung mit entsprechend hässlichem bzw. non-Standard Titelbalken handelt. Auch die Tastatur lässt sich für nahezu nichts sinnvoll einsetzen - man muss praktisch alles mit der Maus machen. Es wäre zumindest nett gewesen wenn man mit der Tastatur blättern hätte können. Doch trotz dieser kleinen Mankos ist es ein sehr leistungsfähiges Programm, dass auch PDFs mit mehreren hunderte Seiten problemlos bearbeiten kann (soweit sie noch in dem Speicher passen). Es hat sich zwar gezeigt dass das Programm nach längerer Arbeit instabil werden kann, und dann etwa die falschen Seiten verschiebt. Aber das ist beim Original Acrobat auch um nichts besser, und insofern kein Nachteil. Man sollte aber immer wachsam sein, ob man beim Verschieben auch tatsächlich die gewünschten Seiten verschoben hat. Dabei reicht es allerdings die erste oder letzte Seite verschobene Seite zu kontrollieren - ist diese korrekt, gilt das auch für die anderen.
pdfchain-1:0.4.4.2-2/text/raspbian {PDF}: Eine GUI-Applikation zum Manipulieren von PDF-Dateien. Es kann mehrere PDFs zu einer Datei zusammen fügen, jede Seite eines PDFs als separate nummerierte Datei exportieren, ein Hintergrundbild oder Logo (welches selbst eine PDF-Datei ist) unter jede Seite eines gegebenen PDF-Dokuments legen, beliebig viele Dateien als (zusätzliche) Anhänge an eine PDF-Datei hängen, ein PDF reparieren (was immer genau das auch tun mag), den Dokumentinhalt komprimieren oder dekomprimieren, bestimmte Metadaten einer PDF-Datei ("Annotation data", "Data fields", "data", "Update-info") in Dateien exportieren, ein FDF aus einem PDF-Formular erzeugen, ein PDF-Formular mit den Inhalt einer gespeicherten FDF-Datei ausfüllen, ein PDF "flatten" (was immer das tut), sowie XFA-Informationen aus einem PDF löschen. UTF-8 wird unterstützt. Weiters kann es PDFs mit einem "User-Password" (und optional auch einem "Owner"-Passsort) ver- und entschlüsseln. Leider gibt es beim Verschlüsseln aber das Problem, dass derzeit nur die ältere PDF-Verschlüsselung mit RC4-40 und RC4-128 unterstützt werden. Mit der aktuellen AES-Verschlüsselung neuerer PDF-Versionen kann das Programm leider nicht umgehen. Man ignoriert daher am besten diese Möglichkeit und verwendet "qpdf" für die Verschlüsselung, welches bis zu AES-256 unterstützt. Am nützlichsten ist dieses Tool daher zum Hinzufügen von Anhängen (entfernen oder anzeigen bestehender scheint es nicht zu beherrschen) sowie zum Zusammenhängen mehrer PDFs. Anders als bei "pdfarranger" wo man alles mit der Maus machen muss, bietet pdfchain eine schöne Liste an wo eine Dateiname pro Zeile angezeigt wird. Man kann dann auch Seitenbereiche für jeden Eintrag wählen sowie einen 90-Grad-Winkel für die Rotation im neuen Dokument. Außerdem kann man gerade und ungerade Seiten ausfiltern wenn man möchte. Man kann auch bereits vorhandene Zeilen duplizieren, etwa um andere Seitenbereiche in diesen auszuwählen. Man kann sogar auswählen, ob die "ID" (was auch immer das sein soll) des neuen Dokuments vom ersten oder letzten Dokument der Liste übernommen werden soll, oder ob eine neue "ID" erzeugt werden soll. Alles in allem macht das Programm fürs Zusammenfügen einen sehr viel besseren Eindruck als "pdfarranger", vor allem wenn dabei sehr viele Dateien beteiligt sind.
pdfgrep-1.3.0/app-text/gentoo {PDF}: Erlaubt es, PDF-Dateien genau wie mittels grep nach Texten zu durchsuchen. Optional können Akzente bei der Suche automatisch sowohl aus den Zeichen im Suchausdruck als auch aus den Zeichen im Dokument entfernt werden, so dass sie auf Suchergebnisse keinen Einfluss haben. Ebenso können Ligaturen in Einzelzeichen konvertiert werden, also etw "Æ" in "AE". Dazu bedient sich das Programm der Funktionalität von app-text/unac. Hilfreich bei der Suche nach Fremdworten. Ein einfach zu verwendendes, nützliches Kommandozeilenprogramm.
pdfshuffler-0.5.1-r1/app-text/gentoo {PDF}: GUI-Applikation zur PDF-Bearbeitung, welche folgende Operationen beherrscht: Zusammenfügen von PDF-Dateien (per Einfügen neuer PDF-Dateien in die gerade bearbeitete), verändern der Reihenfolge von Seiten, Entfernen von Seiten, Rotieren von Seiten in 90-Grad-Schritten. Einfach zu benutzen. Nachteil: Die einzelnen Seiten werden nur als Miniatur-Vorschau dargestellt. Es fehlt eine Funktion, um sie vergrößert anzuzeigen. Die Miniatur-Vorschau ist zwar groß genug dass man in den meisten Fällen die Seiten aufgrund das Absatz-Struktur und anderer optischer Layout-Blocks von einander unterscheiden kann. Aber wenn benachbarte Seiten ein sehr ähnliches Layout haben, kann man sie optisch nicht mehr von einander unterscheiden da man in der Miniatur-Vorschau normalerweise nicht die einzelnen Zeichen erkennen kann. Eventuell kann man sich behelfen indem man die Originale in einem separaten PDF-Anzeige Programm öffnet und daraus dann Rückschlüsse zieht. Aber das ist umständlich. Auf der anderen Seite wird pdfshuffler für die meisten Anwendungsfälle ausreichend sein, etwa um nach dem Ausdruck von Web-Seiten "unnötige" Teilseiten (etwa mit Navigationsframes) aus dem Ausdruck zu entfernen. Für härtere Fälle empfehlen sich andere Tools wie pdftk, die allerdings nur per Kommandozeile zu bedienen sind.
pdftk-2.02-2/text/devuan {PDF}: Command-line tool for postprocessing of already-existing PDF files. Seems to have been implemented in JAVA and C++, but has obviously been compiled into a single 3 MB platform-native executable using gcj. Very few external library dependencies - does not depend on ghostscript or libpoppler or any JRE/JDK. Supported operations: merge PDF documents or collate PDF page scans (shuffle page order), split PDF pages into a new document, rotate PDF documents or pages, decrypt input as necessary (password required), encrypt output as desired, fill PDF forms with X/FDF data and/or flatten forms, generate FDF data stencils from PDF forms, apply a background watermark (a visual one, not a cryptographic one) or a foreground stamp, report PDF metrics such as metadata and bookmarks, update PDF metadata, attach files to PDF pages or the PDF document, unpack PDF attachments, burst (explode) a PDF document into single pages using printf-style output names, uncompress and re-compress page streams, repair corrupted PDF (where possible). A nice feature is that --help displays everything which needs to be known for using the program, including several examples.
pekwm-0.1.17-1+b2/x11/devuan {window manager}{GUI}{X11}: Einer der kleineren (350 kB Download, 1 MB installiert) Window-Manager für X11. Beherrscht auch "Tabbing" mittels "Window Grouping". Dazu zieht man einfach mit dem mittleren Mausknopf den Titelbalken auf den eines anderen Fensters. Verwendet die "Sun-Mouse"-Methode zum Fokuswechsel zwischen Fenstern (läßt sich aber auf normalen Click-Focus umkonfigurieren). Ein Doppelklick auf den Titelbalken lässt das Fenster den verfügbaren Platz am Desktop-Hintergrund "auffüllen", indem es sich entsprechend vergrößert. Zudem kann man einfach Fenster neben oder untereinander anordnen. Natürlich lassen sich die Menüeinträge und Tastenzuordnungen alle redefinieren. Dabei werden auch Sequenzen aus mehreren Tasten (samt Modifiern) unterstützt. Dies ist in der Konfigurationsdatei sogar schön übersichtlich mit verschachtelten Abschnitten gelöst. Panel hat er keines, aber wenn man mit dem mittleren Mausknopf auf den Desktop-Hintergrund oder an einen der Bildschirmränder klickt erscheint eine vertikale Liste aller offenen Fenster (inklusive minimierter) aus denen man eines auswählen kann um dorthin zu wechseln. Wurde ehemals von "aewm" geforkt, hat mit diesem aber kaum Gemeinsamkeiten mehr. Unterstützt auch [Alt]+[Tabulator] zum Wechseln zwischen Fenstern. Verwendet Kantenwiderstand anstatt Snapping beim Verschieben von Fenstern. Beim Verändern der Fenstergröße wird hingegen weder Snapping noch Kantenwiderstand unterstützt und man muss pixelgenau positionieren. Allerdings kann man die meist umgehen indem man ein oder mehrere "Hilfsfenster" (etwa nur zu diesem Zweck gestartete xclock-Instanzen) mit Hilfe von Kantenwiderstand dorthin schiebt wo das gewünschte neue Ende des Fensters sein soll, und dann die Funktion verwendet um den verbleibenden Platz durch das Fenster auffüllen zu lassen welches man vergrößern will. Beim Verkleinern geht man in zwei Schritten vor und verkleinert es zunächst nicht exakt auf weniger als die gewünschte Größe, und vergrößert es dann mit der zuvor genannten Methode auf die exakte tatsächlich gewünschte Größe. Zumindest 9 (statisch eingerichtete) Workspaces werden unterstützt, möglicher Weise beliebig viele. Kann im laufenden Betrieb mit dem Befehl ("Command...") "RestartOther" auf einen anderen Fenstermanager umschalten. Daher als Zweit-Fenstermanager nicht einmal so schlecht. Nicht an Menüs oder Tasten gebundene exotischere (interne) Kommandos von pekwm können mit einem Kommando-Dialog (mit Tab Completion) eingetippt werden. Die XDG-Menü-Spezifikation wird zwar nicht unterstützt, aber der (separat erhältliche) "xdgmenumaker" kann gemäß der XDG-Spezifikation aus *.desktop-Dateien Menüeinträge (unter anderem) auch im Konfigurations-Format von pekwm erzeugen. Der Pekwm zeigt im Gegensatz zur Fluxbox ein mehrspaltiges Übersichtsfenster an während man Alt-Tab drückt, wo die Fenstertitel dargestellt werden. So kann man auch bei vielen offenen Fenstern per Alt-Tab rasch zum gewünschten schalten. Anders als beim mehrspaltigen Fenster-Auswahlmenü der FluxBox kann man hier allerdings nur vor- oder zurück gehen, und nicht etwa mit der Maus direkt einen Eintrag auswählen. Somit spart diese Auswahlfenster zwar das einzelne Aktivieren jedes Fensters während man mit [Alt]+[Tab] ein bestimmtes sucht, nicht aber Tastendrücke. Außerdem kann man das Übersichtsfenster auch nicht mit der Maus verschieben; wenn mehr Fenster offen sind als im mehrspaltigen Auswahlfenster Platz finden, hat man Pech gehabt bzw. hilft einem dieses Fenster dann nichts mehr. (Einzeln per Alt-Tab Durchschalten lassen sich die Fenster dann aber immer noch.) Ein Vorteil von PekWM gegenüber der FluxBox ist die Startdauer wenn bereits viele Fenster offen sind. Beim PekWM geht dies einigermaßen flott, bei der FluxBox dauert es mehrere Minuten wenn 200+ Fenster offen sind. Was mich hingegen störte, ist dass PekWM alle Mausrad-Eingaben fraß, so dass sie nicht mehr zum Scrollen innerhalb von Programmen verwendet werden konnten. Zumindest unter Debian bringt PekWM nahezu keine Dokumentation mit. Es gibt aber ausreichend mit Beispielen versehene Konfigurationsdateien unter /etc, die man sich typischerweise zum Anpassen ins eigene $HOME Verzeichnis kopiert.
perceptualdiff-1.2-2+b1/utils/debian: Kommandozeilen-Utility um die Unterschiede zwischen zwei TIFF- oder PNG-Bildern anhand einer "auf Wahrnehmung basierten Bildmetrik" zu ermitteln. Gibt entweder die Anzahl der abweichenden Pixel aus, oder erstellt eine neue Datei wo nur diese angezeigt werden. Wirkt auf mich wie eine 1:1 Kopie von "compare" die eher weniger kann als letztere. Falls es doch irgend etwas tolles können sollte, merkte ich davon jedenfalls nichts. Dafür gab es aber hunderte "Internal error"-Warnungen beim Laden jeder TIFF-Datei aus wegen irgendwelcher angeblich unbekannter Tags. Wenigstens ist das Programm keine 100 kB groß.
perl-text-reform 1.20-3/community/archlinux: Kein Tool zum Reformatieren von Fließtext, wie ich dachte, sondern nur eine mächtigere Version von perl's eingebauten Formaten.
perlpanel-1 {desktop panel}: 0.9.1+cvs20051225-2.1/x11/debian: Ein tatsächlich in Perl implementes Desktop-Panel! Über den Ressourcen-Bedarf schweigt man daher besser (80 MB virtueller Speicher, 40 MB RAM). Davon abgesehen macht es auf den ersten Blick aber gar keinen so schlechten Eindruck: GTK-Optik, Task-Leiste, Uhr (blendet einen Kalender ein und man kann damit sogar Termine mit Notiz und Alarm für einen bestimmten Tag/Zeit erstellen), visueller Pager, ein Menü wo man das "Startmenü" erwarten würde. Die meisten Komponenten lassen sich auch mit einem Kontextmenü editieren. Auf den 2. Blick werden aber deutliche Einschränkungen erkennbar: Erstens scheint das Programm Probleme mit den eigenen deutschen Übersetzungstexten  zu haben - UTF-8 Texte werden offenbar als Latin-1 verstümmelt angezeigt. Weiters ist das zuvor genannte "Menü" nur ein Einstellungs- und Konfigurations-Tool für das Panel selbst, und nicht etwa ein "Startmenü". Immerhin kann man damit die Reihenfolge der Panel-Komponenten ändern und neue hinzu fügen. Letzteres begeistert einen auf den ersten Blick da eine lange Liste von Plug-Ins erscheint, darunter App-Launcher, "Startmenü", Webcam, Lautstärkeregler, CPU-Monitor etc. Wenn man jedoch irgend etwas *tatsächlich* hinzu fügt, kommen nur lauter Fehlermeldungen und nichts funktioniert. Ich vermute, hier wird versucht fremde Plugins, etwa solche von GNOME einzubinden, und dies scheitert wenn nicht ein Großteil von GNOME installiert ist. Fazit: Nette Idee. Doch zum Ressourcen-sparen taugt das definitiv nichts. Schon für sich alleine ist das Panel ein RAM-Fresser. Aber man muss offenbar auch zusätzlich zumindest einen Teil von GNOME installieren, wenn man auch nur ein Startmenü, CPU-Meter und weitere Plug-Ins verwenden will.
phatch-0.2.7.1-3.1/graphics/devuan {bitmap image editor}: Ein Grafik-Konverter und Stapelverarbeitungs-Manipulator, der mehr oder weniger ein direkter Konkurrent zu imagemagick ist. Allerdings ist phatch in Python implementiert und baut auf den Möglichkeiten der Python Image Library auf. Der größte Unterschied ist jedoch, dass phatch ein komfortables GUI mitbringt und primär über dieses bedient wird, während es bei imagemagick genau umgekehrt ist. Zweifelsohne hat imagemagick um einiges mehr Funktionalität, es ist (jeweils voll installiert) auch 3 x so umfangreich. Aber alle wesentlichen Funktionen hat phatch ebenso, und ist wesentlich einfacher zu bedienen. Es unterstützt die Automatisierung kompletter Workflows als Batch-Prozesse, inklusive Umbenennen von Dateien und der Handhabung von Unterverzeichnissen. Patch beherrscht auch CMYK, YCbCr, 32-bit integer pixels und 32-bit floating point pixels Farbmodi und einige verlustlose JPEG-Transformationen.
phototonic-2.1-2+b2/graphics/debian {graphics image viewer}: Ein in Qt verfasster einigermaßen schlanker Bildbetrachter, der keine Abhängigkeiten von bestimmten Desktop-Oberflächen hat und daher gleich gut mit allen funktioniert. Seine große Stärke scheibt darin zu bestehen scheint, auch große Mengen an Bildern (er kann wahlweise nur die Bilder in einem Verzeichnis anzeigen, oder aber rekursiv alle in einem Verzeichnisbaum) einigermaßen flott als Thumbnails zu laden, und die große Liste dann flott durchzuscrollen. Der Hauptbereich des Fensters zeigt dabei immer die (relativ großen, typischerweise nicht mehr als 3 oder 4 neben einander) Thumbnails und Dateinamen an und enthält einen vertikalen Scrollbalken. Die Thumbnails haben ein Problem wenn Bilder sowohl hochkant und Querkant in derselben Zeile angeordnet sind und überdies längere Dateinamen besitzen: In diesem Fall wird der Dateiname der Hochkant-Bilder manchmal bis auf dessen erste Zeile abgeschnitten. An der Oberseite des Hauptfensters sind standardmäßig mehrere Toolsbars angeordnet, diese lassen sich aber ähnlich wie die Docks verschieben und anderswo andocken oder auch schließen. Unter anderem gibt es ein Textfeld zum Filtern der angzeigten Thumbnails anhand der Dateinamen (Vergleich anhand einer Teilzeichenkette). Eine Diashow ist ebenfalls möglich, inklusive optionaler Zufallsreihenfolge. Über das  Kontextmenü der Thumbnails kann man die Datei im Vollbildmodus anzeigen (Eingabetaste oder Doppelklick tun dasselbe). Eine "Öffnen mit" Funktion erlaubt externe Programme für das Bild zu starten. Die Liste der verfügbaren externen Programme kann bearbeitet und erweitert werden. Cut, Copy und Paste erlaubt das Verschieben selektierter Bilder an eine andere Stelle im Dateibaum. Kopiert man Bilder ins Ursprungsverzeichnis, wird automatisch eine Kopie mit einem modifizierten Namen erstellt. Es gibt auch eine "Kopieren nach"- sowie "Verschieben nach"-Funktion. Dabei wird einem eine Liste von Bookmarks angeboten, welche das Zielverzeichnis der Operation darstellen. Man kann jederzeit neue Bookmarks hinzu fügen, indem man ein Verzeichnis auswählt. Der Pfadname ist immer identisch mit dem Bookmark-Namen. Kein dämliches Namensfeld wie bei Geeqie. Diese Funktionen erscheinen sehr nützlich für das Organisieren von Bildern und reichen an die des IrfanView heran. Weiters kann man die aktuelle (und nur diese) Bilddatei umbenennen oder die Metadaten des Bildes entfernen. Es ist derzeit unklar ob damit Metadaten in der Bilddatei gemeint sind, oder von Programm extern gespeicherte Metadaten wie möglicherweise die Tags. Weiters kann man ein Bild in den Mülleimer (vermutlich jenen nach dem XDG Standard) verschieben anstatt es tatsächlich zu löschen (was auch geht). Schließlich kann man auch alle Thumbnails selektieren oder die aktuelle Selektion invertieren. Neben dem Hauptbereich des Fensters gibt es mehrere optional zuschaltbare Zusatzfenster, welche sich entweder als unabhängige Fenster darstellen lassen, oder frei neben oder übereinander ans Hauptfenster andocken lassen. Ich beschreibe im folgenden das Standard-Layout: Links vom Hauptfensterbereich ist oben eine Dateiliste (unklar was das sein soll), darunter ein Dateisystem-Baum-Browser und noch weiter unten ein Lesezeichen-Fenster (welches dieselben Lesezeichen anzeigt wie für die Kopieren/Verschieben-Nach Funktion, hier allerdings anders als in den Dialogfenstern nur die Basisnamen der Pfadnamen). Rechts vom Hauptfensterbereich ist oben das Preview-Fenster, darunter Bildinformationen, darunter Tags. Das aktuell selektierte Bild wird im erwähnten Preview-Fenster angezeigt. Das Bildinformationsfenster zeigt Allgemeine Angaben zum Bild an, und zusätzlich allfällige EXIF-Informationen. Das Tag-Fenster kam erst in einer neuren Version hinu, und erlaubt es aus einer flachen Liste von vordefinierten Tags einem Bild durch ankreuen Tags zuzuordnen oder die Zuordnung zu entfernen. Weiters gibt es einen Filter, welcher offenbar die dargestellten Bilder anhand der Tags filtern kann. Die Liste verfügbarer Tags kann um zusätzliche Tags erweitert werden, oder bestehende Tags können entfernt werden. Es ist unklar wo die Tags gespeichert werden - insbesondere ob dies in der Bilddatei geschieht oder in irgend einer separaten Datenbank. Ein offensichtlich praktisches Problem der Tag-Liste ist dass sie viel zu lange ist (da flach) und man daher ständig scrollen muss um zu allen Einträgen zu gelangen. Bilder einzeln zu taggen dürfte damit mühselig werden. Aber vermutlich kann man mehrer selektieren und dann allen dasselbe Tag zuweisen. Baumbasierte hierarchische Tags wären trotzdem besser. Das Drücken der Eingabetaste sowie ein Doppelklick auf einen Thumbnail oder das Preview-Fenster startet die Vollbild-Ansicht. In dieser kann man sich mit den [Bild]+[auf] / [Bild]+[ab] Tasten durch zu den anderen Bildern aus der Thumbnail-Ansicht bewegen. In dieser gibt es keine Symbolleiste, jedoch ein Kontextmenü mit einigen Darstellungsoptionen. Denn eigentlich gibt es gar keine dauerhaften Bearbeitungsfunktionen für die angezeigten Bilder, wie etwa Rotieren um 90 Grad, sondern diese Funktionen transformieren das bereits geladene Bild nur für die Darstellung am Bildschirm. Während diese Bearbeitungsfunktionen daher nur das geladene Bild betreffen und keine Auswirkungen auf die Originaldatei haben, gibt es eine Tastenkombination mit welcher man das geladene und bereits transformierte Bild abspeichern kann. Dabei erfolgt eine Neukomprimierung des Bildes, verlustloses Rotieren ist daher nur bei Bildformaten möglich die verlustlos komprimiert sind. Grundsätzlich stehen mit diesen Beschränkungen die folgenden Bearbeitungsfunktionen zur Verfügung: Das Bild in 90-Grad- und sogar auch in 1-Grad-Schritten rotieren. Mehrere Spiegelungs-Varianten, darunter auch welche die rotierte Kopien hinzu fügen. Größe des Bildes ändern (skalieren) nach Pixelbreite/-höhe oder Prozent. Zuschneiden des Bildes auf den Inhalt eines zuvor mit der Maus aufgezogenen Rahmens. Ränder wegschneiden, wobei man dies mit Schiebereglern live einstellen kann oder ganzzahlige Prozentwerte numerisch eingeben. Farbmanipulationen, welche sich auch auf ausgewählte Kanäle (R, G, B) beschränken lassen. Dabei änderbar: Helligkeit und Kontrast, Farbton und Sättigung, Einfärben (tinting), Farbkorrektur (inklusive einer Möglichkeit zur Invertierung der Farben). Man kann separat wählen, ob zu große Bilder für die Darstellung verkleinert werden sollen, und ob zu kleine Bilder für die Darstellung vergrößert werden sollen. Eine man-Page oder Handbuch ist nicht vorhanden, ein "Hilfe"-Eintrag im Menü öffnet lediglich die GitHub-Projektseite mit dem Quelltext und einer sehr kurzen oberflächlichen Beschreibung der Programm-Features. Zum Glück ist das Programm allgemein einigermaßen benutzerfreundlich. Bei einigen wenigen nicht offensichtlichen Funktionen muss man jedoch rätseln. Ärgerlich ist dieses Fehlen jedweder Anleitung auch wegen der verfügbaren Tastenkombinationen. Allerdings kann man dazu im Einstellungs-Dialog den Punkt zum Anpassen das Tastenkombinationen nutzen, wo alle Tastenkombinationen angezeigt werden. Die einfache klare und daher benutzerfreundliche Bedienung sowie gute Performanz und vertretbare Installationsgröße von rund 1 MB (300 kB Download) lassen das Programm aber zumindest als Zweitprogramm doch empfehlen. Es ist ein Herausforderer für gpicview, der um ca. 50 % größer ist als letzteres aber auch deutlich mehr kann. Vorteile gegenüber gpicview sind die Umbenennungs-Funktion für einzelne Dateien sowie die optionalen zusätzlichen dockbaren Fenster. In dieser Hinsicht ist das Programm geeqie ähnlich und übertrifft sogar dessen Thumbnail-Browser, reicht allerdings in den meisten anderen Punkten nicht an dessen Features heran. Im Vergleich zu gpicview kann man bei letzterem mehr direkt mit Toolbar-Buttons erledigen und muss seltener ins Menü gehen. Dafür kann gpicview aber nicht einmal in ein anderes Verzeichnis wechseln, und weigert sich winzige Bilder standardmäßig zu vergrößern. Nach einiger Zeit fiel mir ein Nachteil auf: Das Programm kann zwar LZW-komprimierte RGB TIFF-Dateien laden; beim Speichern nach einer Bearbeitung wird aber immer eine unkomprimierte TIFF-Datei gespeichert. Dies nutzt etwaigen Flash-Speicher am Speicherort unnötig ab, auch wenn man die Datei nachträglich wieder komprimiert. Es könnte eine gute Idee sein, Dateien vor dem Bearbeiten mit diesem Programm in ein RAM-basiertes Dateisystem zu kopieren, soweit der Platzbedarf dies erlaubt.
physfs/dev-games/gentoo: A file system abstraction for game resource files. The idea is that games put most of their resources into archive files, such as .zip, .wad, .grp files or other widely-known game resource formats. The physfs library then allows to read (or even write) resource data from or to those archive files. The abstraction is typically defined around a "search path", where a named resource is searched in a list of virtual directories, while writing always occurs to a single "current" virtual directory only. The virtual directories themselves are placed in specific ones among several currently active archive files.
pidgin-2.7.11/net-im/gentoo {chat}: GTK+ basierter Instant-Messaging Client. Nachteil: Speichert alle Passworte in einem vollkommen unverschlüsselten Konfigurationsfile ab. Allein aus diesem Grund: Unbrauchbar. Außer die Accounts auf denen man "instant-messaged" sind eh nichts wert.
pinball-0.3.20201218-4/games/debian {game}: "Emilia Pinball" ist eine 3D-Flippersimulation. Es gibt zwei Tisch-Designs die man laden kann - "professor" (unübersichtlich) und "tux" (halbwegs OK aber auch nicht toll). Man kann über Optionen einstellen ob man das Spielfeld entweder zur Gänze sehen will, oder nur einen vertikalen (aber dafür detaillierteren) Ausschnitt davon welcher scrollt. Man kann das Spiel in einem Fenster oder im Vollbildschirm spielen. Durchaus OK zu spielen, und auch grafisch OK obgleich relativ geringe Auflösung (es handelt sich um Pixelgrafik) und daher entsprechend klotzig. Aber es bleibt halt trotzdem ein Trottelspiel bzw. hat es wenig Dauer-Motivation. Ca. 7 MB Installationsumfang.
pinball-table-gnu-0.0.20200601-2/games/debian {game}: Ein zusätzliches ladbares Spielfeld welches sich ins Spiel "Emilia Pinball" integriert. Vorwiegend in Grüntönen und gelb gehalten, ist dies tatsächlich das beste für dieses Spiel verfügbare Spielfeld, die des Originalspiels eingeschlossen. Es ist übersichtlich und macht mehr Spaß als die anderen. Allerdings fehlt es ein wenig an Spezialeffekten, was jedoch durch gutes Gameplay ausgeglichen wird.
pinball-table-hurd-0.0.20201119-2/games/debian {game}: Ein zusätzliches ladbares Spielfeld welches sich ins Spiel "Emilia Pinball" integriert. Vorwiegend in Rottönen gehalten, sehr komplex und unübersichtlich sowie eine nervige, schrille Musik. Allerdings illustriert es damit durchaus passend den Wahnsinn von GNU HURD. Andererseits ist dieses Spielfeld auch das mit dem meisten Features und Spezialeffekten unter allen verfügbaren, inlusive der Spielfelder vom Originalspiel.
pinfo-0.6.9/app-text/gentoo: Ein GNU "info"-Viewer, der Farben verwendet und wie lynx zu bedienen ist. Leider funktioniert das Teil vorn und hinten nicht; auch mit UTF-8 gibt es massive Probleme. Unbrauchbar solange diese Fehler nicht behoben werden.
pingus/games-puzzle/gentoo {game}: Ja, das gute alte "Lemmings" - nur mit Pinguinen! Mit Tutorial, Editor und vielen Leveln. Grafisch zwar untadelig gemacht, aber trotz möglicher Hochskalierung auf Fullscreen-Größe nur 800 x 600 Auflösung der Grafiken ohne Anti-Aliasing. Sieht daher auf hohen Auflösungen etwas unelegant aus. Ansonsten aber aber ein gut gelungener Klon des Originals.
pinpoint-0.1.5_pre20141026/app-office/gentoo {PDF}: Ein relativ einfacher Scriptsprachen-Interpreter zum Anzeigen von Präsentationen mit dem Fokus auf Hintergrundbildern (auch Videos werden unterstützt) und simplen aber nett aussehenden Übergangseffekten. Die "Folien" können auch als PDF exportiert werden. Bietet im Grunde nur ein Subset von LibreOffice Impress, ist jedoch unendlich viel schlanker in den Installationsanforderungen. Ein Nachteil ist dass man das Programm zur Anzeige der Präsentation installiert haben muss - man kann nicht einfach einen Webbrowser oder sonst ein Programm dazu verwenden (außer wenn die Folien als PDF exportiert wurden, aber dabei verliert man natürlich die Übergangseffekte). Die Multimedia-Dateien werden in das textbasierte Präsentationsdatei über ihren Dateinamen referenziert; es handelt sich bei einer Präsentation also nicht um eine einzelne Datei in welche alle Medien integriert sind, sondern um eine Sammlung einzelner Dateien. Dieses Programm macht nur Sinn wenn in der Tat die Einbindung von Multimedia-Dateien oder Übergangseffekten geplant ist: Rein textbasierte bzw. nur statische Grafiken enthaltende Präsentationen kann man mit dem "slidy"-Backend von "asciidoc" einfacher erstellen, welche dann auch im Browser lauffähig sind.
pipewalker-0.9.1/games-puzzle/gamerlay/gentoo {game}: Ein Klon von knetwalk. Der Riesenvorteil gegenüber dem grafisch ein wenig hübscher gemachtem Original: Es braucht weder KDE noch Qt; nicht einmal GTK+ sondern nur X11, SDL und OpenGL. Somit kann man knetwalk nun endlich auch ohne riesige Bibliotheken als Abhängigkeiten spielen.
pitivi-0.94/media-video/gentoo {video-editor}: pitivi-2020.09.2-3/gnome/debian: Ein in Python geschriebener und auf dem GStreamer-Framework (anstatt auf ffmpeg) aufbauender nicht-linearer Video Editor. Das GUI basiert auf GTK+ ohne GNOME-Abhängigkeiten. Die 2022 Version sieht jedoch leider exakt wie eine GNOME3-Anwendung aus, inklusive der fehlenden Titelbalken und der X11-feindlichen Client-Side-Decorations. Laut einem Testbericht aus 2013 ist das Programm aber so wählerisch bei den unterstützten Formaten der Eingabedateien, dass es für allgemeines Videobearbeiten unbrauchbar sei. Die Version 0.94 stürzt angeblich dauernd ab; ich konnte sie jedoch wegen einer angeblich fehlenden Abhängigkeit nicht einmal bauen. Eine frühere Version schien mir aber sehr primitiv in der Funktionalität zu sein: Trotz tollen Effekten mangelt es an vielen grundsätzlichen Bearbeitungsfunktionen; im wesentlichen kann man nur mit der Maus Clip-Ausschnitte anordnen. Das Programm zielt wohl primär auf User ab die von nichts eine Ahnung haben, aber trotzdem Videos editieren wollen. pitivi ist 2022 auf Platz 8 der beliebtesten nichtlinearen Video-Editoren (auf slant.co). Nachteile (2022): Keine Hardware-Beschleunigung für Komprimierung oder Dekomprimierung, die Geschwindigkeit eines Clips lässt sich nicht ändern, kein Proxy Editing (automatisches Verwenden einer temporären LQ-Version eines HQ-Clips während dem Editieren). 2022 ist der RAM-Bedarf direkt nach dem Start 121 MB RAM, womit es zumindest im Leerlauf der mit Abstand schlankeste NLE ist.
plocate-1.1.18-1/utils/debian: Eine alternative und seit Debian-12 auch einzige und somit die Standard-Implementation des "locate"-Kommandozeilen-Werkzeugs. Es erzeugt einen um ca. 1/4 kürzeren Suchindex (2021 bei meinem System: Umfang 34 statt 45 MB) als mlocate. Außerdem durchsucht es (außer in sehr ungünstigen Fällen) anders als mlocate nicht den ganzen Suchindex, sondern nur Teile davon. Daher ist es auch schneller als mlocate. Allerdings war auch mlocate immer blitzschnell, und da der Suchindex keine 50 MB groß ist kann jede Festplatte diesen in wenigen Sekunden komplett lesen. Der kleinerer Index von plocate kommt möglicherweise zudem auch nur durch bessere (überhaupt?) Komprimierung des Index, wozu plocate offenbar die zstd-Komprimierung einsetzt. plocate ist im wesentlichen ein Drop-In Replacement für mlocate. Die einzige (dokumentierte) Inkompatibilität ist, dass es bei Angabe mehrerer Suchbegriffe nur solche Treffer meldet in denen alle Begriffe vorkommen. mlocate benötigt die -a Option um dasselbe zu tun. plocate ist geringfügig umfangreicher als mlocate, aber beide sind mit rund 1/2 MB recht überschaubare Installationen. Davon abgesehen scheint der größte Unterschied zu sein dass plocate ist in C++ geschrieben wurde. Ob das bei einem SUID Programm wie plocate eine gute Idee ist? Allein die C++ Laufzeitbibliothek ist so fett dass ich jede Menge Bugs darin befürchte denen ein C-Programm nicht ausgesetzt wäre. Noch dazu wird man in C++ verleitet die tollsten Konstrukte zu verwenden, aber sich wenig um Fehlerbehandlung zu kümmern. Und vor allem ist plocate weniger bekannt, seltener installiert und daher weniger praxisperprobt als mlocate. Da funktional kaum ein Unterschied zu mlocate besteht, sehe ich daher wenig Anreiz plocate zu verwenden, vor allem aus Sicherheitsbedenken.
pmount-0.9.23-3+b2/utils/debian: Erlaubt normalen Benutzern ohne Passworteingabe bestimmte Dateisysteme (Stand 2025: udf, iso9660, vfat, ntfs, hfsplus, hfs, ext3, ext2, ext4, reiserfs, reiser4, xfs, jfs and omfs - in dieser Liste fehlt insbesondere ExFAT) von Wechseldatenträgern zu mounten. Ein direkter Konkurrent von udevil. pmount ist ein SUID/GUID-Programm und hat den Vorteil nahezu keine Konfigurationsdateien zu benötigen. Es gibt nur eine einzige wo zusätzliche erlaubte Blockgeräte eingetragen werden könne. Per Default ermöglicht pmount nur das Mounten von Wechseldatenträgern. Die Angabe des Dateisystem-Typs ist optional. pmount versucht die Dateisysteme ansonsten in exakt derselben Reihenfolge wie in der obigen Liste angeführt zu mounten bis es das erste Mal Erfolg hat. Zusätzlich kann pmount noch LUKS-verschlüsselte Datenträger crypto-mounten. Schließlich kann es Blockgeräte sperren oder die Sperrung wieder freigeben. Die Sperrung wird dabei an einen laufenden Prozess gebunden. Diese Feature ist ähnlich einem von udisks2. Man kann damit verhindern, dass automount-Daemonen sich auf einen Datenträger "stürzen" während man ihn etwa gerade reparieren will oder sonstwas. Der Zugriff auf pmount ist nur dadurch eingeschränkt, dass die Benutzer Mitglieder der Gruppe "plugdev" sein müssen. Allerdings ist das Debian-spezifisch.
polipo-1.0.4.1-r1/net-proxy/gentoo: Ein cachender Proxy-Server mit 1,2 MB Installationsumfang. Scheint recht ählich wie Squid zu sein, und auch ähnlich kompliziert zu konfigurieren. Der wesentliche Unterschied scheint mir zu sein dass polipo seine Dokumentation als GNU "info"-Seiten ausliefert, während man sich bei Squid durch das endlos lange config-File kämpfen muss. Irgendwie habe ich bei Squid ein besseres Gefühl, aber auch dessen Konfiguration ist mir viel zu kompliziert für simples Proxying.
polly-b-gone-1.0/games-puzzle/gamerlay/gentoo {game}: Man steuert so eine Art kleinen Rasenmäher in Marble-Madness-Manier durch ein 3D-Level. Allerdings mit der Tastatur, wobei sich die relative Steuerung als Herausforderung darstellt. Es gibt auch (soweit ich bis es bis jetzt spielte) keine Feinde oder dergleichen, sondern nur Hindernisse welche man überwinden muss. Nett gemacht; das Spiel hat angeblich auch irgend einen Preis gewonnen. Empfehlenswert. Aber auch sauschwer!
poppler-utils-20.09.0-3.1/utils/debian poppler-utils-0.26.5-2+deb8u1/utils/devuan {PDF}: Contains the utilities "pdfattach" (add new attachments) "pdfdetach" (list or extract attachments), "pdffonts" (show fonts used), "pdfimages" (list contained images and report their properties or save them in native or specified format; in the case of native format, saving will be a lossless operation), "pdfinfo" (show metadata including PDF version and whether JavaScript or forms are present), "pdfseparate" (extract all or a single range of pages into separate files), "pdfsig" (display digital signatures of the document and their validity status) "pdftocairo" (use the CAIRO backend to convert into PNG, JPEG, TIFF, PDF [hmmm...], PS, EPS or SVG; can generate single-page or multi-page HTML; can change external .pdf links into .html links), "pdftohtml" (converts a range of pages into HTML or XML, with either PNG or JPEG images), "pdftoppm" (convert to "netpbm" portable anymap format (monocrome, grayscale or color), supports scaling, cropping and specifying DPI; can not only create PNM but also JPEG, TIFF and PNG), "pdftops" (convert to PostScript, selectable format level, can disable font embedding, can emit PS forms, can disable the defined crop-box, can override the paper size, can auto-shrink pages larger than the paper size, can auto-fill pages to match the paper size), "pdftotext" (extract text, can optionally retain the approximate layout in the output) and "pdfunite" (concatenate multiple unencrypted PDF files into a single file; unfortunately it destroys hyperlinks according to a blog-entry from 2013).
postfix/mail-mta/gentoo: The most secure of the actively developed open source mail transfer agents. However, some features that other mailers provide have intentionally been left out because of this. It seems Postfix must be run as a dedicated daemon; I found no way to only run it from inetd when actually needed. The Postfix master daemon acts just a control monitor; starting, stopping or restarting sub-processes which do all the actual work as needed. Postfix is not a single application, but a pipeline of specialized processes where each process only performs a specific job. This makes Postfix very secure, but also means a lot of worker processes have to be created during the execution of its job.
potrace-1.13-3/graphics/devuan: Das enthaltene "potrace"-Utility konvertiert PNM- und .bmp-Pixelgrafikdateien in eines folgenden Vektorgrafikformate: EPS (Default), PostScript, PDF, SVG, DXF, GeoJSON, PGM, Gimppath und XFig. Es gibt auch mehrere Experten-Optionen zum Anpassen der verwendeten Tracing-Algorithmen. Es ist auch ein Preprocessing-Programm "mkbitmap" enthalten, welches Bitmaps für "potrace" vorbereiten kann, indem es sie filtert, s/w-konvertiert und säubert. "mkbitmap" kann die Grafiken optional auch invertieren und skalieren.
povray-3.7.0_rc3/media-gfx/gentoo: Ein Raytracing-Programm, welches Einzelbilder als Ergebnis einer Quelltextbeschreibung einer dreidimensionalen Szene errechnet. Dazu wird eine extrem mächtige Szenen-Beschreibungssprache geboten. Man kann aber auch Animationen erstellen, indem man eine Szene so parametriesiert dass sie von einem "clock"-Wert abhängig die Objekte an einer anderern Stelle, Form oder veränderten Eigenschaften darstellt. POVRay kann dies sowohl intern durchführen und als Ergebnis eine Sequenz von nummerierten Bildern ausgeben (oder externe Tools zum Wegspeichern der Bilder aufrufen), oder extern indem man POVRay in einer Schleife mit unterschiedlichen "clock"-Werten aufruft. POVRay ist von den Möglichkeiten her sehr mächtig, es krankt aber daran dass man alles exakt und in Koordinaten angeben muss. Daher ist er eher für simple Szenen wie zur Erstellung von Logos etc. geeignet, und kaum für die Herstellung eines Spielfilms. Für solche Dinge würde man doch klar zu Blender greifen. Ein Vorteil von POVRay ist dass die Beschreibungen, da es (von eventuellen externen Texturdateien einmal abgesehen) reine Quelltexte sind, die verglichen werden können und allgemein versionskontroll-freundlich sind. Auch die Einarbeitungszeit in POVRay ist sicherlich erheblich geringer als bei Blender. Auch zur Visualisierung von Daten ist POVRay besser geeignet, weil man hier mit exakten Werten arbeiten kann und keinen manuell irgendwie in einem Szeneneditor platzierten Objekten.
powder-116/games-roguelike/gentoo {game}: Ein typisches "Rogue"/"Nethack"-ähnliches 2D-grafisches Dungeon-Erforschungs-Spiel für X11 und kleine Displays. Ursprünglich wurde es für den GameBoy Advanced geschrieben. Es ist auch gut geeignet für Smartphones wie das N900. Mit weniger als 4 MB Installationsumfang ist es auch angenehm klein. Es kann komplett über Tastatur, oder Maus, oder Stylus gespielt werden, oder auch einer Kombination dieser Eingabegeräte. Insgesamt ein nett gemachter typischer Vertreter des Genres, der mir allerdings eher schwerer erscheint da ich beim testweise Spielen immer schnell binnen weniger Minuten starb. Der größte Nachteil des Spiels ist (zumindest auf einem normalen PC) die fixe und zudem geringe Grafikauflösung, da das gesamte Spiel auf Bitmap-Kachelgrafik basiert. Man kann zwar im Fullscreen-Modus spielen, aber dabei werden die Kacheln nur vergrößert und die relative Auflösung des Bildschirms bleibt unverändert gering.
powermanga/games-action/gentoo {game}: Nettes Ballerspiel mit vielen Waffen und *großen* Meteoriten. Allerdings: Nur geringe Auflösung, die auf Fullscreen hochgerechnet wird. Macht aber Spaß! Im Falle der Joystick-Steuerung ist die Button-Belegung leider nicht redefinierbar.
pppconfig/admin/debian: Console-based GUI for creating a working pppd configuration. Might need a little tweaking after the work is done for optimum customization, but otherwise is the next best thing to deploy a hand-written pppd configuration. Definitely low-fat, as compared to wvdial - let alone network-manager and modemmanager.
prboom-2.4.7/games-fps/gentoo {game}: Eine OpenSource-Implementation des originalen Doom. Weitgehend ident, wenn man davon absieht dass es trotz weitaus stärkerer Hardware und 3D-Beschleunigung (schwach) ruckelt. Die Levels sind ident mit der Originalversion, jedoch die Grafik ist nachgemacht. Und diese sieht wahrhaftig *erbärmlich* aus! Vermutlich kann man irgendwie die Original-Grafik installieren, aber der Default-Look ist einfach zum Grausen.
premake4-4.3+repack1-2+b1/devel/devuan {software build system}: Premake ist ein in reinem C geschriebenes Meta-Buildsystem und Kommandozeilentool, welches Projektdefinitionen in seiner eigenen Sprache liest und daraus Projektdateien für die folgenden Build-Systeme bzw. IDEs generieren kann: Visual Studio, Xcode, Codelite und GNU Make. Obwohl es in reinem C geschrieben ist greift es auf Lua-Bibliotheken zurück, um Lua-Scripting in seinen eigenen Projektdateien zu ermöglichen. Die Beschreibungssprache der Projektdateien sieht syntaktisch C- und APT-ähnlich mit geschweiften Klammern aus; immerhin wird scheinbar auf Strichpunkte verzichtet. Zumindest soweit auf Lua-Scripting im Projekt verzichtet werden kann, sieht die Beschreibung simpler Projekte zumindest einfach aus und ist auch in der Lage die Quelltexte aufgrund von Joker-Ausdrücken selbst zu finden anstatt dass man alle indivuellen Quelltexte manuell in die Projektdateien aufnehmen müsste. Leider ist premake kein allgemeines Metabuild-System, sondern unterstützt nur Projekte in den folgenden Programmiersprachen: C, C++, C#. Noch dazu scheint es die Zielplattformen zu beschränken, da es lediglich für 32- und 64-Bit-Systeme Projektcode generieren kann, und die xbox360 ist zudem noch separat genannt. Offensichtlich gibt es auch noch Einschränkungen auf plattformspezifische Projektarten, so ist etwa "ConsoleApp" bereits im ersten Beispiel einer Projektdatei angeführt. Die explizite Nennung von "GNU make" lässt zudem befürchten dass es entsprechende GNU-Erweiterungen benutzt und keine POSIX-Makefiles erzeugen kann.
procmail-3.22-r10/mail-filter/gentoo: Ein Standalone-Mailfilterprogramm, das normalerweise von fetchmail aufgerufen wird um herunter geladene Mail in lokale Postfächer einzusortieren, es dabei in Ordner aufzuteilen und/oder Programme zu starten welche die Mails verarbeiten. Es kann auch als sendmail-Ersatz verwendet werden (procmail ist ein SUID Programm), wenn Mails nur lokal (also via Mailspool-directory) zugestellt werden brauchen. Versteht sowohl das mbox als auch das maildir und MH format. Dazu verwendet es ein Konfigurationsfile welches Regeln und Optionen angibt. Die Regeln bestehen aus Optionen und "egrep"-kompatiblen Regular Expressions, welche alle erfüllt sein müssen damit die Regel "matcht". Die Optionen erlauben es regex-Flags festzulegen, sowie die Regel in Beziehung zu vorangehenden oder nachfolgenden zu setzen (AND-Verknüpfung, ELSE-IF-Logik etc.). Regel-Blocks können durch geschweifte Klammern gruppiert werden. Dadurch ist es auch möglich logisch verschachtelte Regelblocks zu implementieren. Wenn keine Regel zugtrifft, fügt procmail die Mail der lokalen Default-Mailbox des Benutzers zu. Als Actions einer Regel kann die Mail entweder an eine andere Mail-Adresse forgewardet werden, in eine lokale Mailbox geschrieben werden, oder mit einer Pipe an ein beliebiges Kommando übergeben werden. Der Return-Code eines externen Kommandos kann, muss aber nicht in die Interpretation nachfolgender Regeln einbezogen werden. Ebenso kann man sich aussuchen ob eine Action die Filterkette beendet, oder ob die restlichen Regeln weiterbearbeitet werden sollen. Die Syntax der Regel/Konfigurationsdatei ist zwar nicht sonderlich komplex, aber dank der fleißigen Verwendung von Sonderzeichen unleserlich für den nicht Eingeweihten. Sie wirkt teils auch etwas an "ed" angelehnt. Die Art und Weise wie die Verkettung von Regeln mittels AND/ELSEIF-Logik nur durch Regel-Optionen implementiert wird, macht die Beziehung auf einander folgender Regeln nicht auf den ersten Blick erkennbar erkennbar. Auch wenn fetchmail häufig zusammen mit procmail verwendet wird, empfiehlt ersteres man möge besser mail-filter/maildrop verwenden da es eine weniger gewöhnungsbedürftige Syntax und man nicht so leicht Fehler damit machen könne. Ein Vorteil der procmail-Syntax ist dass sie "Low Noise" ist, und die Regel-Files daher kürzer bleiben als es mit "schönen Schlüsselwörtern" der Fall wäre. Ein Nachteil von procmail ist dass es nicht mehr aktiv weiter entwickelt wird.
prosody-0.8.2/net-im/gentoo {chat}: Ein in Lua geschriebener Server für das XMPP Instant-Messaging-Protokoll (füher als "Jabber" bekannt). Kann beispielsweise als Server-Komponente für Gajim fungieren. Gilt als ziemlich ressourcenschonend im Vergleich zu anderen derartigen Servern.
psensor-1.1.5-1+b4/utils/debian {resource monitor}{GTK+}: Ein ziemlich unfähiges Programm zum Anzeigen einer sehr limitierten und reichlich mutwillig erscheinenden Auswahl bestimmter Systemparameter, primär Temperaturen. Auch GPU (nur NVIDIA zur Zeit, vermutlich mit proprietärem Treiber) und HDD werden unterstützt. Ansonsten kann nur noch CPU-Auslastung und freier RAM angezeigt werden. Weder GPU- noch HDD-Temperatur funktionierten bei mir, aber das mag natürlich einfach nur Pech gewesen sein. Ärgerlich ist vor allem dass eine große Fläche für das Zeichnen von Performance-Kurven frei gehalten wird - aber diese werden einfach nicht gezeichnet. Man sieht somit nur die Zahlen werte. Aber immerhin ist es schlank: 70 kB Download, 380 kB installiert. Wenn man nicht bereits einen der viel fetteren aber auch viel besseren anderen Resource-Monitore installiert haben sollte, ist es zumindest eine erwägenswerte Alternative. Aber sicherlich nicht zusätzlich.
psh/app-shells/gentoo: A shell which evaluates Perl code at the command line. Perhaps nice, but its programming features (loops etc.) are not compatible to the normal UNIX shell. This means it cannot run any but the most simple sh scripts correctly.
puddletag-2.0.1-2/sound/debian: Ein MP3-Tagger ähnlich wie easytag mit einer grundsätzlich interessanten Idee: Anstatt in einem Formular-Layout wird alles in einem Gitter wie in einer Tabellenkalkulation angezeigt. Das ist wesentlich übersichtlicher wenn man viele Songs mit teilweise überlappenden Attributen wie etwa aus demselben Album hat. Doch leider kann puddletag nur *.mp3- und *.aac-Tags editieren, während easytag auch die von *.ogg-Dateien editieren kann, welche häufig als Container für den Opus-Codec verwendet werden (der nicht von vielen Containern unterstützt wird) den YouTube in vielen Audio-Tracks verwendet.
puppet-5.5.10-4/admin/debian {configuration management}: Eines der ältesten SCM-Systeme. In Ruby geschrieben. Erfordert neben einem Server ("puppet master") auch einen Puppet-Client ("agent") auf jedes betreute System installiert. Unterstützt mehrere Betriebssysteme, allerdings nicht einheitlich. Der Server ist optional, bei "serverless-Betrieb" können die Konfigurationsdateien auch manuell per git verteilt werden. Ein Nachteil des serverless-Betriebs ist es jedoch, dass es einfach ist die manuellen Aktualisierungen zu vergessen und dann nicht alle Clients am selben Stand sind. Die Konfigurationsdateien welche "Manifest" genannt werden sind in einer Ruby-basiertem Domain-Specific Language verfasst. Ein Manifest definiert nicht einfach irgend einen Vorgang, sondern enthält alles was nötig ist um das Zielsystem abhängig vom aktuellen Zustand in einen definierten Systemzustand zu versetzen. Es handelt sich also mehr um eine Art Zustands-Management-System als ein bloßes Verteilen gescripteter simpler Einzelaufgaben. Die Manifeste werden vorkompiliert und dann standardmäßig alle 30 Minuten zwischen Server und den Clients abgeglichen. Die Clients wenden diese kompilierten Manifeste dann auch gleich an um die neue Konfiguration herbei zu führen. Angeblich ist Puppet mehr auf die praktischen Erfordernisse von Administratoren zugeschnitten als andere SCM-Systeme. Der Nachteil ist dass Ruby-Kenntnisse zum Erstellen eigener Manifeste erforderlich sind. Allerdings gibt es auch hier eine große Sammlung bereits fertiger Manifeste zum Downloaden.
pv-1.6.6-1/utils/debian: Ein Filter den man in eine Pipe einbauen kann und welcher alle Daten unverändert durchleitet. Dabei zeigt er allerdings die Geschwindigkeit an mit der die Daten derzeit durch die Pipe fließen, sowie die erwartete Restzeit wenn man mit einer Option die erwartete Gesamtdatenmenge angibt (und weiß). Ebenso kann die Durchflussgeschwindigkeit durch den Filter limitiert werden, was in Kombination mit dem Segment-Window Management von TCP zu einer Limitierung von Up- und Download Raten in Netzwerkverbindungen genutzt werden kann. Nützlich auch zum Verzögern von simulierten Tastendrücken durch eine Pipe, wenn ein Programm diese nicht schnell genug verarbeiten kann. Die größtmögliche unterstützte Verzögerung ist ein Byte pro Sekunde. Erfolgreich getestet beim QEMU Monitor, welcher je nach Lust und Laune nicht mehr als 30 bis 300 Bytes pro Sekunde entgegen nahm.
pwgen-2.08-2/admin/debian {security}: Ein Passwort-Generator, der angeblich leicht merkbare Passworte erzeugt. Standardmäßig bestenen die Wörter aus Groß- und Kleinbuchstaben sowie Ziffern. Kann mehrere Passwörter auf einmal mit einer gegebenen Länge erzeugen, welche (abschaltbar) auch in Spalten ausgeben werden damit mehr auf den Bildschirm passen. Optional kann man diese Parameter auch so interpretieren, dass eine einzige Pass-Phrase ausgegeben werden soll, die aus gegebenen Anzahl an Worten mit stets derselben gebenen Länge besteht. Kann neben leserlichen auch rein zufällige Passworte erzeugen. Verwendet normalerweise immer /dev/random um seine Entropie zu ernten, was sehr schlecht ist. Allerdings kann man auch eine Seed-Datei angeben welche zur gänze mit SHA-1 gehasht wird, und zusätzlich noch einen Personalisierungs-String der ebenfalls dazu gehasht wird. Der Hash dient dann als Seed für die Passwort-Erzeugung. Mit dieser Methode sollte der Generator daher auch kryptografisch sichere Passworte erzeugen können wenn man ihm eine Seed-Datei mit ausreichend Entropie bereit stellt. Die so erzeugten Hashes sind dann auch wiederholbar. Es gibt mehrere Optionen um das Alphabet aus dem die Zeichen gewählt werden zu vergrößern oder zu verkleinern. Ebenso können Einschränkungen definiert werden, wie z. B. ob zumindest ein Sonderzeichen im Passwort vorkommen soll. Es ist allerdings unklar welche Stärke das erzeugte Passwort hat, da all diese Optionen die Wahrscheinlichkeiten verändern. Es ist nicht einmal klar ob die Passwörter durch Umwandlung von Zufallsbytes gebildet werden, oder ob jedes einzelne Zeichen unabhängig von den anderen "erwürfelt" wird. Wegen dieser Unklarheiten ist der Generator für Anwendungen welche eine bestimmte Schlüsselstärke fordern ungeeignet.
pwsafe-0.2.0-r1/app-misc/gentoo: Eine Kommandozeilenapplikation zur Passwortverwaltung. Kompatibel mit Dateien des Windows-basierten "Password Safe" von Counterpane Systems. Kann auch Einträge importieren, exportieren oder zusammenmischen (interaktiv). Passwörter können zur weiteren Verwendung in die X11-Zwischenablage kopiert werden. Sinnvoll wohl nur wenn man bereits Passwort-Dateien von "Passwort Safe" vorliegen hat und auch unter Linux darauf zugreifen können will.
pystopwatch-2012.12.24.1/app-misc/gentoo {reminder}: Bietet 4 umschaltbare Ansichten in einem Fenster: Aktuelle Zeit, Stoppuhr, Countdown-Timer für bestimmte Zeitspanne, Countdown-Timer bis zu einer bestimmten Uhrzeit. Alle Ansichten funktionieren unabhängig von einander und nur sekundengenau. Beim Ablauf der Countdown-Timer lässt sich ein benutzerdefinierbares Kommando ausführen sowie eine Alarmmeldung anzeigen. Allerdings sind Meldungstext und Kommando für beide Countdown-Timer dieselben. Die Anwendung lässt sich zwar in den Traybar minimieren, jedoch sieht man dann dort nur ein Symbol und nicht die Zeit selbst.
python-aafigure-0.5-4/python/debian: Ein in Python implementierter ASCII-Art nach Grafik-Datei-Konverter. Parst ASCII-Art-Dateien und erzeugt daraus PNG, SVG, PDF, GIF, JPEG, PPM, TIFF sowie alle Bildformate, welches die Python Imaging Library (Paket python-pil) unterstützt. Dieses Paket stellt eine leichtgewichtige Alternative zum Paket graphics/ditaa dar, welches in JAVA geschrieben ist und mitsamt Abhängigkeiten eine leider sehr fette Installation ist. Es gibt ein text/asciidoc-Plugin für aafigure, welches es erlaubt die ASCII-Art Diagramme direkt in asciidoc-Quelltexte aufzunehmen. Im praktischen Einsatz erweist es sich als etwas ärgerlich, dass alle im Text vorkommenden doppelten Buchstaben als Schraffur-Symbole interpretiert werden, und die Texte dann zwischen Hochkommas gesetzt werden müssen um dies zu unterbinden. Genauer gesagt ist das nicht nur "etwas ärgerlich", sondern macht das Programm nahezu unbrauchbar für ASCII-Art in der vorwiegend Textboxen vorkommen. Eventuell kann man mit einem "sed"-Script die erforderlichen Hochkommas in einem Vorverarbeitungs-Schritt automatisch ergänzen. Das Programm ist somit nur für Diagramme geeignet in denen nur wenig Text vorkommt. Ansonsten nimmt man besser graphics/ditaa, obwohl es fetter ist, schweinelangsam und kein SVG kann.
python-docutils-0.13.1+dfsg-2/python/debian: Konvertierungs-Tools, um aus Textdokumenten welche die textbasierte Auszeichnungs-Sprache "reStructuredText" verwenden andere Dokumentformate zu erzeugen. ReST kommt in vielen Tools als Backend zum Einsatz, etwa in "sphinx" oder einigen Wikis, aber dieses Projekt ist die "Heimat" von reST. Die folgenden Zielformate können aus .rst-Textdateien erzeugt werden: HTML, HTML5, LaTeX, man-Pages, odt (OpenOffice/LibreOffice Textdateien), XML, S5 (ein Template-System zum Erzeugen von Web-basierten Präsentationen als Konkurrent zu PowerPoint & Co) und noch ein paar Exoten. Der Ursprung des gesamten Projekt ist die Dokumentation der Python-Programmiersprache und ihrer Standard-Bibliothek. Docutils werden auch vom Python-Entwicklern genutzt, um automatisch generierte API-Beschreibungen (die ihrerseits wiederum aus Kommentaren in Quelltexten extrahiert wurden) in per Web-Browser durchforstbare HTML-Dokumentation umzuwandeln. Docutils enthalten daher auch die originale Dokumentation der reST-Auszeichnungssprache.
python-sphinx-1.4.9-2/python/debian: Ein Text-basierter Generator für strukturierte Dokumente und ganze Webseiten. Als Grundformat für das Verfassen der einzelnen Abschnitts-Dokumente wird "reStructuredText" (*.rst-Textdateien) benutzt, ein textbasiertes Auszeichnungsformat das für manuelles Erstellen und Bearbeiten gut geeignet ist. Dem originalen reST fehlt aber jede Möglichkeit, auf andere Dokumente Bezug zu nehmen und Verknüpfungen zwischen Dokumenten zu erstellen. Genau hier setzt Sphinx an, indem es entsprechende Direktiven zu reST hinzu fügt. Mit den Direktiven kann einfach eine Baumstruktur aus Dokumenten beschrieben werden. Daraus wiederum kann Inhaltsverzeichnis und Stichwort-Index generiert werden. Die erzeugten HTML-Dateien können sogar eine Suchfunktion enthalten, mit welcher - falls der zum Ansehen verwendete Browser JavaScript beherrscht - nach Stichworten gesucht werden kann. Optisch kann das Aussehen durch verschiedene "Styles" verändert werden, ohne dass man dazu selbst Arbeit investieren müsste. Sphinx kann jedoch nicht nur herkömmliche Webseiten in Form verlinker HTML-Dateien erzeugen. Es kann auch alles in einer einzigen großen HTML-Datei unterbringen! Und es kann nicht nur HTML als Ausgabe erzeugen, sondern (neben einigen weiteren weniger verbreiteten) auf in den folgenden Formaten: LaTeX (um daraus PDF-Dokumente zu erzeugen), man-Pages, EPUB (ein verbreitetes e-Book-Format), Reintext, pickle/JSON (für die Weiterverarbeitung der Dokumente durch andere Scripte), GNU "gettext" Übersetzungskataloge, linkcheck (Pseudo-Format, verifiziert statt dessen die Erreichbarkeit aller externen Links), XML (zur Weiterverarbeitung mit python-docutls), GNOME-Online-Hilfe-Format (devhelp), qthelp (dasselbe für Qt-basierte Anwendungen), Microsoft CHM Hilfedateien, changes (erzeugt eine HTML-Datei mit einer Änderung-Historie der Abschnitte der Webseite/Dokuments, damit die Webseite Besucher im Groben auf Unterschiede zu früher hinweisen kann). Alles in allem macht Sphinx einen netten Eindruck, und "erobert" einiges von dem zurück, was reST gegenüber "asciidoc" an Boden verloren hatte, da letzteres schon immer mehrere Dokumente mit einander kombinieren konnte. Die beiden Pakete sind auch (zusammen mit allen Abhängigkeiten) etwa gleich fett. Ein Unterschied ist dass Sphinx für größere Projekte gedacht ist, da man mehrere Dateien erzeugen muss (auch wenn einem ein Generator/Wizard dies abnehmen kann) und man daher normalerweise ein Verzeichnis pro Projekt benötigt. Bei asciidoc braucht man bei kleineren Projekten hingegen nur eine einzige Datei welche alles enthält. Im Gegenzug sind die Möglichkeiten welche Sphinx für das Verknüpfen der Einzeldokumente bietet (vor allem auch automatisch dabei erstellte Links) um ein Vielfaches mächtiger.
python3-minecraftpi-0.22-1/games/debian: Eine Python-Anbindung sowohl an das kommerzielle "Minecraft" als auch an das OpenSource-Pendant "minetest". Es ist damit möglich, die Spielerfigur zu programmieren und somit programmiert die Spielwelt zu erforschen. Sicherlich nicht uninteressant wenn an an Roboterprogrammierung interessiert ist, da man so mit einfachen Mitteln den Roboter in einer 3D-Umgebung steuern kann.
python3-numpy-1:1.19.5-1/python/debian: Python-Bibliothek für Matrizen und Mathematik. Ein Array-Objekt für beliebige gleichartige Elementtypen, schnelle Berechnungen mit Arrays, lineare Algebra, Polynomberechnungen, Fourier Transformation, Zufallszahlen-Generierung.
qalc-4.5.1-1/math/raspbian: {calculator}{math}{symbolic calculation}{command line utility}: Eine Kommandozeilen-Taschenrechner, welcher ein alternatives non-interaktives Front-End für dieselben Bibliotheken darstellt welche auch vom GUI-Front-End qalculate-gtk (sie dort für eine Beschreibung der wesentlichen Features) benutzt werden. Es bietet nicht alle Funktionen der GUI-Version an; so fehlen z. B. alle Bearbeitungsdialoge. Aber die Kernfunktionalität und die meisten sinnvollen Funktionen stehen auch in der Kommandozeilen-Variante zur Verfügung. Dach meinem Dafürhalten der beste Kompromiss zwischen Ressourcen-Verbrauch und einfacher CAS-Funktionalität. Mit Maxima kann es natürlich nicht mithalten, aber das lädt auch viel länger und verbraucht deutlich mehr RAM.
qalculate-gtk-4.5.1-1/math/raspbian qalculate-kde/sci-calculators/gentoo {calculator}{symbolic calculation}{math}{GTK+}: Der Alleskönner. Eigenbezeichnung "Qalculate!". Ein Taschenrechner, der alle Stückerln spielt. Kann auch mit Variablen rechnen, mit Brüchen und mit beliebig exakten Zahlen. Ähnlich wie der TI-92. Nicht ganz so gut, aber fast. Vor allem kann man den Text in ein Edit-Feld eingeben. Mit History. Kann auch Einheiten umrechnen und GNUplot zum Anzeigen von Graphen verwenden. 60 MB RAM-Verbrauch, 5,4 MB Installationsumfang, 2,2 MB Download. Damit zwar der fetteste Download, aber bereits der Installationsumfang ist geringer als z. B. beim gnome-calculator. Vor allem aber ist dieser Taschenrechner mit Abstand der mächtigste. Er kann auch symbolisch Differenzieren, Integrieren, Limits berechnen und Gleichungen lösen. Zwar nur relativ beschränkt und nicht mit einem echten CAS wie Maxima zu vergleichen, aber in vielen Fällen reicht es völlig aus. Bringt eine umfangreiche und erweiterbare Sammlung aus Formeln und Konstanten mit. Kann Währungen umrechnen (Kurse  aus dem Internet aktualisierbar). Kann Funktionen plotten wenn gnuplot installiert ist. Kann auch mit komplexen Zahlen, Vektoren und Matrizen rechnen. Verschiedene Zahlensysteme, Zeit-Arithmetik, Datums-Arithmetik. Kann vor allem auch mit Einheiten rechnen - weiß etwa dass 5 Volt mal 2 Ampere 15 Watt ergeben. Enthält auch Datensets, etwa für chemische Elemente und Planeten. All dies ist erweiterbar - Datensets als CSV-Dateien und Formeln, Konstanten und Funktionen könne im eingebauten Editor bearbeitet werden. Enthält neben der GUI-Komponente auch noch eine Kommandozeilen-Version welche dasselbe kann, aber aus Scripten heraus aufgerufen werden kann. Die verfügbaren Operatoren erlaubten darüber hinaus auch grundsätzlich das Verfassen von Programmen/Scripten, da sowohl Schleifen als auch Variablenzuweisungen und Verzweigungen zur Verfügung stehen. Seit neuestem kann es auch Datumsangaben zwischen verschiedenen Kalendersystemen umrechnen, etwa dem christlichen und hebräischen, chinesischen oder koptischen. Es gibt eigene Ansichten für die Periodentabelle, Prozentrechnen, Einheiten- und Zahlensystem-Konvertierungen. Ein RPN-Modus ist ebenfalls vorhanden. Eine geringe aber etwas ärgerliche Einschränkung ist dass man nur das Zahlenfeld oder die History anzeigen kann, aber nicht beides zugleich. Zwar kann kann man mit einem Mausklick zwischen beidem umschalten, aber den muss man dann auch jedes Mal tätigen. Bei der Tastatureingabe ist dies allerdings kein Problem, da man dann eine Kommandozeilen-History-Funktion mit den Cursor-hoch/hinunter-Tasten zur Verfügung hat.
qasmixer-0.23.0-1/sound/debian {audio}{GUI}{X11}: Ein grafisches Mixer-GUI für ALSA. Mit Qt implementiert. Riesige Sliders und Buttons, welche allerdings auch für kleinere Fenstergrößen skaliert werden. Neben den Slidern sind auch die numerischen Werte angezeigt, allerdings nur als Db-Werte. Grafisch etwas überladen, aber komfortabel.
qdbm/dev-db/gentoo {key/value store}: Can do the same as the traditional dbm, gdbm, bdbm or berkdb packages; i. e. provide file-based storage for hash-tables and an access API. qdbm can emulate all (most?) features of the beforementioned traditional packages by providing compatible APIs (but from differently named header files). However, this is only an API-level compatibility; qdbm uses a completely different on-disk format. It also provides several proprietary APIs which provide additional features. Summing up, qdbm provides files containing hash-tables or B+ trees, and can also split the contents of each such file into several different files within a directory to overcome per-file size restrictions of the operating system. The total resulting size of each logical database file can be up to 1 TiB. Besides the usual C API, command line tools are provided which allow to also exploit most of the library's capabilities from within simple shell scripts. Another important difference between qdbm and the other packages is its license: It uses the LGPL which also allows it to be used in closed source projects if desired - which is strictly prohibited by the other packages.
qdiskusage-1.0.4/sys-apps/gentoo: Zeigt nicht den Füllstand von Partitionen an, sondern visualisiert den belegten Platz innerhalb eines gegebenen Unterverzeichnisbaums als (2D-) Tortendiagramm. Qt-basiert. Leider ist das Programm dabei so dämlich dass es sich offenbar von Symlinks herein legen lässt - bei meinem Versuchen lief es jedenfalls offenbar in eine Endlos-Schleife und las dieselben Verzeichnisse immer und immer wieder ein. Unbrauchbar, zumindest in dieser Version. Dafür aber dennoch ganz nett aussehend und auch sehr klein.
qemu-0.9.0/app-emulation/gentoo: Netter Emulator mit geringem Installationsumfang, der auch andere CPUs als die native emulieren kann. Nachteil dieser Version: Kann nur auf GCC < Version 4 übersetzt werden.
qemu-utils-1: 2.8+dfsg-6+deb9u8/otherosfs/devuan: Enthält unter anderem die Hilfsprogramme qemu-img (kann qcow2-Disk-Abbild-Dateien erzeugen und bearbeiten, wie etwa Snapshots verwalten - kann jedoch auch fremde Abbild-Formate konvertieren, konkret bochs, cloop, dmg, gluster, iscsi, luks, nbd, nvme, qcow, qed, quorum, raw, rbd, vdi, vhdx, vmdk, vpc, vvfat), qemu-io (keine Ahnung, völlig wirre Beschreibung) und "qemu-nbd". Letzteres leistet dasselbe wie Versionen des von QEMU völlig unabhängigen "nbd-server" Programms, aber es unterstützt wahlweise die alte (vor NBD 3.11, dies ist der Default) und neue (optional) Version des NBD-Protokolls. Nur im Zusammenhang mit QEMU-VMs als Protokoll-Clients unterstützt es optional auch ATA TRIM und Sparseness sowie das Laden vom Snapshots in qcow2-Datenträger-Abbild-Dateien. In jedem Fall kann das Programm optional eine temporäre Datei anlegen in welche alle Schreibzugriff auf das freigegebene Abbild umgelenkt werden und das beim Beenden wieder gelöscht wird. So kann man auch Read-only Datemträger-Abbilder exportieren, und der Client kann temporär scheinbare Schreibzugriffe darauf durchführen, wenn man dies wünscht.
qgis-2.14.11+dfsg-3+deb9u1/science/raspbian {3D}: Ein ganz großartiges in Python und C++ geschriebenes GIS-Programm, das eine Vielzahl von Vektor- und Rasterkartenquellen benutzen kann, sowohl Online-basierte als auch lokal abgespeicherte. Versteht zu diesem Zweck eine Vielzahl von Datenformaten und XML-Spezifikationen zur Kartendefinition, darunter auch basemap.at und OpenStreetMap. Hat ein Qt5-basiertes GUI das - vermutlich - alle Stückerln spielt, ist zugleich aber auch ein elendsfettes Programm welches sich am Raspberry Pi zumindest bei basemap.at bereits beim Versuch aufhängte, auch nur die Übersichtskarte für Österreich von basemap.at anzeigen zu wollen. Das Programm hat auch viele Plugins, mit denen man zusätzliche Funktionalitäten wie Routing und Analysen aller Art durchführen kann. Zusammen mit gpsbabel kann es auch GPS-Tracks und Karteninformationen zusammenführen. Unterstückt am Backend auch diverse Datenbanksysteme, wie PostgreSQL und MySQL. Allerdings sind diese keine zwingende Abhängigkeit des Programms - ich vermute es kann intern auch mit den geometrischen Datentypen von SQLite3 auskommen. Vermutlich das beste Programm wenn man es mit GIS "ernst meint" und Karten auch bearbeiten oder neu Erstellen will. Nur fürs Anzeigen von Karten erscheint es mir mit rund 250 MB Installationsumfang aber deutlich zu fett.
qgis-3.10.14+dfsg-1/science/debian {GIS}: Ein Qt-basierter grafischer Manager für GIS-Dateien und -Datenbanken. Kann sowohl Vektor- als auch kachelbasierte Bitmapdaten verwalten. Ebenso DEM-Daten (separat gespeicherte Höheninformationen). Kann eine Vielzahl von GIS-Datenformaten lesen/schreiben sowie PostgreSQL-basierte "PostGIS"- und SQLite-basierte "SpatiaLite" Datenbanken benutzen. Auch MS SQL und DB2 Datenbanken werden unterstützt. Überdies scheint das Programm die geografischen Daten auch editieren zu können. OSM-Daten scheinen nicht direkt verwendet werden zu können, aber vermutlich ist dies indirekt möglich wenn sie bereits in eine PostgreSQL/SQLite-Datenbank importiert wurden. Neben seinem nativen Format wird der Import von AutoCAD-Vektordaten im DXF und DWG-Format unterstützt.
qgit-2.6-1/vcs/devuan {version control}{Qt}: Download 400 kB, installiert 1,1 MB. Scheint eine Qt4-Version eines git GUIs so sein. Ist noch stärker als gitg an der originalen Tcl-Version orientiert, aber natürlich ungleich hübscher. Wobei "orientiert" fast noch eine Untertreibung ist, das Ding wirkt teilweise 1:1 nachprogrammiert. Es wird vom vom Projektmodul des "kate"-Editors direkt unterstützt. Ein Nachteil scheinen unverständlicher Weise Probleme mit Umlauten zu sein, wo es Ersatzzeichen anzeigt. Das sollte bei einer Qt-Anwendung eigentlich wirklich kein Problem mehr sein! Außerdem zeigt es beim Eingeben des Commit-Kommentar zwar die Spaltenposition an, warnt aber nicht wenn die Zeile zu lange wird.
qiv-2.3.3-1/graphics/raspbian {graphics image viewer}: Ein in GTK+ implementierter sehr kleiner Bildbetrachter. Unterstützt alle Bildformate der "libimlib2", was alle relevanten klassischen und auch die meisten relevanten neuen Formate sins. Download-Größe 154 kB (2023, raspios).
qmmp-1.6.2-1/sound/raspbian {media-player}: Ein sehr an den WinAMP und XMMS erinnernder Music Player. Wirkt auf den ersten Eindruck recht vollständig. Das Programm kann alles was man von einem Audio-Player erwartet, und unterstützt auch alle populären Backends wie ALSA, PulseAudio, Pipewire, JACK, DiskWriter, Icecast usw. Auch optionaler spezieller GNOME-Support wie UDisks und Sleep Inhibition wird unterstützt. Das Programm funktioniert jedoch auch unter minimalen WMs wie der Fluxbox gut. Auf den 2. Blick störten mich dann aber doch ein paar Dinge: In der Media-Library scheint es nur eine fixe 3-stufige Darstellung zu geben. Insbesondere gibt es keine flache Anzeiger nach Liedtitel oder Dateinamen sortiert. Das Programm kann Metadaten aus dem Internet holen, jedoch ist unklar wann genau das geschieht. Ich möchte nicht dass der Player vielleicht vor jedem Abspielen irgend eines Titels einem Server im Internet davon brühwarm berichtet. Während ich mir hier Sorgen wegen möglicherweise zu vielen Internet-Zugriffen machte, hatte ich bei Album-Covers und Songtexten das genaue Gegenteil: Ich bekam nie welche zu sehen. Einzig eine manuelle Möglichkeit lokale eine JPEG-Datei als Cover-Abbild zu laden fand ich. Gegenüber dem VLC sehr ich daher eigentlich eher wenige Vorteile, auch wenn das Programm möglicherweise ressourcenschonender sein mag da es ja nur ein Audio-Player ist. Zumindest bei einem Kurztest bestätigte sich dies auch: qmmp verwendete "nur" 105 MB RAM, vlc hingegen 256 MB in einer ähnlichen Konfiguration. Bei einem RPi0 sollte man dem "qmmp" daher durchaus eine Chance geben. Außerdem ist der Player mit 3 MB Download-Umfang auch einigermaßen kompakt, zumal dabei viele Plugins vorinstalliert werden welche nicht alle standardmäßig aktiv ist. Auf Rechnern mit deutlich mehr als 2 GB RAM scheinen die Vorteile des qmmp aber zu gering, um die Installation eines zusätzlichen Media-Players zu rechtfertigen.
qpdf-2.3.1/app-text/gentoo {PDF}: Ein Kommandozeilentool zum Ändern der Sicherheitsoptionen und der Komprimierung von bestehenden PDF-Dateien. Ein besonders nützliches Feature ist, dass man mittels "qpdf --decrypt current_protected.pdf new_unprotected.pdf" DRM-Beschränkungen aus PDF-Dokumenten entfernen kann, die sich zuvor zwar anzeigen, aber nicht drucken, editieren etc. ließen. Das Dokument wird dabei sogar noch etwas kleiner! Weiters kann qpdf auch Seiten aus PDF-Dokumenten extrahieren oder in andere Dokumente importieren. Es kann die Reihenfolge der Seiten ändern. Man kann verschiedene Erlaubnis- und Verschlüsselungsoptionen (AES-256 als stärkste) auswählen, wobei es eine gewisse Überschneidung mit app-text/pdftk gibt. Allerdings scheint man im qpdf die Verschlüsselungs-Parameter in detaillierterer Form spezifizieren zu können. Was die Komprimierung angeht, kann man hier im wesentlichen zwischen der "Web Optimized"-Form (was zu Datenduplikation führen kann) und der nicht-weboptimierten Form konvertieren zu können. qpdf kann nur Änderungen auf der ebene kompletter PDF-Dateien durchführen; nicht auf Einzelseiten. Mit rund 1,5 MB Installationsumfang gehört es zu den schlankeren PDF-Editoren.
qpdfview-0.4.17~beta1+git20180709-2/graphics/debian {document viewer}{PDF}{Qt}: Ein Qt-basierter Betrachter für PostScript-, PDF- und DejaVu-Dateien. Diese können zudem als .gz-Datei komprimiert vorliegen. Unterstützt - konfigurierbar - Anti-Aliasing und Text-Hinting. Kann mehrere Dateien mit Tabs geöffnet haben. Konfigurierbare Tastenkürzel. Optionale Seitenleiste für Dokumenten-Gliederung (oder nur einfach Seitennummern bei nicht gegliederten Dokumenten), Dokument-Eigenschaften, Vorschaubilder der Dokument-Seiten sowie für benutzerdefinierte Lesezeichen. CPUS-Integration zum Ausdrucken des angezeigten Dokuments. Vollbild- und Präsentations-Modus vorhanden. Ansichts-Modi: Fortlaufend (oder seitenweise), zweiseitig (immer 2 Seiten neben einander), zweiseitig mit Titelseite (die erste Seite wird allein dargestellt, alle folgenden Seiten zweiseitig), mehrere Seiten (neben einander, die Anzahl ist einstellbar, per Default 3), von links nach rechts (ändert die Reihenfolge bei der "mehrere Seiten"-Ansicht). Anpassing an Seitengröße oder -breite möglich. Rotieren in 90-Grad-Schritten. Farben können ignoriert, in Graustufen umgewandelt oder an die Papierfarbe angepasst (?) werden. Leere Randbereiche können (separat für jede Seite) automatisch erkannt und in der Anzeige weggeschnitten werden. Mit Maustasten und Mausrad können zusammen mit konfigurierbaren Modifikator-Tasten ([Umschalt] etc.) folgende Funktionen ausgelöst werden: Skalieren, rotieren, Bildlauf, in Zwischenablage kopieren, Anmerkung hinzu fügen, Auswahl vergrößern, "Öffnen mit ..."-Funktion (? - vielleicht bei PDF-internen Anhängen). Eine Hilfe-Funktion ist eingebaut. Suchfunktion ist vorhanden. Als Anmerkungen stehen Hervorhebung (Leuchtstift samt optionaler Textanmerkung) und Textanmerkung (als anklickbares Symbol dargestellt) zur Verfügung. Beide Formen der Anmerkung können durch Anklicken angezeigt und editiert werden. Außerdem wird die Textanmerkung in beiden Fällen als Tool-Tipp angezeigt wenn die Maus darüber bewegt wird. Was nicht vorgesehen ist, ist das Verschieben der Textbox welche den Anmerkungstext zum Editieren anzeigt. Man kann in diesem Fall nur die Anmerkung löschen und erneut an einer anderen Position anlegen. Lesezeichen können optional nur temporär sein, oder beim Schließen des Dokuments in eine lokale Datenbank abgespeichert werden, wobei sie automatisch geladen werden wenn das Dokument erneut geöffnet wird. Die Anmerkungen werden hingegen im Dokument gespeichert, wozu man es allerdings explizit speichern muss (also nicht etwa automatisch). Man kann sie danach auch mit Okular editieren. qpdfview belegt für dasselbe Dokument ca. 11 % mehr RAM (RSS) als Okular. Wenn man allerdings das PSS betrachtet, benötigt qpdfview 28 % weniger RAM als Okular. Mit anderen Worten, beide Programme spielen in einer ähnlichen Fettheits-Liga, wobei qpdfview das etwas schlankere ist. Außerdem ist qpdfview kein KDE-Programm, und startet daher nicht die KDE-Launcher-Prozesse im Hintergrund (welche danach weiterlaufen bis man sie explizit beendet). qpdfview befindet sich im Ressourcenverbrauch daher zwischen Okular und mupdf, und stellt somit einen guten Kompromiss beim Ressourcenverbrauch dar. Das Blättern mit den Seite auf/ab Tasten funktioniert dabei sehr viel besser als bei mupdf. Die Leertaste hingegen springt immer gleich zur nächsten Seite - unbrauchbar, außer wenn die dargestellten Seiten immer zur Gänze zu sehen sind.
qps-1.9.18.6-2.3/x11/debian: Eine von LXDE empfohlene Alternative zu lxtask, das nicht mehr weiterentwickelt wird sobald LXDE zu Qt gewechselt hat. Leider funktioniert dieses Programm zumindest unter Raspbian überhaupt nicht - terminiert sofort mit einem Fehlercode. Außerdem wird es angeblich nicht mehr weiter entwickelt.
qrencode-3.4.3-1/utils/debian: Erzeugt QR-Codes entweder als Grafiken (PNG, EPS,S VG) oder aus Leerzeichen mittels Steuer-Befehlen von ANSI-Terminals, welche die Hintergrundfarbe der Textausgabe umschalten. Weiters können UNICODE-Blockgrafik-Zeichen zur Ausgabe von QR-Codes auf der Konsole verwendet werden. Auch die Kombination von UNICODE-Blockgrafik-Zeichen und ANSI-Farbsteuerbefehlen wird unterstützt. Schließlich können noch ASCII Raute-Zeichen für die Ausgabe auf ein dummes Terminal verwendet werden, optional auch invertiert (wenn das Terminal helle Zeichen auf dunklem Hintergrund darstellt). Die Darstellung ist dabei gut genug, dass ein Smartphone den QR-Code immer noch lesen kann, wenn man es nur weit genug vom Bildschirm entfernt hält. Im Falle der Grafikausgabe kann die Grafik auch direkt auf die Standard-Ausgabe geschrieben werden, womit sie durch weitere Filter wie "display" vom ImageMagick zur sofortigen Anzeige umgeleitet werden können. Es gibt des weiteren ein Plug-In für text/asciidoc, welches die Erzeugung von QR-Codes direkt aus asciidoc-Quelltextdokumenten heraus erzeugt.
qt-creator-1.2.1/dev-util/gentoo, qtcreator-4.2.0-1/devel/devuan {development_environment}{Qt}: Sehr nette IDE für C/C++. Hat zwar spezielle Features für die Entwicklung von Qt-Programmen, kann aber eben so gut auch normale Makefile-basierte Kommandozeilen-Applikationen entwickeln. Im Gegensatz zu KDevelop ist diese IDE nicht von KDE-abhängig, obgleich es optionalen KDE-Support in den Installationsoptionen gibt. Der integrierte Editor beherrscht sowohl weichen Zeilenumbruch als auch Anzeige der maximalen gewünschten Zeilenlänge. Auch Code Folding beherrscht er besser als die Konkurrenz. Er beherrscht auch das Parsen von C/C++ Symbolen und kann per Pull-Down-Menü und einen mehrstufigen Pop-Up-Filter die Definitionen anspringen. Seltsamerweise scheint es keinen Symbol-Browser zu geben der die Symbole aus dem Pull-Down-Menü kombiniert darstellt. Leider hat der Editor nur Syntax-Highlighting-, Folding- und Browsing-Support für C/C++, aber für keine anderen Sprachen. Weitere Features sind Keyword-Autocompletion, Bookmarks, optionale git/Subversion/cmake Integration (obgleich "native" Projekte qmake-basiert sind), und natürlich jede Menge spezifischer Features für die Qt-Entwicklung. Die Organisation ist zweistufig: Eine Session gruppert mehrere Projekte, und Projekte gruppieren zusammengehörige Source-Files und Build Targets. Out-Of-Source-Directory Builds werden unterstützt. Ein großes Manko zumindest der Version 1.x ist die Tatsache, dass der Debugger zwar alles sehr schön in Fenstern anzeigt, aber es gibt keine GDB-Konsole wo man für kompliziertere Fälle direkt auf die GDB-Kommandos zurück greifen kann. Das macht diesen Debugger eher zu einem "Schönwetter-Debugger", als für irgend etwas das man bei komplexeren Audrücken welche Casts erfordern gebrauchen könnte. Außerdem ist diese IDE zwar von KDE unabhängig, doch wenn man sich den Größenvergleich ansieht bringt dies offenbar nicht viel: KDevelop-4: 7 MB, Qt-Creator-1: 20 MB. OK, mag sein dass einiges bei KDE in anderen abhängigen Paketen versteckt ist. Aber dennoch. Zum Kennenlernen von Qt-Entwicklung in C++ dürfte Qt-Creator zwar wirklich toll sein. Aber für alles andere bietet er mir einfach nicht genug!
qt5-assistant-5.15.8-2/devel/raspbian: Enthält den Standalone-Dokumentations-Browser "assistant", welches erforderlich ist Qt 5 Dokumentation im proprietären "*.qch"-Format anzeigen zu können.
quake2-63/contrib/games/debian {game}: Ein sauberer Port von Quake 2. Flüssig auch in hohen Auflösungen selbst mit integrierter INTEL Onboard-Grafik und höchsten Grafik-Effekteinstellungen. Verwendet die Original-Leveldateien welche man zusätzlich besorgen muss. Die Texturen werden hochgerechnet und geglättet, was zwar etwas matschig wirkt aber wenigstens kein Kopfweh befürchten lässt wie bei Crispy Doom. Sehr gut gelungen.
quake2-icculus-0.16.1-r1/games-fps/gentoo {game}: Sollte ein passabler Port von Quake-2 sein - doch es gibt mit meinem (veralteten) fglrx-Treiber Probleme; das Spiel funktioniert zwar, jedoch mit Grafikfehlern/"Hängern" die es unbrauchbar machen. Eventuell mit einem neueren Kernel und fglrx-Treiber neu versuchen. Das Spiel an und für sich wäre durchaus nett. Man braucht allerdings eine Kopie des kommerziellen Original-Spiels, da die Ressourcen-Dateien von diesem verwendet werden und in ein bestimmtes Verzeichnis kopiert werden müssen.
quakespasm-0.93.1+dfsg-1/games/debian {game}: Ein sauberer Port von Quake (Quake 1; das Originalspiel). Verwendet die Original-Leveldateien welche man zusätzlich besorgen muss. Die Texturen werden hochgerechnet und geglättet, was zwar etwas matschig wirkt aber wenigstens kein Kopfweh befürchten lässt wie bei Crispy Doom. Außerdem fällt die Matschigkeit deutlich weniger auf als bei Quake 2, da die Levels allgemein so dunkel gehalten sind. Sehr gut gelungen.
quanta/kde-base/gentoo: Ein HTML-Editor der Luxusklasse. Leider auch sehr fett und aufgeblasen. Aber er liefert Kontext-Hilfe für alle HTML-Elemente, stellt deren Optionen in hübschen Dialogen dar, und beherrscht WYSIWYG-editieren. Wahrscheinlich eher etwas für "Vollprofi"-Web-Designer die Zeit haben sich wochenlang in dieses komplexe über-drüber-Tool einzuarbeiten, als den Gelegenheits-Bearbeiter von HTML-Seiten.
queen/games-rpg/gentoo {game}: Ein typisches 90'er Jahre Lucasarts Point-And-Click-Adventure. Leider auch mit der Grafik der 90er Jahre; sprich geringe Auflösung und vielleicht 256 Farben. Aber inhaltlich top. Dennoch - nach heutigen Maßstäben... Basiert wie viele derartige Konversionen auf der SCUMM-VM, d. h. arbeitet mit Original-Daten. Dennoch frei.
racket/lisp/debian plt-scheme/dev-scheme/gentoo {programming language}{development_environment}{GUI}{X11}: Eine IDE, mit Debugger, Interpreter und Compiler für die Programmiersprache SCHEME. Besonders gut: Die zahlreichen Tutorials und gute Dokumentation, die beiliegt. Auch wenn man eigentlich nur LISP lernen wollte, ein guter Einstieg wegen der guten beiliegenden Offline-Dokumentation. Mit rund 80 MB für eine Vollinstallation (30 MB davon davon Dokumentation) jedoch nicht gerade klein.
radare-gtk-1 {hex-editing}: 1.5.2-4/devel/debian: Ein GTK+-Front-End für den Hex-Editor/Code Analyzer "radare". Sehr nett. Hat nur einen Haken: Wenn man auch nur das lächerlichste "Hello, World" damit öffnet, beginnt er zu analysieren und anaylsieren und analysieren... bis man die Geduld verliert und das Programm beendet. Ansonsten wäre es möglicherweise noch als Hex-Editor zu gebrauchen, aber da gibt es wahrlich schlankere Lösungen. Unbrauchbar. Außerdem basiert es noch auf der Version 1 von Radare, während der Rest der Welt Version 2 verwendet. Es gibt auch bereits ein GTK+-Front-End für r2, allerdings nicht im derzeitigen Raspbian-Repository (Stand 2017-08).
radicale-0.7.1/app-office/gentoo: Ein simpler und kleiner in Python geschriebener CalDAV- und CardDAV-Server. Der Server arbeitet mit vielen Kalender- und (e-Mail-Programm-) Adressbuch-Clients auf vielen Betriebssystemen zusammen, welche über solch einen Server ihre Einträge unter einander synchronisieren können.
rafkill/games-action/gentoo {game}: Galaga-ähnliches Spiel mit vielen Waffen und mit Punkten erkaufbaren Extras. Relativ große Schiffe. Man sieht immer nur eine Ausschnitt des gesamten scrollenden Spielfeldes (ein Radarschirm zeigt den Rest). Alles OK, außer dass die Grafikobjekte irgendwie etwas plump designt wirken. Aber damit kann man leben und es stört den Spießspaß nicht wirklich. Zumal dies eine der wenigen Galaga-ähnlichen Spiele ist, die problemlos Fullscreen funktionieren.
ranpwd/admin/gentoo: Erzeugt nur 8-Zeichen Passwords, und das schweinelangsam. Sehen aber halbwegs nett aus.
raspberrypi-firmware 20151010-1/alarm/archlinux: Ein Metapaket, welches die Installation von aller anderen Pakete erzwingt, welche mit diesem Paketnamen als Präfix beginnen.
raspberrypi-firmware-bootloader 20151010-1/alarm/archlinux: Enthält die Firmware-Dateien des Bootloaders; das sind die *.elf, *.dat und *.bin-Dateien in /boot. Was es nicht enthält, sind die Konfigurationsdateien oder das Device-Tree-Overlay. Die in diesem Paket enthaltenen Dateien werden für alle Modelle des Raspberry Pi zum Start benötigt.
raspberrypi-firmware-bootloader-x 20151010-1/alarm/archlinux: Enthält zusätzliche experimentelle mittels der GPU Hardware-beschleundigte Codecs in der Firmware-Datei "start_x.elf". Das sind zumindest solche für MJPEG (Motion-JPEG), VP6 (*.flv), Google VP8 (*.webm), Ogg Theora (video) und Ogg Vorbis (audio). Der omxplayer kann dann diese zusätzlichen Formate wiedergeben. Die Video-Codecs darunter unterstützen allerdings nur "Standard Definition" und keine "High Definition"-Auflösungen. Außerdem scheinen sie teilweise buggy zu sein und spielen nicht immer jede korrekte komprimierte Datei ab. Der MJPEG-Codec ist zudem auch ohne dieses Paket in den Standard-Bootloader-Dateien (konkret in start.elf) enthalten. Um die Codecs in diesem Paket freizuschalten, sind die folgenden Einträg in der config.txt erforderlich: "start_file=start_x.elf" und "fixup_file=fixup_x.elf". Überdies sollte man der GPU 128 oder sogar 256 MB RAM geben, zumindest war das eine Empfehlung die ich las wenn es bei der Wiedergabe Probleme gäbe und nur ein schwarzes Bild gezeigt würde. Kommt mir unglaubwürdig vor, da der nicht minder komplexe h.264 Codec mit 72 MB auskommt.
raspberrypi-firmware-examples 20151010-1/alarm/archlinux: Das sind Beispiel-Programme mit Quelltexten, welche in /opt/vc/src/hello_pi installiert sind. Obgleich teilweise lustig anzusehen bzw. als (eher bescheidene) "Demos" der Grafikfähigkeiten geeignet, sind keinerlei nützliche Programme darunter. Insbesondere ist die Hardware Video Encoding Applikation *nicht* darunter, die unter Raspbian in diesem Verzeichnis installiert war.
raspberrypi-firmware-tools 20151010-1/alarm/archlinux: Enthält Tools für die Video-Hardware des Raspberry Pi, welche in /opt/vc installiert ist. Das umfasst sowohl binaries um Kommandos an die GPU zu schicken oder Informationen aus der GPU anzufragen, die EDID-Informationen des Monitors auszulesen, sowie das externe Kameramodul des Pi anzusteuern. Ebenfalls enthalten sind diverse Header-Files im Zusammenhang mit der Display-Hardware, beispielsweise für OpenGL ES.
raspi-config-20160322/utils/debian {text-terminal IO}: Ein "komfortables" Konfigurations-Tool für den Raspberry Pi. Im wesentlichen ist es ein Shell-Script mit Text-Mode-Dialogen, welche diverse Basics vom User abfragen und dann entsprechende Änderungen an Konfigurationsdateien vornehmen. Nichts was man nicht auch selbst machen könnte... wenn man wüsste wie es geht. Vor allem was Overclocking und ähnliche Dinge angeht, kennt das Script geeignete Frequenzen die man sonst im Internet zusammensuchen müsste. Empfehlung: Zwar installiert lassen um im Script nachsehen zu können, aber keinen der damit verbundenen Services starten und das Script auch niemals aufrufen, damit es einem nicht die aktuelle Konfiguration versaut. Wenigstens ist es nicht groß!
ratpoison/x11-wm/gentoo {window manager}{GUI}{X11}: Funny - it works almost like GNU "screen". However, it's panel reuse-algorithm can drive one mad. Best to be used with full-size windows only.
razorqt-0.4.1-r2/x11-wm/gentoo {window manager}{Qt}: Eine minimalistische Desktop-Oberfläche, die auf Qt aufbaut und angeblich sehr ressourcenschonend sein soll. Razor enthält keinen Fenstermanager sondern benutzt andere, wie KWin, Metacity oder xfwm4. Derzeit hat hat Razor nur eine einzige Leiste, die man an einem der Fensterränder anordnen kann, und dann mit einer ärmlichen Handvoll Plugins bestücken kann. Derzeit gibt es nur die grundlegendsten Plugins, wie Fensterleiste, Anwendungsmenü, Arbeitsflächenumschalter, Uhr und "Desktop Anzeigen". Sicher kommen später noch mehr dazu. Als "Plasmoid"-ähnliche Widgets für den Desktop sind vorhanden; derzeit nur eine Analog-Uhr und der Inhalt eines auswählbaren Directories, welches dann in File-Manager-Manier in einem editierbaren Bereich am Desktop angezeigt wird. Auch hier kommt später sicher noch mehr dazu. Weiters kann man auch Startbuttons für Anwendungen zum Panel hinzu fügen. Das ist auch schon so ziemlich alles, was Razor derzeit kann - also fast nichts. Andererseits bietet es damit zumindest ähnliches wie die anderen minimalen WMs, nur mit dem Unterschied dass man bei Razor keinen WM dabei hat! Offensichtlich ist der Sinn des Projektes eine schlankere Alternative zu KDE zu werden; optisch sieht es KDE3 recht ähnlich. Es sieht freundlich aus und könnte später einmal, wenn es mehr Plugins gibt, zu einer interessanten Alternative werden. Derzeit reicht es an Xfce aber noch nicht heran; am ehesten ist es ein Konkurrent für LXDE (welches allerdings momentan deutlich mehr Plugins hat). Fazit: Derzeit praktisch uninteressant, aber man sollte es im Auge behalten und in ein paar Jahren noch einmal evaluieren.
rc-gui-1.12/admin/debian: Irgend ein grafisches Konfigurationswerkzeug (in GTK+ geschrieben). Leider lässt es sich nicht mehr starten wenn man den vordefinierten User "pi" entfernt hat oder es gewagt haben sollte, den "lightdm" Display Manager zu entfernen. Was ich getan hatte. Aus den Betrachten einer Ressourcen-Datei kann man aber vermuten, dass dieses Werkzeug (zumindest) die folgenden Funktionen bieten würde: Das Dateisystem vergrößern, offenkundig für den Fall dass ein kleineres Image auf eine größere SD-Karte kopiert worden war. Die Locale anpassen. Passwort ändern. Auflösung einstellen. WiFi-Landescode setzen. Wenn das wirklich alles war, ist dieses Paket so unnötig wie ein Loch im Knie!
rclone-1.45-3/net/debian {deduplication}{compression}{FUSE}{dirtree sync}: Eine Art "rsync für die Cloud". Multi-Plattform, unterstützt alle weitverbreiteten Betriebssysteme. Laut Wikipedia nutzt es anders als rsync aber keinen Delta-Algorithmus auf Block-Ebene, sondern überträgt ganze Dateien als kleinste Einheit der Synchronisation. Allerdings dürfte es zumindest so wie wget in der Lage sein, unterbrochene Downloads fortzusetzen. Außerdem kann es aufgrund von Hashes und Modifikationsdatum zumindest entscheiden, ob eine Datei an Server sich überhaupt geändert hat und deswegen neu herunter geladen werden muss. Ebenso dürfte das Herunterladen von kompletten Dateien vermieden werden wenn man lokal bereits eine mit identischem Hash besitzt. Weiters unterstützt es keine Dateiattribute (Owner, Permissions, Hard Links etc.) und scheinbar auch weniger mächtigere Selektionsfilter als rsync. rclone ist in "Go" geschrieben. Unterstützt die folgenden OpenSource-basierten wie auch kommerziellen Cloud-Dienste sowie auch einige Nicht-Cloud-Dienste als Gegenseite der Synchronisation: Amazon Drive, Amazon S3, Backblaze B2, Box, Ceph, DigitalOcean Spaces, Dreamhost, Dropbox, FTP, Google Cloud Storage, Google Drive, HTTP, Hubic, Jottacloud, IBM COS S3, Memset Memstore, Mega, Microsoft Azure Blob Storage, Microsoft OneDrive, Minio, Nextcloud, OVH, OpenDrive, Openstack Swift, Oracle Cloud Storage, ownCloud, pCloud, put.io, QingStor, Rackspace Cloud Files, SFTP, Wasabi, WebDAV, Yandex Disk, the local filesystem. Wenn man es selbst bauen möchte wird es wegen der vielen Abhängigkeiten sehr fett - zumindest 80 MB Downloads zu erwarten. Das Utility vereint viele Unterkommandos in einem einzigen Commandline-Frontend. Zweifelsohne gibt es auch grafische Shells dafür. Darunter auch ein Kommando zum Deduplizieren von identischen Dateien. Ein anderes listet die Hashes der Remote-Dateien auf. Das funktioniert aber nur wenn auf der Gegenseite ebenfalls ein rclone läuft welches dann als "smart server" fungiert. Grundsätzlich operiert rclone normalerweise in Einheiten von Verzeichnisbäumen, die synchonisiert, hoch- oder heruntergeladen werden sollen. Es bietet darüber hinaus auch die Möglichkeit, die Gegenseite als FUSE-Dateisystem zu mounten. Also in der Regel ein Netzwerkdateisystem. Möglicherweise macht rclone damit davfs2 obsolet. Leider unterstützt es aber bei WebDAV nur "dummes" Herunterladen ohne das Beachten von Prüfsummen, und nicht einmal die Änderungszeit der Dateien kann synchronisiert werden. Ansonsten ist die Übertragung als "chunks" grundsätzlich aber unterstützt da es Optionen dafür gibt. Jedoch wird dies offensichtlich nicht zur Deduplikation genutzt, sondern dient eher dazu dass bei Datenbanken nicht ständig die ganze Datenbank kopiert werden muss nur weil ein Datensatz darin sich geändert hat. Etliche der Befehle beschäftigen sich mit der Verwaltung eines lokalen Caches (sowohl auf Disk als auch im RAM), sowohl für Dateien als auch für Directories. Zumindest für HTTP-Verbindungen kann rclone auch als "Smart Server" fungieren. Automatische Verschlüsselung von hochgeladenen Inhalten und automatische Entschlüsselung von heruntergeladenen Inhalten wird unterstützt. Unklar ist wie das genau bewerkstelligt wird und wie sicher es daher sein kann. Grundsätzlich ergibt sich der Eindruck, dass rclone in der Tat im Wesentlichen ein eingeschränkter Klon von rsync mit inkompatiblem Protokoll aber dafür vielen Backends ist. Aber auch hier ist es immer erforderlich dass auch am Server eine Instanz von rclone läuft, da man sonst auf die "Smart"-Features wie Erkennen von (zur Gänze) identischen Dateien verzichten muss. Es ist also kein Ersatz für zsync. Oder auch nur für die Bandbreiten-Erparnis von rsync dank dessen Deduplikations-Features. Andererseits dürften praktisch alle relevanten Hyperscaler rclone laufen haben, so dass man die Smart-Features dort nutzen kann. Auch wenn das Utility einen freundlichen Eindruck macht - schnell durchgelesen ist die man-Page trotzdem nicht: Sie ist über 600 kB lang! Andererseits ist sie im Wesentlichen in annähernd identische Abschnitte für jeden unterstützten Dienst unterteilt, so dass man üblicherweise nur einen kleinen Teil davon zu lesen braucht. Dennoch erweckt das Utility ein wenig den Anspruch von Gigantomanie.
rdfind-1.5.0-1.1/utils/raspbian {deduplication}: Ein in C++ geschriebenes und daher schnelles Utility zum Finden von Duplikaten und optionalem Ersetzen durch Symlinks oder Hardlinks in Verzeichnisbäumen. Alternativ können Duplikate auch gelöscht werden. Per Default wird nur eine Textdatei erzeugt in welcher über gefundene Duplikate berichtet wird. Eine Seltsamkeit des Programms sind seine non-standard langen Optionsnamen mit nur einem Dash. Allerdings sind diese damit ähnlich wie bei "find", was möglicherweise die Motivation dahinter war. Ein Nachteil ist dass die Dateiattribute ignoriert werden. Sollten zwei identische Dateien daher andere Owner oder Permissions haben, werden sie dennoch als Duplikate behandelt. Wenn einem das missfällt, sollte man statt dessen "hardlink" verwenden. Doch von letzteren gibt es leider unterschiedliche Implementierungen, so dass "rdfind" Distributionsübergreifend eine zuverlässigere Wahl ist. Ein Ärgernis von rdfind ist dass es per Default immer eine Textdatei mit den Vergleichsergebnissen anlegt, selbst wenn man die Dateien gleich hardlinken möchte. Zwar kann man dies abschalten, aber dazu muss man eine zusätzliche lange Option angeben. Ignoriert man diese Problematik einfach, bleibt die Ergebnis-Datei als Müll im Dateisystem zurück.
rdiff-2.3.1-1/utils/debian {binary-diff}: "rdiff" ist ein Signatur-basiertes binäres Diff/Patch-Tool. Es ist typischerweise weniger effizient als Delta-basierte Tools, hat allerdings einen großen Vorteil: Es erlaubt das Erstellen eines Patches welcher aus einer alten die neue Datei macht, ohne dass die alte Datei dazu vorhanden sein muss. Statt dessen muss nur eine "Signatur" derer vorhanden sein, welche viel kürzer als die alte Datei ist. Dieses ist nützlich um große Dateien die nur teilweise herunter geladen oder beschädigt wurden, wie etwa unvollständig heruntergeladene Bittorrent-Dateien, zu vervollständigen. Es kann aber auch genutzt werden ältere Versionen von Datenträger-Abbild-Dateien auf neuere zu aktualisieren, vorausgesetzt diese sind nicht komprimiert (oder einzig mit "gzip --rsyncable" komprimiert worden, siehe dazu weiter unten). Dabei erstellt man zunächst mit "rdiff signature" aus der unvollständigen Datei eine Signaturdatei, welche man auf denselben Rechner transferiert wo sich die vollständige befindet. Dort erzeugt man mit "rdiff delta" eine Datei welche nur die fehlenden Bestandteile enthält, und transferiert diese auf den Rechner mit der unvollständigen Datei. Dort wendet man mit "rdiff patch" das Delta auf die unvollständige Datei an, um die vollständige daraus zu erzeugen. rdiff ist allerdings nur effektiv wenn jeweils große zusammenhängende Bereiche vorhanden sind oder fehlen, da es nur Blöcke fixer (allerdings einstellbarer) Größe "signieren" kann, indem es Prüfsummen für alle Blocks in der Signaturdatei ablegt. Je kleiner die Blockgröße daher, desto größer die Signaturdatei. In die Delta-Datei werden nur jene Blöcke der vollständigen Datei kopiert, die nicht bereits durch die Prüfsumme eines Blocks in der Signaturdatei beschrieben werden. Im letzteren Fall wird nur die Prüfsumme des Blocks in die Delta-Datei geschrieben, denn der zugehörige Block befindet sich bereits in der unvollständigen Datei. Wenn es keine Unterschiede zwischen den beiden Dateien gibt, ist die Delta-Datei allerdings nicht komplett leer, jedoch nur wenige Bytes groß. Vermutlich ist in jedem Fall eine Prüfsumme oder irgendwelchen minimalen Metadaten darin enthalten. rdiff ist nur dann effektiv, wenn möglichst viele komplette Blöcke nicht in die Delta-Datei geschrieben werden müssen, da sie sich ihre Inhalte bereits irgendwo in der unvollständigen Datei befinden. Entsprechend wichtig ist eine geeignete Blockgröße für möglichst kleine Deltas: Ist sie zu klein, wird die Signaturdatei zu groß. Ist sie zu groß, werden nicht genügend übereinstimmende Blöcke gefunden. Überhaupt nicht geeignet ist rdiff zur Erzeugung von Deltas für bereits komprimierte Dateien. Sie sollten vor der Deltifikation entpackt werden. Mit einer Ausnahme: Einige bekannte Komprimierungsprogramme, konkret gzip und zstd, unterstützen eine "--rsyncable"-Option, welche die damit komprimierten Dateien "rsync"-freundlich macht. Und damit ist es auch rdiff-freundlich, denn beide Programme verwenden denselben "rsync"-Algorithmus. Im Vergleich des Synchronisieren von "--rsyncable"-komprimierter und unkomprimierter Version derselben Textdatei zeigte sich, dass bei der komprimierten die Signatur kleiner aber das Delta größer wird. In der Summe der Dateilängen war die komprimierte Version allerdings minimal kürzer. Es gibt leider verschiedene Binär-Versionen der erzeugten Dateien; Kompatibilität der ausgetauschten Signaturen und Deltas ist daher nur gegeben wenn beide Seiten kompatible Programmversionen verwenden. Für Langzeit-Backups is rdiff daher nur bedingt geeignet; man sollte dann zumindest notieren mit welcher Version des Programms die Dateien erstellt wurden. Ein Benchmark mit einem 4 MB großen Texdokument, aus dem zufällig 1 % der Zeilen (ca. 40 kB) entfernt wurden, ergab dass die Signatur-Datei ca. halb so groß wie die fehlende Datenmenge war (25 kB), und das erzeugte Delta ca. 100 x so groß (693 kB bzw. 1/6 der Originaldatei) wie die fehlende Datenmenge war. Man konnte daher zwar immer noch Datenvolumen bei der Übertragung einsparen, aber sehr viel weniger als bei anderen Binär-Delta-Programmen. Diese Werte gelten für die Standard-Blockgröße von 2 KiB. Kleinere Blockgrößen erhöhten die zu transferierende Dateimenge erheblich, größere verminderten sie kaum (Signatur + Delta zusammen waren um bestenfalls 20 kB kleiner). Bei 7 % gelöschter Zeilen änderte sich das, da war eine Blocklänge von 128 Byte die beste. Wurden hingegen nur 0,01 % gelöscht, waren 4 KiB bei der Blockgröße am besten und 2 KiB fast gleich gut. Beim Diffen zweier entpackter Linux-Kernelversionen (je ca. 800 MB an Quelltexten), erwies sich die Blockgröße von 192 Bytes am besten. Das ergab 160 MB Transfer-Volumen. Wenn man jedoch xz -9 darauf losließ, waren es nur noch 73 MB und mit lrzip -L9 -U -z schließlich 69 MB. Die Signaturdateien ließen sich dabei kaum komprimieren - kein Wunder sie enthalten ja fast nur Hashes. Die Deltas konnten dafür um so besser komprimiert werden. Es war zwar etwas effizienter die tar-Archive komplett zu extrahieren und sortiert neu zu packen, aber nicht nennenswert. Entpacken und dann das ganze tar diffen sollte also meist völlig ausreichend sein, wenn man nicht auch noch das letzte Byte einsparen will.
rdiff-backup-fs-1.0.0-5/utils/debian {backup}{FUSE}{deduplication}{compression}: Ein optionales Zusatz-Programm für rdiff-backup welches es erlaubt, eine ältere als die neueste Backup-Generation direkt als FUSE-basiertes virtuelles Dateisystem zur Verfügung zu stellen. Mit anderen Worten, man kann ein älteres Backup einfach mounten, anstatt sich mit den rdiff-Backup-Kommandozeilenbefehlen zum Wiederherstellen von Dateien herum schlagen zu müssen. Sicherlich nützlich wenn man häufiger Dateien aus Backups zurückholen muss, oder noch nicht sicher ist was man eigentlich genau zurück kopieren will. Besonders toll die einfach Nutzung: Einfach den Mount-Point und das Backup-Directory als Argumente angeben. Das FUSE-Dateisystem enthält dann in oberster Ebene das Datum des inkrementellen Backups, und darunter dann den Inhalt des entsprechenden Snapshots. Weitere Optionen sind normalerweise unnötig.
rdiff-backup/app-backup/gentoo {backup}{deduplication}{compression}: Speichert das letzte Backup immer als direkte gespiegelte Kopien des kompletten Verzeichnisbaums. Ältere Versionen der Dateien werden mit rdiff als Backward-Deltas in gzip-komprimierten Dateien gespeichert, die sich alle in einem einzigen speziellen Verzeichnis befinden. Sobald der Platz zur Neige geht, wird das älteste .gz-File mit Backward-Deltas gelöscht, bis wieder genug Platz für das nächste Backup ist. In Python geschrieben; auch netzwerkfähig. Das einzige Problem sind die User/Gruppennamen, da diese vielleicht am lokalen System eine andere Bedeutung haben als von dort woher das Backup stammt. Daher kann man entweder Mappings definieren, oder die IDs einfach speichern wie sie sind. (Dann kann allerdings unter Umständen nur der Administrator die Dateien lesen, da er sich über alle Dateirechte hinweg setzen kann.) Ein weiteres praktisches Problem ist der Umstand, dass Umbenennungen oder Verschiebungen von Dateien im Verzeichnisbaum nicht erkannt werden, und dann wie neue oder gelöschte Dateien behandelt werden und daher keine Deltas sondern Vollversionen gespeichert werden. Da andere Backup-Programmme bei inkrementellen Backups aber meist gar keine Deltas sondern immer nur Vollversionen speichern, ist dies zwar ärgerlich aber kein Nachteil anderen Programmen gegenüber. Neben dem eigentlichen Backup-Programm inkludiert dieses Paket über Abhängigkeiten auch das Signatur-basierte binäre Diff/Delta/Patch-Tool "rdiff".
rdup-1.1.15-1/utils/devuan {backup}{deduplication}{compression}: rdup ist (angeblich) kein Backup-Programm sondern erstellt nur Dateilisten von Dateien, welche ein Backup-Programm backuppen soll. Praktisch allerdings enthält diese "Dateiliste" in der Default-Einstellung auch den kompletten Inhalt der Dateien, so dass es praktisch eher eine Art "tar" ist. Die Intention für rdup war es, ein rsync-ähnliches Programm zu schaffen, welches aber die Dateien aber auch komprimiert und verschlüsselt in einer Archivdatei auf einem Remote-Server abspeichern kann. Es ist also ähnlich wie rsync, nur dass sich auf der Gegenseite keine Kopie des Dateibaums sondern eine optional verschlüsselte und komprimierte Archivdatei befindet. Die Übertragung auf einen Remote-Server kann das Programm entweder selbst mittels SSH durchführen, oder überläßt dies dem Anwender. rdup scheint allerdings nur äußerlich betrachtet die genannten Ähnlichkeiten mit rsync zu haben; insbesondere scheint es keine Delta-Kompression oder Deduplikation zu beherrschen. Andererseits steht es einem frei, die erzeugten "Listing"-Dateien (samt Dateiinhalten) selbst zu deltifizieren oder zu deduplizieren, bevor man sie auf einem Remote-Server ablegt. Grundsätzlich gibt es 3 Programme in der Suite: Eines zum Selektieren der Dateien und Erzeugen der "Listings", eines zum Anwenden / "Einspielen" / Synchronisieren der in einem rdup-"Listing" enthaltenen Dateien ins reale Dateisystem (typischerweise im Fall eines "Restore"), sowie ein drittes Programm welches rdup-Listings in normale tar oder cpio-Archive konvertieren kann. Das in C++ geschriebene rdup selbst besteht zwar nur aus einer Hand voll kleiner Programme, hängt aber von erstaunlich viele Bibliotheken ab. Doch diese scheinen auf einem typischen System ohnehin bereits wegen anderer Programme installiert zu sein, so normalerweise dass kein zusätzlicher Platz für deren Installation belegt wird.
re2c-0.16-2/devel/debian {parser/lexer-generator}{code-generator}: Ein Generator für lexikalische Scanner ("Lexer"), der C-Quelltexte aus Regular Expressions erzeugt. Der Generator bezieht seine Definitionen dabei aus speziell annotierten Kommentaren in existierenden C/C++-Quelltexten mit (per Konvention) der Dateierweiterung ".re". Es sind also nicht C/C++ Code in Lexer-Definitionen eingebettet, sondern genau umgekehrt. Dadurch kann man das Programmgerüst des erzeugten Codes einfacher bestimmen und auch gleich das main() implementieren. Die erzeugten Quelltexte sind meiner Ansicht nach hübscher und sauberer als die welche flex & Co erzeugen. Per Default schreibt der Generator den erzeugten Quelltext direkt auf die Standard-Ausgabe, "kleistert" also keinesfalls das Ausgabeverzeichnis mit unzähligen synthetische benannten Einzelfiles zu wie so mancher andere Generator. Als Eingabetext unterstützt re2c - wahlweise - "ASCII" (tatsächlich jedes 8-Bit Single-Byte Character Set, wie insbesondere LATIN-1), EBCDIC, UTF-8, UTF-16, UCS-2 und UTF-32. Generell wird der volle 21-Bit Codepoint-Bereich von UNICODE unterstützt. Oktale und Hexadezimale Escape-Sequenzen für die UNICODE-Zeichen stehen ebenso wie die üblichen '\t', '\n' etc. zur Verfügung. Ebenso kann die Unterscheidung zwischen Groß-/Kleinschrift global deaktiviert werden, so dass man sich in den Regexes nicht mehr darum kümmern muss. Die Regexes sind annähernd dieselben wie die POSIX "extendend" Regular Expressions, abzüglich benannter Character- und Equivalence-Classes. Classes können daher nur aus Bereichen expliziter Zeichen oder Codepoints bestehen. Dadurch benötigt der erzeugte Scanner zwar keine umfangreichen UNICODE-Tabellen, bietet zugleich aber auch keinen Locale-Support. Da er somit auch kein UNICODE-kompatibles "[[:lower:]]" oder "[[:upper:]]" kennen kann, dürfte es auch mit dem zuvor erwähnten Ignorieren von Groß-/Kleinschreibung nicht all zu weit her sein. Re2c ist daher nur für Programmiersprachen etc. geeignet und nicht für natürliche Sprachen, zumindest soweit dabei eine Unterscheidung von POSIX Character-Classes wie "[[:alpha:]]" vonnöten wäre. Eben so wenig gibt es die sehr nützlichen erweiterten "non-greedy" Modifiers von PCRE/Perl. Die einzige tatsächliche "Spezialität" scheint hingegen ein Operator zu sein, mit dem ein Ausdruck davor bewahrt werden kann identisch mit einem längeren Ausdruck zu sein. Dafür hat dieser Lexer zusätzlich zu den Regexes *Zustände*, welche wie Schalter wirken und andere Regexes freischalten oder sperren. Da solche Lexer ja nur Tokens erkennen sollen und alles "höhere" dem Parser überlassen, sollte das Gebotene im Normalfall wohl ausreichen. Eine Spezialität von re2c ist dass der erzeugte Scanner - optional - seinen aktuellen Zustand in einer Variablen speichern kann, so dass man ihn unterbrechen und später wieder fortsetzen kann. Das ist vor allem sehr nützlich wenn das Lexer in Form eines Callbacks betrieben werden soll. Dadurch kann re2c auch sowohl im "pull"-Modell arbeiten (er ruft eie Routine auf wenn er mehr Eingabetext braucht), als auch im "push"-Model (er wird von der Routine welche die Eingabe liest aufgerufen bis diese erschöpft ist). Leider entdeckte ich beim Betrachten des Generierten C-Codes einen Umstand, der bei mir die Sympathie für diesen Code-Generator schwinden ließ: Der Code vergleicht Zeichenliterale auf größer/kleiner. Da das Source Character Set bekanntlich keinesfalls dasselbe sein muss wie das Execution Character Set, bezweifle ich dass es portabel sein kann solche Relationen auszunutzen. Etwas anderes wäre es wenn der Code Oktal-Konstanten oder korrespondierende Integers vergleichen würde - aber das tut er nicht. Daher muss ich diesen Code-Generator, so schön er ansonsten auch sein mag, leider als "unbrauchbar" abqualifizieren: Ich bin nur an *portablem* Code interessiert!
recordmydesktop 0.3.8.1-7/community/archlinux: Ein netter Screen-Recorder, die aus dem Bildschirminhalt eine OGG-Video-Datei erstellt. (Diese kann man danach natürlich in ein anderes Format konvertieren.) Auch Sound - etwa aus einem Headset - kann dabei /(optional) aufgezeichnet werden. Man kann die OGG-Komprimierung entweder sofort oder erst nach dem Ende der Session durchführen, was unterschiedlich viel temporären Speicherplatz und CPU-Leistung erfordert. Neben dem ganzen Bildschirm kann man auch nur einen Ausschnitt eines solchen, den etwa ein Fenster belegt, aufzeichnen. Das Programm ist einfach aus der Kommandozeile heraus aufzurufen.
redeclipse-1.3.1/games-fps/gentoo {game}: Netter Multiplayer First-Person Shooter. Auch alleine offline gegen Bots spielbar; allerdings ist der Spaß dann eher gering, da die Levels nicht als Single-Player-Missionen ausgelegt sind, sondern darauf dass man vergleichsweise schnell jeden Punkt im Level erreichen kann um dort zu kämpfen. Mit meiner Grafikkarte (ATI RADEON HD 3850) gibt leider ein Problem welches periodisch zu mehrsekündigen Aussetzern (einfrieren) während des Spiels führt. Auch wenn ich davon ausgehe dass dies nicht die Schuld des Programms ist, macht es das Spiel für mich unspielbar.
regexxer-0.9/dev-util/gentoo: Ein in GTK+ / C++ geschriebenes GUI-Tool zum Suchen und Ersetzen von PCRE-Regexes in mehreren Dateien. Auch rekursive Suche in Unterverzeichnissen wird unterstützt. Die Dateien selbst können unverständlicher Weise jedoch nicht mit RegExes selektiert werden, sondern nur mit Bash-Style "glob"-Jokern. Vermutlich verfügt kfilereplace über eine ähnliche Funktionalität; dieses Paket hat jedoch keine KDE-Abhängigkeiten. Das Programm arbeitet zweiphasig: In der ersten Phase werden einmal alle Source-Files gesucht, die für die nachfolgende RegEx-Suche in Betracht gezogen werden sollen. Diese Suche ist optional rekursiv, und es kann gewählt werden ob versteckte Dateien einbezogen werden. In der zweiten Phase werden dann RegEx-Ausdrücke in diesen vorselektierten Dateien gesucht und/oder ersetzt. Das Ersetzen kann sowohl einzeln als auch in einer einzigen Operation erfolgen. Die Änderungen an allen Dateien sind nur temporär, außer man speichert sie ab. Dabei hat man die Möglichkeit einzelne Dateien abzuspeichern oder alle geänderten auf einmal.
rej-0.16/dev-util/gentoo {rej-conflict-resolver}: Rej ist ein Programm das speziell für das Auflösen von patch-Konflikten entwicklelt wurde, welche .rej-Dateien hinterlassen. Es unterstützt dabei sowohl Unified diffs als auch Context Diffs als Quellen der Konflikte. Es versucht solche (zeilenbasierte) Konflikte durch Umschalten auf wortbasierte Differenzbildung aufzulösen, und startet danach ein GUI-basiertes Diff-Programm mit dem man das Endergebnis noch einmal kontrollieren kann. Es unterstützt allgemeine externe GUI-Diff-Programme; vimdiff, kdiff3, meld und tkdiff werden dabei konkret als funktionierend genannt. Das Programm weist extra darauf hin dass es nicht für komplexe Konflikte entworfen wurde, sondern damit einfache schnell und komfortabel gelöst werden können. Rej überschneidet sich somit mit wiggle, hat diesem aber die Unterstützung von GUI-basierten Diff-Programmen voraus. Auf der anderen Seite hat wiggle noch zusätzliche Verwendungsmöglichkeiten.
rekall/dev-db/gentoo: Ein ACCESS-ähnliches Datenbank-Frontend. Die kostenpflichtige Version kann alles mögliche, die freie ist aber abgehalftert und kaum brauchbar.
remind-03.01.12-1/utils/debian {PIM}{reminder}: A command-line based calendar and alarm clock. Although it can be operated that way, it is usually accessed via front end application "wyrd" (text mode user interface) or "tkremind" (TCL/TK-based X11 GUI). "remind" itself has no dependencies except for the standard C runtime libraries. It is small compared to "normal" calendar applications - just about 150 KiB. The program acts actually as an interpreter for a "programming language" which defines calender events. Given a certain date and a source text describing the calender events, the interpreter can then show all events which occur on that date. Instead of just displaying event descriptions, the language can also run user-defined scripts, produce PostScript output for specially rendering a calendar cell, and more. The language is powerful in expressing repeated events, exclusion ranges etc. It can also evaluate expressions containing date calculations and has a lot of built-in functions, such as for calculating the easter date, moon phases or returning the current time. Conditional expressions and "include"-statements are also provided. It certainly exceeds the expressiveness of "at". Also, events can be pre-announced before the date of the actual event. Events can be all-day-events or include time as well. Time can also be repeated, specified as ranges, and contain exclusion just like dates. remind is normally run as a batch job, but if events specifying a time are scheduled to occur on the same date, it can put itself into the background and wait until the last time event for that day has occurred, executing the programmed action as the events occur. (This behavior can be disabled, of course.) Translation of weekdays, month names etc. into some languages is supported. German is not among those languages. remind does not seem to make use of the OS' locale support, or it could get the translations from there. remind is intended to be run either as back-end, batch tool, or in log-in scripts where it can produce "banners" showing today's events - and it can also run event scripts for those events. My impression is that remind is powerful but rather hard to learn because of the many language features. People will normally prefer easier-to-use calendar applications. On the other hand, remind's resource consumption seems to be rather low, and it does not require a graphical user interface. Its very limited localization can also represent a problem for users of the unsupported languages, especially if remind is used to export the generated messages to other applications which are fully locale-aware.
reptyr-0.9.0-1/misc/raspbian: Tiny utility which allows to redirect stdin, stdout and stderr of an already running program started on some other terminal to the current terminal. This allows, for instance, to move a long-running program which has been started on a normal console to the terminal provided by a running "screen", "tmux" oder "dtach" instance. But it can also be used to move programs out from there, back to a normal terminal.
resolvconf-1.76.1/net/devuan: Ein Script-Framework für das Ziel, die DNS-Konfigurationen welche von verschiedenen Paketen (wie ifupdown, Network-Manager, PPP und DHCP-Clients) bereits gestellt werden zu prioritisieren, selektieren, und für systemweites DNS am lokalen Rechner verfügbar zu machen. Es ist sowohl für diverse BSD-Varianten als auch Linux verfügbar, und war bei Debian das ursprüngliche Framework zu diesem Zweck. Leider hat dieses Paket eine Reihen von Nachteilen. Einerseits verwendet es hard-codierte Defaults, die nicht immer mit den tatsächlich installierten Paketen korrespondieren und dann ein Anpassen der Konfiguration nötig machen. Vor allem aber hat es die ärgerliche Eigenschaft, einen etwaig installierten dnsmasq oder andere DNS-Server automatisch zu starten und als lokalen DNS-Server laufen zu lassen, anstatt einfach /etc/resolv.conf dynamisch zu verändern (was es sehr wohl auch kann). Zwar unterlässt resolvconf diese vielleicht unterwünschte Integration lokaler DNS-Server wenn die entsprechenden Dienste in ihrer Service-Konfiguration deaktiviert wurden. Allerdings prüft es diese Bedingung nur während seiner eigenen Installation, womit die Reihenfolge der Paket-Installationen unnötiger Weise relevant wird. Es gibt auch keine globale Konfigurations-Option, um resolvconf von einer solchen Integration grundsätzlich abzuhalten. Ein weiteres Riesenproblem von resolvconf ist, dass es nur *eine* Liste von DNS-Servern zur selben Zeit bereit stellen kann. Im Falle von VPNs will man aber häufig, dass diese unterschiedliche DNS-Server als das Hauptsystem verwenden. Alles in allem wird empfohlen dieses Paket nicht zu verwenden, und statt dessen "openresolv".
restic-0.3.3-1+b2/misc/devuan {backup}: Ein ganz toll auf Verschlüsselung und Sicherheit ausgerichtetes, deduplizierendes Backup-Programm, das allerdings zwingend voraussetzt dass man dem von der NSA bei jeder Gelegenheit ständig wärmstens empfohlenen AES-Algorithmus absolut vertraut. Leider lässt sich diese Verschlüsselung auch nicht abschalten, so dass man sinnlose Rechenzeit dafür verplempert wenn man die Backups mangels Vertrauen in AES ohnehin noch zusätzlich verschlüsseln muss. restic ist in Go geschrieben und zumindest unter Debian (mehr oder weniger) statisch gelinkt, so dass es ein einzelnes ausführbares Programm ist welches nur die libc als Abhängigkeit hat. Dafür ist das Executable aber saftige 6 MB groß, da wohl die halbe Go-Runtime darin enthalten ist. Soweit einen dies nicht abschreckt, erhält man aber ein Backup-Programm mit minimalen Abhängigkeiten von externen Bibliotheken. Für seine internen Prüfsummen verwendet restic SHA-256 was ausreichend sein sollte. Für die Integritätsprüfung gegen vorsätzliche Manipulation verwendet es hingegen Poly1305, was - für diesen Zweck - auch ausreichend sein sollte. Wenn man davon absieht dass die Sicherheit des ganzen Programm mit AES steht und vor allem fällt. Im Gegensatz zu den meisten anderen Backup-Programmen ist für restic ein Design-Dokument vorhanden, welches einige Detailkonzepte und Design-Entscheidungen daher besser als üblich erklärt. Die Deduplikation von restic basiert auf einem Rolling Hash (Rabin Fingerprints; für Content-Defined Chunking) mit 64 Byte Breite des Sliding Windows, und wäre daher grundsätzlich mächtig. Aber leider können nur Dateien ab einer Größe von 512 KiB überhaupt erst dedupliziert zu werden. Tatsächlich strebt restic sogar eine Blockgröße von 1 MiB an, und Blocks können bis zu 8 MiB groß werden. Das mag zwar ausreichend für große Datei wie VM Disk-Images sein, aber die unzähligen existierenden Text- und Quelltextdateien sind typischerweise viel kleiner und würden daher niemals dedupliziert werden (soweit sie nicht zur Gänze identisch sind). Das ist um so schlimmer, als restic offenbar an keiner Stelle Komprimierung verwendet.
retropie-4.3-rpi1_zero.img.gz/installed-system-image/retropie {linux distribution}: Die Edition von RetroPie für den Raspberry Pi Zero. Es handelt sich um eine auf Debian-8/"Jessie" und systemd basierende Live-Distro für zahlreiche Spiele-Emulationen. Ausgerechnet ein C64-Emulator ist aber nicht standardmäßig an Bord und muss erst nachträglich dazu installiert werden (immerhin lässt er sich für eine spätere Offline-Installation bereits vorab downloaden). Kein X11 und nicht einmal ein Konsolen-Maustreiber ist enthalten. Die diversen Emulatoren benutzen offenbar direkt das Framebuffer-Device des RPi. Wenigstens leitet journald seine Logs an rsyslogd weiter. Aber auch dieser brettert die Log-Einträge hinaus wie ein Wilder und verkürzt die Lebensdauer der SDXC-Karte des RPi Zero entsprechend. Eine Busybox deren syslogd in einen RAM-Puffer loggen könnte, ist nicht an Bord (aber kann natürlich nachinstalliert werden). So etwas wie ein Menü oder eine grafische Oberfläche sah ich nicht; man ist nach dem Booten in der Textkonsole. Das muss aber nicht notwendiger Weise bedeuten dass es keine Oberfläche gibt; vielleicht ist sie nur schwer zu finden. Ich beendete meine Evaluation nämlich vorzeitig damit das herzhaft loggende System meine SDXC-Karte nicht zu Tode schrieb. Das ausgelieferte Dateisystem-Abbild besteht aus einer 59 MB vfat Boot-Partition und einer 3,8 GB ext4 Partition für alles andere. Von letzterer sind noch 2 GB frei. Alle erforderlichen Treiber für den RPi Zero, insbesondere Bluetooth und Wi-Fi, sind bereits installiert. Aktualität der vorinstallierten Pakete: Stand 2017-06.
rgbpaint-0.8.7-5/graphics/debian {bitmap image editor}: Ein Bitmap-Zeichenprogramm, wie es kaum mehr simpler geht. Es gibt nur die Werkzeuge Bleistift, Füll-Kübel, rechteckige Auswahl und Zoom. Keine Linien, Kreise etc. Die Werkzeugpalette enthält sogar noch weniger Tools: Kreise, Quadrate sowie Zufalls-Pixel als Pinsel in 3 verschiedenen Größen, und einen Einzelpixel-Pinsel, Ansonsten gibt es noch noch eine Farbpalette mit 2 x 10 fix vordefinierten Einträgen und eine benutzerdefinierbare Farbauswahl mit dem Farbrad/Dreieck. An Dateiformaten wird nur unterstützt: PNG, JPG, ICO. Das war's im Wesentlichen. Schlank ist ja gut und schön - aber dieses Programm übertreibt es damit ein bisschen! Da bleibe ich lieber bei mtpaint, das kann deutlich mehr und ist immer noch relativ schlank.
rhide-1.5/dev-util/gentoo {development_environment}{text-terminal IO}: IDE im Character-Mode Look wie weiland Borland-C 3.1. Für DOS und Linux. Verwendet gcc und gdb hinter den Kulissen. Konsole und X11. Nett auch über SSH zu verwenden. Leider kein UTF-8 Support, man sollte beim Start daher eine Single-Byte-Locale für LC_CTYPE setzen.
ri-li-2.0.1/games-arcade/gentoo {game}: 2D SDL Spiel mit einer Spielzeugeisenbahn die man in "Snakes"-ähnlicher Manier dazu bringen muss alle Bonuswaggons aufzusammeln wodurch der Zug immer länger wird, ohne mit sich selbst zu kollidieren. Zu diesem Zweck muss immer die jeweils nächste Weiche entsprechend umgestellt werden. Es gibt auch diverse Bonus-Objekt. Vermutlich eher für kleine Kinder gedacht, aber gar nicht all zu einfach. Nette Soundtracker-Musik als Untermalung. Etwas nervig: Zwischen den Leveln wird man immer über irgendwelche Menschenrechtskonventionen belehrt, indem wie in der Schule Paragrafen abgeprüft werden. Eine falsche Antwort hat allerdings gottlob keine nachteiligen Effekte. Sehr nett gemacht. Mit 135 MB Installationsumfang für ein relativ simples Spiel aber auch nicht gerade winzig.
ripwrap-0.20/media-video/gentoo: GTK/Perl Wrapper für mencoder/mp4box zur automatischen Konvertierung von DVDs nach MPEG-4.
ristretto-0.6.3/media-gfx/gentoo {graphics image viewer}: Der Bildbetrachter der Xfce-4 Desktop-Umgebung. Startet schnell, ist einfach zu bedienen, sieht auch aufgeräumt und freundlich aus wie alle Xfce-Applikationen. Aber er hat, zumindest in dieser Version, einen schweren Fehler: Er merkt sich die Zoom-Settings nicht wenn er zwischen Bildern wechselt. Jedes Bild beginnt immer bei 1:1-Darstellung, bestenfalls verkleinert falls es sonst nicht auf den Bildschirm passt. Aber das von mir geschätzte Setting "in Fenstergröße einpassen" merkt er sie nicht und auch wenn es nur einen Button-Click erfordert um diese Funktion aufzurufen, ist dies ein Button-Click zu viel wenn man hunderte Bilder ansehen will. Ansonsten ist die Funktionalität simpel: Links ist eine Leiste mit kleinen Übersichtsbildern, oben ein Toolbar mit den benötigten Funktionen, den Rest nimmt das angezeigte Bild ein. Diashow und Vollbildmodus kann das Programm auch. Ebenso kann man Bilder drehen - aber nur temporär fürs Display. Bearbeitungsfunktion gibt es keine, wenn man davon absieht dass man per Buttonklick eine Dialog zum Aufruf anderer Programme anzeigen kann kann um das Bild mit diesen zu bearbeiten. Eine Spezialität von Ristretto ist ein Porno Mode, äh das "Löschen von persönlichen Daten" (womit vermutlich die History der angezeigten Bilddateien gemeint ist). Es gibt weiters eine Option wo man verhindern kann dass Dialoge des Thunar-Dateimanagers in verschiedenen Situationen aufgerufen werden, was gut ist wenn man ihn zwar (zwangsweise) installiert hat aber hasst (etwa wegen dem Papierkorb) und nicht verwenden will. Weiters meckerte das Programm beim Versuch eine PNG-Datei anzuzeigen dass ich Tumbler nicht installiert hätte - ohne diesen Hintergrund-Dienst kann es offenbar nur JPEG-Thumbnails anzeigen. Entgegen dieser Meldung wurden dann aber sehr wohl Thumbnails auch von PNG-Dateien sehr wohl im Programm angezeigt. Keine Ahnung was nun eigentlich das Problem sein soll. Vielleicht wird es nicht gecachet; das dürfte aber auch schon alles sein. In Summe ist Ristretto ein weiterer simpler Bildbetrachter wie es einige gibt, und wenn der obige Mangel nicht wäre hätte ich ihn sogar installiert gelassen. Bis dahin bleibe ich bei Geeqie, das kann doch deutlich mehr auch wenn es etwas langsamer startet.
rman-3.2-7+b1/text/devuan {text-formatting}: Ein Konvertierungs-Tool für "man"-Pages vieler UNIX-Plattformen. Kann sowohl (bevorzugt) Quelltexte für troff/nroff als auch daraus bereits erzeugte/formatierte "man"-Pages als Eingabedateien entgegen nehmen, und konvertiert dies in eines der folgenden Formate: ASCII, roff, TkMan, Tk, Sections, HTML, SGML, MIME, LaTeX, LaTeX2e, RTF, POD. Unterstützt bein Parsen auch den "tbl"-Präprozessor (zum Erkennen von Tabellen), nicht jedoch "eqn" (zum Erkennen von mathematischen Formeln). Bereits formatierte "man"-Pages von folgender Plattformen werden unterstützt: SunOS, Solaris, HP-UX, System V, OSF/1, Ultrix, IRIX, Linux, FreeBSD, SCO. "man"-Quelltexte werden von folgenden Plattformen unterstützt: SunOS, Solaris, HP-UX, System V, OSF/1, Ultrix.
rocksndiamonds-4.3.5.1+dfsg-1/contrib/games/raspbian rocksndiamonds/games-arcade/gentoo {game}: Der beste und umfangreichste Boulder-Dash-Clone für Linux. Unzählige Levels, eigener Level-Editor, alles was man braucht. Enthält auch alle Original-Level des klassischen Spiels. Überdies sind auch die meisten Levels aller Klone enthalten, wie etwa Emerald Mine. Sokoban ist auch noch integriert. Unzählige Feldtypen wie "Game Of Life"-Logik sind ebenso zusätzlich enthalten. Kann im Full-Screen gespielt werden; das eigentliche Spielfeld-Fenster ist allerdings immer quadratisch. Im Fenster-Modus kann das Fenster mit der Maus relativ frei gezoomt werden. Alternativ kann man einige fixe Vergrößerungs-Faktoren auswählen. Diverse Anti-Aliasing-Filter und Video-Sync Optionen sind verfügbar. Auch Netzwerk-Spiele und Internet-Upload der Highscores ist möglich. Vorsicht: Der Internet-Download der aktuellen Highscores is per Default eingeschaltet! Nur wegen des Uploads wird gefragt. Man sollte diese automatischen Highscore-Downloads unbedingt im Setup abschalten, da sonst bei jedem Start des Spiels ein Netzwerkzugriff stattfindet. Mit rund 741 MB Installationsgröße in ca. 101.000 einzelnen Dateien (Download-Umfang: 135 MB) allerdings auch ein ordentlicher Platzverschwender auf der Festplatte. Obgleich typische "moderne" 3D-Spiele natürlich noch weitaus mehr fressen. Bei der Debian-Version sind die erwähnten Levels allerdings nicht enthalten, sondern müssen von einer Webseite /usr/share/games/rocksndiamonds/downloads/ kopiert und dann nach /usr/share/games/rocksndiamonds/ entpackt werden. dpkg-reconfigure kann beides automatisieren, oder nur das Entpacken durchführen. Vorsicht: Bei einem Upgrade der Level-Dateien löscht er alle alten gepackten Dateien! Ich empfehle daher, die gepackten Level-Dateien in ein neues Verzeichnis /usr/share/games/rocksndiamonds/downloads/uninstall-backups/ als Backups zu hard-linken. Die gepackten Level-Dateien können auch auf eine andere Maschine kopiert werden, um einen erneuten Download dort zu vermeiden. Negativ fällt auf, dass es zumindest unter Raspbian keine ARM-Version des Spieles gibt. Jedoch gelang es mir, das Paket dort selbst zu bauen. Nur das Binärpaket fehlte.
rocs-4.11.5/kde-base/gentoo: Langweilig als "Graphentheorie-Werkzeug" bezeichneter grafischer Editor, mit dem man Datenstrukturen visualisieren kann sowie - mittels Scripting - Algorithmen welche diese Datenstrukturen manipulieren. Klingt sehr nützlich, da man diese Dinge früher nur auf Papier - genauer gesagt vielen Papieren welche die einzelnen Schritte der Algorithmen darstellen - visualisieren konnte.
rofs-2006.11.28-2.1/utils/debian {FUSE}: Erlaubt es, eine Read-Only Sicht eines existierenden Verzeichnisbaums an anderer Stelle im Dateisystem zu mounten. Nur potenziell sinnvoll wenn man nicht zugleich auch unionfs-fuse installiert, welches dieselbe Möglichkeit als Teil seiner Funktionalität bietet.
rox-2.10/rox-base/gentoo {file manager}{GTK+}: Ein Dateimanager mit geringem Installationsumfang (4 MiB für die Kernapplikation) und etwas ungewöhnlicher Implementation einiger Features. Er ist der Standard-Dateimanager der Live-Linux-Distribution "Puppy". Außerdem kann er den Desktop-Hintergrund "übernehmen" und dort Icons und/oder ein Hintergrundbild darstellen. Zusätzlich kann er auch noch ein Panel am Desktop darstellen, welches sich entlang eines der vier Bildschirmränder anordnen lässt. Zusammen mit einem Fenstermanager wie OpenBox (das weder Panels beherrscht noch Desktop-Icons oder ein Hintergrundbild unterstützt) kann Rox daher ein simples Desktop-Environment implementieren. Vorgabemäßig verwendet Rox das Öffnen von Objekten mittels Einfachklicks; das lässt sich auf Doppelklick umkonfigurieren. Rox folgt dem SDI-Konzept und unterstützt auch keine Tabs. Er unterstützt aber auch nicht die "Windows-Explorer"-übliche Cut/Paste-Metapher zum Verschieben von Dateien. Wenn das Verschiebe-Ziel ein Unterverzeichnis des aktuellen Verzeichnisses ist, kann man Dateien mit Drap & Drop verschieben. Andernfalls bleibt einem nichts anderes übrig als das Zielverzeichnis in einem separaten Fenster zu öffnen. Rox unterstützt zwar das Markieren mehrerer einzelner Dateien mittels Strg, aber nicht das Selektieren eines Bereichs mittels der Umschalt-Taste. Ebensowenig kennt er eine "Quick Search"-Möglichkeit, um in einem umfangreichen Verzeichnis zu Einträgen zu springen welche mit einer bestimmten Zeichenkette beginnen. Dieses Versäumnis ist in der Praxis sehr lästig. Es ist allerdings möglich Dateien mittels Suchausdrücken zu markieren; diese können außerdem dazu verwendet werden die Anzeige der Dateiliste zu filtern. Leider gibt es keinen auffälligen Indikator ob ein Anzeigefilter gerade in Verwendung ist. Dadurch besteht die Gefahr dass man dies vermisst und irrtümlich meint die angezeigten Dateien wären alle vorhandenen. Für die Dateisuche und Selektion besitzt Rox eine einigermaßen mächtige Suchsprache, deren Teilausdrücke simple Shell-ähnliche Glob-Pattern sowie relationale Ausdrücke sein können die Eigenschaften wie Größe, Alter usw. vergleichen. Auch wenn ein Großteil des "find"-Befehls in dieser Suchsprache nachprogrammiert zu worden scheint, fehlt leider dessen sehr nützliche GNU-Erweiterung um Regular Expressions verwenden zu können. In den Dialogen wo man Dateien oder Verzeichnisse auswählen soll, wird eine von der Bash unabhängige Form der Tab-Completion unterstützt. Rox hat benutzerdefinierte Lesezeichen und eine Verzeichnis-Chronik. Es gibt auch eine RegEx-basierte Möglichkeit zur Mehrfachumbenennung von Dateien. Rox unterstützt ungewöhnliche Darstellungsformen in der Dateiliste, nicht nur die übliche Icon/Name oder ausführliche Listen-Ansicht. Diese ungewöhnlichen Kombinationen stellen Icon, Name und noch eine ausgewählte weitere Eigenschaft in einem Eintrag dar. Besonders dabei die Unix-Rechte-Anzeige. Diese zeigt nicht nur die üblichen Rechte, Owner und Group an, sondern unterstreicht dabei auch noch die auf den aktuellen User zutreffenden "rwx"-Gruppe (je nachdem ob dieser Owner-, Group- oder Other-Rechte an dieser Datei hat). Eine weitere Eigenheit von Rox ist dass er die Größe des Fensters automatisch an die für die Darstellung des Verzeichnisinhalts erforderliche Größe anpasst (diese Automatik lässt sich abschalten und auch manuell aufrufen). In Rox scrollen alle Verzeichnislisten immer nur vertikal, obwohl er sehr wohl in der Lage ist mehrere Einträge pro Zeile anzuordnen wenn die erforderliche Spaltenbreite dafür platzmäßig ausreicht. Die bei mir so verhassten Horizontalscroll-Listen gibt es daher unter Rox nicht - auch nicht in der Symbolansicht. Ein eindeutiges Plus! Dafür werden überlange Einträge angeschnitten (ein Indikator für diesen Umstand wird angezeigt) - allerdings kann man die erlaubte Maximalbreite in Pixel frei einstellen. Leider unterstützt Rox nicht das abwechselnde Einfärben von Listenzeilen, so dass es schwierig werden kann die Einträge der Detailansicht eines Eintrags optisch als zusammengehörige Einheit zu erfassen. Weiters kann man sich bei den Sortierkriterien aussuchen ob Dateien und Unterverzeichnisse beim Sortieren getrennt oder gleichartig behandelt werden sollen. Rox kann Thumnails für Grafikdateien erstellen und cached diese in einem separaten zentralen Verzeichnis. Dabei werden Cache-Dateien nach einem gewissen Alter automatisch gelöscht; es ist daher kein unkontrolliertes Anwachsen dieses Verzeichnisses zu befürchten. Wenn man sys-fs/avfs zusätzlich installiert, kann Rox auch so konfiguriert werden dass er in gepackte Archive "hinein gehen" kann. (Allerdings kann man avfs auch mit anderen Dateimanagern so verwenden. Rox dokumentiert dies jedoch explizit in seiner Hilfedatei.) Rox kann auch den Speicherplatz markierter Dateien inklusive Unterverzeichnisse ermitteln. Rox zeigt ab sowohl die Anzahl der markierten Dateien als auch deren kumulierte Größe an. Leider fehlt eine Anzeige des noch freien Platzes im Dateisystem. Größenangaben erfolgen nicht notwendiger Weise immer in Bytes, sondern die Einheiten werden immer so gewählt dass die Größe als 1- bis 4-stellige Ganzzahl dargestellt werden kann. Dies lässt sich auch nicht ändern. Obwohl immer Kibi- und Mebibytes etc. als Einheiten verwendet werden, werden die nicht die korrekten binären SI-Präfixe verwendet, sondern die "traditionellen" alten Abkürzungen. Das aktuelle Verzeichnis und die darin ausgewählten Einträge können mit Strg-Zifferntaste gespeichert und durch das Drücken derselben Zifferntaste jederzeit wieder hergestellt werden. Ein interessantes Feature ist auch dass Ansichtsoptionen ordnerspezifisch gespeichert werden können. Rox besitzt umfangreiche Möglichkeiten, Befehle Dateityp-spezifisch anzubieten. Er unterstützt auch die freedesktop.org MIME-Type-Spezifikation, was bedeutet dass er die meisten MIME-Typen automatisch erkennt. Leider unterstützt er aber nicht ebenso die .desktop-File Spezifikation von freedesktop.org, was bedeutet dass er keine Ahnung hat welche Programme sich für einen MIME-Type "zuständig fühlen". Man muss dies statt dessen mühsam manuell konfigurieren (oder ein Programm schreiben welches diese Information aus den .desktop-Files extrahiert). Ebensowenig unterstützt er den freedesktop.org "Papierkorb"-Standard. Rox ist besonders fähig wenn es darum geht riesige Verzeichnisse einzulesen: In diesem Fall wird erst der Verzeichnisinhalt, aber noch nicht die stat()-Information eingelesen. Dadurch kann man in Unterverzeichnisse wechseln sobald diese angezeigt werden, auch wenn der Rest des Verzeichnisses noch nicht eingelesen wurde oder noch nicht alle Details der gelesenen Verzeichniseinträge gelesen wurden. Rox hat eine Buttonleiste, die sich zwar kaum anpassen lässt (man kann nur Einträge ausblenden) aber recht sinnvoll bestückt ist. Das Umschalten wichtiger Modi wie "Detailansicht"/"Icon Ansicht" lässt sich so mit einem Mausklick erledigen. Weitere Modi sind das Aktivieren von Miniaturbildanzeige oder von versteckten Dateien. Das Rox-Bedienungskonzept basiert auf individuellen Fenstern verschiedener Größe; er ist aber nicht gut dafür geeignet wenn man häufig eine "Norton-Commander"-like-Ansicht durch zwei neben einander liegende Fenster realisieren will: Er merkt sich nicht (wie etwa der Thunar-Dateimanager) die Größe des letzten Fensters; man muss jedes neue Fenster erneut resizen. Rox kann über SOAP-Messages "ferngesteuert" werden (auch wenn mir kein rechter praktischer Nutzen für diese Funktion einfallen mag). Rox scheint GTK+-2 Themes zu unterstützen; zumindest unter Xfce4 fügt er sich nahtlos in das aktuelle Theme ein. Rox ist meiner Ansicht nach derzeit (2012-02) einer der besten X11-Dateimanager neben Krusader, pcmanfm und xfe.
rox-filer-1 {file manager}{GTK+}: 2.11-1/x11/raspbian: An unusual file manager. It is the default file manager of the Puppy Linux distribution It looks similar to all the other "explorer-type" file managers, yet differs a lot in the details. For instance, it normally (can be disabled) adjusts its window size in order to match the number of entries in a directory. It has only a dozen of buttons on its toolbar, but those are cleverly chosen and do different things depending on the mouse button they are pressed with. (Ballon help explains all functions.) Bookmarks can be created, their titles edited. There a basically two view modes, just names and icons or details (icon, name, type, permissions, owner, group, size). In symbol mode, one additional attribute (size etc.) may be selected for display. There is even a choice for all three times together (mtime, atime, ctime). Very nice: Both views only scroll up and down. No sideway scrolling (except if the shown columns are too wide). If multiple files are selected, the cumulative size and the number of files is displayed. The files being displayed can be filtered using shell wildcards, and the current display settings (sorting order, list style) can also be saved per directory (by default, the settings remain the same when moving between directories). RegEx-based multi-renaming tool with preview. Powerful mechanisms for linking file types to particular applications or scripts. Unfortunately it ignores any already-established standards for this, in particular all freedesktop.org standards as rox-files predates them. The current set of selected files can be assigned to numbered memory locations and can be restored from later. It search function uses a powerful search-language, similar (in purpose but not in syntax) to the arguments accepted by "find". The program can also act as the desktop background, allowing to put files there as if it were a normal directory. In addition, it can provide "panels", where application icons can be put which actually do stuff when clicked. The program is in fact powerful, but most of its power can be exploited when using together with a very minimalistic window manager. Then rox-filer can supply many features missing from the window manager.
roxterm-1.16.3/x11-terms/gentoo {terminal emulator}{GTK+}: Ein auf x11-libs/vte basierender Terminal-Emulator für X11, der eine gute Balance zwischen Features und Installationsumfang darstellt - solange man damit leben kann, dass es eine GTK+ Anwendung ist und daher die GTK+ Libraries als Abhängigkeiten hat. Von diesem Nachteil abgesehen kann sich Roxterm aber durchaus sehen lassen: Tabs, Font-Zoom, Input Methods, UNICODE-Support. Anpassbare Tastatur-Shortcuts, Font, RGB-Farben, Blinkverhalten des Cursors. Die Einstellungen können darüber hinaus noch in Presets organisiert werden. Und all dies ist über normale Menüs und Dialoge zu erreichen. Rox-Term scheint eine sehr gute Wahl für Leute zu sein, denen sowohl konsole als auch gnome-terminal zu fett sind, aber viele Features wünschen. Mit nur 1 MB Installationsumfang ist Roxterm auch nicht groß - allerdings kommt vte mit 2,5 MB hinzu und die GTK+ Libraries muss man halt noch als Abhängigkeit einplanen. Dennoch die vermutlich beste Wahl für Leute die einen mächtigen Terminal-Emulator wünschen, jedoch weder GNOME noch KDE verwenden.
rpi-update-20140705/unknown/raspbian: Ein Script, welches von Web-Servern aktuelle Kernel- und Firmware-Updates für dem RPi herunterlädt und danach installiert. Ich las Empfehlungen, die Finger von diesem Tool zu lassen da es leicht das ganze System unbenutzbar machen kann, da dies Kernel- und Firmware-Versionen dann nicht mehr zum restlichen installierten System passen. Statt dessen ist es besser die offiziellen Pakete der Distribution für Kernel und Firmware zu benutzen. Oder anders gesagt, rpi-Update ist ein Spezialisten-Tool, das normale Benutzer nicht brauchen und welches in ihren Händen sogar gemeingefährlich ist.
rpl-1.5.5/app-text/gentoo: Tauscht genau einen fixen String gegen genau einen zweiten in beliebig vielen Dateien aus; kann auch rekursiv Unterverzeichnisse durchsuchen. Die Suche kann modifiziert werden indem nur ganze Worte gesucht werden oder Groß-/Kleinschreibung ignoriert werden; darüber hinaus gibt es keine Features. Insbesondere kann nicht nach RegExes gesucht werden; entsprechend gibt es auch keine "Captures" die man im Replacement String verwenden könnte. Dafür gibt es die Möglichkeit vor Replacements gefragt zu werden und C-ähnliche Escape-Sequenzen in den Strings zu aktivieren. Alles in allem ein eher simples Tool.
rrootage-0.23a-9/games/debian {game}: Angeblich ein 2D Ballerspiel. Allerdings funktioniert es nicht ohne OpenGL, und daher auch nicht am Raspberry Pi.
rrootage-0.23a/games-action/gentoo {game}: Ein abstrakt aussehendes völlig hirnloses Ballerspiel, wo oben ein großes "Boss"-Raumschiff nach unten auf einen feuert, und man steuert ein kleineres Raumschiff das ständig von unten nach oben auf den "Boss" feuert. Das hirnlose daran ist dass es kaum Möglichkeiten gibt den Schüssen auszuweichen, und diese zudem nichts anderes tun als einen Lebenszähler herunter zu zählen. Es gibt keinerlei anderes Feedback auf das Einschlagen der Schüsse. Fällt der Zähler auf 0, explodiert man plötzlich - oder der "Boss". Obwohl das Spiel nicht so schlecht aussieht, nervt es nach kurzer Zeit dass man oder der Boss ständig unmotiviert explodieren, wenn man nicht den Zähler beständig im Auge hat. Auch mit der angepriesenen "Hugeness" des Boss ist es nicht weit her: Dieser ist vielleicht 5 x so groß wie man selbst. Auf jeden Fall passt er komplett auf den Bildschirm - es handelt sich keinesfalls um einen Star-Wars-ähnlichen Luftkampf über riesigen Sternenzerstörern oder dergleichen. Fazit: Wegen Sinnlosigkeit vergessen.
rsbackup-3.1-3+b1/admin/devuan {backup}{deduplication}: In C++ geschriebenes Backup-Programm, welches die Backups als identische Kopien in Backup-Verzeichnisse kopiert. Entsprechend werden diese auch nicht zu komprimieren oder sonstwie zu verändern versucht. Dort allerdings setzt es die Möglichkeiten von rsync ein um identische Dateien zu erkennen und durch Hard-Links zu ersetzen. Echte Deduplikation von mehrfach vorkommenden Datenblöcken welche nur Teile von Dateien darstellen beherrscht es nicht. Die Metadaten speichert es offenbar in einer Sqlite-Datenbank. Mittels SSH kann können Backups sowohl von mehreren Maschinen als Original-Dateisysteme erstellt als auch die Backups auf mehrere Maschinen verteilt abgelegt werden. rsbackup kümmert sich pro Backup-Repository automatisch darum, dass zu alte Backups nach einer Zeit gelöscht werden, damit der verfügbare Platz für weitere Backups nicht zwangsläufig irgendwann ausgeht. Trotz seiner Nutzung von Hardlinks für unveränderte Dateien über mehrere Backup-Generationen hinweg, scheint rsbackup sowohl Symlinks als auch Hardlinks zu unterstützen. Vermutlich wird diese Information in den Metadaten hinterlegt, welche wohl in der erwähnten SQLite-Datenbank gespeichert werden mögen. rsbackup unterstützt Hook-Scripte, welche bei verschiedenen Aktionen automatisch aufgerufen werden und dann beispielsweise ein LVM-Snapshot erstellen können, damit dieses als möglichst konsistentes Original fürs Backup dient wenn dieses etwa als cron-Job läuft. rsbackup kann in Falle einer Unterbrechung fortsetzen wo es abgebrochen wurde, allerdings nur bis ein neues Backup gestartet wurde. Im letzteren Fall wird das vorherige abgebrochene Backup unbrauchbar und sollte entfernt werden um Platz zu sparen. Es gibt dieses Programm offenbar auch für Windows und MacOS, aber es kann nicht auf allen Plattformen ACLs und Extended Attributes backuppen. Alles in allem ein eher langweiliges Programm.
rsnapshot/app-backup/gentoo {backup}{deduplication}: Scheint mir dasselbe zu sein wie app-backup/dirvish, nur vielleicht weniger netzwerkzentrisch und ohne das integrierte Rotationssystem. In Perl geschrieben.
rssh-2.3.3/app-shells/gentoo: A restricted shell for usage with SSH. Restrict the connecting party to running only one or more from a list of specific supported commands. The following commands are currently supported: scp, sftp, cvs, rdist and rsync. No other commands can be executed from the restricted shell. And even the commands supported will only be allowed if they are enabled either globally or on a per-user basis in the rssh configuration file. The "or" is to be taken literally: Any global definitions are only honored for users for which there are no per-user entries in the configuration file. Otherwise, only the per-user entries are honored and the global entries will be completely ignored.
rsync-3.1.3-6/net/debian {deduplication}{compression}: Ein extrem hilfreiches Utility, welches bei abgebrochenen oder fehlerhaften Downloads in der Lage ist, den fehlenden bzw. beschädigten Teil von Dateien gezielt downzuloaden, ohne dafür auch den Rest der Datei downloaden zu müssen. Davon abgesehen kann es auch lokal als allgemeiner Ersatz für "cp" oder "mv" verwendet werden, der dann die Vorteile eines besseren Fortschrittsbalken bietet (etwa Anzeige der vermutlichen Restzeit für den Kopiervorgang) sowie auch deutlich mehr Möglichkeiten bietet (Symlinks konvertieren, Hardlinks mit kopieren, nur ausgewählte Dateiattribute kopieren, fortsetzen von zuvor abgebrochenen Kopiervorgängen, komplexe Filterbedingungen zum ein- und ausschließen von zu kopierenden Dateien, optionales Löschen von im Herkunftsverzeichnis nicht mehr existierenden Dateien die im Zielverzeichnis noch vorhanden sind, und noch vieles mehr). Um es für Downloads von entfernten Servern benutzen zu können, muss auf dem entfernten Server entweder ein rsync-Service laufen, oder man muss diesen Server mittels ssh oder sonstwie mit einem Shell-Account erreichen können, und dort muss ebenfalls das rsync-Utility installiert sein. Per Default erfolgt der Zugriff über SSH, aber mit Optionen kann man jedes beliebige Programm zum Herstellen einer Verbindung definieren.
rtorrent-0.7.9/net-p2p/gentoo: Console-based Bittorrent-client with curses-based user interface. Works well with tracker-based as well as trackerless Kademlia-based torrents. Written in C and thus faster and with lower resource requirements than JAVA-based clients. The only drawback: Braindamaged default key bindings and no online help for it, e. g. keep the man-page close to you at all times.
rxvt-unicode-9.07-r1/x11-terms/gentoo {terminal emulator}{GUI}{X11}: Ein möglicherweise sehr leistungsfähiger X11-Terminalemulator. Kommt völlig schmucklos daher; keinerlei Menüs oder Buttons vorhanden. Leider muss man eine elendslange Anleitung durchlesen falls man das Ding nach eigenen Kriterien anpassen will; das habe ich mir bisher nicht angetan. Allerdings trifft diese Kritik auf das Standard-"xterm" ebenso zu wenn man davon absieht dass xterm sehr wohl ein paar simple Menüs hat. Auf jeden Fall kann dieses Programm offenbar mit UNICODE-Support aufwarten; zumindest lässt sich dies aus dem Namen erschließen. Laut Dokumentation ist rxvt primär als Ersatz für xterm gedacht, und hat den Vorteil im Betrieb weniger Speicher zu brauchen - ca. 1/4tel. Das macht vor allem auf Multi-User-Systemen einen Sinn, wo sehr viele User eingeloggt sind und jede Menge Terminal-Emulatoren laufen lassen. Hat ebenso wie xterm nur sehr geringe Library-Abhängigkeiten. Unterstützt ebenso Outline-Fonts mittels libfreetype. Obwohl rxvt selbst keinen Tab-Support bietet, liebt ein Perl/Tk-Script bei welches dies durch Einbettung erzielt. Über den Overhead dieser Lösung schweigt man freilich besser. Der Autor von rxvt scheint ein Gentoo-Hasser zu sein, oder zumindest hält er nicht viel davon. Grundtenor: "Wenn es ein Problem unter Gentoo gibt, belästigen sie uns nicht; die Gentoo-Maintainer unkooperativ und pflegen schlechte Patches ein". Das stimmt einen nicht gerade mit Zuversicht. Der Installationsumfang ist mit 2,6 MB noch erträglich; das Haupt-Executable umfasst knapp mehr als 1 MB davon.
s3dfm-0.2.2.1-3+b1/utils/debian: Angeblich eine Art Ersatz für den X11-server welchen man als 3D-Desktop verwenden kann. Keine Ahnung wie das zu verstehen ist; ich nehme eher an es handelt sich um einen normalen X11 Client, der sich jedoch eine Client gegenüber als X11-Server ausgibt. Oder was auch immer. Beim Starten verreckt das tolle Programm jedenfalls mit dem Versuch sich zu Port 111 (Sun RPC) zu verbinden. Weshalb auch immer. Unbrauchbar oder gemeingefährlich!
s6-2.1.3.0/sys-apps/gentoo {service manager}: Eine schlanke (1,4 MB inklusive umfangreicher HTML-Dokumentation) Service-Management Suite bzw "init-System", die als funktionaler sysvinit-Ersatz dienen kann. Die Code-Qualität scheint hoch zu sein, und man gewinnt den Eindruck dass korrektes Verhalten der Suite auch in prekären Situationen ein wichtiges Anliegen der Autoren war. Funktional ist es sehr ähnlich wie die "runit"-Suite, besteht aber aus mehr Programmen, damit die einzelnen Programme schlanker und minimalistischer sein können. Wie bei runit folgt s6 der Philosophie, dass jeder Dienst von einem eigenen zugehörigen Supervisor-Prozess beobachtet werden sollte, der seinerseits extrem wenige Ressourcen verbraucht. Die Supervisor-Prozesse selbst werden dabei von einem zentralen Super-Supvervisor-Prozess überwacht bzw. gestartet, der als PID 1 laufen kann (aber nicht muss). s6 kann auch syslogd ersetzen, obgleich mir nicht ganz klar ist ob das dann einen 2. Zusatz-Prozess für jeden Service-Prozess bedeuten würde. Im Gegensatz zur sehr minimalistischen BusyBox-Implementierung von "runit" kümmert unterstützt s6 auch Service-Abhängigkeiten durch ein simples File-Descriptor-basiertes Event-System. Ich habe den Eindruck, dass s6 das möglicherweise zuverlässigste und gleichzeitig eines der ressourcensparendste init-System ist welches derzeit existiert. Allerdings missfallen mir ein paar Punkte: So gut wie nirgends wird es fertig mitgeliefert; man wird es in den meisten Fällen selbst bauen müssen. Es hängt dabei von 2 weiteren Bibliotheken ab, die man gleichfalls selbst wird bauen müssen. Zweitens empfiehlt es aus nicht nachvollziehbaren Gründen stark, dass die man die Supervisor-Prozesse für gestoppte Dienste weiterlaufen lassen soll, obwohl es durchaus Befehle gibt sie zu beenden. Es steht zu befürchten, dass dies irgend etwas mit den Service-Abhängigkeiten zu tun haben könnte, und dass es andernfalls mögliche Probleme wie Race-Conditions geben mag. Dieser Punkt missfällt mir extrem! Und schließlich wäre da noch die längliche Anleitung für die vielen - dutzenden - Einzelprogramme, welche die Suite mitbringt. Das runit der BusyBox kommt mit wesentlich weniger Befehlen aus. Allerdings kann s6 dafür auch "Socket Activation" und ähnliche Dinge, die in bestimmten Situationen wohl nützlich sein dürften. Ein Vorteil von s6 gegenüber sysvinit ist dass man sich die ganze Problematik um Service-Abhängigkeiten erspart, bzw. dass sich diese implizit durch Events "von selbst lösen". Ein klarer Nachteil von s6 (genau wie von "runit" oder "upstart") ist, dass es nicht kompatibel mit sysvinit (oder gar systemd) ist, und man daher alle Service-Startscripte vermutlich mit der Hand reimplementieren wird müssen. Das würde mich aber weniger schrecken als sinnlos laufende Supervisor-Prozesse, und wenn sie noch so wenige Ressourcen fressen.
sauerbraten-2008.06.17/games-fps/gentoo {game}: Ein schneller First-Persion Shooter mit Single-Player Missionen ebenso wie für Serverbasiertes Multiplayer Deathmatch oder Capture The Flag. Multiplayer-Maps lassen sich auch von Single Playern spielen; in diesem Fall werden einfach Monsterhorden gespawnt. Client- und Server-Executable liegen bei. Leider - zumindest bei dieser Version - nur binär in vorkompilierter Form, und dabei nur als 32-Bit Executables. Ist allerdings auch auf amd64-multilib-Systemen lauffähig. Ein außergewöhnliches Feature ist ein Singleplayer-Modus, wo man wenn man getroffen wird nicht stirbt sondern nur immer langsamer wird - bis hin zur Extrem-Zeitlupe. Dies kostet einen natürlich Punkte da das Ergebnis an der benötigten Zeit gemessen wird. Aber man kann so alle Gegner fertig machen ohne zu sterben und muss dennoch keinen Schummel-Modus benutzen. Taugt mir. Ein anderes cooles Feature ist dass man jederzeit aus dem laufenden Spiel heraus den Level-Editor aktivieren kann um das Level zu verändern. Dies sogar im Multiplayer-Modus gemeinsam (Coop-Edit)! Beim Verlassen des Editor-Modus erscheinen allerdings alle Gegner wieder neu, die bereits eingesammelten Waffen hingegen nicht. Der Editor funktioniert direkt in der 3D-Ansicht; es gibt kein Umschalten zu einer eigenen Editor-Ansicht. Man "buddelt" sich einfach durch die Gegend oder erzeugt neue Blöcke aus dem Nichts. Das Spiel basiert auf der "CUBE"-Engine, und alles im Spiel basiert auf Würfel. Diese können aber durch andere Würfel zerteilt, durchbohrt, verschmolzen und rotiert werden, so dass man dies nicht unbedingt mehr sieht. Waffen, Monster etc. werden allerdings auf herkömmliche Weise als 3D-Polygonmodelle geladen und können im Editor auch nicht geändert sondern nur verwendet werden. Es werden von QUAKE stammende Polygonformate verwendet; sie können mit Blender erzeugt und exportiert werden. Für komplexere Interaktionen von Türen, Schlüsseln, Triggern etc. gibt es eine simple Scripting-Sprache.
sbc 1.3-1/extra/archlinux {audio}: Der Bluetooth Subband Codec ist ein Audio-Codec für Bluetooth der geringen Rechenaufwand mit guter Qualität und mittleren Bitraten verbindet. Ist Teil des Advanced Audio Distribution Profile (A2DP).
sbcl-1.0.19/dev-lisp/gentoo {programming language}: Die mit Abstand beliebteste Common LISP-Implementation laut einer Umfrage von 2008. Erzeugt schnellen native Code, unterstützt UNICODE und Multithreading. Verbesserter Fork von CMUCL. Cross-Plattform. Die Lizenz erlaubt das problemlose Verwenden auch in kommerziellen Programmen. SBCL benötigt ein bereits vorhandenes (aber beliebiges) Common LISP zum Bootstrappen. In der getesteten Version des Ebuilds liegt zu diesem Zweck dem Quelltext ein vorkompiliertes Binary bei, das leider ohne Wahlmöglichkeit eines anderen LISPs (etwa CLISP) zum Bauen verwendet wird.
sc-7.16-4+b3/math/debian {text-terminal IO}: Ein Tabellenkalkulationsprogramm fürs Terminal bzw. die Konsole! Für Neulinge fürchterlich umständlich zu bedienen, da an "vi" angelehnt mit getrenntem Kommando- und Einfügemodus und reiner Tastaturbedienung. Für "vi"-Liebhaber und Terminal-Erfahrene aber dafür um so angenehmer. Alle Funktionen des Programms werden in einer einzigen man-Page beschrieben, daher ist auch keine umfangreiche zusätzliche Dokumentation vonnöten. Es gibt eine eingebaute Hilfe für alle wichtigen Kommandos, inklusive der Details aller eingebauten Funktionen die man in Formeln verwenden kann. Der Programm kann keine Excel/LibreOffice-Dateien lesen oder schreiben (nicht einmal das SYLK-Format) sondern benutzt sein eigenes Speicherformat und seine eigene Formelsprache. Es liegen aber Utilities für die Konvertierung von/in matrixförmiger Textandordnung sowie CSV bei; allerdings nur für Zahlenwerte und nicht für Textfelder. Reiner Export ist darüber hinaus in Reintextformat sowie LaTeX möglich. Die abgespeicherten Spreadsheets sind tatsächlich nichts anderes als Quelltexte in der internen Makrosprache, die bis auf die fehlenden Zeilennummern recht BASIC-artig aussieht, welche der Reihe nach Zuweisungen an alle Zellen der Tabelle tätigen, inklusive der verwendeten Formate und globalen Optionen. Entsprechend kann man diese Dateien auch mit der Hand editieren, und sie lassen sich unter Versionskontrolle stellen. Delta-freundlich ist das Format aber leider nicht, da es Zellverweise immer absolut in der EXCEL-üblichen Schreibweise angibt, anstatt relativ. Dadurch ändern sich sämtliche Verweise auf dahinter stehende Zellen, sobald man eine Zeile oder Spalte einfügt. Oder eine Zelle bzw. einen Bereich verschiebt. Wohlgemerkt, das Programm selbst verhält sich dabei EXCEL-artig. Nur "diff"s zwischen Versionen werden dadurch erheblich größer als nötig. Es gibt eine Funktion zum Speichern von Ausschnitten des Spreadsheets, bei welcher der gespeicherte Bereich implizit an eine andere Position reloziert wird. Mit dieser simplen Funktion ist das spätere Zusammenführen von Spreadsheets recht problemlos möglich, ohne dafür ausgefeilte Import-Wizards zu benötigen. Von den Funktionen her bietet es aber alles wichtige: Relative und absolute Zellbezüge, benutzerdefinierte Variablen, (ausschließlich) Fließkomma-Arithmetik, if/then/else-Funktion, Bereichsfunktionen für Summen und dergleichen, Lookup-Funktionen für Zell-Referenzen, numerische Funktionen wie Sinus, String-Funktionen, Ausführung externer Programme während der Auswertung einer Zelle, Finanzfunktionen, Zeit-/Datums-Funktionen. Was fehlt sind diverse exotische Einzelfunktionen, Matrixfunktionen, Datenbankfunktionen und eine "richtige" Makro-Programmiersprache (insbesondere Schleifenkonstrukte fehlen). Viele der fehlenden Funktionen können aber durch den Aufruf externer Kommandos realisiert werden. Externe Kommandos müssen nach dem Laden erst erlaubt werden, ansonsten haben sie keinen Effekt. Es gibt ein paar nette Ideen: Mit den +/- Tasten können Zellinhalte direkt um 1 erhöht/erniedrigt werden, ohne dass man sie editieren muss. Ebenso kann man bei der Funktion zum Ändern des Spaltenformats mit den Cursortasten die Spaltenbreite und Anzahl der Nachkommastellen inkrementell ändern, anstatt direkt Werte eingeben zu müssen (was ebenfalls möglich ist). Augenfällig Unterschiede zu Execl & Co sind: Die Zeilennummern der Zellen beginnen mit 0 statt 1. Es gibt nur eine Tabelle pro Datei (und somit auch keine umschaltbaren Tabs für verschiedene Tabellen). Das Programm aktualisiert berechnete Werte in Zellen sehr primitiv in einer fixen Reihenfolge, anstatt den Abhängigkeiten zwischen den Zellen zu folgen. Da es dies aber so lange wiederholt bis sich dadurch keine Änderungen mehr ergeben, liefert das normalerweise trotzdem die richtigen Ergebnisse, wenngleich mit unnötig hohem Rechenaufwand je nach Situation. Jede Zelle besteht aus einem Text-Teil und einem numerischen Teil, die separat editiert werden können. Ein vorhandener Text-Teil versteckt dabei den numerischen Teil, welcher aber nach wie vor in Berechnungen einfließt. Beschränkter Locale-Support ist vorhanden, muss aber explizit aktiviert werden, und bezieht sich selbst dann nur auf Dezimalkomma und Tausender-Gruppierung. Formate können nur für einzelne Zellen oder Spalten gesetzt werden, jedoch nicht für ganze Zeilen oder Bereiche. Das interne Datumsformat ist der UNIX-Timestamp. Es gibt Funktionen um diesen aus den Komponentenwerten (Jahr, Monat, etc.) zu konstruieren oder diese zu extrahieren, sowie Zugriff auf die strftime()-Funktion von C. Ähnlich gibt es auch optionalen Zugriff auf die sprintf-Funktion von C für die Zahlenformatierung, jedoch nur für Fließkomma-Werte. Es gibt 5 vordefinierte und 5 benutzerspezifische globale Formate, alle lassen sich redefinieren. Diese 10 Formate kann man jeder Zelle oder Spalte als Alternative zu einem explizit angegebenen Format zuweisen. Der Vorteil ist Speicherplatzersparnis im abgespeicherten Spreadsheet, vor allem bei Zellenformaten, da Referenzen zu den 10 globalen Formaten dort weniger Platz beanspruchen als explizit spezifizierte Formate. Die Ausgabe von Diagrammen ist nicht direkt möglich, jedoch sind Befehle vorhanden um Y- sowie X/Y-Diagramme in einem Format auszugeben welches gnuplot einlesen und daraus die Diagramme erzeugen kann. Es gibt allerdings keine eingebaute Funktion für das direkte Erzeugen von Histogramm-Diagrammen. Es gibt 2 Methoden das Programm mit Plugins um zusätzliche Funktionen zu erweitern: Erstens externe Kommandos die als klassische UNIX-Filter arbeiten, und zweitens Plugins zum automatischen Konvertieren von Dateien beim Laden/Speichern in andere Datenformate. sc ist ein bereits relativ altes Programm (erste Version 1998), das nur von der C-Laufzeitbibliothek und der ncurses-Library abhängt. Mit 336 kB ist das Executable auch überschaubar groß. 216 kB Download-Umfang des Programmpakets, 476 kB Installationsbedarf.
scantailor-0.9.11.1/media-gfx/gentoo: Ein interaktives Workflow-basiertes Hilfswerkzeug zur Nachbearbeitung gescannter Dokumenten. Es bietet Funktionen wie das korrigieren falscher DPI-Angaben in der Eingabedatei, das Aufteilen von linker und rechter Seite im Fall eingescannter Bücher, Wegschneiden von Seitenrändern, gerade-drehen von Seiten, Hinzufügen von Rändern bzw. anpassen an eine einheitliche Seitengröße, Ändern der Auflösung, entfernen von Schmutz und Umwandlung von Farbe/Grauton nach S/W. Diese Arbeitsschritte werden meist stapelmäßig über alle Seiten durchgeführt. Sie sind meist automatisierbar, können aber für individuelle Seiten angepasst werden. Das Programm arbeitet mit einzelnen Dateien (unterstützt werden TIFF, PNG und JPEG) für jede Seite, und das Endergebnis ist ein neuer Satz an Dateien welche entsprechend bearbeitet / bereinigt wurden. Das Programm unterstützt kein OCR, kann aber Scans gut für nachfolgende OCR aufbereiten.
scilab/sci-mathematics/gentoo: "MatLab"-Clone für viele Plattformen, Unix und Windows werden beide bestens unterstützt. Nicht ganz so MatLab-kompatibel wie Octave, aber dafür dürfte es eine größere Benutzergemeinde geben, und auch die Dokumentation soll außerordentlich gut sein. Die Grafikfunktionen sollen besser als bei Octave sein.
scite/app-editors/gentoo: Inferior Look-And-Feel
screen-4.0.3/app-misc/gentoo {KVM sharing}{text-terminal IO}: GNU "screen" is a terminal multiplexer. Can also act as a serial Terminal emulator. It allows to run any number of shells/terminal applications within a single physical terminal (or terminal emulator window). It allows to display a list of multiplexed windows and switch between them using a hotkey (Ctrl-A by default). It also provides a scrollback buffer independent of the one provided by the real terminal (if any). Copy/paste operations using this scrollback buffer can be performed via the keyboard alone, which is useful for machines without a mouse. It also remembers the identity of logical lines which have been broken over several physical lines because of the width of the current terminal. This allows "screen" to reflow the terminal contents when the terminal width is changed later. Alarms can be defined for individual multiplexed windows which notify the user when something in the windows changes, such as new output by a program. The reverse is also possible - to set alarms for chatty windows which notify the user if no more output has occurred for some time. "screen" also provides a multiuser feature, where the owner of the instance can define users and ACLs, allowing other users to access the same instance from a different terminal. Together with screen's display splitting capabilities (only vertical splits, however) this allows collaboration scenarios where different users work in different panes, allowing the other user to watch what is done. "screen" can also recognize ZMODEM uploads arriving at the current terminal device, automatically launching "rz" oder another application for actually downloading the data. GNU "screen" instance can easily be nested by using different hotkeys for the nested instances. This is handy for managing different machines via SSH, where every machine runs its own outer "screen" instance, and within those outer instances are nested inner instances of screen for different user-accounts on those machines.
scribus/app-office/gentoo: Ein sehr nettes DTP-Programm in der Art von Quark XPress. Hat eine gewisse Ähnlichkeit mit kword, geht aber in Sachen Layout weit über dieses hinaus. Es speichert Projektdatei (mit Texten) und Grafiken in separaten Dateien. Scribus ist immer dann das Mittel der Wahl, wenn man volle Kontrolle über das Layout innerhalb der Seite braucht, wie zum Druck von Flyern, Foldern oder Handouts. Man kann mit LibreOffice & Co ähnliches erreichen, aber es ist dort umständlicher. Weiters ist Scribus besser für die Kooperation mit externen Versionskontrollsystemen wie git geeignet. Denn die Projektdatei ist eine (nur optional gzip-komprimierte) "pretty formatted" XML-Datei. Wenn man die Einrückung beim Vergleichen ignoriert, oder entfernt, kann man daher mit Text-basierten diff-Tools zwei Dateiversionen gut mit einander vergleichen, Patches erstellen oder Unterschiede mit merge zusammen führen. Andererseits macht Scribus (und DTP-Programme im Allgemeinen) nur Sinn wenn man gedruckte Dokumente mit starrem Seitenlayout als Endergebnis sehen will. Ansonsten können PowerPoint-Hasser es noch zum Erstellen von Slides für Slideshows im PDF-Format verwenden.
scummvm-1.3.1/games-engines/gentoo {game}: Eine Game-Engine, welche die meisten alten Point-And-Click 2D-Adventures von LucasArts & Co abspielen kann, wie etwa "Flight of the Amazon Queen" (games-rpg/queen). Zumindest soweit man dazu die Original-Game-Dateien hat. Ein praktisches Problem ist jedoch, dass viele der alten Games CD-Musik oder Soundblaster-Hintergrundmusik verwendeten, was über den Einsatzbereich von SCUMM hinaus geht. Daher ist es besser diese Spiele im DOS-Emulator "DOS-Box" zu spielen, welche komplette CDs mitsamt Musik-Tracks emuliert.
sdlbasic-0.0.20070714-5+b1/devel/devuan {programming language}: Download 908,2 kB (inklusive Runtime-Paket). Eigentlich besteht es aus 2 Paketen: sdlbasic ist die IDE samt ausführlicher mehrseitiger HTML-Anleitung mit Frames, sdlbrt ist der eigentliche Interpreter. Man sieht sofort, dass sdlbasic toller als bwbasic und yabasic ist: Es bietet einfach von allem mehr. Es scheint insbesondere für Spieleprogrammierung gedacht zu sein, und bietet Grafik (inklusive Bits, Sprites, BOBs, Scrolling, Double Buffering, VSYNC), Bildformate (JPEG, PNG, GIF, TGA, BMP, PBM, IFF, XPM, XPM), Audio-Dateien (WAV, MP3, OGG), Musik (SoundTracker/MOD, MIDI), Musik-CDs (Tracks abspielen), Video-Dateien, Netzwerk-Sockets, Maus- Tastatur-, Joystick-Support - alles was man braucht. Es ist ebenfalls möglich, ein Standalone-Executable aus einem Basic-Programm zu machen, wenngleich dies von den vielen Runtime-Libraries getrübt wird von denen das Programm trotzdem noch abhängt. Das BASIC selbst ist ebenfalls üppig und übertrifft in den meisten Punkten auch yabasic. Allerdings scheinen yabasic gegenüber die Fähigkeiten zu fehlen, BASIC-Code zur Laufzeit zu kompilieren, und Funktionen alternativ auch über ihren Namen als String aufrufen zu können. Ebenso fehlt der ncurses-Support. Aber davon abgesehen schlägt sdlbasic seine Rivalen klar. Was die Kompatibilität angeht, reicht es zwar nicht an bwbasic heran, übertrifft aber yabasic klar. Zumindest was VB-Kompatibilität angeht. Denn von den unstrukturierten Original-Varianten scheint sich sdlbasic komplett verabschiedet zu haben. Zumindest sehe ich in der Anleitung weder Zeilennummern noch unstrukturierte Kontrollstrukturen erwähnt. Nicht einmal ein GOTO scheint es zu geben! Was für ein BASIC ist denn das??! Zum Ausführen klassischer BASIC-Programme taugt es daher wenig. Etwas eigenwillig ist zudem, dass Arrays mit eckigen Klammern indiziert werden. Der Debugging-Support scheint aber deutlich mächtiger zu sein, es scheint sogar Single-Stepping-Support zu geben. Kleiner Nachteil allerdings: Die tolle BASIC-IDE startete nicht sondern stürzte sofort mit einem Segfault ab. Mit anderen Worten, es funktioniert der derzeit nicht. Das mag aber meinem derzeit etwas kaputten System geschuldet sein; später noch einmal genauer evaluieren.
seahorse-2.32.0/app-crypt/gentoo {security}: Das grafische Front-End für gnome-base/gnome-keyring. Teil des GNOME Desktop Environments, kann aber auch separat davon verwendet werden. Es erlaubt, die Passwörter und Schlüssel welche mittels des GNOME Keyring APIs von Applikationen angesteuert werden können auch durch den User zu organisieren und zu verwalten. Da GNOME Keyring seinerseits wieder als Front-End oder Ersatz für andere Programme wie die Kombination "gpg" + "gpg-agent" dienen kann, kann seahorse auch dezidierte User-Interfaces für diese Backend-Programme ersetzen. Etwa "gpa". Allerdings wird es als generisches Front-End natürlich kaum je alle Detailsfähigkeiten dezidierter GUI-Interfaces (wie eben gpa) der Backends bieten können. Ein Problem von Seahorse ist, dass es noch nicht sonderlich ausgereift ist. Es gibt derzeit einige Funktionalitäten welche geplant aber noch nicht implementiert sind. Die wichtigsten Anwendungsfälle beherrscht es allerdings bereits ausreichend gut. Aufgrund der eher schwachen Algorithmen mit denen "gnome-keyring" seine Schlüsselbünde sichert, würde ich Seahorse aber nur mit Bedacht und für keine übermäßig vertraulichen Passworte oder Schlüssel einsetzen. Angeblich verschlüsselt Seahorse seine Passworte mit AES-128 und hashed mit SHA-256; an anderer Stelle sind aber nur wesentlich schwächere Algorithmen bis hin zu lächerlichem RC4-40 und MD2 angeführt. Das ganze ist nicht sehr klar dokumentiert. Insgesamt traue ich den einzelnen Komponenten gpg-agent, gpa und ssh-agent mehr als seahorse, und KeePassX scheint mir als Passwort-Safe weitaus geeigneter.
seahorse-plugins-2.30.1-r1/app-crypt/gentoo {security}: "seahorse-preferences" ist ein GUI-Tool mit dem man einen Default-Schlüssel auswählt sowie einstellt ob bei jeder Verschlüsselung zusätzlich auch an diesen Schlüssel verschlüsselt werden soll. "seahorse-tool" ist ein Kommandozeilen-Tool welches es erlaubt, mit dem durch "searhorse-preferences" ausgewählten Schlüssel Dateien zu verschlüsseln, entschlüsseln, unterschreiben und zu prüfen. Es greift dann also aufs seahorse-API zu, und dieses dann etwa wieder auf gpg als Backend. "seahorse-agent" ist die wohl wichtigste Anwendung welche dazu dient Pass-Phrases gecached im Speicher zu halten. Es dient offenbar als Drop-In-Replacement für gpg-agent, denn es lässt sich nicht starten wenn dieser bereits läuft. Offenbar ist es ein alternatives "gpg-agent"-kompatibles Front-End für "seahorse-daemon" (der Teil des Basis-Pakets "seahorse" ist), welcher das eigentliche Programm zu sein scheint welches die Pass-Phrases zwischenspeichert. Genau wie "gpg-agent" kann auch "seahorse-agent" neben PGP-Schlüsseln auch SSH-Schlüssel verwalten bzw. das Passwort für diese abfragen. "seahorse-plugins" enthält auch ein optionales Plug-In für den GNOME-Editor gedit, welches den markierten Text direkt verschlüsseln, signieren oder entschlüsseln/prüfen kann. Beim Ver- und Entschlüsseln wird dabei der markierte Text direkt durch das umgewandelte Gegenstück ersetzt; beim Prüfen wird das Ergebnis der Prüfung in einer Sprechblase angezeigt. Dieses Plugin macht wohl nur Sinn wenn man wirklich sehr häufig Text außerhalb von Mails verschlüsselt oder entschlüsselt/prüft; ansonsten gibt es mehrere andere Tools wo man mit einem Zwischenschritt mehr über die Zwischenablage dasselbe tun kann.
searchandrescue-1.5.0-2+b1/games/debian {game}: 3D Hubschrauber-Simulation. Man steuert einen Rettungshubschrauber und muss in verschiedenen Missionen Leute retten. Nicht einfach zu steuern, aber eigentlich sehr nett gemacht. Allerdings auch nicht gerade schlank - 53 MB Download, 75 MB installiert. Allerdings gehört es damit noch zu den schlankeren Flugsimulatoren, da die anderen wie Flightgear noch um einiges fetter sind. Die Grafik könnte schöner gemacht sein, aber die nur eher geringe Polygonzahl ohne besondere Anti-Aliasing-Filter unterstützt nur den Simulations-Charakter. Daher, trotz der eher wenig detaillierten Grafik, mein derzeitiger (Stand 2021) Lieblings-Flugsimulator für Debian. Weiters wäre zum Umfang zu sagen, dass dieser nahezu ausschließlich durch die Bitmap-Grafiken sowie Textdateien entsteht, welche die 3D-Modelle und Missionsbeschreibungen enthalten. Das eigentliche Spiel ist mit rund 1 MB Installationsumfang nicht groß. Theoretisch könnte man sich wohl auch einfach Custom-Missionen und eigene 3D-Modelle bauen, wenn man die verwendeten 3D-Formate kennen würde. Aber wer hat schon die Nerven für so etwas. Der Source-Code nennt es "V3D"-Format, die File extension ist allerdings nur ".3d". V3D ist irgend ein Microsoft-Format. Ich hoffe einmal, das ist nur eine zufällige Namensgleichheit! Außerdem fällt auf, dass der Großteil der 50 MB gar nicht für die 3D-Modelle verbraten wird, sondern: 4 MB Images, 7 MB Sounds, 11 MB Textures und 46 MB Music! Kein Wunder dass es nicht viel zu sehen gibt, weil fast alles für Audio-Dateien drauf geht! Leider erwartet sich die Grafik offenbar höherwertige Grafikkarten, und ist mit den verbreiteten INTEL onboard-Grafikkarten gerade noch so spielbar. Komfortabel ist aber anders. Weiters sind trotz der über 50 MB an Multimedia-Daten die einzelnen Levels nur extrem spärlich mit 3D-Objekten "bevölkert". Andererseits hat man ohnehin immer konkrete Missionsziele und gar nicht die Zeit sich groß umzuschauen. Aber nicht einal der Boden hat Texturen! Meist sind es nur einfach Farbverläufe je nach Terrain.
seetxt-0.72-6/text/raspbian: Primär ein man-Page-Anzeigeprogramm für X11, kann aber auch beliebige Textdateien anzeigen. Sogar mit vernünftig aussehendem Textumbruch. Aber *leider* ist das Programm offenbar nicht einfach dazu gedacht, mit irgendwelchen Dateinamen als Argumenten aufgerufen zu werden. Nein, man soll dazu eine Dateiliste vorbereiten, deren Position man dann auch noch im Konfigurationsfile eintragen soll. Zwar kann man Dateien auch so anzeigen, aber dann kommen Warnungen über die fehlende Dateiliste beim Start. Weiters hat das Programm ständig den Wahn in einen "Server-Modus" verfallen zu wollen, wo es dann von anderen Instanzen Befehle entgegen nimmt. Vermutlich ist die Idee dass es nur ein Fenster geben soll in dem Texte angezeigt werden, egal wie oft und von wo das Programm zum Anzeigen von weiteren Dateien gestartet wird. Das Programm scheint des weiteren seine eigenen Icons nicht mitzuliefern sondern sich darauf zu verlassen dass irgend ein anderes Paket das an seiner Stelle tut; jedenfalls bekam ich auf den Buttons nur Platzhalter-Symbole angezeigt. Und natürlich gibt es in bester (neuer) GTK-Tradition keine Texte mehr auf den Buttons, so dass man wirklich keine Ahnung mehr haben kann wofür sie gut sind. Fazit: Mit etwas Anpassung vielleicht brauchbar, sicherlich kann man alles irgendwie konfigurieren. Aber "out of the box" ist es unbrauchbarer Schrott.
seq24-0.9.3/media-sound/gentoo {audio}{music}: Ein erstaunlich schlanker MIDI-Synthesizer, wenn man bedenkt dass er bei 0,5 MB Installationsumfang (der Quelltext umfasst gar nur 216 kB) noch ein Qt-GUI mitbringt. Seq24 besteht nur aus einer einzigen ausführbaren Datei; es benötigt keine unzähligen Zusatz-Dateien oder Scripte zum Starten wie die meisten anderen Sequencer-Lösungen. Das GUI besitzt einen Pattern-Editor, mit dem man "Tracker"-ähnlich Songs erstellen kann. Deren Noten dann allerdings per MIDI ausgegeben werden statt direkt über Samples oder lokal im Programm erzeugte Effekte wie in den meisten "Tracker"-Applikationen üblich. Seq24 kann auch MIDI-Dateien importieren und exportieren. Für die tatsächliche Sound-Ausgabe ist allerdings ein MIDI-Backend erforderlich; sei es eine Hardware-MIDI-Soundkarte oder Software MIDI-Synthesizer wie FluidSynth oder Timidity.
serious-sam-tfe-1_beta3/games-fps/gentoo {game}: Ein Linux-Port von Serious Sam: The First Encounter. Erfordert die Dateien der Original-CD zur Installation. Startet zunächst noch recht vielversprechend, sogar mit Sound. Doch dann: Speicherzugriffsfehler; und das war's. Später noch einmal versuchen, sobald die Versionsnummer etwas höher ist.
sharutils/app-arch/gentoo: Endlich ein Paket, welches die simplen, überall erwähnten aber komischerweise nirgends sonst direkt auffindbaren POSIX-Tools uuencode und uudecode implementiert! Ach ja, nebenbei kann man mit den Paket auch Shell-Archives erstellen, d. h. selbstextrahierende Archive die ein portables (Bourne-) Shellscript sind. Nette Spielerei; braucht das jemand? Aber uuencode und uudecode sind allgegenwärtig erwähnt!
shash/app-crypt/gentoo {security}: Generates file or optionally salted password hashes using a large number of cryptographic hash functions. HMACs are also supported.
shed-1.15-5/admin/raspbian {hex-editing}{text-terminal IO}: Ein ncurses-basierter Binärdaten-Editor für angeblich beliebig große Dateien. Tatsächlich versagte der Sprungbefehl zum Anspringen des letzten Bytes einer 8 Exbibyte großen Testdatei komplett und sprang irgendwo völlig anders hin. Überhaupt scheint die Adress-Eingabe auf 32-Bit Offsets beschränkt zu sein, obwohl das Programm sehr wohl 64-Bit Offsets anzeigt. Der Editor zeigt pro Zeile nur ein Byte mit wahlweise dezimalem oder hexadezimalem Offset an, dieses jedoch in ASCII, hex, oktal, dezimal sowie binär. Man kann 1, 2 oder 4 Bytes zugleich auswählen, wodurch die aktuelle Spalte in mehreren Zeilen zugleich hervorgehoben werden. Ein zuschaltbarer Preview-Modus erlaubt es, ein paar Dutzend Bytes ab der aktuellen Position als ASCII-Text als zusätzliche Spalte einzublenden. Ein problem des Programms ist dass es unglaublich pingelig auf nicht unterstützte Tasten reagiert. Dann gerät es offenbar in eine Endlos-Schleife wo es den Terminal-Prozess zu 100 % auslastet so dass dieser nicht mehr reagiert. Ärgerlich ist dass es keine Taste gibt um zum Anfang oder Ende der Datei zu springen. Man muss statt dessen das Kommando zum Anspringen einer bestimmten Byteposition aufrufen und dort den Text "top" oder "end" anstatt einer Zahl eingeben. Geht es noch umständlicher? Ohne die erwähnten Bugs wäre das Programm vielleicht nett, so kostet es aber zu viele Nerven.
shed/app-editors/gentoo {hex-editing}{text-terminal IO}: Console-based hex editor. Cannot edit large files.
shotcut-21.01.29+ds-1/video/debian {video-editor}: Shotcut ist ein QML- und Qt-basierter (keine KDE-Abhängigkeit) in C++ und JavaScript implementierter nicht-linearer Video-Editor. Shotcut ist 2022 auf Platz 4 der beliebtesten nichtlinearen Video-Editoren (auf slant.co). 2022 ist der RAM-Bedarf direkt nach dem Start 166 MB RAM und steigt nach einigen Minuten auf 180 MB an ohne dass man etwas getan hätte. Bei einem geladenen Clip in der Timeline steigt der RAM-Bedarf auf 440 MB. Picture-in-Pictur Effekt. Stabiler als openshot und pitivi, obwohl es nicht alle derer Features bietet. Nachteile 2022: Man kann nicht mehr als einen Clip gleichzeitig auf der Zeitlinie selektieren, was das (nachträgliche) Verschieben ganzer Abschnitte der Zeitlinie zu einem Horror machen kann. Keine fortschrittlichen Effekte. Shotcut ist nur zum Zusammenfügen von Clips gedacht. Dafür hat es keine Probleme, Clips unterschiedlicher Auflösung oder Framerate in der selben Zeitlinie zu verwenden. Nett auch die Option beim Anlegen eines neuen Projekts, die Auflösung, Framerate, Codecs usw. automatisch an jene des ersten enthaltenen Clips anzupassen. Hat auch kein Problem mit 4K Material, soweit der Rechner schnell genug ist. Hat irgendwelche Features um grafische Animationen in HTML-Seiten einzubetten. Hat irgendwelche Features für Farbanpassung unterschiedlicher Videos (Unterwasser-Aufnahmen wurden als Beispiel genannt). Es gibt keine Offline-Hilfe. Die Hilfefunktion geht immer auf die Webseite. Das dortige "User-Manual" ist 2022 aber nur ein Haufen unzusammenhängender Wiki-Seiten einzelner Themen ohne erkennbare Reihenfolge. Und die meisten Seiten sind sogar nur leere Mockup-Dummies. Es gibt aber immerhin ein "Getting Started" als PDF zum Herunterladen. Bei der Wiedergabe gibt es Tastenkombinationen um auf der Zeitlinie in den folgenden Intervallen vor/zurück zu gehen: 1 Bild, 1 Sekunde, 2 Sekunden, 5 Sekunden, 10 Sekunden.
sigil-0.8.6/app-text/gentoo: Ein e-Book Editor für das EPUB-Format. Im Wesentlichen ist es ein eingeschränkter HTML-Editor mit vordefinierten Buttons und Menüeinträgen für von EPUB unterstützten HTML-Konstrukten. Ebenso kann man die Metadaten editieren, eine korrekte Dateistruktur wird eingehalten, etc. Eine sicherlich nützliche Applikation wenn man ausschließlich EPUB-eBooks verfassen will. Ich für meinen Teil sehe aber nicht so recht den Mehrwert gegenüber einem stinknormalen Texteditor, wo man das e-Book zuerst als normalen Text erstellt, und dann mit Tools wie asciidoc ins EPUB-Format konvertiert. Bestenfalls nachbearbeiten würde ich es in Sigil.
sil-doulos-4.106/media-fonts/gentoo: UNICODE-Font mit deutschen Umlauten. Darüber hinaus besondere Stärken bei romanischen und kyrillischen Zeichen. Wurde für die IPA entwickelt.
sil-gentium-1.0.2/media-fonts/gentoo: UNICODE-Font mit deutschen Umlauten. Darüber hinaus besondere Stärken in lateinischen und griechischen Zeichen.
simhash-0.0.20150404-1+b1/utils/devuan: Erzeugt aus beliebigen Dateien per Default-Einstellung 516 Byte große (2 Bytes Version, 2 Bytes Parameter, 128 x 32-Bit-Hashes) binäre *.sim-Dateien welche einen Hashwert der Originaldateien darstellen. Dies ist aber kein normaler Hash sondern ein "Similarity Hash", welcher Ähnlichkeiten in den Originaldateien abbildet. Man kann dann, ohne weiteren Zugriff auf die Originaldateien, die Ähnlichkeit zwischen zwei .sim Dateien (und damit zwischen den Originalen) als Wert zwischen 0 und 1 anzeigen lassen, oder sich die Unterschiede zwischen N Dateien in einer N x N Matrix anzeigen lassen. Das Verfahren funktioniert angeblich gut bei sequenziellen Daten wie Texten, jedoch nahezu überhaupt nicht bei Bildern und anderen mehrdimensionalen Datentypen. Ich habe allerdings ein grundsätzliches Problem mit der Sinnhaftigkeit dieses Programms. Denn ich sehe keine Möglichkeit wie man damit bei vielen Dokumenten Gruppen ähnlicher Dokumente finden sollte, oder auch nur das ähnlichste Dokument zu einem gegebenen, ohne dazu einen Aufruf des Programms für alle Dokumente durchzuführen. Das ist unrealistisch. Der einzige Nutzen des Programms scheint es zu sein dass man gezielt die Frage beantworten kann wie ähnlich zwei lokal nicht mehr verfügbare Dokumente sind. Doch wen interessiert so etwas überhaupt abseits einer Suche nach *allen* ähnlichen Dokumenten?
similarity-tester-3.0.2-1/devel/raspbian {text-diff}: A suite of small programs to find similarities in particular programming languages (C, C++, Java, PASCAL, MODULA-2, LISP, Miranda and 8086 assembler) or in plain text files. They read the source files and look for segments of text that are similar. Two segments of program text are similar if they only differ in layout, comment, identifiers, and the contents of numbers, strings and characters. Runs of sufficient length are reported. The programming-language specific variants compare the tokenized input rather than the actual text, so simply reformatting the source text or white space change will not make them miss similarities. The utility is typically used to find proof for copyright infringement.
simple-revision-control-1.24-1/vcs/debian {version control}: Es handelt sich um ein in Python2  geschriebenes alternatives Commandline Front End "src" (was übrigens ein Wortspiel auf "RCS" sein soll) für verschiedene andere Versionskontrollsysteme. Per Default arbeitet es mit ",v"-Dateien von RCS, kann jedoch auch mit Dateien des SCCS-Versionskontrollsystems umgehen. Es ist dabei allerdings nicht komplett kompatibel mit RCS, da es einige der RCS-internen Felder für eigene Metadaten verwendet, was normalerweise aber kein Problem darstellt da RCS diese Felder ohnehin nie von sich aus benutzt. Unverständlicher Weise legt es die ",v"-Dateien nicht in einem RCS-Unterverzeichnis ab wie RCS dies (optional) tut, sondern in einem applikations-proprietären ".src"-Unterverzeichnis. Ein gewisser Mehrwert von src gegenüber dem Original-RCS sind konsistenter designte Kommandos mit weniger umständlichen Optionen, aber im Grunde ist es natürlich ein- und dasselbe. Möglicherweise nützlich ist hingegen dass es einzelne Versionskontroll-Historien ins Fast-Export Format von Git konvertieren kann, und von diesem auch wieder zurück ins RCS-Format. Was den SCCS-Support angeht, ist der sogar noch rudimentärer als der für RCS, obwohl doch bereits das Original-SCCS so wenig kann. In jedem Fall ist dieses Paket nichts was man wirklich braucht - im Zweifelsfall fährt man besser mit den Originalen, sei es nun RCS oder SCCS. Die Vereinfachung einiger Kommandos ist es nicht wert, sich mit den wenn auch geringen Unterschieden und Kompatibilitätsproblemen herum zu ärgern, die gegenüber den Original-Utilities vorhanden sind.
simutrans-0.112.3/games-simulation/gentoo {game}: Ein Transport-Tycoon Klon. 20 MB Installationsumfang. Komplett mit 1000 Karten, Grafiken und In-Game Bedienungsanleitung. MIDI-basierte Musik, die dank FluidSynth und JACK ganz normal in guter Qualität über die PCM-Soundkarte ausgegeben wird. Nett gemacht, obwohl die Standard-Grafik etwas pixelig aussieht. Jedoch gibt es alle möglichen Grafikpacks zum Dazu-Installieren, weswegen das vermutlich kein Problem darstellt. Scheint auch ausreichender Community-Support vorhanden zu sein. Wenn ich solche Spiele nicht so sterbenslangweilig finden würde, wäre ich echt davon begeistert!
simutrans/games-simulation/gentoo {game}: Freier Transport-Tycoon-Clone. Sogar mehrsprachig, und mit vielen Addons in der Fan-Gemeinde. Nachteil: Nur erbärmliche Bildschirmauflösung, sowie, warum auch immer, nur ein Binary und kein Source Package im Portage Paket.
sk1–0.9.1/media-gfx/gentoo: A vector graphics editor aiming to be file-format-compatible with CorelDraw and Adobe Illustrator. Can read and write several vector formats, including PostScript, AutoCAD and SVG. Written in Python. Not very mature yet; I could not even make it starting up.
slbackup-0.0.12-8/utils/devuan {backup}{deduplication}: Ein in Python implementiertes Backup, welches rdiff-backup für die eigentliche Arbeit verwendet und diesem so die zusätzliche Fähigkeit spendiert, mehrere Clients über SSH-Verbindungen auf einen zentralen Server zu backuppen. Das Programm scheint nicht immer zu funktionieren wie es soll und gelegentlich in inkonsistentem Zustand hängen bleiben, was sich aber Dank mit den Möglichkeiten des rdiff-backup-Backends reparieren lassen sollte. Es scheint auch nicht weiter gepflegt zu werden. Es gibt - anderswo - eine neue Version 2+ dieses Programms, welches nicht mehr rdiff-backup als Backend benutzt, sondern direkt von Object-Storage (etwa von Cloud Providern) Gebrauch macht und MD5 zum Erkennen identischer Dateien nutzt. Es ist daher mit größeren Datentransfers zu rechnen, da der rsync-Algorithmus nicht mehr zum Einsatz kommt. Weiter ist die Maximalgröße einzelner Dateien dann auf 5 GB begrenzt. Doch wie gesagt, diese neue Version ist ohnehin noch nicht unter Debian verfügbar (Stand 2019-01).
slib-3b1-5/lisp/debian: Eine plattformunabhängige (also nur als Quelltexten bestehende) Bibliothek für die Programmiersprache Scheme. Kann von vielen Scheme-Implementationen aus genutzt werden. Explizit angeführt sind derzeit: gsi, mzscheme, guile, scheme48, larceny, scmlit, elk, sisc, kawa. Aber grundsätzlich sollte jedes Scheme welches den Standard ausreichend genug implementiert diese Library benutzen können. Ein besonderes Anliegen dieser Bibliothek ist es, eine plattformübergreifende Implementierung für die Definition und Nutzung von Software-Paketen unter Scheme bereit zu stellen, wie insbesondere die "require"-Prozedur. Davon abgesehen stellt die Bibliothek eine große Anzahl von solchen Paketen für alle möglichen Anwendungsgebiete zur Verfügung. Darunter sind sowohl Eigen-Implementationen von im RnRS-Standard beschriebenen Standard-Funktionen, als auch eigenständige General-Purpose Funktionen, wie etwa Primzahlenbehandlung, FFT, CSV-Dateien, Diagramm-Grafiken, Matrixfunktionen, eigenimplementierte relationale/ISAM Datenbank (kein SQL), Sortieren, Suchen, Hashen, CRC, Baumstrukturen, eigenimplementierten Winkelfunktionen und ähnliche Standard-Mathematik-Funktionen, XML, HTML, Kommandozeilen-Optionsparser, Zeit-/Datumsfunktionen, Priority-Queues sowie vieles mehr. Wenn die eigene Scheme-Implementation irgend ein Feature nicht kennt (z. B. Arrays oder die Format-Funktionen), kann man in vielen Fällen die vermissten Funktionen aus der die slib importieren. Dasselbe gilt auch wenn man auf älteren Scheme-Versionen diverse Features aus neueresn Scheme-Standards nutzen möchte, welche die Library bereit stellt. Insgesamt kann man die Installation der Library sehr empfehlen, wenn man irgend ein Scheme als Programmiersprache nutzt. Per Stand 2021-01: Rund 4 MB Installationsumfang, 800 kB Download.
slim-1.3.2-r7/x11-misc/gentoo: Ein grafischer Login-Manager für X11. Im Gegensatz zu xdm zeigt er ein hübsches Hintergrundbild und grafische Login-Widgets an. Mit F1 kann man verschiedene Sessions auswählen, die man allerdings sämtlich vorher im Konfigurationsfile definieren muss. Er beherrscht neben normalen Logins vier Spezialfunktionen, welche man durch das Eingeben eines Schlüsselworts anstatt eines Login-Namens auslösen kann wobei man ins Passwort-Feld das "root"-Passwort eingeben muss: "halt" fährt das System hinunter, "reboot" startet es neu, "suspend" versetzt es in die Tiefschlafmodus und "exit" startet ein simples Terminalfenster als Notfall-Shell. Diese vier Funktionen führen einfach vordefinierte Befehle aus, die man im Konfigurationsfile aber auch frei redefinieren kann. Ansonsten beherrscht er keine Spezialfunktionen, insbesondere kein Shutdown/Reboot ohne Kenntnis des Root-Passworts oder eine Rückkehr in den Textmodus. Die Spezialfunktionen sind auch nicht über Buttons erreichbar sondern nur über die oben genannte Methode, was voraussetzt dass man die Schlüsselworte kennt. slim hat nur geringe Paketabhängigkeiten und ist insofern deutlich schlanker als kdm/gdm, allerdings ist der Installationsbedarf durch die ganzen Themes und Grafiken dennoch deutlich höher als bei xdm.
slmon/app-misc/gentoo: A console-based graphical simple monitoring tool. Allows to monitor CPU load, network load, processes and storage utilization. Nothing special, but OK unless you have better tools. And under Linux you certainly do have.
smplayer-16.11.0~ds0-1+deb9u1/video/devuan {media-player}: Grafisch ansprechendes Front-End für mplayer oder mpv. Gut für diejenigen, welche sich mit der Tastaturbedienung alleine nicht begnügen wollen. Zumindest das mplayer-Backend hinkt allerdings von der Codec-Optimierung her nach dem VLC-Player nach.
smstools-3.1.15-2/comm/devuan: Ein e-Mail-ähnliches Framework zum Senden und Empfangen von SMS. Benötigt keinen systemd. (Ich habe noch nicht gestestet was geschieht wenn ModemManager installiert ist.) Sobald man sich erst einmal ein Modem im Konfigurationsfile definiert hat, läuft ein Server-Prozess und wickelt alles weitere über /var/spool/sms ab. Wenn man dort eine e-Mail-ähnliche Textdatei in einem Ausgangsverzeichnis anlegt, wird diese vom Serverprozess automatisch gefunden, auf gültige Syntax geprüft, und wenn erfolgreich automatisch versandt. Das Programm unterstützt Textnachrichten in den Zeichensätzen GSM, ISO-8859-15, UTF-8 and UCS2 (Unicode). Ebenso unterstützt es binäre Nachrichten wie Klingeltöne, Logos oder WAP-Push. Ähnlich tauchen eingehende SMS als neue Dateien in einem Eingangsverzeichnis auf. Allerdings werdend diese danach von Modem gelöscht, außer wenn man mit "keep_messages = yes" einen speziellen Testmodus aktiviert wo das Programm aber nicht normal laufen sondern nur SMS vom Modem herunterladen kann. Das Programm unterstützt auch Blacklists unerwünschter Telefonnummern. Versand und Empfang arbeiten Warteschlangen-orientiert, und im Falle von Versandfehlern kann es nach einer Wartedauer ein paar Mal erneut versucht werden bevor das Programm aufgibt und die SMS in einen "nicht zustellbar"-Ordner verschiebt. Es lassen sich auch Message-Handler-Scripte hinterlegen, die beispielsweise beim Empfang einer SMS aufgerufen würden und dann einen Signalton abspielen könnten. Grundsätzlich funktioniert das alles. Das Empfangen von SMS-TANs auf diese Weise funktioniert beispielsweise gut. Problem: Von den früher empfangenen SMS welche bereits am Telefon gespeichert waren, wurde nur ein Subset nach nicht nachvollziehbaren Kriterien automatisch beim Start vom Modem ins Eingangsverzeichnis verschoben. Aber vermutlich ist das nur ein Konfigurationsproblem, da man viele AT-Kommandos konfigurieren sollte aber ich mich nur bei den wenigsten davon auskenne. So kann ein Modem beispielsweise verschiedene Speicherbereiche für SMS besitzen - vermutlich hätte ich einen anderen oder zusätzliche auswählen müssen. Weiters stört mich dass dieses Programm alle 5 Sekunden den Status des Ausgangsordners auf neue zu versendende SMS prüft. Was bedeutet, dass es ständig aus etwaigem PowerSave-Schlaf aufwacht. Eine serverlose Lösung wäre mir lieber. Schließlich scheint das Programm zu dämlich zu sein zu erkennen, wenn man das Modem absteckt oder abschaltet. Es müllt dann sein ganzes Log-File mit endlosen Meldungen (zwischen mehrsekündigen Wartepausen) zu, dass es zu I/O-Errors gekommen wäre. Ein schwerwiegenderes Problem ist dass das Programm nicht mitbekommt sobald neue SMS eintreffen. Etwa mTANs fürs Online-Banking. Die spool-Dateien bleiben leer. Es ist unklar ob das ein Konfigurationsproblem ist oder ein Bug, aber es ist sehr ärgerlich. Ich habe mir das Programm daher wieder deinstalliert, weil nur zum Selbstzweck lasse ich keine Dienste permanent laufen.
snake3d/games-arcade/gentoo {game}: Der Schlangenspiel, tatsächlich in 3D. Allerdings: Größtenteils Wireframe-Grafiken. Zumindest der Spielfeld. Nicht sehr toll. Außerdem friert nach dem Beenden des Spiels der Rechner kurzzeitig ein; dann geht es aber wieder weiter. Seltsam.
snake4-1.0.14-1+b1/games/debian {game}: Snake! Was soll man noch mehr dazu sagen? Das Original, obwohl dieses recht kleine Früchte und aufzusammelnde Objekte allgemein hat. Aber das Spielprinzip ist das klassische: Friss mit der Schlange die Früchte, wodurch der Schwanz der Schlange immer länger wird, und kollidiere weder mit dem eigenen Schwanz noch mit Monstern, Wänden oder schädlichen Nahrungsmitteln. Mit 38 kB Download-Größe (246 kB installiert) ist es auch nur eine winzige Installation verglichen mit den meisten anderen Spielen.
snapraid-12.2-1/admin/raspbian {backup}: Eine RAID-5/6-artige Parity-Lösung auf Datei-Ebene für Windows und Linux, die im Userspace läuft und daher keinen speziellen Kernel-Support braucht. Im Gegensatz zu einem echten RAID erzeugt SnapRAID seine Redundanz-Informationen nicht in Echtzeit, sondern arbeitet eher wie ein Backup-Programm. Man ruft es explizit oder in einem cron-Job auf, um den aktuellen Zustand des Dateisystems oder der Dateisysteme (es ist möglich, den Inhalt mehrerer Dateisysteme gemeinsam durch die Parity-Informationen zu schützen) mit den Parity-Dateien zu synchronisieren. Im Falle eines Datenverlustes kann man dann das Dateisystem oder ausgewählte Dateien auf den Zustand zum Zeitpunkt des letzten Backups zurück setzen. SnapRAID ist vor allem für große Dateien effektiv die sich selten/nie ändern. Also etwa für Multimedia-Dateien. Anders als RAID-5/6/Z kann es bis zu 6 Parities zu einer vorhandenen Disk hinzu fügen. Bis 2 Parities ist die CPU-Last angeblich nie ein Problem, darüber hinaus werden allerdings CPUs mit SSSE3 empfohlen für welches offenbar spezielle Optimierungen im Programm vorhanden sind. Über ARM verliert die Anleitung kein Wort. Man kann zu existierenden SnapRAIDs nachträglich weitere Parities hinzufügen, jedoch nicht wieder (ohne alle Parities komplett neu berechnen zu müssen) entfernen. Anders als die echten RAIDs speichert SnapRAID neben der Parity-Information auch 128-Bit-Hashes ab (Murmur3 bevorzugt für 32-Bit OS oder SpookyHash bevorzugt für 64 Bit OS), so dass es erkennen kann ob Daten beschädigt sind auch wenn kein Lesefehler für sie gemeldet wird. Es legt die Parity-Information in einer normalen, aber riesigen Datei ab, welche sich auf einem anderen Dateisystem (das fallocate() unterstützt) befinden muss als die Parity-geschützten Disks. Neben den Parity-Informationen müssen auch noch mehrere Kopien von Content-Dateien angelegt werden, welche die Metadaten inklusive der Hashes aller Dateien enthalten. Normalerweise wird eine Kopie direkt im zu schützenden Dateisystem abgelegt - diese Kopie wird vom Programm dann speziell behandelt. Weitere Kopien werden normalerweise als 2. Datei auf den Parity-Platten abgelegt. Es wird immer eine Content-Datei mehr benötigt als es Parity-Dateien gibt. Beschädigte Content-Dateien leert man einfach; die Reparatur verwendet dann eine der anderen. Bei der Reparatur mit dem "fix"-Befehl kann man sowohl Parity-Dateien als auch den zu schützenden Dateibaum reparieren lassen. Man kann mit dem "fix"-Befehl auch in-place gezielt einzelne Dateien oder Directories auf den Zustand der letzten Synchronisation zurück setzen lassen. Das ermöglicht überdies auch ein "undelete" dieser Dateien. SnapRAID lässt sich nachträglich zu bereits mit Daten gefüllten Disks hinzufügen oder wieder entfernen, ohne dass diese irgendwie reformatiert oder mit irgendwelchen zusätzlichen Superblocks versehen werden müssten. Ein Nachteil von SnapRAID kann der Speicherbedarf sein: Es wird 1 GiB RAM pro 16 TiB verwaltetem Disk-Speicherplatz benötigt. Durch Ändern der internen Block-Größe kann man das in gewissen Grenzen beeinflussen. Bis 30 TB an zu schützenden Daten reicht auch ein 32-Bit OS aus; darüber hinaus wird ein 64 Bit OS benötigt. Da es nicht auf Sektor- sondern auf Datei-Ebene arbeitet, kann man die Daten und Parity-Dateien auch defragmentieren oder mit normalen Datei-Befehlen auf andere Datenträger verschieben ohne dass sich etwas an der Konsistenz ändert. Außerdem können gelöschte Dateien wiederhergestellt werden. SnapRAID beherrscht keine inkrementellen Backups. Man kann nur eine einzige "letzte" Version als Backup haben. Daher ist es gut geeignet kürzlich gelöschte Dateien wiederherzustellen. Jedoch nicht die vom letzten Jahr. Außer natürlich man legt mehrere Parity-Disks an die unabhängig von einander zu verschiedenen Zeitpunkten synchronisiert werden. SnapRAID scheint Änderungen von Dateien nur anhand Zeit/Datum zu erkennen. Daher ist es nicht in der Lage Datenbank-Dateien zu sichern deren Inhalt sich zwar ändert, das Änderungsdatum hingegen nicht. VeraCrypt-Containers tun dies z. B. per Default, allerdings kann man das in diesem speziellen Fall mit einer Option abschalten. Eine weitere und recht schlimme Einschränkung ist dass es nur Dateiinhalte, Modifikationszeit, Symlinks und Hardlinks speichert. Weder Berechtigungen, Ownership, ACLs oder EAs werden gebackupt. Auch für Bootlaufwerke ist SnapRAID nicht gedacht, da es Bootsektoren usw. nicht sehen kann. Es wird nicht einmal für /home empfohlen, da es auf sich selten ändernde Dateisystem-Inhalte optimiert ist. Meiner Meinung nach macht snapraid nur dann einen Sinn, wenn man mehr als eine Parity-Platte verwenden will. Andernfalls kann man ein ganz normales Backup-Programm nehmen, und den Inhalt der zu schützenden Verzeichnisbäume auf dieselbe Platte sichern wohin man mit snapraid die einzelne Parity-Datei sichern würde. Kostet auch nicht mehr Speicherplatz - mit Kompression wahrscheinlich sogar weniger. Außerdem kann man so alle Metadaten mitsichern und überdies meist auch inkrementelle Backups machen.
snowdrop-0.02b-13/utils/raspbian: Erlaubt es, unsichtbare Wasserzeichen in C-Quelltexte oder Englische Textdateien einzubauen, damit man nachher beweisen kann es mit dem Wasserzeichen versehen zu haben. Die C-Version variiert Whitespace, alternative Identifier-Namen und äquivalente C-Ausdrücke wie "!x" vs. "x==0" damit sich das Wasserzeichen als Prüfsumme ergibt. Es gibt 2 Versionen für Englishen Text: Eine benutzt zusätzlich angebliche Tippfehler, die andere nicht. Beide Versionen variieren Interpunktationszeichen (etwa verschiedene Arten von Hochkommas), Whitespace und Wort-Synonyme um eine als Wasserzeichen gewünschte Prüfsumme zu erzeugen. Als Synonyme wird eine 13 kB große Textdatei mitgeliefert, man kann jedoch auch eine eigene Datei bereit stellen. Leider sind die verschiedenen Variations-Verfahren fix in den Programmen eingebaut; man kann nicht etwa unerwünschte Verfahren wie Whitespace-Variation ausschalten. Allein schon deshalb erscheint mir das Programm unbrauchbar, denn so etwas fällt zumindest mir überdeutlich auf und ist überdies hässlich. 
socat-1.7.2.0/net-misc/gentoo: Das ist die Power-Version von "cat". Es kann alles was netcat-6 kann, darüber hinaus aber noch viel mehr. Denn es kann neben TCP und UDP auch UNIX Domain Sockets, SCTP, RAW Sockets, Sockets mit explizit angegebenen Protokoll im Stream oder Datagram Mode, Pipes, FIFOs, normale Dateien, bereits offene File Handles, Pseudo-Terminal-Devices, GNU Readline-basierte E/A, Linux TUN Devices als auch erst neu zu startende externe Kommandos als Ein- oder Ausgabestrom verwenden. Bi-direktionale Ströme können dabei auch im "listen"-Mode betrieben werden. TCP-basierte Verbindungen könnten darüber hinaus auch noch mit SSL/TLS verschlüsselt und mit Zertifikaten gesichert werden; HTTP- und SOCKS-4/4A-Proxies werden ebenfalls unterstützt. Neben diesen Basis-Features bietet es noch unzählige Optionen, wie etwa eine Anfangsposition im Falle von Dateien, Zugriffsrechte, Zeilenende-Konvertierung, Broadcast, Routing-Optionen, Puffergrößen-Definitionen, Voll/Halb-Dupluex, tcpwrappers, Address-Bereiche, Timeouts und noch mehr. Kurzum, socat bietet so ziemlich alles was einem für solch ein Tool einfallen kann. (Hmmm. SOCKS-5 scheint es nicht zu beherrschen. Das ist aber auch schon alles das fehlt!) Mit einem Installationsumfang 1 MB ist es etwas mehr als doppelt so groß wie netcat-6, kann aber auch ein Vielfaches davon. Ich würde es in allen Situationen statt einer Installation von netcat/netcat-6/dpipe empfehlen wo man nicht gerade jedes einzelne Byte des Installationsumfanges abzählen muss um Platz zu sparen. (Im Zweifelsfall sollte man aber natürlich immer das simpelste Tool installieren das den Job erledigt, und *das* wird socat kaum je sein. Allein schon die man-Seite ist beeindruckend lang.) Socat ist etwas einfacher als netcat zu benutzen weil es eine einheitliche Syntax hat: Es werden immer zwei Quell/Ziel-Adressen angegeben. Jede davon kann STDIN oder STDOUT sein, oder auch keine davon. Dadurch kombiniert socat die Fähigkeiten eines "cat" mit denen einer bidirektionalen Pipe wie "dpipe". Allerdings ist die Syntax von "dpipe" übersichtlicher wenn eine Kette von mehr als 2 Prozessen bidirektional verbunden werden sollen. In socat geht das nur durch rekursiven Einsatz weiterer socat-Instanzen als geforkte Quell/Ziel-Subprozesse.
solarwolf/games-arcade/gentoo {game}: Gut gemachte Adaption eines alten Arcade-Games. Die Feinde schießen von allen 4 Bildschirmseiten her auf einen, man muss ausweichen und Objekte aufsammeln. Dabei wird man zusätzlich von Meteoriten, UFOs etc belästigt. Extras leisten temporäre Hilfe. Ein Spiel der Sorte "es wird immer schwerer bis es unmöglich wird", aber durchaus unterhaltsam.
soldieroffortune/games-fps/gentoo {game}: Die Windows-CD reicht leider nicht; man bräuchte eine spezielle an Linux angepasste Loki-CD-Version zum Installieren.
solvespace-3.1+ds1-3+rpi1/graphics/raspbian {3D}{CAD}: Ein 3D CAD Programme mit parametrischem Modellieren. Auch für 2D geeignet. Ein direkter Konkurrent von FreeCAD. Im Vergleich zu diesem ist SolveSpace ein wesentlich schlankeres Programm, einfachere statische Benutzerschnittstelle (die Menüpunkte ändern sich nicht ständig situationsabhängig), schneller zu erlernen, intuitiver und angenehmer zu benutzen. Es liegt bezüglich des Bedienungskomforts zwischen LibreCAD und FreeCAD. Seine vektorbasierte Oberfläche sieht schlichter und weniger hübsch aus als die Qt-Oberfläche von FreeCAD, ist aber wesentlich aufgeräumter und übersichtlicher als jene von FreeCAD. Allerdings ist FreeCAD von den Features her SolveSpace klar überlegen, welches wiederum LibreCAD überlegen ist. So kann SolveSpace z. B. Objekte nicht entlang eines beliebigen Pfades extrudieren. Verwendet NURBS oder Triangle-Meshes für 3D-Objekte. Bei Verwendung der (exakteren) NURBS hat SolveSpace einige Bugs bzw. Mängel, so dass es einige Spezialfälle nicht korrekt behandelt. Es unterstützt auch weniger Import-/Export-Formate als FreeCAD. Auch die Simulations-Funktionen sind weniger umfangreich als die von FreeCAD, und es hat eine kleinere Community und entsprechend weniger Support durch diese. Alle wesentlichen CAD-Features beherrschen aber beide Programme. Wenn man einfach nur ein CAD-Programme benötigt, sollte SolveSpace gut geeignet sein. Nur bei besonders gehobenen Ansprüchen kann FreeCAD vonnöten sein. Der schlanke Charakter von SolveSpace wird etwas durch den Umstand konterkariert, dass das Programm über keine Offline-Hilfe verfügt. Wenn man die HTML-Dokumentation samt Grafiken und Erklär-Videos mittels "wget" als Offline-Hilfe von der Webseite herunter lädt und nur die *.webm Version der Videos aufbewahrt, resultiert dies in einer 86 MB großen Datei (als 7zip-Archiv komprimiert).
sonic-pi-1 {audio}{music}: 2.10.0-2/editors/debian: Ein System zum angeblichen "Live"-Editieren von Musik. Da denkt man natürlich gleich an irgend eine DJ-Software. Was man tatsächlich bekommt, ist ein zwar hübsch gemachter aber eben doch nur ein Texteditor in dem man ein Programm eintippen kann, mit integrierter Hilfe welche Befehle die simple Programmiersprache bereit stellt und Sound zu erzeugen. Die Sprache bietet dabei zwar alles was man braucht bis hin zu aufwändigeren Effekten wie Hall, aber es ist eben doch nur eine Programmiersprache. Die gepriesene Interaktivität kommt einzig daher, dass Buttons wie "Start" und "Stop" verfügbar sind, die das Programm ausführen oder anhalten, wodurch dann der entsprechende Sound erklingt. Grundsätzlich ist das ganze sicher nicht schlecht. Aber es ist in erster Linie eine Software um die Grundlagen des Programmierens zu erlernen, und keine DJ-Software. Es gibt keine ausgefuchsten Dialogfenster mit allen möglichen Schiebereglern, keinen Pattern Editor, keinen MIDI-Editor, keinen Sequencer, kein Notenfenster. Nicht einmal eine Klavier-Tastatur ist verfügbar um wenigstens einen einzelnen Ton abzuspielen ohne dazu einen Programmbefehl aufrufen zu müssen. Kurzum, es ist in Wahrheit nur ein Lehrprogramm, kein Musikprogramm. Das Programm hat überdies vergleichsweise umfangreiche Abhängigkeiten wie Ruby, Tcl/Tk, die Supercollider IDE oder die Scintilla-Bibliothek. Überhaupt scheint SonicPi nichts weiter zu sein als ein zusätzlicher Frontend-Layer oberhalb der Supercollider IDE, der eine benutzerfreundliche Online-Hilfe integiert.
spacefm-1.0.6-5/utils/raspbian spacefm-1.0.6-4/utils/debian {file manager}{GTK+}: Ein Fork des PCManFM-Dateimanagers, welcher (Stand 2012) einer der interessantesten Dateimanager für Linux überhaupt ist. Er hat nur geringe Abhängigkeiten von anderen Libraries, mit Ausnahme von GTK-2 auf dem er basiert. Er bietet im wesentlichen alle Features welche bereits im Review des PCManFM angeführt sind, darüber hinaus aber erheblich erweitertes User Interface. Das Neuartige an diesem Dateimanager ist, dass es sich eigentlich um einen 4-Fenster-Dateimanager handelt, von dem jedes Fenster dasselbe bietet wie der frühere PCManFM. Genauer gesagt handelt es sich nicht um 4 eigenständige Fenster, sondern das Fenster ist horizontal und vertikal in jeweils zwei Teilfenster unterteilt, in Summe daher 4 Teilfenster. Die Besonderheit von SpaceFM besteht nun darin, dass man jedes dieser 4 Fenster mit einem Mausklick dazu- oder auch wieder wegschalten kann. Entsprechend kann das Fenster aus 1 - 4 Teilfenstern bestehen, je nachdem wie viele man aktiviert hat. Dadurch kann der SpaceFM sowohl das Aussehen eines "klassischen" Windows-Dateimanagers mit nur einem Fenster bieten, oder das eines 2-Fenster_Dateimanagers a la Norton Commander, oder ein Norton Commander mit zusätzlichen Einzelfenster darüber/darunter, oder zwei Norton Commanders über einander. Da man die Darstellungsoptionen für jedes der 4 Fenster separat festlegen kann, können die einzelnen Fenster durchaus für verschiedene Typen von Arbeit optimiert werden. Darüber hinaus bietet SpaceFM sehr detaillierte Sortieroptionen. So kann man neben den üblichen Sortierkriterien auch noch festlegen, wie Dateien, Ordner und versteckte Objekte im Vergleich zu anderen Objekten angeordnet werden sollen. Also etwa, dass alle Ordner zuerst kommen sollen, oder alle versteckten Dateien zuletzt. Bevor die eigentliche Sortierreihenfolge greift. Das ist sehr praktisch, da die meisten andere Dateimanager diese Einstellungen fix einprogrammiert haben und dadurch in speziellen Aufgabenstellungen nur unbefriedigend funktionieren. Weiters hat SpaceFM eine eigene Implementation eines virtuellen Dateisystems eingebaut, so dass es keine externen Frameworks und Daemonen wie GVFS benötigt um zu funktionieren. Selbst wenn einzelne Features dabei sehr wohl auf die Hilfe externer Tools angewiesen sind (etwa sshfs für SSH-Support), vermindert dies die Abhängigkeit von anderen Paketen und man braucht nur jene Zusatztools zu installieren die man auch tatsächlich benötigt. So etwas wie Archive als virtuelle Ordner öffnen kann SpaceFM nicht direkt. Dafür wird aber ein (Shell-basiertes) Scripting-Framework mit GUI-Editor geboten, wo man abhängig vom Dateityp beliebige Einträge für das Kontextmenü hinzufügen kann. Damit kann man z. B. externe FUSE-Dateisysteme wie AVFS mounten, um den Inhalt von Archivdateien als virtuelles Dateisystem in einem spacfm-Ordnerfenster anzeigen zu lassen. Außerdem kann man noch "Actions" mit dem Scripting-Framework definieren. Solche Menü-Einträge stehen unabhängig vom Dateityp immer im "Actions"-Untermenü des Kontext-Menüs zur Verfügung. Ein sehr nützliches Detail von SpaceFM ist dass weitere Dateien welche während eines bereits laufenden Kopiervorrgangs in das selbe Zielfenster gezogen werden keine parallelen Kopiervorgänge auslösen, sondern zunächst nur in eine Warteschlange für dieses Fenster eingereiht werden welche dynamisch am unteren Ende des Dateilistenansicht eingeblendet wird. Das verhindert Disk-Thrashing, insbesondere wenn große Dateien wie Videos kopiert werden. Wo paralleles Kopieren tatsächlich gewünscht wird, können Kopiervorgänge aber jederzeit mit einem Klick auf einen Eintrag in der Warteschlange parallelisiert werden. Ebenso lassen sich bereits parallel laufende Kopiervorgänge jederzeit anhalten und wieder in normale sequenzielle Warteschlangen-Einträge umwandeln. Schließlich hat SpaceFM (ähnlich wie PCManFM) einen vergleichsweise sehr kleinen Installationsumfang - rund 1,7 MB bei der 64-Bit-Version. SpaceFM ist zudem der Standard-Dateimanager des "Parted Magic" Live-Systems (Version 2012-09) zum Bearbeiten von Disk-Partitionen. SpaceFM kennt anders als PCManFM kein "in-place" umbenennen, sondern zeigt einen eigenen Dialog dafür an. Dafür bietet dieser aber mehr Möglichkeiten, etwa die Datei auf den neuen Namen zu kopieren oder zu symlinken anstatt zu verschieben ("Umbenennen"). Man den Vorgang optional als User "root" durchführen; sozusagen ein eingebautes "sudo". Außerdem zeigt der Dialog den eigentlichen Dateinamen und seinen Pfad in separat editierbaren Feldern an. Überdies kann man mit einem optionalen Auswahl-Dialog eines oder beide Felder durch die korrespondierenden Eigenschaften das ausgewählten Objekts ersetzen. Was SpaceFM leider nicht zu beherrschen scheint, ist eine ad-hoc Filterung der im Fenster angezeigten Dateien. Man muss die vollwertige Suchfunktion dafür verwenden, die dafür aber umständlicher zu verwenden ist. Denn diese bietet zwar mehr Möglichkeiten (Shell-Joker, optionales Ignorieren von Groß-/Kleinschreibung, optionaler Ausschluss von versteckten Dateien oder Unterordnern, optionale explizite Liste von zu durchsuchenden Verzeichnissen, optionales Durchsuchen von Dateiinhalten mit optionalen RegExes, Einschränken von Dateigröße und Änderungsdatum), aber man kann mit den Treffern nichts anderes tun als sie zu öffnen/starten oder einen neuen Tab für das Verzeichnis des ersten markierten Treffers erzeugen zu lassen, in dem der Suchtreffer dann nicht einmal die aktuell ausgewählte Datei ist. Vor allem gibt es keine Möglichkeit, Pfad oder Name der Suchtreffer irgendwie in die Zwischenablage zu bekommen. Der Praxiswert der Suchfunktion ist daher nahezu Null, wenn man mit allen Suchtreffern irgend etwas tun möchte, wie etwa sie löschen. Immerhin bietet das "Actions"-Menü aber zumindest die Möglichkeit Dateien im aktuellen Verzeichnis mit Shell-Jokern aus-/abwählen zu können.
spacerider-0.13/games-arcade/gentoo {game}: Ein sehr simpler 2D Sideways-Scroller. Zwar eine ganz nette Soundtracker-Musikuntermalung, aber die Grafik ist relativ fade (immer dasselbe) und man muss dauernd wie ein Wahnsinniger auf die Spacetaste hämmern welche als Feuertaste dient. Es gibt auch nur 3 Gegner-Typen (die sich geradlinig von links nach rechts bewegen, dabei nichts weiter tun und einen einfach nur rammen wenn man sie nicht abballert oder ausweicht) und nur eine Art von Schuss. Je mehr Punkte man hat, desto mehr Monster erscheinen. Irgendwelche Waffen-Addons oder höhere Levels konnte ich nicht entdecken. Offenbar ist das Spiel noch in den Anfangszügen der Entwicklung und man kann vorläufig einfach noch nicht mehr tun. Der Quelltext des Spiels könnte aber eine gute Ausgangsbasis sein um einen Beispielcode für ein simples SDL-Spiel zu studieren.
speedcrunch-0.12.0-6/math/raspbian speedcrunch/math/debian {calculator}{Qt}: Der Nützliche. Ein in Qt4 implementierter, freundlich und einfach aussehender Desktop-Taschenrechner. Markant ist vor allem seine Aufteilung des breitformatingen rechteckigen Fensters: Den Hauptteil der Breite mit etwa weniger als 2/3 belegte unten das Tastenfeld, darüber ein ziemlich niedrig wirkendes einzeiliges Eingabefeld, und der Rest bis zur Menüleiste oben am Fenster wird von einem "Papierstreifen"-Bereich eingenommen, wo man die bisherigen Eingaben und Ergebnisse - sehr bunt eingefärbt - sehen kann. Das rechte Drittel (tatsächlich etwas mehr als dies) der Fensterbreite wird hingegen von einer Art Browser eingenommen, der mit Tabs zwischen verschiedenen Ansichten umschaltet: Formelsammlung, eine lange Liste von Naturwissenschaftlichen Konstanten aus 8 Kategorien, einer Liste von ca. 90 verfügbaren Funktionen von denen im Tastenfeld nur eine kleine Auswahl angeboten ist, Liste benutzerdefinierter Variablen, Liste benutzerdefinierter Funktionen, Verlauf. Der "Verlauf" enthält anders als der Papierstreifen nur die eigenen Eingaben. Außerdem sind die Zeilen alternierend eingefärbt was die Übersichtlichkeit erhöht. Alle Browser-Tabs bis auf die Formelsammlung haben auch ein Suchfeld, was sicherlich hilfreich ist um sich bei bekanntem Namen des Gesuchten langes Scrollen zu ersparen. Man kann alle Tabs im Menü selektiv ein- oder abschalten, so dass selten genutzte Tabs einen nicht zu irritieren brauchen. Die oben geschilderte Anordnung ist allerdings nur die Voreinstellung. Tatsächlich kann man nämlich alle Teilbereiche des Displays "undocken" und dann als separate Fenster woanders hin verschieben bzw. wieder zurück docken. Nur 2 Bereiche bleiben fix: Das Tastenfeld, darüber der Papierstreifen, und dazwischen die Eingabezeile. Da man das Tastenfeld allerdings abschalten kann, sind Eingabezeile und Papierstreifen darüber die einzigen zwingenden Bestandteile des Fensters. Die Formelsammlung besteht aus gerade mal 5 Kategorien mit wiederum im Durchschnitt 5 Formelgruppen pro Kategorie, welche hier nur als Name angeführt sind. Klickt man auf einen Namen, kommt man auf eine Ansicht nur für diese Formelgruppe. So gibt es bei "Kreis" etwa sowohl die Formeln für Fläche als auch Umfang. Oder bei der für quadratische Gleichungen für jede der beiden Lösungen eine separate Formel. Klickt man nun auf eine Formel, wird diese ins Eingabefeld übertragen und bunt eingefärbt. Durch die Farbe erkennt man die Variablen, welche man durch konkrete Werte ersetzen soll. Während man dies tut, wird bereits das Ergebnis angezeigt - also nicht erst wenn man "=" oder die Eingabetaste drückt. Ebenso kann man frühere Eingaben oder Ergebnisse im "Papierstreifen"-Bereich anklicken, worauf hin diese ebenfalls in die Eingabezeile übertragen werden. Eine Besonderheit des Programms ist das Rechnen mit Einheiten. Anders als bei Qalculate! welches ebenfalls mit Einheiten rechnen kann, müssen hier immer die vollen Namen der Einheiten eingegeben werden. Das Programm rechnet dann 3volt*5ampere = 15 watt. Man muss das "volt" und "ampere" dazu aber nicht komplett eingeben, denn es erscheint bereits wenn man "v" und "a" tippt ein Vervollständigungs-Fenster, wo man das "volt" und "ampere" auswählen kann. Allerdings ist dies nie eine automatische Vervollständigung - wenn man die Vorschläge nicht aufgreift und einfach weiter tippt, bewirken sie (anders als bei anderen Programmen) keine unerwünschten Eingaben. Diese Eingabe-Vervollständigung wird nicht nur auf Einheiten angewendet, sondern auch auf Funktionen, Konstanten und Variablen. In diesem Fall erspart man sich das Benutzen des Browsers. Weiters ist anzumerken dass eingefügte Funktionen auch eine automatische Pop-Up-Hilfe für die erforderlichen Argumente anzeigen wenn man noch keines davon eingegeben hat. Leider verschwindet diese Hilfe sobald man mit der Eingabe beginnt und kommt auch nicht wieder, außer man löscht alle Argumente. Da die meisten Funktionen aber nur ein oder zwei Argumente haben, ist das praktisch kaum je ein Problem. Es gibt einen interessanten Modus, wo sowohl Beistrich als auch Punkt als Dezimalkomma interpretiert werden. Das könnte nützlich sein wenn man bei der Arbeit abwechselnd aus deutschen und englischen Dokumenten Zahlen für Berechnungen kopieren muss. Ein bisschen ärgerlich ist hingegen die ständige Anzeige "Kompilierfehler" die immer so lange erscheint als der bislang eingegebene Ausdruck noch syntaktisch unvollständig ist so dass kein Ergebnis angezeigt werden kann. Das könnte gerade unbedarfte Benutzer verwirren. Tippt man etwa "1", "+", "5" ein erscheint erst "Aktuelles Ergebnis: 1", dann "Kompilierfehler", dann "Aktuelles Ergebnis: 6". Mit der Eingabetaste wird wird dann sowohl Eingabe als auch Ergebnis auf den Papierstreifen übertragen. Dieser erhält bei Bedarf auch einen Scrollbalken wenn die Anzahl der Einträge nicht mehr ins Fenster passt. Etwas umständlich gelöst ist auch die Variablen-Zuweisung - man muss dazu die "x="-Taste am Anfang der Zeile drücken bzw. dies einfügen - und nicht erst wenn das Ergebnis bereits fest steht. (Obgleich man mit x=ans denselben Effekt bewirken würde. Aber es bleibt umständlicher als nötig.) Das Programm hat eine - optionale - Statuszeile, wo Zustandsvariablen wie die aktuelle Art des Winkelmaßes angezeigt werden. Anders als bei den meisten anderen Programmen kann man aber auf diese Einstellungen klicken, und dadurch die verschiedenen möglichen Werte der Einstellungen der Reihe nach durschschalten. Etwas eigenartig ist, dass es zwar einen hexadezimalen Modus gibt, aber sich das Tastenfeld deswegen nicht ändert, so dass man die Ziffern A bis F nicht über die Bildschirmtasten eingeben kann. Aber natürlich sehr wohl über die Tastatur ins Eingabefeld. Statt dessen gibt es ein zuschaltbares Tastenfeld, wo man jedes einzelne der bis zu 64 Bits ein- und ausschalten kann. Auch Shift-Operatoren sind vorhanden, wo man in der Einzelbit-Tastendarstellung dann zusehen kann wie die gedrückten Tasten um eine Position "wandern". Das Programm rechnet nur mit normalen Fließkommazahlen bzw. Ganzzahlen und damit nicht beliebig genau, macht dafür aber einen sehr aufgeräumten und (vordergründig) simplen Eindruck. Eine Besonderheit ist die erwähnte Infix-Eingabe in einem Textfenster, wobei automatisch die Variable "ans" am Anfang eingefügt wird falls man den Ausdruck mit einem Infix-Operator beginnt. Diese Variable enthält das Ergebnis des vorherigen Ausdrucks. Überdies kann man die die im "Papierstreifen" aufgezeichneten Ein- und Ausgaben von zuvor auch über die Cursortasten als "History"-Funktion zurück holen um sie weiter zu verwenden. Als Zahlenformate werden Dezimal, Binär, Oktal und Hexadezimal unterstützt. Winkelmaße können nur Radiant oder Grad verwenden; die selten verwendeten Neugrad werden nicht unterstützt. Die Anwendung ist voll internationalisiert; das Dezimalkomma kann separat konfiguriert werden. Das Programm ist sichtlich auf praktischen Bedarf ausgerichtet und verzichtet auf esoterische Konfigurationsoptionen. Es scheint mir gerade für "Normalanwender" die viel rechnen müssen sehr gut zugeschnitten zu sein - zumindest unter den Programmen welche die Formeleingabe per Textgeld überhaupt unterstützen. Weiters kann man Sitzungen auch speichern (benutzt dafür das JSON-Format), laden und exportieren. Letzteres als HTML-Text oder Reintext. Die letzte Sitzung wird aber automatisch geladen wenn man das Programm startet, so dass es normalerweise nicht nötig ist irgend etwas explizit abzuspeichern. Alles in allem hinterlässt das Programm einen positiven Eindruck von Benutzerfreundlichkeit und hohem Praxiswert. Zwar reicht es bei weitem nicht an die Möglichkeiten von Qalculate! heran, ist aber auch wesentlich simpler zu benutzen und völlig ausreichend wenn man nur mit Fließkommazahlen und Einheiten rechnen möchte. 82 MB RAM-Verbrauch, 3,6 MB Installationsumfang, 860 kB Download (die zusätzlich erforderlichen Qt-Bibliotheken nicht eingerechnet). Der hohe RAM-Verbrauch ist das größte Argument gegen dieses ansonsten sehr nette Programm. Denn sogar das deutlich mächtigere qalculate-gtk verbraucht "nur" 60 MB RAM und ist daher um einiges schlanker.
spiralmodular-0.2.2a-r1/media-sound/gentoo {audio}{music}: Ein lustiges in FLTK verfasstes GUI, in dem man die verschiedenen Komponenten eines (Sound-) Synthesizers konfigurieren und mit einander kombinieren kann. Es gibt Input-Plugins für MIDI oder die PC-Tastatur als Piano-Keyboard, und Output-Plugins für OSS/ALSA oder Disk-Writer. Die Soundkarte kann aber auch als Live-Sample-Quelle genutzt werden! Und das Sampler-Plugin kann dies aufzeichnen und Wiedergeben. Weitere Plugin-Komponenten sind für Oszillatoren, Envelope, Echo etc. zuständig. Es gibt auch ein Plugin welches vom Programm und seinem Plugin-API völlig unabhängige LADSPA-Plugins in SpiralSynthModular laden kann. Jede Komponente hat ein oder mehrere Ein- und Ausgänge, welche sich im GUI-Editor frei mit anderen Komponenten verbinden lassen. Es gibt sogar ein simples Sequenzer-Plugin; ein editierbares Raster welche Note wann gespielt werden soll. Dieses Plugin kann sogar aufnehmen! Statt rein synthetischen Klangquellen können überdies auch Samples aus externen Dateien geladen und verwendet werden. Mit dem Sequenzer-Plugin und den Sound-Generator-Plugins können selbstständig spielende Songs als Konfiguration erstellt werden. Weiters gibt es Visualisierungs-Plugins, etwa ein Oszilloskop, welches im GUI direkt die Ausgabe visualisiert. Die Position der im GUI als Kästchen dargestellten Komponenten lässt sich frei verschieben; die Verbindungslinien folgen dem. Zusätzlich kann man Textkommentare platzieren, um Funktionsgruppen zu dokumentieren oder allgemeine Hinweise zu erteilen. Alle Settings der Komponenten lassen sich jederzeit dynamisch ändern, auch während der Sound ausgegeben wird. Jede Komponente kann sich in 2 Zuständen befinden: Iconisiert oder normal wo sie alle Regler anzeigt. Klickt man auf den "x"-Button einer Komponente, wird sie iconisiert. Ein Klick auf eine iconisierte Komponente kehrt zur Normaldarstellung zurück. Im Gegensatz zum entsprechenden Verhalten eines X11-Fenstermanagers ändert sich dadurch aber nicht die Position am Bildschirm. Die Komponenten dürfen einander dabei am Bildschirm überlappen. Der GUI-Editor hat horizontale und vertikale Scrollbalken, so dass man die virtuelle Arbeitsfläche unabhängig von der Bildschirmauflösung oder -Größe bearbeiten kann. Der GUI-Editor lädt oder speichert die aktuelle Konfiguration in Textdateien, welche auch ohne GUI verwendet bzw. editiert werden können. Vermutlich ist es einfach möglich, eigene Plugins zu entwickeln und diese dann genau so zu verwenden wie die mitgelieferten. Nett: Jedes Plugin hat einen "?"-Button, der direkt im Programm ein kleines Hilfe-Fenster öffnet, welches einen entsprechenden (simplen, kein HTML oder so) Hilfstext anzeigt. Dadurch sowie die mitgelieferten ladbareb Tutorials braucht man eigentlich gar keine Dokumentation zu lesen. Soweit alles sehr nett. Nachteile: Benötigt eine veraltete FLTK-Version. Es gibt keine Möglichkeit, Komponenten zu gruppieren und die Gruppe als eine Komponente im GUI anzuzeigen. (Ob man dies vielleicht mit einem Plugin nachrüsten könnte?) Dadurch wird das ganze recht sehr unübersichtlich weil umfangreich, sobald man viele Komponenten hinzu fügt. Weiters wirkt das ganze mehr wie ein Schaltplan als ein Musikstück (wenn es über den Sequencer selbsttätig spielen soll): Man verbindet die einzelnen Komponenten mit Leitungen, einem Timing-Plugin als Clock-Source und Triggern - das wird sehr schnell komplex. Die Text-Kommentare können nur einzeilig sein. Allerdings kann man beliebig viele davon anordnen. Es fehlen jegliche Hilfsfunktionen zum Alignen oder Grid-Snapping der GUI-Komponenten. Nicht einmal Mehrfachselektion ist möglich. Das Programm ist auch etwas absturzfreudig; allerdings mag das Plugin-spezifisch sein. Resümme: Trotz kleinerer Kritikpunkte insgesamt sehr nett; zumindest zum damit Herumspielen! Leider wird das Ding nicht mehr aktiv weiter entwickelt. Es gibt einen Nachfolger namens "om", und dieser wiederum hat einen Nachfolger namens "ingen".
spline-1.2-4/math/debian {math}: Approximiert eine unbekannte Funktion, von der eine Menge von Koordinaten entlang ihres Kurvenverlaufes als Eingabe vorliegt, als eine Kurve die aus Akima-Splines besteht. Dann gibt es ähnliche Werte wie die der Eingabe aus, nur dass die Ausgabwerte auf der Spline-Kurve liegen. Das Besondere an den Akima-Splines ist angeblich, dass sie der handgezeichneten Approximation der Kurve ähnlicher sehen als solche welche durch übliche Polynom-Approximationsmethoden erzeugt wurden. Insbesondere schwingen Akima-Splines nicht sondern erzeugen klatte Kurvenverläufe. Ein Nachteil der Akima-Splines ist allerdings, dass deren 2. Ableitung (im Gegensatz zur 1.) chaotisch sein kann. Man kann die Anzahl der Ausgabe-Punkte bzw. deren Dichte auch anders als die der Eingabepunkte festlegen. Was das Programm leider nicht kann, ist extrapolieren. Es kann die unbekannte Funktion nur im Wertebereich zwischen der kleinsten und größten X-Koordinate der Eingabedaten interpolieren.
splint-1: 3.1.2+dfsg-5/devel/debian: Ein statischer Code-Checker für C. Angelehnt an das historische UNIX-Tool "lint" für denselben Zweck. Praktisch ist es jedoch mit den Default-Optionen unbrauchbar für unmodifizierten Code, da unzählige unzutreffende Warnungen angezeigt werden. Erst durch sehr umfangreiches Hinzufügen von Annotations-Kommentaren zu den bereits vorhandenen Quelltexten können diese in einen Zustand gebracht werden, dass splint tatsächlich hilfreiche Warnungen ausgibt. Splint deckt dabei eine Unzahl an Themenbereichen ab, beginnend mit erweiterten Typprüfungen über Speicherallokation und Reference Ownerships bis hin zu Null-Pointer-Management und Kontrollfluss-Analysen. Splint ist kein "lass ich einfach drüberlaufen"-Tool für C-Quelltexte, sondern eher eine eigene Annotations-Sprache die erheblichen Umfang als Teil des Quelltextes erreichen kann, wenn sie effektiv eingesetzt werden soll. Es gibt allerdings auch einige "relax"-Optionen mit denen man die schlimmsten falschen Warnungen bei unangepasstem Code verhindern kann, wobei aber die Chance immer noch höher ist dass Fehler gefunden werden als bei einem C-Compiler allein. Allerdings werden zugleich auch die meisten sinnvollen Warnings deaktiviert wenn man diese Relaxation-Optionen nutzt. Splint ist ein Utility auf das man sich einlassen muss und das sehr viel Zeit erfordert um vorhandene Quelltexte für die Benutzung durch das Tool zu modifizieren. Dann jedoch kann es sicherlich einen wichtigen Beitrag zur Fehlervermeidung leisten.
spout-1.4-4/games/debian {game}: Ein winziges Spiel (17 kB Download, 50 kB installiert) nur mit schwarz-weiß-Monochrom-Grafik in einem kleinen Fenster und ohne Sound. Das Fenster lässt sich nicht vergrößern. Aber selbst in dem Fenster sieht die Grafik schon extrem pixelig aus. Man kann allerdings via Commandline-Optionen einen Full-Screen-Modus wählen sowie frei definierbare Zoom-Stufen, welche allesamt aber nichts anderes tun als die gering aufgelöste Grafik hoch zu skalieren. Trotzd dieser Nachteile hat das Spiel einen gewissen Reiz bzw. Charme. Man steuert dabei ein wie ein riesiges Spermium oder wie ein großer Schlüssel aussehendes Raumschiff (oder was auch immer) durch zufällig generierte Level die von oben nach unten Scrollen. Die zufällig generierten Formen haben allesamt einen höhlenartigen Charakter. Allerdings gibt es keine garantierten Zugänge, manchmal ist der Weg komplett versperrt. Hier muss man den "Schwanz" des "Spermiums" schwenken, aus dem nämlich ständig ein Düsenschub entströmt auf dem man reiten muss, um zu verhindern dass man den unteren Bildschirmrand erreicht (es gibt Gravitation) wodurch man stirbt - genau so wie bei der Berührung der Wände. Mit dem geschwenkten Antriebsstrahl lassen sich die Pixel-Hindernisse nämlich aus dem Weg räumen. Alledings muss man danach schnell genug wieder die Düsen nach unten richten, denn sonst stürzt man wegen dem geschwenkten Antriebsstrahl nach unten aus dem Bildschirm und verliert. Überdies hat man ein Zeitlimit innerhalb dessen das Level beendet sein muss - das schaffte ich bislang aber noch nie.
sputnik-12.06.27-2/web/devuan {wiki}: In Lua 5.1 geschrieben. 3,58 MB installiert. Verwendet Markdown für die Textinhalte. Kann seine Daten in Reintextfiles, einem Git-Repository oder in einer SQL Datenbank ablegen. Diffs und RSS-Feeds können generiert werden. Angeblicher Null-Konfigurations-Aufwand. Dem widerspricht, dass es auch mehrere Benutzer mit Rechten unterstützt. Ist eine Fast-CGI-Anwendung und bringt einen eingebauten Webserver mit, kann aber auch mit anderen Webservern benutzt werden. Bietet Captcha-Support. UTF-8 und Right-To-Left-Support. Bereits der erste Versuch in der Sandbox auf der Projekt-Homepage herum zu spielen führt zu einer Fehlermeldung mit Lua Stack-Trace.
sqlitebrowser-3.12.2-1/database/raspbian: Ein Qt-basiertes grafisches Programm zum Editieren von SQLite3-Datenbanken. Man kann damit auch neue Datenbanken erstellen. Dasselbe gilt für Tabellen, Views, Tigger und Indizes. Weiters kann man die Tabelleninhalte in einem Excel-artigen Matrixansicht bearbeiten (ansehen, Inhalte verändern, neue Datensätze hinzufügen, Datensätze löschen). Dabei kann man auch Filter für jede Spalte festlegen, was die Anzahl der angezeigten Datensätze automatisch reduziert. Per Default wird ein simpler Substring-Filter verwendet. Man hat aber auch die meisten Vergleichmöglichkeiten von SQL (inklusive "BETWEEN") zur Verfügung, bis auf "LIKE". Statt dessen kann man jedoch nach RegExes suchen lassen, was noch mächtiger ist. Die resultierende Anzeige kann man dann als neue VIEW abspeichern lassen. Für die Eingabe neuer Daten gibt es sogar eine Komfort-Möglichkeit, wo man mit der Tabulatortaste immer zum nächsten leeren Feld kommt. Nach dem letzten Feld wird einen neuer Datensatz angelegt und man kommt zu dessen erstem Feld. Man kann daher bequem Daten eingeben ohne je die Maus zu benutzen - etwa über den Ziffernblock der Tastatur, wenn die andere Hand auf der Tabulator-Taste liegt. In die Matrix-Zellen passen aber nur relativ kurze Zahlen und Texte, sonst beginnt der Zellinhalt zu scrollen. Es gibt jedoch ein Seitenfenster, wo man das aktuelle Feld als längeren Text (mit weichem Zeilenumbruch) und sogar als Bild oder Binärdaten anzeigen kann. Bei Bedarf kann man während der Eingabe zwischen der Zelle und diesem Seitenfenster für die Eingabe länger Texte hin- und her wechseln. Allerdings muss man dies scheinbar mit der Maus machen - ich fand keinen Shortcut um in den Seitenfenster-Editor zu wechseln. Dabei ist dieser Editor sehr mächtig: Nicht nur dass er einzeiligen oder weich umgebrochenen Text bearbeiten kann. Er kann auch RTL-Text bearbeiten. Für JSON sowie XML gibt es Syntax-Highlighting und sogar eine Pretty-Print Ansicht mit zuklappbaren Unterstrukturen. In der Binär-Ansicht steht sogar ein Hex-Editor zur Verfügung, wo man die Byte sowohl als Text als auch als Hex-Werte bearbeiten kann. Der Feldinhalt kann auch aus Dateien geladen oder gespeichert werden. Weiters kann man auch Bilddateien in ein BLOB-Feld laden und dann als Bild anzeigen lassen. Es kann dann alle Bildformate anzeigen die Qt unterstützt. Momentan (2025) sind dies auf meinem Rechner: BMP, GIF, JPG, JPEG, PNG, PBM, PGM, PPM, XBM, XPM, SVG, GIF, ICO, TGA, WBMP, MNG, ICNS, TIFF, WebP. Speichern kann ein BLOB-Feld natürlich jedes Bildformat, aber diese Bildformate können im Seitenfenster-Editor auch angezeigt werden. Das Schema der Datenbank wird als ansonsten als Quelltext oder Feldliste angezeigt. Man kann auch direkt SQL-Ausdrücke eingeben und ausführen lassen, mit Tab- und Dropdown-Completion für Schema-Objekte (wie Tabellen und Feldnamen) aus der Datenbank sowie Tokens der SQL-Syntax. Weiters kann man die Namen von Objekten aus einem Schema-Browser mit der Maus in den SQL-Text ziehen. Dabei wird auch Mehrfach-Auswahl unterstützt. Das ist nützlich wenn man bei einem SELECT Statement die Liste der Eingabefelder als Ausgabefelder in den Befehl kopieren will, um diese Liste danach zu verändern. Syntax-Highlighting wird ebenfalls im Editor geboten. Überhaupt ist dieser SQL-Editor das "Herz" des Programms wo man am meisten tut, abgesehen von der Datenanzeige in der erwähnten Matrix-Ansicht (die übrigens auch für das Betrachten des Ergebnisses von manuell eingetippten SELECT-Befehlen verwendet wird). Mit Ausnahme von Tabellendefinitionen die auch in einem speziellen Feld-Editor bearbeitet werden können, werden die meisten bereits existierenden SQL-Objekte beim Bearbeiten einfach als SQL-Quelltext angezeigt den man dann verändern kann. Wenn man z. B. eine VIEW bearbeite will, wird im SQL-Editor eine "DROP"-Anweisung für die alte VIEW eingefügt, gefolgt von der aktuellen Definition der VIEW zur Bearbeitung. Führt man diesen SQL-Befehl dann aus, wird die neue VIEW erzeugt. Einige Pragmas wie "Fremdschlüssel" können konfiguriert werden. SQL-Befehle können ausgeführt werden. Import ind Export sind als SQL-Quelltest und CSV möglich. Export darüber hinaus auch noch als JSON. Ich überprüfte auch mit "lsof" ob das Programm irgendwo Temporärdateien anlegt. Das scheint nicht der Fall zu sein. Nur die Datenbank selbst und ihre WAL/Rollback-Datei im selben Verzeichnis waren geöffnet. Allerdings kommen natürlich Tempordateien hinzu welche SQLite3 selbst anlegt. Das dürfte sich jedoch auf /tmp beschränken. Es sollte daher möglich sein auch sensitive Daten wie Passwörter mit dem Programm zu bearbeiten, wenn /tmp ein tmpfs und Swap verschlüsselt ist (oder fehlt), und die Datenbank selbst auf einem verschlüsselten Datenträger (oder tmpfs) abgelegt ist. Das Programm kann jedoch noch eine XML-Projektdatei abspeichern, welche Dinge wie aktuelle Suchfilter und Sortier-Einstellungen enthält die in der Datenbank selbst nicht vorhanden sind. Wenn man diese Datei am selben Ort speichert wie die Datenbank selbst, sollte daraus ebenfalls kein Sicherheitsrisiko erwachsen. Alles in allem ein nützliches Programm um schnelle Änderungen an bestehenden Datenbanken vorzunehmen (das Editieren einzelner Feldinhalte ist auch möglich) oder simple Datensätze zu ergänzen. Aber kein Ersatz für "richtige" Datenbank-GUIs wie MS-ACCESS oder LibreOffice Base. Ein kleines Ärgernis des UI ist dass überall kleine Icons angebracht sind um Funktionen zu erklären. Dadurch erscheint aber nicht etwa eine Hilfe, sondern der Web-Browser wird gestartet um irgend eine Webseite anzuzeigen. Dadurch wird man dann ausspioniert, welches Hilfethema man zu welcher Zeit ansieht. Außerdem ist die Hilfe dann nicht verfügbar wenn man gerade keine Internet-Verbindung hat. Zum Glück betreffen die meisten solchen Hilfepunkte Details von SQLite, welche man auch in dessen (Offline-) Dokumentation nachschlagen kann. Mit hoher Bereitschaft für Installationsaufwand kann man allerdings das Wiki welches die Dokumentation im Markdown-Format enthält von GitHub herunter laden. Allerdings hat man dann nur einzelne Seiten welche nicht mit einander verlinkt sind. Einfacher dürfte es daher sein, das Wiki mit wget zu "scrapen" und so an eine funktionierende Dokumentation zu gelangen.
squashfuse-0.1.103-1/utils/debian {FUSE}: Erlaubt es das SquashFS-Dateisystem welches auf vielen Live-CDs und Rettungssystemen zum Einsatz kommt zu mounten, auch wenn kein Kernel-Support dafür vorhanden ist (was bei normalen Kernel selten der Fall ist da dieses Dateisystem kein offizieller Bestandteil des Linux-Kernels ist und daher erst dazu gepatcht werden muss). SquashFS ist eines der platzeffizientesten Dateisysteme und komprimiert die enthaltenen Dateien stark. Allerdings ist es ähnlich wie ISO-9660 nur ein Read-Only-Dateisystem (es wurde auch dafür konzipiert auf CD-ROMs abgelegt zu sein). Die Live-CDs mounten daher über das SquashFS in der Regel noch ein Overlay-Dateisystem wie unionfs oder AUFS, um scheinbar dennoch ins SquashFS schreiben zu können. Dafür kann man auch unionfs-fuse benutzen.
ss-1.39/sys-libs/gentoo: Does mostly the same thing as "netstat", but comes just with the right default options. If requested, it can also display more detailed TCP information than netstat can provide.
ssdeep-2.13/app-crypt/gentoo ssdeep-2.14.1+git20180629.57fcfff-2/admin/raspbian: Berechnet fuzzy-Hashes von Dateien, und erlaubt es später festzustellen welche neuen gegebenen Dateien *ähnlich* den zuvor gehashten sind, und wie sehr. Oder man gibt einen Schwellenwert an, und lässt sich nur Dateien anzeigen die stärker von den früher gehashten abweichen. Es ist definitiv kein Ersatz für md5sum & Co, da es keine Garantie gibt dass identische Hashes auch identische Dateien bedeuten. Ein Anwendungsfall für ssdeep wäre beispielsweise festzustellen, welche Dateien (seit dem letzten "Snapshot" mit ssdeep) in welche neuen Namen umbenannt wurden, auch wenn sich die Dateien seit dem verändert haben - aber eben nicht zu stark. Ebenso kann man mögliche Kopien (Forks) von Dateien erkennen, die aus einer gemeinsamen Originaldatei hervor gingen. Mit anderen Worten, diese Tool kann vieles von der Rename-Detection von "git" reproduzieren, jedoch ohne den Overhead einer echten Versionsverwaltung. ssdeep unterscheidet generell zwischen Erzeugung der Hashes und deren Verwendung. Ersteres kann auch rekursiv erfolgen und erzeugt eine Datei, welche pro Eintrag eine Blockgröße, zwei Hashes und einen Dateinamen enthält. Im matching-Modus können neue Dateien angegeben werden, die mit den Hashes verglichen werden die ein früherer Programmlauf erzeugte. Dabei wird ausgegeben, welche neue Datei ähnlich zu welcher früheren ist. So lassen sich z. B. verschiedenen Revisionen desselben Quelltextes erkennen. Ein anderer Anwendungsfall ist die Originaldatei zu einer gekürzten bzw. abgeschnittenen Version derselben Datei zu finden. Weiters ist es möglich, alle Dateien eines einzelnen Aufrufs zu untersuchen und Paare ähnlicher Dateien aufzulisten. Schließlich kann man die Inhalte zweier durch separate Programmläufe erzeugter Dateien mit Hashes mit einander vergleichen um Paare ähnlicher Dateien zwischen den beiden Aufrufen zu finden. Dies kann sehr zeitintensiv bei einer größeren Anzahl Dateien werden.
ssft-0.9.17+nmu1/utils/debian {cmdline-dialog}: Ein Kompatibilitäts-Wrapper um Dialog-Anzeige-Utilities wie etwa "zenity". Die aktuelle Version kann im konkreten Fall entweder Gebrauch von "zenity", "kdialog" oder "dialog" machen (in dieser Reihenfolge der Präferenz). Das Paket stellt exakt ein einzelnes Shell-Script "ssft.sh" zur Verfügung, das ein gutes Dutzend Funktionen zur Verfügung stellt, die von allen der zuvor genannten Dialog-Utilities unterstützt werden. Jedoch ist es leider nicht so dass man anstatt z. b. kdialog einfach ssft.sh aufruft um dasselbe Ergebnis zu erzielen. Statt dessen muss man etwas umständlich zuerst eine Funktion aufrufen die ermittelt welches der Dialog-Utilities tatsächlich vorhanden sind und was die bevorzugte Variante davon ist. Dann muss man dies einer Shell-Variable zuweisen. Und erst danach kann man dann die Funktionen benutzen. Ein bisschen viel Aufwand um einen direkten Aufruf eines der Dialog-Utilities zu vermeiden. Ein Vorteil ist jedoch, dass man so Scripte schreiben kann die sowohl unter X11 als auch in der Textkonsole funktionieren, vorausgesetzt "dialog" ist zusätzlich zu einem der grafischen Utiltities installiert. Ein weiterer Vorteil ist dass ssft.sh auch das setzen einer Textdomain für das gettext()-Framework erlaubt. Dadurch können die Dialog-Meldungen an die aktuelle Sprache der Locale angepasst werden, vorausgesetzt man installiert zusätzlich entsprechende Übersetzungskataloge. Ein Nachteil von ssft.sh ist dass es nur den kleinsten gemeinsamen Nenner aller Dialog-Utiltities an Funktionen zur Verfügung stellt. Funktionen wie das Anzeigen eines Kalenders sucht man vergebens. Konkret vorhanden sind (zusätzlich zu den schon genannten Funktionen): Fehlermeldungen, Textmeldungen und Textdateien anzeigen. Datei- oder Directory-Auswahl-Dialoge. Fortschrittsbalken. Frage beantworten. Textzeile oder Passwort entgegen nehmen. Einen oder mehrere Einträge aus einer Textliste wählen. Den Inhalt einer Textdatei anzeigen. Ein Problem ist dass man keinerlei Einflussmöglichkeiten auf die Position oder Größe der angezeigten Dialoge hat. Textdateien werden z. B. in einem Bildschirmfüllenden Fenster angezeigt, selbst dann wenn die maximale Breite der Textzeilen nur gering ist.
sshfs-2.10+repack-2/utils/debian {FUSE}: Ein super-komfortabel zu benutzendes Netzwerkdateisystem, welches am Zielrechner nichts weiter als einen installierten SSH-Server erfordert. Da die Verbindung durch SSH-getunnelt wird ist es zudem auch sehr sicher. Der eigentlich einzige Nachteil ist die eher geringe Performanz, da SSH einen erheblichen Rechenaufwand im Vergleich zu weniger sicheren Netzwerkdateisystemen wie SMB und NFS hat. Außerdem ist es nicht geeignet für Langzeitverbindungen, da auch SSH notorische Probleme mit solchen hat. Es ist aber optimal geeignet für vorübergehenden Zugriff auf die Dateien eines entfernten SSH-Servers. Überdies ist es auch sehr benutzungsfreundlich, da es kaum Optionen gibt die man kennen oder gar verwenden müsste.
ssmtp/mail-mta/gentoo: Program to post mail to a mailhub for people who don't *want* a complete sendmail. Cannot be used as an SMTP server. Cannot do local delivery (i. e. sending mail directly to other users's mailboxes on the same computer system). Supports multiple users, but only a single mailhub server can be used for all outbound mails. A serious problem of ssmtp is that all accounts which should be able to send mail must be able to read the central configuration files, which contains the access passwords for the SMTP server in cleartext. Which normally means the file must be world-readable or group-readable. File system ACLs might also work. In any case, more than one person can usually see the passwords in the configuration file. An alternative might be to install ssmtp as SUID root, but this might be even more dangerous as the program has not been designed for this. Therefore, ssmtp is only suitable for single-user desktop systems where there are no other users. Ssmtp does not manage a mail queue; each mail is sent immediately. There is a restriction on the header of outbound mails, which represents a limit for overly long "subject" lines or a long list of recipients. But ssmtp is one thing: Simple to setup. At least compared to most alternatives.
ssvnc-1.0.28/net-misc/gentoo {KVM sharing}{GUI}{X11}: Ein VNC-Viewer der ebenfalls das "Tight" (JPEG-komprimiertes) Protokoll beherrscht. Das Paket bietet keine Server-Komponente, aber dafür zwei Vorteile: Erstens unterstützt dieser Viewer genau wie TigerVNC auch X.509 Zerifikate, wenn der Server dies bietet, wie etwa KVM/QEMU). Vor allem aber kann er sich nicht nur zu einem Internet-Socket verbinden, sondern auch zu einem maschinen-lokalen UNIX Domain Socket.  Natürlich muss auch der VNC-Server dies unterstützen, aber zumindest KVM/QEMU kann dies. Der konkrete Verteil solcher Sockets: Sie sind normaler Dateisystemobjekte, haben als solches einen Besitzer und lassen sich durch Zugriffsrechte schützen. Auf einen Internet-Socket kann hingegen jeder zugreifen der im selben Netz ist oder zumindest einen Account auf derselben Maschine hat (falls an localhost gebunden). Natürlich gibt es noch das VNC-Passwort selbst, aber das ist mit 64 Bit einfach zu schwach für ernsthafte Sicherheit.
stalonetray-0.8.1-1+b1/x11/devuan {desktop panel}: Ein Stand-Alone Traybar (unter 400 KiB Installationsumfang, das Executable ist 70 KiB groß) für die Verwendung in Windows Manager, die so etwas nicht bieten, wie etwa twm. Kompletter XEMBED-Support ist "under development" laut der man-page, und XEMBED-Support (keine Rede mehr von "kompletter") ist "planned" laut README. Und somit vermutlich noch *überhaupt* noch nicht implementiert. Da das Programm mittlerweile auch seit 9 Jahren nicht mehr weiter entwickelt wird (Stand: 2019), kann man wohl auch vergessen dass sich je etwas daran ändern wird. Funktioniert dennoch mit jedem EWMH-compliant Fenstermanager, wenn auch vermutlich nur irgendwie eingeschränkt. Benötigt nicht die ganze Breite des Displays. Beherrscht einen "dockapp mode", wo es den Systemtray scheinbar als "WindowsMaker"- sowie (alternativ) "OpenBox"-kompatible "Dock App" darstellt. Solche Dock Apps werden wiederum von einigen Fenstermanagern direkt unterstützt, etwa als "Slit" bei der Fluxbox. Man kann das Panel an jeder Bildschirmposition oder -Ecke anbringen und sowohl vertikal als auch horizontal ausrichten, und auch die Richtung festlegen in welche das Panel dynamisch wachsen soll wenn zusätzliche Systemtray-Icons hinzu kommen. Ebenso kann man festlegen entlang welcher Bildschirmkante das Panel fixen Platz für sein eigenes Wachstum zu reservieren. Alternativ kann man eine feste Position und Größe für das Panel festlegen, und eine Scroll-Funktion aktivieren so dass man auch dann alle Systemtray-Icons erreichen kann wenn die fixe Größe des Panels nicht mehr ausreicht um alle Icons zugleich anzuzeigen. In diesem Fall kann man zudem festlegen in welcher Richtung die Icons angeordnet werden bis die fixe Größe des Panels gefüllt ist. Leider ist die minimale Größe des Panels jene eines Icons, es verschwindet also niemals zur Gänze. Und belegt auch noch Platz entsprechend seiner eigenen Höhe/Breite entlang einer kompletten Bildschirmkante, den andere Fenster nicht nutzen können. Automatisches Verstecken wird nicht unterstützt. Minimalste Abhängigkeiten - nur die X11 Libraries. Bessere Windows-Manager bieten allerdings selbst Traybar-Support; daher vermutlich nur in Kombination mit allerminimalsten WMs interessant. Ein offensichtlicher Bug ist es, dass das Panel nur dann die seine konfigurierte Icon-Größe verwendet bis es beendet wird. Sobald man das Panel neu startet, haben die Icons wieder ihre App-spezifische Größe. Etwas ärgerlich ist auch dass man nicht einstellen kann auf welcher Bildschirmkante es Platz reserviert. Wenn es z. B. link rechts unten nach links unten wächst, reserviert es den ganzen rechten Randbereich des Bildschirms mit der derselben Breite wie die aktuelle Breite des Panels. Das ist extrem ärgerlich!
stardict-3.0.1-r2/app-text/gentoo: Ein nettes grafisches Front-End für "stardict"-Wörterbücher. Dabei können sowohl übers Internet Wörterbuchserver als auch lokal installierte Wörterbücher aus app-dicts/stardict-* Ebuilds abgefragt werden. Darüber hinaus können auch vorkonfektionierte Webseiten wie leo.org abgefragt werden. Andere Wörterbuch-Webseiten können mittels benutzerdefinierbarer Templates definiert werden. Eine Spezialität des Programmes ist der "Scan"-Modus, bei dem jedes mit der Maus selektierte Wort in irgend einer Applikation augenblicklich übersetzt wird, und ein Pop-Up mit der Übersetzung erscheint. Weiters kann das Progamm die Worte auch aussprechen, soweit das Wörterbuch die entsprechende Aussprache enthält. Dazu kann grundsätzlich Festival oder Espeak verwendet werden; allerdings kann man im Grunde beliebige externe Kommandos zu diesem Zweck definieren. Bei der Suche unterstützt das Programm nicht nur die Eingabe kompletter Worte, es kann auch nach ungefähren Begriffen gesucht werden (Levenshtein-Distanz) oder gar mittels Regular Expressions. Das ganze Programm erinnert ein wenig an den unter Windows einst sehr populären "Babylon-Translator", wenngleich es nicht ganz an dessen Look & Feel heran reicht. Es ist aber das beste Linux-Pendant zu diesem Zweck das ich bislang fand.
stardict-freedict-eng-deu-2.4.2/app-dicts/gentoo: Ein lokal installierbares Englisch-Deutsch Wörterbuch für app-text/stardict. Enthält auch Aussprache. Problem dabei: Die Aussprache wurde synthetisch durch ein Programm (txt2pho) generiert, so dass die Aussprache zwar meist stimmen wird aber man sich nicht definitiv darauf verlassen darf.
statsprocessor-0.11+git20160316-2/utils/debian {security}: Ein "Wortgenerator" der offenbar Passworte aufgrund von Wörterbuch-Wahrscheinlichkeiten erzeugen soll, welche dann z. B. vom Programm "Hashcat" (ein Programm zum Cracken von Passwort-Hashes) weiter verarbeitet werden können. Es benötigt eine "hcstat"-Datei als Eingabe, aber es wird nirgends erklärt wo man diese her bekommt. Vermutlich enthält die Datei die Wörterbuchwahrscheinlichkeiten. Man kann für die Generierung der Passwörter minimale und maximale Passwort-Länge wählen, ebenso verschiedene Zeichensätze und alle möglichen weiteren Parameter. Unklar ist des weiteren ob alle möglichen Kombinationen, nur die wahrscheinlichsten, oder lauter zufällige Passworte generiert werden (sowie woher in letzterem Fall die Entropie stammt).
stellarium/sci-astronomy/gentoo: Angeblich ganz ein tolles de-fakto Programm für Hobby-Astronomen. Rendert fotorealistische Bilder vom Himmel, von der Erde aus gesehen zu jeder gegebenen Zeit an jedem Ort der Erdoberfläche. Alles wäre *ganz* super, wenn es nur nicht sang- und klanglos beim Start sofort mit einem Segfault verrecken würde.
step-4.11.5/kde-base/gentoo: Ein Physik-Simulator. Man platziert Kugeln, Polygone, geladene Teilchen, Federn usw. auf einem Spielfeld, ordnet ihnen dann physikalische Eigenschaften wie Masse, Geschwindigkeit usw. zu, und startet dann die Simulation um zu beobachten wie sie sieh bewegen und mit einander interagieren wenn sie zusammenstoßen, von einander abprallen usw. Könnte durchaus unterhaltsam sein.
stone-soup 0.16.2-2/community/archlinux {game}: Ein nethack-ähnliches kachel-basiertes Dungeon-Erkundungs-Spiel mit dem vollen Namen "Dungeon Crawl Stone Soup". Es ist in Lua implementiert, und bringt 2 Front-Ends mit: Ein beinahe-"klassisches" wo jede Kachel durch ein simples Text-Zeichen (allerdings kein reines ASCII, da beispielsweise auch Spielkarten-Symbole verwendet werden) implementiert ist und ansonsten nur noch Farben zur Unterscheidung der Kacheln dienen, und das rein mit der Tastatur gesteuert wird. Sowie ein 2. grafisches, wo die Kacheln durch einigermaßen hübsche Grafiken repräsentiert werden, und das mit Tastatur und optional auch Maus gespielt wird. Die Levels scheinen algorithmisch aus vordefinierten Bestandteilen generiert zu werden; es gibt aber auch komplett handgestaltete Levels wie etwa das Tutorial. Alle wesentlichen Elemente des Spiels werden durch Textdateien implementiert, so dass man vermutlich auch ohne übermäßigem Aufwand eigene Levels oder Level-Bestandteile erstellen könnte. Während das Text-Interface auch am Raspberry-1 noch ohne Probleme läuft, ist das grafische Interface dort so langsam dass man es besser sein lässt. Eventuell läuft es am Raspberry-2 schnell genug; sicherlich tut es das wohl auf einem "normalen" Rechner. Wirklich ressourcenschonend ist das Spiel zwar nicht, da die Textversion rund 75 MB RAM und die Grafische Version rund 250 MB benötigt. Aber es bewegt sich diesbezüglich noch im akzeptablen Rahmen für ein Spiel, auch wenn in C geschriebene klassische nethacks deutlich genügsamer sind. Auf der Ebene der Spielmechanik verfügt es über einige Extras wie Auto-Explore, Map-Mode und weiteres. Allerdings scheint das Spiel auch buggy zu sein; mehr als einmal provozierte ich einen (text-basierten) Crash Dump. Allerdings mag das vielleicht auch an irrtümlich illegalen Eingaben meinerseits gelegen sein.
storebackup-3.2.1-1/utils/devuan {backup}{deduplication}: Ein als Perl-Scripte implementiertes Backup-Programm welches die gebackupten Dateien in ein lokal erreichbares Dateisystem speichert. Es unterstützt daher nicht direkt Remote Backups, diese sind aber mittels gemounteter Netzwerkdateisystemen wie sshfs oder NFS dennoch möglich. Es ist möglich, mehrere Backups von mehreren Originalen im selben Backup-Repository zu speichern, um die Deduplikations-Features von storebackup nutzen zu können. Diese arbeitet zunächst einmal nur auf Datei-Ebene, wo es alle identischen Dateien aus allen Backups und Backup-Generationen durch Hard-Links ersetzt. Überdies basierte der Pfadname innerhalb des Backup-Repositories auf dem MD5-Hash des Dateiinhalts (allerdings gibt es von dort zweifellos auch Hardlinks in einen Verzeichnisbaum welcher dem Dateisystem-Layout des Originals entspricht), so dass Inhalts-Duplikate auch denn erkannt werden wenn die entsprechenden Dateien in den Original-Verzeichnissen in völlig anderen Unterverzeichnissen lagen oder relativ zu einander umbenannt wurden. Um nicht nur ganze Dateien deduplizieren zu können sondern auch Teile davon, gibt es die Option Dateien aufgrund bestimmter Kriterien für eine Blockung im Backup auszuwählen. Deren Inhalte werden dann nicht länger als komplette Datei gespeichert, sondern durch ein Unterverzeichnis identischem Namens ersetzt, in dem sich durchnummerierte Dateien befinden, in welche die Originaldatei zerhackt wurde. Diese einzelnen Teile werden dann automatisch auf Dateiebene Dedupliziert wie auch die nicht-zerhackten Dateien. Leider schein das Programm diese Zerhackung nur in Blöcke fixer Größe zu beherrschen, was die Deduplikation sehr ineffizient machen dürfte wenn nicht gerade linear wachsende Logdateien oder Dateisystem-Abbilder mit günstiger interner Clustergröße dedupliziert werden. Diese fixe Blockgröße läßt sich zwischen 10 kB und 1 MB frei auswählen. Per Default werden nur Dateien an 100 MB Größe überhaupt geblockt, auch wenn man dies ändern kann. Jedenfalls scheint dieses Feature wirklich nur für sehr große Dateien gedacht zu sein. Deduplizierung innerhalb keiner Dateien wird daher nicht sinnvoll funktionieren. Weiters können Dateien (nach einer eventuellen vorherigen Zerhackung wie zuvor erläutert), abhängig von Kriterien wie der Größe, darüber hinaus auch noch komprimiert abgespeichert werden. Ein Vorteil von storebackup ist die einfache Strukturierung des Repositories, da alle unabhängigen Backups und einzelnen Revisionen innerhalb dieser einfach als normale Verzeichnis-Bäume vorhanden sind. Das Zurücksichern alter Dateien ist daher ein Kinderspiel (solange sie nicht für Deduplikation zerhackt wurden), und könnte etwa direkt mittels rsync erfolgen. Aber selbst zerhackte Dateien kann man durch "cat" einfach wieder zusammensetzen, ohne spezielle Tools zu benötigen. Um wieder mehr Platz zu schaffen kann man zudem unabhängig auswählen welche älteren Backups man löscht; es ist nicht nötig hier in strikter zeitlicher Reihenfolge vorzugehen (auch wenn man dies normalerweise wohl tun wird). storebackup behält auch Berechtigungen, Hardlinks und Symlinks bei, wobei darüber hinaus auch noch ACLs und extended attributes unterstützt werden - allerdings nur wenn spezielle Optionen zu diesem Zweck aktiviert werden. Ein offensichtlicher Nachteil ist dass das Backup-Repository ein Dateisystem benutzen muss welches dieselben Features hat wie das Original-Dateisystem - insbesondere muss es Hardlinks unterstützen, und sollte dabei auch möglichst geringe Beschränkungen bezüglich der Anzahl erlaubter Hardlinks pro Datei haben. Backups auf SAMBA-Shares ist beispielsweise aus diesem Grund nicht möglich. NFS funktioniert. Im Fall von NFS kann das Erzeugen von Hardlinks für die neueste Revision eines Backups allerdings unglaublich lange dauern, da NFS für jeden Hardlink einen separaten Netzwerk-Request überträgt. Für diesen Zweck gibt es die Option statt der Hardlinks die komplette Kopien der Dateien zu übertragen, und erst nachträglich am Remote-Server mit einem Script die Dateien durch Hardlinks zu ersetzen. Natürlich spart einem das keinerlei Datenvolumen bei der Übertragung, aber es kann trotzdem schneller sein wenn sich nur wenige Dateien geändert haben und diese nicht all zu groß waren. Allerdings ist diese Option gefährlich weil sie die Metadaten des Backups vorübergehend in einen inkonsistenten Zustand bringt, man darf daher keinesfalls etwas aus dem Backup-Repository löschen bevor das genannte Script ausgeführt wurde und die Duplikate wieder durch Hardlinks ersetzt hat. Eine weitere Frage ist ob der MD5-Hash noch gut genug für eine Deduplikation ist. Aber ohne böswilligen Vorsatz wo man gezielt MD5-Kollisionen in den Originaldateien erzeugt wird er es wohl tun. storagebackup braucht zwar nur ganz wenige Parameter in typischen Einsatz-Szenarien, hat aber eine gefühlte Million Optionen die man benutzen kann. Etwa für die zahlreichen Kriterien, wann und wie eine Datei zerhackt werden soll, ob sie komprimiert werden soll, etc. Es ist zu befürchten dass die Defaults einem nicht gut genug sein werden, und man sich dann mit diesen endlos vielen Optionen erst recht herum schlagen muss. Überdies ist unklar wie man das Programm für Remote Backups benutzen soll wenn man *kein* NFS benutzen will. Denn nur wenige Netzwerkdateisysteme bieten volle POSIX-Semantik; insbesondere FUSE-Dateisysteme sind hier beschränkt (etwa bezüglich Owner/Group). Es gibt keine vernünftige man-Page für das Programm, die primäre Dokumentation ist eine aus offenbar mittels LaTeX erzeugte PDF-Datei. Schlechte Karten daher wenn man nur eine Textkonsole zur Verfügung hat und etwas in der Anleitung nachschlagen will. Die Regeln welche das Programm in seinen diversen Kriterien verwendet basieren auf einer relativ komplexen und mächtigen Syntax - typisch Perl. Sie setzen sich aus Shell-Wildcards, Regular Expressions und Attribut-Vergleichen zusammen. Simpel ist bei diesem Programm bei näherem Hinschauen jedenfalls offenbar *nichts*. Mein Eindruck von diesem Programm: Viele gute Ideen, aber leider nicht konsequent zu Ende gedacht.
strawberry-1.0.14-1/sound/raspbian {audio}{music}: Ein Qt-basierter sehr komfortabler Music Player. Ein weiterentwickelter Fork von "clementine", das an zu vielen Fehlern leidet. Sowohl "strawberry" als auch "clementine" versuchen beide, das unter KDE-Abhängigkeiten leidende "amarok" zu ersetzen. Strawberry gelingt dies deutlich besser. Es kann Album-Covers und Songtexte automatisch aus dem Internet herunterladen (und danach in einer lokalen Datenbank speichern). Es kann auch "Internet-Radio"-Streams anzeigen und Wiedergeben. Es hat eine Medienbibliothek, normale und "intelligenzte" Wiedergabelisten (z. B. zufällige Wiedergabe, Filter für die meistgespielten, neuesten oder höchstbewerteten Lieder, usw.). Neben der Playlist hat es auch eine Warteschlange. In dieser kann man Titel zur Wiedergabe (normalerweise wird das nächste aus der Playlist genommen) einreihen und manuell die aktuelle Reihenfolge ändern. Mit 5 MB Download-Umfang (ohne Abhängigkeiten) ist es kein schlankes, aber auch kein übermäßig fettes Programm. Leider ist der RAM-Verbrauch im laufenden Betrieb aber beachtlich: Bei 50 Titeln in der Playlist verbraucht das Programm 1,7 GB RAM (Resident Set Size). Allerdings startet das Programm noch 2 Hilfsprozesse für das Verarbeiten von Metadaten, welche jeweils weitere 1,4 GB RAM (RSS) verbraten. Zusammen sind das also 4,5 GB RAM. Ein Teil dieses RAM muss allerdings geshared sein, da ich meine Messungen auf einem Raspberry Pi durchführte der nur über 4 GiB RAM verfügt... Dennoch, ein ziemlicher RAM-Verbrater, leider, dieses ansonsten sehr nette Programm.
stunnel-5.17/net-misc/gentoo: Ein Proxy, der es erlaubt lokale Dienste die keine Verschlüsselung unterstützen aus der Ferne durch einen TLS-Tunnel erreichbar zu machen. Dasselbe ist auch auf Client-Seite möglich, wo ein Client der kein TLS unterstützt auf einen Server zugreifen kann welcher TLS erfordert. stunnel lässt sich sowohl mit inetd-Dienste als mit eigenständige Dienst-Daemonen benutzen. stunnel kann somit z. B. einem reinen HTTP-Webserver HTTPS "beibringen" (bis auf den "https"-URL-Präfix, den muss der HTTP-Webserver als alias zu "http" ansehen können damit es funktioniert). Problem: Unzählige Optionen, viel zu viele Features, sollte deshalb in einem Root-Jail laufen - und benutzt SSL-Crypto. Bugs daher garantiert. Weiters: Ich vermute stark, das alles kann socat auch, ohne dass man ein eigenes Tool dafür bräuchte. Allerdings ist das socat-Executable auch gut doppelt so lange.
sub2srt-0.5.3/media-video/gentoo: Dieses Tool wandelt *nicht* die gerippten idx/sub-Dateien von DVDs in SRT-Dateien um, wie man vielleicht glauben mag. Sondern es wandelt (offensichtlich bereits in Textform vorliegende) Untertiteldateien von "microdvd" und "subrip" in SRT-Dateien um, wozu keine OCR-Fähigkeit benötigt wird. Kurzum, ein unnützer Reinfall, denn natürlich will man DVD oder BlueRay-Subtitles mittels OCR konvertieren. Genau dies wird dieses Programm aber niemals können, wie extra in der Anleitung angemerkt ist.
suckless-tools-38-2/x11/debian {screen locker}{GUI}{X11}: Small package which contains a couple of tiny tools for X11. The only tool I was interested in was "slock", a minimalistic screen locker: And indeed, as the name of the package implies, it sucked less than i3lock or xscreensaver. Because it worked... and it could not work any simpler: The screen just turns black until the password is entered. There is no feedback of any kind on password entry. It successful, the lock is released. Otherwise the screen stays black. Could it be any simpler? A real fun tool is swarp: It moves the mouse cursor to specified x/y co-ordinates. lsw shows a list of the tiles of all windows. dmenu displays a horizontal bar with text choices and let the user select one using the the keyboard and TAB completion. "st" is a poor man's xterm. There are a few more tools, but I have not evaluated them yet, and they did not seem particularly interesting either.
sudoku-1.0.5-2+b3/games/debian: Ein sudoku fürs Terminal. Nur monochrom. Nur 42 kB Download. Identisch zu nudoku, jedoch ohne dessen Farben und Highlighting-Funktion. Dafür gibt es als zusätzliches Feature das Abspeichern sowie Laden von Spielfeldern. Das ist auch nützlich wenn man aus Zeitgründen das aktuelle Spiel abbrechen muss. Dazu muss der enthaltene Solver wohl auch mehr drauf haben, was die etwas größere Programmlänge erklärt. Außerdem sind die Hints interessanter - es wird nicht einfach ein Feld ausgefüllt, sondern mit Pfeilen auf irgendwas hingewiesen dass einem helfen soll. Weiters kann man ein komplettes eigenes Spielfeld eingeben und dann spielen oder abspeichern. Dazu gibt es die Funktion "fix squares" nach der man die bereits am Spielfeld gesetzten Ziffern nicht mehr ändern kann. Außerdem unterstützt das Spiel verschiedene Speicherformate (alle als Text), welche in der man-Page auch genau erklärt werden. Wenn nur diese "Hint"-Funktion (und die Farben) gegenüber nudoku nicht fehlen würde, wäre sudoku diesem in jeder Hinsicht überlegen. Im Gegensatz zu "nudoku" werden keine Trennlinien zwischen den Elementen der 3x3-Quadrate gezeichnet; nur die 3er-Blöcke als Ganzes sind durch Trennstriche separiert. Ebenso fehlt die "check"-Funktion - man wird erst bei der Hint-Funktion auf Fehler im Board aufmerksam gemacht. Insgesamt scheint mir diese Programm eher für Fortgeschrittene Spieler zu sein.
superkaramba-3.5.5/kde-base/gentoo: Erlaubt es Python-Skripts auszuführen, welche ihre Ausgabe am Desktop-Hintergrund tätigen. Sinnlos für jene, deren Desktop-Hintergrund kaum je sichtbar ist.
supertuxkart-0.9.2+dfsg-2/games/devuan {game}: Super-lustige relativ kleine comic-artige Go-Carts fahren auf diversen 3D-Strecken herum, sammeln Waffen, bekämpfen einander. Oder spielen gegen die Zeit. Oder wer der schnellste ist. Oder man spielt Fußball mit den Fahrzeugen. Mehrere Modi. Kampagnen, Story-Modus, etliche Levels. Alles ganz toll wenn man Rennspiele liebt. Was ich nicht tue. All das tolle hat seinen Preis: Rund 650 MB Installationsumfang.
surf-0.6-1/web/devuan {www-browser}{GTK+}: Ein sehr schlanker Web-Browser, der mit Ausnahme des Anklickens von Hyperlinks und seines Scrollbalkens komplett tastaturgesteuert bedient wird. Zoomen, Seite vor/zurück - alles nur per Tastatur. Stammt von den "suckless"-Entwicklern, von denen auch mehrere andere extrem schlanke Tools stammen. Basiert auf WebKit2 und GTK+. Anders als ebenfalls recht minimalistische Dillo hat er überhaupt keinen Toolbar, beherrscht dafür aber auch JavaScript und "Plugins" - vermutlich solche von Mozilla da dazu ein "nspluginwrapper" verwendet wird. Mit Commandline-Optionen sowie Tastenkombinationen lassen sich das Laden von Bildern, JavaScript und Plugins deaktivieren - leider merkt man nur am Effekt was ein- oder ausgeschaltet ist, da der Browser keinerlei Statusanzeigen besitzt. Etwas seltsam erscheint mir auch, dass bei jedem Start das JRE aktiviert zu werden scheint, selbst wenn man mit abgeschalteten Plugins startet. Zumindest wenn man Firefox bereits installiert hat muss Surf kaum noch etwas dazu installieren und ist dann eine extrem schlanke installation von nur ein paar hundert kB. Was Surf komplett zu fehen scheint sind Bookmarks. Eine History hat er zwar, aber offenbar nur im RAM und sie wird nicht abgespeichert. Man kann daher zur Navigation nur entweder interaktiv URLs eingeben oder Hyperlinks anklicken, und ansonsten nur eine URL beim Aufruf des Browsers in der Kommandozeile angeben. Allerdings sollte es möglich sein, sich ein statisches HTML-Dokument als Ersatz für Bookmarks selbst zu erstellen und dieses dann zu öffnen. Surf beherrscht keine Tabs, unterstützt aber das XEMBED-Protokoll, womit er sich in andere Applikationen einbinden lässt. Damit kann man ein andere suckless-tool, "tabbed" nutzen, um aus der Kommandozeile "surf" so zu starten dass er de facto ein Browser mit Tabs wird. Allerdings hat "tabbed" ein Problem wenn mehr als nur ein paar wenige Tabs offen sind, da wird die Bedienung rasch umständlich. Weiters sieht "surf" zwar schlank aus und belegt auch deutlich weniger RAM als Firefox. Allerdings belegt er dafür immer noch ca. 5 x so viel RAM wie der Dillo. Und anders als dieser kann er zumindest zur Laufzeit Cookies annehmen und sich temporär merken, so dass man auch Webseiten wie GMX damit benutzen kann. Surf bietet JavaScript, Cookies, Tabellen (auch mit inneren Gitterlinien was nicht alle Browser bieten), SVG-Grafiken und einen mächtigen Object-Inspektor. (Das meiste davon offensichtlich automatisch von der WebKit-Bibliothek geerbt. Und nicht alles was in der man-Page dokumentiert ist funktioniert auch tatsächlich. Den Web-Inspektor z. B. brachte ich nie zum Starten, eben so wenig wie die Quelltext-Ansicht.) Insgesamt ist Suft ein nützlicher Zweitbrowser für den Notfall dass Firefox mal wieder ein Problem hat und Dillo von den Features her nicht ausreicht. Und trotz seiner minimalistischen Benutzerschnittstelle steckt letztendlich dieselbe Browser-Engine dahinter, die auch Chrome, Safari Microsoft Edge und Internet Explorer antreiben. Tatsächlich hat sich dieser Browser bereits als sehr nützlich erwiesen, komplexe Formulare und Anmeldungs-Webseiten auszufüllen, an denen der Firefox wegen seiner diversen Blocker gescheitert ist (selbst wenn man die Blocker dort alle abgeschaltet zu haben glaubte).
suxpanel-0.4b-r3/x11-misc/gentoo {desktop panel}: Very small size. Unfortunately, it does not compile.
sweep-0.9.3/media-sound/gentoo {audio}{music}: GTK-basierter Multitrack Audio-Editor, der vor allem Features für Live-Performances bietet (Scrubbing, Reverse Playing, Piano-Style Playback. Nachteil: Unterstützt nur direkte Ausgabe auf eine Audio-Gerätedatei; kein Support für Sound-Server.
swftools-0.8.1/media-gfx/gentoo: Enthält diverse Commandline-Tools zum Konvertieren von verschiedenen Font-, Audio- und Bildformaten in swf-Dateien, zum Zusammenfügen von swf-Dateien, Dumpen der Struktur. Ein Compiler welcher .swf-Dateien aus Quelltext-Scripten erstellt. Vor allem aber ein Tool, welches die in einer swf-Datei eingebetteten Multimedia-Elemente extrahieren kann. Leider ist dieses eigentlich sehr nützliche Paket hard gemasked was auf Probleme schließen lässt.
swig/dev-lang/gentoo swig-4.0.2-1/interpreters/debian {code-generator}: SWIG kann C/C++ Header-Files parsen und daraus Code für Interfaces anderer Programmiersprachen erzeugen. Allerdings wird das normalerweise nicht getan, da SWIG nicht alles versteht (etwa #pragma, __attribute__((symbol)) usw.) was in echten Header Files vorkommen kann, und man muss die tatsächlich benötigten Deklarationen daher von dort in die Eingabedatei von SWIG heraus kopieren. Daher werden normalerweise vielmehr spezielle Eingabedateien (häufig mit der Dateierweiterung ".i" benannt) erstellt, die ähnlich wie jene von lex oder yacc aufgebaut sind und einen Teil ihres Inhalts unverändert an die Ausgabe durchreichen, während nur der Rest der Datei C/C++ Deklarationen und #defines enthält die von SWIG verarbeitet werden. Der durchgereichte Teil der Eingabedatei enthält im wesentlichen #include Anweisungen die nötig sind (typedef, #define) dass ein C/C++ Compiler sowie SWIG die Deklarationen der Eingabedatei überhaupt parsen kann, welche aber ihrerseits nicht direkt für die Zielsprache zur Verfügung gestellt werden sollen. SWIG ist jedoch kein Foreign Function Interface. Ein FFI erlaubt dynamisch den Zugriff von einer Sprache auf Funktionen einer anderen zur Laufzeit. SWIG hingegen erzeugt statischen Code und unterstützt nur C/C++ Deklarationen die schon zur Compile-Time bekannt sind. Bei FFI sind Bindings in der Zielsprache verfasst. Die erwähnten von SWIG erzeugten "Interfaces" sind hingegen in der Regel nicht etwa in der Zielsprache verfasst, sondern es handelt sich um C/C++ Code. Dieser wird danach kompiliert was ein in C/C++ implementiertes Erweiterungsmodul für die Zielsprache erzeugt, welches diese dynamisch laden kann. Und das geladene Erweiterungsmodul stellt dann Funktionen für die Zielsprache bereit, um um all jene C/C++ Funktionen aufzurufen, deren Deklarationen in der SWIG-Eingabedatei enthalten waren. Und zwar nur die Deklarationen aus jenem Teil den SWIG auch verarbeitet hat (der also nicht bloß durchgereicht wurde). Die Eingabedateien von SWIG benötigen oft zusätzliche Meta-Instruktionen um zu funktionieren, die ein C/C++ Compiler aus eigener Kraft direkt aus dem Quelltext ermitteln könnte. So geht SWIG z. B. bei allen ihm unbekannten Namen davon aus, dass es sich um Pointer auf unbekannte Datentypen handelt. Ebenso behandelt es "const" in einigen Fällen anders als ein C/C++ Compiler, so dass man in solchen Fällen ebenfalls spezielle Meta-Instruktionen hinzu fügen muss. Version 4.0.2 vom SWIG kann Wrapper für folgende Sprachen erzeugen: C#, D, Go, Guile, Java, Javascript, Lua, Octave, Perl 5, PHP 7, Python, R (aka GNU S), Ruby, Scilab, Tcl 8, XML. Experimentell werden auch MzScheme/Racket und OCaml unterstützt. SWIG kann aber auch genutzt werden um Interfaces anderer Sprachen für C/C++ zur Verfügung zu stellen. In diesem Fall deklariert man Callbacks, welche die anderen Sprachen dann nutzen können um ihrerseits Callbacks an C/C++ Code weiter zu reichen der sie dann verwenden kann. Obwohl es in simplen Fällen möglich sein mag einen C/C++ Header direkt als Eingabedatei für SWIG zu verwenden, erfordert der allgemeine Fall einige Handarbeit um vorhandene C/C++ Deklarationen als SWIG-taugliche Eingabedatei aufzubereiten. Freilich kann man diesen Prozess manchmal auch automatisieren, und die SWIG-Eingabedatei oder große Teile davon dann durch ein Script erzeugen lassen. Doch das muss man aus eigener Initiative tun - SWIG unterstützt einen dabei nicht.
syncthing-1.19.2~ds1-1/utils/raspbian {dirtree sync}: Automatische bidirektionale P2P Live-Dateisynchronisation zwischen beliebig vielen Peers. Offlining von Peers ist jedoch möglich - die Synchronisation wird dann fortgesetzt sobald der Peer wieder erreichbar ist. Die in "Go" geschriebene und daher 7 MB große Syncthing Node-Software kann unpriviligiert gestartet werden und verwendet ein lokales Web-GUI zur Konfiguration. Immerhin handelt es sich dabei nur um ein einziges Executable was das Deployment vereinfacht. Der RAM-Bedarf einer laufenden Instanz sind ca. 32 MB für einen leeren Datenordner. Wenn sich 800 Dateien mit ca. 340 MB im Ordner befanden, kletterte der RAM-Bedarf einer Instanz auf 80 MB, während eine zweite Instanz welche an der Synchronisation desselben Ordners nur 50 MB RAM verbrauchte. Möglicherweise ist der wild fluktuierende RAM-Verbrauch auf die Garbage Collection von Go zurück zu führen, welcher den RAM-Bedarf anscheinend vorübergehend annähernd verdoppeln kann. Leider sind die Hilfetexte des Web-GUIs nicht lokal vorhanden und können ohne Internet-Verbindung daher nicht angezeigt werden. Daher bleibt in diesem Fall die Bedeutung vieler Einstellungs-Parameter unklar. Startet man Syncthing zum ersten Mal, stellt es ungefragt eine Anzahl von Verbindungen zu externen Servern des Projekts her, was sich in der Konfiguration zwar abschalten lässt - dann aber natürlich zu spät da die Verbindungen bereits erfolgt sind. Man sollte daher die Internet-Verbindung trennen wenn man Syncthing einrichtet, allerdings um den Preis dass man dann nicht erfährt wozu die Parameter dienen welche man anpassen kann. Überhaupt ist die Netzwerkaktivität des Programms sehr schwer zu durchschauen. Es benutzt eine große Anzahl von Ports, Protokollen und externen Servern für Hilfsdienste. Die meisten davon (alle?) zwar abschaltbar, aber es ist nicht leicht genügend Durchblick zu erhalten um dies auch zu tun. Dafür funktioniert das Programm recht problemlos wenn man sich um all diese Details nicht kümmert und keine Bedenken dabei hat wenn es ungefragt fremde Server kontaktiert und mit diesen unerklärliche Daten austauscht. Die Synchronisation erfolgt immer zwischen Nodes, wobei wobei man auf beiden Nodes die gegenseitige ID des jeweils anderen Nodes eingeben muss, damit die beiden Nodes mit einander verbunden sind. Jeder Node kann mit dabei mit beliebig vielen anderen Nodes verbunden werden. Jeder Node kann beliebig viele Ordner freigeben, die von anderen Nodes dann selektiv eingebunden werden können. Die Synchronisation des Ordnerinhalts erfolgt zwischen allen Nodes, welche diesen Ordner freigegeben oder eingebunden haben. Dateiinhalt und Änderungszeit von Dateien wird dabei immer synchronisiert, optional auch Zugriffsrechte, Symlinks, EAs und ACLs. Hardlinks und die Modifikationszeit von Directories können hingegen nicht synchronisiert werden. Syncthing überträgt alle Daten einer Datei in Blöcken mit Größen zwischen 128 KiB und 16 MiB via TLS. Die Blockgröße wird pro Datei abhängig von deren Größe gewählt und ist innerhalb der Datei einheitlich. Syncthing erkennt Änderungen an den Ordnern durch inotify, was aber abgeschaltet werden kann. Zusätzlich scannt es in regelmäßigen Intervallen den gesamten Verzeichnisbaum der Ordner, da inotify nur begrenzt zuverlässig und überdies optional ist. Erkannte Änderungen werden soweit möglich sofort synchronisiert, oder sobald es wieder möglich ist. Synchronisationskonflikte werden durch das Anlegen zusätzlicher Dateien gelöst, welche die kollidierenden fremden Inhalte enthalten und vom Benutzer wieder zusammengeführt und danach gelöscht werden können. Überdies kann man eine Versionierung aktivieren, welche geänderte alte Versionen eine Zeit lang speichert. Dabei gibt es verschiedene Schemas, das mächtigste davon hält mehrere Kopien derselben Datei vor, die abhängig vom Alter der Datei in immer größeren Intervallen abgelegt bzw. ausgedünnt werden, bis zum definierten Maximalalter. Das Programm reagiert allergisch darauf wenn verbundene Nodes vorübergehend unerreichbar sind, später aber wieder erreichbar werden. Es erfordert dann scheinbar einen Neustart, damit die Nodes erneut als erreichbar erkannt werden. Die Synchronisierung erfolgt standardmäßig bidirektional, ein Node kann aber optional auch als Master (nimmt keine fremden Änderungen an) oder Slave (nimmt jede fremde Änderung und betrachtet eigene Änderungen im Fall eines Konflikts als wertlos) konfiguriert werden. Grundsätzlich funktioniert alles zufriedenstellend, nur die (zumindest für Uneingeweihte) intransparente Netzwerkaktivität und der relativ hohe RAM-Bedarf sind störend. Ab syncthing-2.0.0 dürften die variablen Blockgrößen mittels rolling Hashes abgeschafft worden sein. Es ist daher zu befürchten, dass neuere Versionen sehr viel mehr Datenverkehr verursachen könnten und nur noch für den Einsatz mit Flat Rates bzw. im LAN geeignet sind.
synfigstudio 1.0.2-2/community/archlinux: Ein angeblich sehr gutes Animations-Studio für vektorbasierte 2D-Animationen mit einem netten GUI. Es kann automatisch Übergänge für alle möglichen Attribute wie etwa Farbe zwischen Keyframes berechnen ("Tweening"), und nicht nur für die Positionen von Schlüsselpunkten der Animationsobjekte. Zusätzlich werden auch Bitmap-Objekte unterstützt, jedoch mit weniger Möglichkeiten. Ausreichende Tutorials sind vorhanden. Einziges Problem ist dass die Rechenleistung eines (originalen) Rasperry-Pi 1 nicht ausreicht, um das GUI flüssig genug zu betreiben so dass das Arbeiten komfortabel bleibt.
syrep-0.9/net-p2p/gentoo {dirtree sync}: Ein bidirektionales (eigentlich multidirektionales) Dateiations-Tool, das besonders gut für die Synchronisation von Audio- und Videiodateien geeignet ist. Das Tool erstellt und verwaltet Hashes für jede einzelne Datei in einem Dateibaum was als "Snapshot" bezeichnet wird. Immer wenn man neue Dateien zum Dateibaum hinzufügt, Dateien umbenennt, verschiebt, kopiert, sym- oder hardlinked, sollte man danach das Snapshot aktualisieren damit es den aktuellen Zustand des Dateibaums abbildet. Diese Snapshots, welche nur eine Historie der Hashes und Pfadnamen aber nicht den Inhalt der Dateien umfassen, kann man nun mit den Snapshots anderer Dateibäume vergleichen. Aus dem Ergebnis dieses Vergleichs wird dann eine "Patch"-Datei erzeugt, welche alle Dateiinhalte enthält, welche der jeweils anderen Seite fehlen. Wenn man diese Patch-Datei dann auf der anderen Seite anwendet, ist diese im selben Zustand wie die Herkunfts-Seite des Patches. Da man diese Patches für zwei beliebige Dateibäume erstellen kann, lassen sich so Dateien zwischen beliebig vielen Dateibäumen synchronisieren. Weiters ist zur Erstellung eines Patches kein direkter Zugriff auf den anderen Dateibaum vonnöten; es reicht wenn man eine Kopie von dessen letztem Snapshot hat. Da die Snapshots wesentlich kleiner als die zugehörigen Dateibäume sind (beispielsweise 400 KB für einen 80 GB Dateibaum), können diese auch leicht per Mail versandt offline übermittelt werden. Der Patch kann ebenfalls offline übermittelt werden, da es belanglos ist auf welchem Weg er von Ersteller des Patches zum Anwender gelangt. Insbesondere das Übermitteln von Patches ber USB-Stick ist oft eine sinnvolle Möglichkeit. Da die jeweiligen lokalen Snapshot-Dateien History enthalten, wachsen sie mit jedem Snapshot. Man kann daher entscheiden ab wann alte History "weggeworfen" werden soll. Ein Vorteil des Programms ist, dass es auf große Datenmengen und maximale Geschwindigkeit optimiert wurde. Ein Nachteil ist dass es erstens immer nur ganze Dateien mittels der Patches überträgt - es ist daher nicht geeignet für große Dateien die sich häufig ändern oder "wachsen". Es erzeugt keinerlei Deltas zwischen Dateiinhalten. Man kann sich lediglich aussuchen, ob die erzeugten Patches oder Snapshot-Dateien als ganzes komprimiert werden sollen. Das Programm arbeitet rein Hash-basiert und synchronisiert auch keine anderen Metadaten als den relativen Pfadnamen der Dateien. Insbesondere speichert es weder das Datum der Datei, noch Zugriffsrechte und dergleichen, und unterscheidet nicht einmal zwischen Kopien, Symlinks oder Hardlinks. Für das Programm zählt nur welcher Dateiinhalt unter welchem Pfadnamen zu erreichen ist. Im Gegensatz zu einem Versionskontrollsystem zeichnet es auch keine Historie auf, sondern vergleicht nur das jeweils letzte Snapshot. Allerdings erfolgt aufgrund der hashbasierten Arbeitsweise eine automatische Deduplikation innerhalb der Patches, jedoch nur auf der Ebene kompletter einzelner Dateien. Wenn beim Anwenden von Patches Konflikte auftauchen, müssen diese interaktiv gelöst werden. Die Entscheidungen dabei sind jedoch einfach da man sich im Grunde nur entscheiden welche der beiden Versionen man übernehmen will wenn dieselbe Datei seit dem letzten Abgleich lokal und auf der Gegenseite geändert wurde. Aufgrund der genannten funktionalen Einschränkungen ist das Programm nur schlecht geeignet, Dokumente auszutauschen welche in Zukunft noch bearbeitet werden. (Außer diese sind so klein dass es egal ist dass sie bei jedem Update erneut komplett übertragen werden.) Es ist aber gut für die Replikation von Multimediadateien, Archiven, Backupdateien und archivierte Datenbank-Logfiles geeignet, die immer nur komplett erzeugt werden und sich danach nicht mehr inhaltlich ändern. Umbenennen oder Verschieben innerhalb des Dateibaums ist dabei kein Problem da es nichts am Inhalt der Dateien ändert.
sysdig 0.7.1-1/community/archlinux {text-terminal IO}{X11}{GUI}: Angeblich ein ganz ein toller Ersatz für htop & Co mit speziellem Support für Container und konfigurationsfrei. Mag alles sein, jedoch stürzte dieses tolle Programm bereits beim Start mit einer Fehlermeldung ab, so dass ich nichts davon überprüfen konnte. Weiters ist dieses Programm alles andere als nicht-invasiv: Es baut und installert (mittels DKMS) sogar sein eigenes Kernel-Modul, und legt ein eigenes Character-Device in /dev an! Außerdem scheint es auch noch auf Netzwerk-Übertragung seiner Trace-Dateien ausgelegt zu sein, so dass es eventuell auch noch Sicherheitsprobleme geben könnte. Dafür gibt es aber ein ncurses-TUI und zusätzlich sogar ein richtiges GUI (in Python verfasst). Das Programm basiert auf Lua-Scripting und nutzt luajit. Download ca. 0,5 MB, Installationsumfang ca. 4,5 MB. Freilich nützt das alles wenig wenn es schon beim Start abstürzt. Eventuell zu einem späteren Zeitpunkt (*diese* Kommentare stammen aus 2016-01) oder auf anderen Plattformen erneut testen.
syslinux-utils-3: 6.03+dfsg-5+deb8u2/admin/devuan: Enthält unter anderem die folgenden Utilities: "isohybrid" kann bootfähigen CD-ROM oder DVD-ROM Abbildern welche mittels "mkisofs" oder "genisoimage" erzeugt wurden so manipulieren, dass sie sich (ohne zusätzliche Änderungen) zusätzlich auch von Hard Disk booten lassen. Das Perl-Script "mkdiskimage" kann das Abbild eines USB-Datenträgers erzeugen (und auch gleich auf diesen schreiben), welches sich danach mit als "USB-ZIP" vom BIOS booten lässt (was hilfreich ist wenn USB-HDD nicht angeboten wird oder funktioniert). Optional kann dieses Abbild auch gleich als FAT-32 formatiert werden.
systemd-cron-1.5.16-1/admin/debian: Ein Ersatz für den klassischen crond auf systemd-basierten Systemen. Funktioniert annähernd kompatibel zum klassischen crond und auch crontab wird unterstützt. Ein Vorteil ist dass kein eigener Daemon dafür laufen muss, da diese Implementierung Gebrauch von systemd Timer-Units macht, welche ohnehin fix in systemd eingebaut sind. Leider gibt es aber auch Nachteile. Zum einen schien es mir, als ob die Ausführung von "cron.hourly"-, "cron.daily"-usw.-Scripten einfach abgebrochen würde nur weil eines der Scripte versagt hatte. crond macht das nicht so. Weiters gibt es keine einfache Möglichkeit, alle Timer-Units vorübergehend anzuhalten und später wieder weiterlaufen zu lassen, wie es mit start/stop crond sehr wohl möglich war. Es gibt auch keine MAILTO-Unterstützung für die cron-Jobs, was mich aber am noch wenigsten gestört hätte. Am meisten störte es mich hingegen, dass User cron-Jobs offensichtlich nur ausgeführt werden wenn auch eine User-Instanz von systemd ausgeführt wird. Erstens einmal verbraucht dies viel RAM zusätzlich so dass es mir sehr missfällt. Zum anderen bedeutet es dass für jeden User der crob-Jobs ausführen will ein eigener systemd per-User Prozess laufen muss. Mit einer Option "lingering" kann man dabei erzwingen dass solche Prozesse bereits beim Systemstart gestartet werden und nicht erst wenn sich tatsächlich jemand einloggt. Allerdings bleibt unklar ob das nur zum Start der Timer-Units erforderlich ist, oder ob diese Per-User-Instanzen auch permanent laufen müssen um die cron-Jobs bei Erreichen der Ausführungszeiten auch tatsächlich zu starten.
systemd/sys-apps/gentoo {service manager}: Eine Alternative zu sysvinit, die allerdings noch nicht sonderlich ausgereift ist. Es ist als Drop-In-Replacement für sysvinit gedacht, parst LSB-Header von alten sysvinit-Service-Scripts (die unter Gentoo allerdings gar nicht verwendet werden) und macht intensiven Gebrauch von DBUS, UDEV und dem Control Group Feature des Kernels. Im Gegensatz zum (unter Gentoo bislang nicht verfügbaren) konkurrierenden System "Upstart" ist systemd nicht einzig auf Events ausgerichtet, sondern erlaubt es Abhängigkeiten in "klassischer Form" zu definieren. Ein Vorteil ist, dass systemd Dienste nur bei Bedarf startet (fürs automatische Beenden nicht mehr benötigter Dienste bietet es allerdings keinerlei Unterstützung), während Upstart automatisch alle installierten Dienste startet sobald alle für sie erforderlichen abhängigen Dienste ebenfalls gestartet wurden. Außerdem kennt systemd die Abhängigkeiten zwischen den Diensten und kann diese daher auch anzeigen, während in Upstart Abhängigkeiten nur implizit als Auswirkungen von Events existieren und daher auch nicht direkt angezeigt werden können. Der Nachteil von systemd ist dass er sehr tief ins System eingreift und Dienste wie udev, dbus und autofs mehr oder weniger obligatorisch werden, während sie bisher immer rein optional waren.
sysvinit-2.88-r1/sys-apps/gentoo {service manager}: Der "klassische" init-Daemon. Extrem ausgereift und zuverlässig. Wird über die Datei /etc/inittab kontrolliert und erlaubt es ja nach aktuellen Runlevel ein anders Set von Prozessen zu starten und diese im Falle eines Absturzes neu zu starten. Leider ist dieses Konzept völlig untauglich bei modernen Systemanforderungen, da weder Abhängigkeiten zwischen den Prozessen formuliert werden können noch sinnvoll auf Hardware-Events (wie Plug & Play) reagiert werden kann. Daher wird hier mit Scripten um die Funktionalität von sysvinit herumgefrickelt um die modernen Anforderungen zumindest teilweise zu realisieren.
tails-amd64-3.5.iso/live-system/tails {linux distribution}: Eine auf die Wahrung der Privatsphäre spezialisierte Linux Distribution, die direkt von einem Live-Medium (optische Disc, USB-Datenträger oder SD-Karte) gestartet wird. Die Disc-Version belegt ca. 1,2 GB. Doch für die Installation auf einen USB-Stick sind - warum auch immer - mindestens eine 8 GB nötig. Beim Booten kommen zwar gleich zu Beginn angsteinflößende Kernel-Meldungen wie "invalid opcode", aber das scheint keine weiteren negativen Auswirkungen zu haben, auch wenn die erste Phase des Boot-Prozesses ungewöhnlich lange dauert. Danach kommt jedenfalls ein grafischer Wizard, so man die Locale auswählt - auch Deutsch ist vorhanden. Dadurch wird auch gleich Tastaturbelegung und Datumsformat definiert, obwohl man dies auch separat anpassen kann. Es gibt an dieser Stelle noch weitere per Default aktive Optionen, wie etwa der die Netzwerkkarte eine gefälschte MAC-Adresse zu geben. Weiters wird per Default mit dem TOR-Netzwerk verbunden, aber man kann auch eine TOR-Bridge definieren oder alle Netzwerkfunktionen deaktivieren. Vor allem aber gibt es eine Funktion, ein Administrator-Passwort zu setzen, was per Default deaktiviert ist. Ohne ein solches kann man später keine Administrator-Rechte via "sudo" erlangen, sondern Tails nur als normaler Nutzer verwenden! Es fällt auf, dass das GUI zu diesem Zeitpunkt bereits KVM-Guest-Tools zu verwenden scheint, da sich das ein KVM SDL-GUI-Fenster innerhalb und außerhalb wie ein normales Fenster benutzen lässt, ohne die Maus einzufangen. Genauer gesagt scheint der vermeintliche GUI-Wizard tatsächlich eine angepasste Version des GNOME-"Greeters" zu sein, also jener Komponente wo man normalerweise das grafische Login vornimmt sowie die gewünschte grafische Oberfläche auswählt. Doch die normalen Funktionen gibt es hier nicht, und anstatt sich Einzuloggen vergibt man hier optional das Administrator-Passwort. Erst nach dieser zwingenden Vorauswahl startet das eigentliche Live-System dann, welches leider GNOME3-basiert ist. Sprich systemd und all seine "Extras" wie journald, upowerd, GVFS, PulseAudio, udisks2, colord, AccountService, at-spi-bus und ModemManager laufen, verprassen RAM, und pfuschen überall mit. Man sollte nun glauben man könnte ein vergessenes Administrator-Passwort dadurch setzen indem man sich einfach ausloggt, so dass der GNOME-Greeter erneut erscheint. Jedoch scheint es zumindest im tollen GNOME3-GUI keine Option dafür zu geben - man kann nur runterfahren oder neustarten. Immerhin ist das GUI ansonsten für ein GNOME3 recht komfortabel vorkonfiguriert, und auch hier sind offensichtlich wieder die KVM-Guest-Tools aktiv. Es erkennt sogar explizit wenn es als Emulation läuft und zeige eine entsprechende Warnung an. Neben den eher verzichtbaren systemd-spezifischen Diensten laufen auch ein paar sinnvoller klingende: Der "haveged" Entropie-Sammeldienst, das CUPS Drucksystem, der IBUS für erweiterte Eingabemethoden (etwa für chinesische Zeichen), memlockd (vermutlich soll dieser Swappen vertraulicher Daten auf Disk unwahrscheinlicher machen), TOR, gpg-Agent, GNOME-Keyring. Letzterer scheing von Tails als zentrale Stelle für das Verwalten von Schlüsseln aller Art genutzt zu werden. Bei einem realen System hätte ich da Bedenken wegen der hohen Bug-Dichte von systemd, GNOME3 & Co sowie der wenig vertrauenswürdigen Verschlüsselung (nur AES) des GNOME Keyrings. Aber in einem Live-System das per Default nur in den RAM schreibt lässt es sich vermutlich vertreten. Die vorinstallierten Favoriten sind der TOR-Browser (ein für TOR vorkonfigurierter Firefox-Webbrowser mit vorinstallierten Security-AddOns wie NoScript, uBlock, HTTPS Everywhere und natürlich einem für TOR; gemeingefährliche PlugIns wie Flash oder zusätzliche Video-Decoder sind keine installiert), Thunderbird (Mailprogramm), Pidgin (Instant-Messenger) sowie KeePassX (Passwort-Safe/Manager). Ansonsten sind folgende erwähnenswerte GUI-Programme vorhanden: Dasher (für statistische Text-Eingabe mittels Maus; eine Alternative zur Bildschirmtastatur), LibreOffice, bookletimposer (kann die Seitenanordnung innerhalb von PDF-Dokumenten ändern, damit bis zu 16 PDF-Seiten zugleich am Bildschirma angezeigt werden um den Platz auf Riesenbildschirmen besser auszunutzen), poedit (zum Anpassen von Übersetzungsdateien für Programme), GIMP (Fotobearbeitung), Scribus (Desktop Publishing), Inkscape (Vektorgrafik-Zeichenprogramm), Simple Scan (Papierscanner-Software), Electrum (Bitcoin Wallet), Gobby (ein Texteditor, mit dem man Texte TLS-verschlüsselt übers Netzwerk mit anderen Personen gleichzeitig bearbeiten kann), Lifrea (ein Aggregator für News Feeds), Onion Share (ein Filesharing-Programm für TOR), Audacity (Audio Sample Editor), Brasero (Disc Brennprogramm), Pitivi (Videoschnitt), Sound Juicer (MP3-Tags und ähnliche Metadaten von Mediendateien editieren), Tonaufzeichner (simpler Audio-Recorder), Traverso (scheint dasselbe wie Audacity zu tun; ein Konkurrent), Videos (Medienwiedergabeprogramm "totem"), GtkHash (berechnet Hashes und HMACs für Dateien als per Voreinstellung MD5, SHA-1 und SHA2-256, oder an die 30 sonstigen Hashes und CRCs, leider nur ältere, weder SHA-3 noch BLAKE2 sind unterstützt, oder vergleicht sie mit einem eingegebenen Hash, kann auch Prüfsummendateien verwenden, aber leider keine explizit binären Prüfsummen berechnen - auch wenn dies nur unter DOS/Windows einen Unterschied macht), Taschenrechner (recht mächtig, kann auch mit Imaginärzahlen und anderen Zahlensystemen umgehen, jedoch kann er nicht exakt mit Brüchen rechnen), WhisperBack (ein besonders transparenter Bug-Reporter der deutlich anzeigt was er übertragen wird, und dies natürlich auch verschlüsselt tun kann), MAT (entfernt verräterische Metadaten wie EXIF-Tags aus Mediendateien, aber auch aus Archivdateien), Synaptic (Paketverwaltung), p7zip (Archivprogramm das viele Formate beherrscht). An Tails-spezifischer Software gibt es neben den genannten TOR-Anpassungen einen Installer um Tails vom aktuellen Medium (etwa DVD) auf einen USB-Stick (mindestens 8 GB groß) oder SD-Karte zu installieren, einen Wizard zum (natürlich verschlüsselten) dauerhaften Speichern von lokalen Anpassungen und erzeugten Dateien für das Live-System (funktioniert allerdings nur wen Tails bereits auf einem USB-Stick installiert ist), sowie einem Programm zum möglichst rückstandsfreien Löschen solch einer Datei. An potenziell interessanten Commandline-Tools ist enthalten: vim-tiny, nano, busybox, sshfs (SSH als Remote-Dateisystem mounten), rng-tools (zum Ausnutzen von Hardware-Zufallszahlengeneratoren), ssss (N Teile einer geheimem Datei so erzeugen dass K Teile davon zur Rekonstruktion ausreichen), monkeysign (erlaubt PGP-Schlüssel irgendwie mittels QR-Codes und e-Mails auszutauschen), exfat-fuse, mtools, ntfs-3g, cryptsetup, dmsetup, lvm2, isolinux, syslinux, grub2, amd64/intel-Microcode Updates, diverse auch unfreie firmware, git, perl, python, rsync, man-pages. Was leider fehlt sind joe, encfs, screen, locate, tmux (aber das GNOME-Terminal hat zumindest Tabs), Compiler (C, C++, JAVA) sowie Hacking-Tools. Generell scheint Tails für Büro-Anwender und nicht Entwickler gedacht zu sein. Zu kritisieren wäre neben der GNOME3-Verwendung vor allem der Tails-Installer, der keine Offline-Anleitung mitbringt, dessen Fenster bei VGA-Auflösung nicht komplett auf den Bildschirm passt und auch nicht so verschoben werden kann dass man den "Installieren"-Button sichtbar machen kann, sowie der Umstand dass dieser Button bei Problemen ohne jede Erklärung ausgegraut ist.
tapecalc-20230205-1/math/raspbian: {calculator}{text-terminal IO}: Ein ncurses-basierter Vollbild-Taschenrechner für die Textkonsole. Weiße Schrift auf blauem Hintergrund. Kann im wesentlichen nur die Grundrechenarten, diese jedoch mit Fixkommarithmetik. Dies bedeutet, dass es intern alle Additionen und Subtraktionen nur mit Ganzzahlen durchführt. Das Dezimalkomma wird erst für die Anzeige in die Ganzzahlen einfügt so dass sie wie Zahlen mit Nachkommastellen aussehen. Dadurch werden Ungenauigkeiten bei Summen und Differenzen unmöglich, was das Programm nach eigenen Worten für Berechnungen im Finanzbereich prädestiniert. Bei der Multiplikation und Division kommt allerdings leider weiterhin Fließkomma-Arithmetik zum Einsatz, so dass die Ergebnisse dieser Operationen auf jedem Rechner geringfügig anders sein können. Ich sehe das als großes Manko. Das Programm zeigt alles auf einem "Papierstreifen" an, d. h. man kann auf diesem auch herumscrollen. Ist im Grunde ganz nett für lange Additionsketten weil er die Zwischenergebnisse in jeder Zeile anzeigt. Im Gegensatz zu früheren Versionen des Programms wird nun auch die aktuell eingestellte Locale verwendet, welche Zeichen wie den Tausenderpunkt und das Dezimalkomma definiert. Allerdings beachtet es nur diese Aspekte der Locale. Andere wie Größe der Zifferngruppierung ignoriert es und verwendet hat codierte Werte dafür, derzeit 3 für Tausendergruppierung. Die mitgelieferte Anleitung hat zwar eine angenehme Länge, ist aber leider unzureichend. Sie erklärt nicht einmal die Wirkungsweise der ohnehin nur wenigen eingebauten Spezialfunktionen, wie etwa für "Zinsberechnung" und "Umsatzsteuerberechnung". Da hilft nur ein Studium des Quelltextes.
taskcoach-1.1.4-r1/app-office/gentoo: Eine in Python geschriebene Verwaltung für Aufgaben und To-Do-Listen sowie Aufwandserfassung. Dokumente werden als XML-Dateien gespeichert. Eine Aufgabe kann einen Anfangszeitpunkt, Endzeitpunkt, zugeordnete fixe oder zeitabhängige Kosten haben. Hat sie nichts davon, ergibt sich die Funktionalität eines simplen To-Do-Listen-Eintrags. Weiters können Kommentare, Notizen und sogar Attachments einer Aufgabe zugeordnet werden (allerdings nur im Form von internen Verweisen auf externe Dokumente). Eine Aufgabe befindet sich entweder im Zustand "noch nicht begonnen", "abgeschlossen" oder einem als Prozentsatz angegebenen Fortschritt. Aufgaben können Unteraufgaben haben (baumförmige Struktur). Zeit- und Kostenbudgets können Aufgaben zugeordnet werden; das verbleibende Budget wird berechnet. Eine Stoppuhr-Funktion erlaubt es die aktuelle Tätigkeit einer bestimmten Aufgabe zuzuordnen. Aufgaben können weiters beliebig vielen Kategorien zugeordnet werden. Auch Kategorien können mit Unterkategorien baumförmig dargestellt werden. Die Aufgaben können mittels SyncML auf auf andere Geräte oder Programme synchronisiert werden; allerdings tritt dabei normalerweise Informationsverlust auf da nicht alle beteiligten Programme dieselben Features unterstützen. e-Mails können mittels Drag & Drop von Thunderbird (immer nur einzelne e-Mails) oder Outlook (auch mehrere gleichzeitig) importiert werden. Dabei wird nur der Betreff und Textinhalt als neue Notiz übernommen. Ein Autospeicher-Intervall scheint nicht vorgesehen zu sein, aber dafür kann man automatisches Speichern direkt nach jeder Änderung einstellen. Das Programm macht einen optisch ansprechenden und nützlichen Eindruck. Allerdings wird es aufgrund seines XML-Dokmentformats mit einer großen Anzahl von Aufgaben vermutlich nur schlecht skalieren, da es an keine Datenbank gebunden ist sondern bei jedem Speichervorgang das komplette Dokument erneut schreiben muss. Ebenso muss das gesamte Dokument während der Arbeit im Speicher gehalten werden. Als Kalenderersatz wird das Tool daher kaum geeignet sein.
tboplayer git-1-20121230/community/archlinux: Ein in Python/Qt geschriebenes GUI-Frontend für den omxplayer. Leider ist es derart primitiv, dass es nicht einmal möglich ist mehr als eine Datei gleichzeitig mit dem Dateiauswahldialog auszuwählen, um sie in die Playliste aufzunehmen. Daher praktisch unbrauchbar. Viel mehr als die Tastatur-Kommandos und -ausgaben des omxplayers via ein paar Pipes umzuleiten tut dieses Programm ohnehin nicht. Inzwischen ist es auch in keinem Arch Repository (das zu in diesem Eintrag angeführte Repository ist nur eine Vermutung da ich es nicht leer lassen will) mehr zu finden; vermutlich wegen der miesen Qualität rausgeflogen. Möglicherweise ist das Projekt auch einfach noch zu jung und wird in ein paar Jahren (diese Aussage: 2015) mehr taugen.
tcc-0.9.27-8/devel/debian tcc-0.9.25/dev-lang/gentoo: Ein geradezu winzig kleiner C-Compiler mit einem Installationsumfang von nur knapp über 1 MB. Beherrscht angeblich das komplette ANSI-C 89 und zusätzlich die meisten C99-Features sowie zahlreiche GNU-Extensions. tcc kann direkt ausführbaren Code erzeugen (ohne Umweg über Assembler-Code), enthält jedoch auch einen kleinen "gas"-ähnlichen Assembler (nur für x86-32 und x86-64) für Inline-Assembly-Anweisungen (der dafür keine temporären Dateien erzeugt; kann aber auch externe Assembler-Dateien assemblieren) und auch einen eigenen eingebauten Linker. Weiters besitzt tcc einen eingebaute Librarian und kann als Ersatz für "ar" benutzt werden. Tcc kann zur Zeit (2021) keine statisch gelinkten Executables erzeugen (die Option dafür ist vorhanden funktioniert jedoch aufgrund von Bugs nicht). Tcc unterstützt die gcc-Optionen zum Erzeugen von "Makefile"-Fragmenten für Abhängigkeiten. Es ist auch möglich tcc nur als C-Präprozessor zu benutzen. Der Linker kann zwar relozierbare ELF-Dateien und auch dynamische Libraries erzeugen, unterstützt jedoch keinen Position-Independent Code (PIC). Zusätzlich kann tcc als Script-Interpreter benutzt werden, wobei der ausführbare Code nur temporär erzeugt und ausgeführt wird ohne dass eine ausführbare Datei zurück bleibt. Tcc kann sich selbst übersetzen. Tcc kann auch als Cross-Compiler zwischen x86-32 und x86-64 benutzt werden. Zumindest auf diesen beiden Plattformen kann er Cross-Compiler für die folgenden Zielplattformen bauen: arm64-tcc, arm-tcc, arm-wince-tcc, c67-tcc, i386-tcc, i386-win32-tcc, x86_64-osx-tcc, x86_64-tcc und x86_64-win32-tcc. Tcc ist zum größten Teil ein Ein-Pass-Compiler und unterstützt nur simple Optimierungen wie Constant Folding, Shifts statt Multiplikationen, Strength Reduction sowie irgend eine Optimierung mit den Condition-Flags bei Vergleichsoperationen. Höherwertige Optimierungen welche einen interne Zwischencode des Programms erfordern würden wie  Invariant Out-Of-Loop Hoisting gibt es nicht. Der Compiler compiliert dafür aber irrsinnig schnell, zumindest verglichen mit dem gcc. Der tcc kann sogar dynamisch (ohne Temporärdateien) "on the fly" C-Code generieren indem man einer Library-Funktion einen String mit einem C-Programm übergibt. Zu diesem Zweck wird die libtcc.a bereit gestellt. Man kann mit tcc nicht nur Executables sondern auch shared Libraries erzeugen. Der einzige Nachteil von tcc ist seine relativ geringe Auswahl an Target-Architekturen; derzeit unterstützt er nur generisches x86 (32 Bit, 80x87 Floats, die am besten unterstützte Architektur; alle anderen gelten als Portierungen mit Alpha-Status), x86-64 (64 Bit, SSE Floats), ARMv4 (32 Bit, nur VFP Floats), ARMv8 (64 Bit), TMS320C67xx, CIL (.NET bytecode). Spezielle Befehlssatz-Erweiterungen wie Multimedia-Instruktionen werden dabei nicht gesondert unterstützt. Allerdings unterstützt er damit zumindest die am meisten verbreiteten Architekturen. Tcc setzt ferner eine bereits installierte C-Standard-Library und deren Header-Files voraus - zumindest wenn man deren Funktionen nutzen will. Weiters inkludiert tcc einen optional zuschaltbaren Bounds-Checker (funktioniert allerdings nicht zusammen mit longjmp) und Memory-Checker, die angeblich keine schlimmere Performance-Einbuße als einen Faktor 2 - 3 bewirken.
tcpflow-0.21/net-analyzer/gentoo: Captures data contents of each TCP connection to its own file
tcplay-0.11-1/admin/debian {security}: Eine TrueCrypt-Implementierung, die nur mit dem Kernel Device-Mapper/dmcrypt arbeitet. Leider unterstützt diese Version nur die Encryption-Modi neuer TrueCrypt-Versionen, und ist daher unbrauchbar für die alten (Version 4 und älter). Der in "cryptsetup" eingebaute TrueCrypt-Support ist diesbezüglich besser.
tcpslice-1.1_alpha3/net-analyzer/gentoo: Filter tcpdump by time ranges
tcptrace-6.6.1-r1/net-analyzer/gentoo: Only creates statistics about the output of tcpdump
tcsh 6.19.00-3/community/archlinux: Eine erweiterte, aber rückwärtskompatible Version der originalen csh der Berkeley UNIX Labs. Es fällt negativ auf, dass diese Shell sogar *noch* fetter als die ohnehin schon ziemlich fette Bash ist: 4 MB RAM-Bedarf bzw. 7 MB virtueller Speicher. Zum Vergleich: Bash 3 bzw. 6 MB. BusyBox ash 2 bzw. 5 MB. dash 1 bzw. 2 MB. Auf der positiven Seite bietet die tcsh ein paar Extras gegenüber der bash: Kann Tastenbindungen anzeigen. Hat mit "sched" eine Art kleines "at" direkt eingebaut, mit dem man Kommandos zu einem späteren Zeitpunkt ausführen lassen kann. Ein Vorteil gegenüber dem echten "at"-Kommando ist, dass "sched" direkt in der tcsh eingebaut ist und daher keinerlei spezielle Rechte zur Inbetriebnahme vonnöten sind. Davon abgesehen scheint es eine ziemlich sinnlose Duplikation des Standard-Kommandos "at" mit reduzierter Funktionalität zu sein. Überhaupt scheint tcsh eher willkürlich etliche Befehle fest eingebaut zu haben, die man auf anderen Shells einfach als externe separate Programme aufruft. So zum Beispiel Kommandos welche Terminal-Eigenschaften ändern oder anzeigen. Oder Kommandos welche die Aktivitäten anderer User überwachen, wie logouts. Viele dieser Kommandos scheinen zweifelhaften Nutzen zu haben, da man sie einfach durch normale externe Standard-POSIX-Kommandos ersetzen könnte. Viele Features hat die tcsh mit der Bash gemeinsam: Flow-Control Kommandos wie "if" oder "while" (jedoch mit anderer Syntax), Redirections, jede Menge Spezialvariablen und Settings (scheinen mir sogar mehr als bei der Bash zu sein), Tab Completion (Ctrl-d zum Auflisten von Alternativen - fungiert zugleich aber auch wie gewohnt als "End-Of-File"-Zeichen was mir bedenklich erscheint), History Editing und -Expansion, Spelling Correction, Farb-Support für $LS_COLORS, Locale-Support, Job-Control, Traps, Directory Stack, Command Hashing, Resource Limits, Arrays, Aliases, Subshells, Substitutions. Ein großer Unterschied zwischen tcsh und Bash ist dass tcsh keine benutzerdefinierten Funktionen zu kennen scheint. Was sich nicht als Alias implementieren lässt, scheint nur in Form eines externen Scripts die vergleichbare Funktionalität einer Bash-Funktion entfalten zu können. Insbesondere rekursive Funktionsaufrufe scheinen mit Aliases allein nicht möglich zu sein. Dafür bietet tcsh allerdings ein "goto"-Kommando, welches wiederum die Bash nicht hat. Außerdem stellt die Alias-Expansion der tcsh das noch nicht expandierte Original-Kommando temporär in der History zur Verfügung, so dass man mit History Expansion gezielt auf Argumente des Aliases zugreifen kann. Weiters inkludiert die History der tcsh auch den Zeitpunkt wann eine Kommandozeile ausgeführt wurde. Bash bietet dafür RegEx-Support im eingebauten "test" Kommando, während tcsh nur in der History-Expansion RegExes unterstützt.
tdb-1.2.7-r1/sys-libs/gentoo {key/value store}: "Trivial Database System", a simple LGPL'ed noSQL database much in the spirit of (but incompatible with) dbm. tdb has been developed as part of the SAMBA file server. It is a pure key/value-store (binary and arbitrary sized); keys must be unique and have no defined order. One specialty of tdb is that it supports transactions and multiple concurrent writers despite its general simplicity. It can be compiled to use either memory mapping or read/writes, and it can also be selected whether file locking is compiled in. Tdb does not cache data internally beyond what the file system itself does. When locking and memory mapping has been compiled in, both can be disabled with flags when opening a database. Similarly, transactions or transaction nesting can also be disabled. Support for one sequence counter per database. A function for traversing the complete database is provided. Small installation footprint - just about 400 KiB including header file and manual. Tdb is especially well suited for maintaining "account"-like databases. Which means the database might be used quite often, but typically only for a short time during each usage.
tea-50.0.4-1/editors/raspbian: {text-editor}{Qt}: Ein Qt-basierter in PASCAL programmierter schneller Texteditor. Kann auf den ersten Blick alles wesentliche: Weichen Zeilenumbruch, optionales Einblenden von Zeilennummern, UNICODE-Unterstützung sowie viele Single-Byte-Codepages, Syntax-Highlighting, kann eine Linie für statischen Zeilenumbruch einblenden, kann mehrere Dateien zugleich in Tabs anzeigen, kann die aktuelle Zeile hervorheben. Was er leider nicht kann: Der Mauszeiger wird nicht versteckt sobald man zu tippen beginnt und sich dieser gerade über dem Text befindet; das ist häufig der Fall nachdem man etwas mit der Maus markiert hat. Dann verdeckt der Mauszeiger oft genau dort Zeichen wo man gerade tippt. Das Programm sieht Qt-typisch auf den ersten Blick sauber und aufgeräumt aus. Wohltuend ist vor allem auch der normale Scrollbalken, wenn man zuvor mit einem gtk-basierten Editor wie "mousepad" gearbeitet hat wo einen die GTK3+ "Strich-Scrollbalken" ständig ärgern. Allerdings machen die gewählten Icons einen "klotzigen" Eindruck - ein bisschen wie im Kindergarten. Aber das muss ja nicht unbedingt schlecht sein. Besser als der Eindruck von Komplexität. Der Editor ist offensichtlich in erheblichem Ausmaß zum Bearbeiten von HTML-Dateien gedacht, da es ein ganzes Menü gibt aus dem man makro-ähnlich entsprechende Auszeichnungen einfügen kann. Allerdings gibt es ein 2. Menü wo man zwischen verschiedenen populären Auszeichnungssprachen wie TeX oder XML umschalten kann, für welches im anderen Menü dann passende Auszeichnungen angezeigt werden. Was er nicht zu beherrschen scheint ist Folding. Allerdings gibt es ein Plugin-System, wo sich so etwas später einmal vielleicht nachrüsten läßt. Derzeit gibt es aber offenbar noch keine Plugins, zumindest nicht über die Paketverwaltung angeboten. Was etwas verwirrt, sind die spartanischen Kontextmenüs welche nur die base Basics (Copy/Paste/Undo etc.) enthalten aber keine weiteren Editor-spezifischen Funktionen. Statt dessen muss man alles über die normalen Menüs, rechts angebrachte Tabs mit zusätzlichen Funktionen, oder Keyboard-Shortcuts erreichen. Möglicherweise interessant ist in diesem Zusammenhang die Unterstützung des Programms für die dieser Tage selten gewordene uralte Funktion, Pull-Down Menüs ablösen zu können so dass sie danach als eigenständige Fenster offen bleiben. Die Suchfunktion ist ungewöhnlich implementiert indem alle Optionen sich als Kästchen im normalen Menü befinden, und nur die eigentliche Textzeile für die Suche erscheint. Die Suche unterstützt auch RexExps sowie Fuzzy-Search. Außerdem kann er auch in Verzeichnisse durchsuchen und nicht nur geöffnete Dateien. Ebenfalls sehr eigenwillig ist der integrierte Dateimanager. Laut Dokumentation hatte das Programm ursprünglich keine separaten Öffenen/Speichern-Dialoge, weshalb man den Dateimanager dazu nutzte ein Verzeichnis oder einen Dateinamen auszuwählen. Dies ist nach wie vor der Default, aber es lassen sich nun annähernd normal funktionierende Öffnen/Speichern-Dialoge einschalten. Der Dateimanager beherrscht auch etliche Datei-spezifische Funktionen wie löschen, umbenennen, Verzeichnis anlegen, Anzahl der Zeilen in allen selektierten Dateien ermitteln, SHA-1, SHA-2, SHA-3 über Dateiinhalte berechnen, mehrfaches Umbenennen, ZIP-Dateien erstellen oder auflisten. Er kann Bilddateien voranzeigen, auf gleiche Dimensionen bringen, ihre Größe skalieren oder eine Web-Fotoalbum aus ihnen erstellen. Dateien können mit RegExp selektiert und deselektiert werden. Was ich nicht finden konnte war eine Funktion zum Anzeigen versteckter Dateien: Genauer gesagt werden diese *immer* angezeigt. Es fehlt also vielmehr das Gegenteil, nämlich versteckte Dateien tatsächlich zu verstecken. Rudimentäre Build-Funktionalität ist enthalten: Man kann ein Programm bauen, ausführen und die Build-Dateien löschen. Die dabei aufgerufenen Befehle müssen zuvor in einer Projektdatei definiert werden. Man kann dies auch mit Profilen kombinieren, welche sich anlegen lassen. Damit lassen sich schnell Editor-Settings wie Zeilenlänge, Einrückungs-Modi, Fonts, Fenstergrößen usw. umschalten. Diese Funktion ersetzt zugleich die automatische Erkennung spezieller Dateitypen - man legt statt dessen unterschiedliche Profile für die Dateitypen an. Syntax-Highlighting gibt es ebenfalls. Sie scheint automatisch zu funktionieren und keinen Bezug zu den Profilen zu haben. Sie läßt sich auch erweitern, indem man Definitions-Textdateien für neue Sprachen in einem Konfigurationsverzeichnis ablegt. Es gibt eine Funktion um zwischen Quelltext und zugehöriger Header-Datei hin und her springen. Im Text der Dateien können "Labels" mittels spezieller konfigurierbarer Markierungzeichen markiert werden, welche der Editor dann finden und anspringen kann. Ein ungewöhnliches Feature ist der eingebaute Kalender, der eine Kalenderdatei (als Textdatei) pro Tag verwaltet in der man Termine eintragen kann. Sogar Alarme lassen setzen; jedoch muss der Editor laufen damit sie auch ausgelöst werden können. Ein ganz besonders wichtiges Feature scheint dem Autor dabei die Mondphase zu sein, denn es können 4 Algorithmen ausgewählt weden diese zu berechnen, und außerdem sind zahlreiche Fotos des Mondes in verschiedenen Phasen und Drehpositionen vorhanden die in der Kalenderansicht eingeblendet werden können. Der Kalender kann auch einige Berechnungen anstellen, wie die Anzahl von Tagen zwischen zwei Daten (und natürlich auch für Mondtage!) zu berechnen. Alles in allem ist der Kalender ein eher sinnloses Feature für einen Texteditor und sichtlich von Autor zum Eigenbedarf entwickelt. TEA beherrscht auch "Scripts", das sind einfach benutzerdefinierbare externe Programme die aufgerufen weden und dann den markierten Text (oder das ganze Dokument) als klassische UNIX-Filterprogramme verarbeiten können. Tea kann zwar nur Textdateien bearbeiten und speichern, kann aber auch andere verbreitete nicht-Text Dateien öffnen und versucht dann, den Textinhalt und soweit möglich auch die Formatierung aus diesen Dateien zu extrahieren. Konkret kann er die folgenden Formate anzeigen/importieren: ODT (OpenDocument Text), KWD (altes KWord's format), FB2, DOCX, RTF, SXW (altes OOo/StarOffice format), ABW (Abiword) formats und gzip-komprimierte Dateien. Ein originelles Feature ist "save as different", wo man die aktuelle Datei mit einem Zeitstempel im Namen (oder alternativ nur mit einer simplen .bak-Dateierweiterung) als unabhängige Datei abspeichern kann. Man kann in TEA auch Templates für neue Dateien erstellen, so dass die neue Datei dann einen vordefinierten Anfangsinhalt hat. Sessions werden ebenfalls unterstützt - dazu enthält eine Session Datei einfach die Liste von Dateien die zum Projekt gehören. Es können auch Bookmarks für Dateien gesetzt werden, ähnlich wie KDE/GNOME das von Haus aus in ihren Datei-Dialogen können aber unabhängig davon. Text-Snippets welche an der Cursor-Stelle eingefügt werden können sind ebenfalls möglich. Eine ganze Reihe mehr oder weniger höchst willkürlicher erscheinender fest eingebauter Filterfunktionen wie z. B. "Morsecode nach russisch" oder Dezimalgrad nach Grad/Stunden/Minuten sind ebenfalls vorhanden, aber auch sinnvollere wie zum Sortieren, Klein-/Großschreibung, Reformatieren und noch einiges mehr. Insgesamt bleibt das Gesamteindruck, dass die Bedienung des Programms einigermaßen eigenwillig ist. Jedoch betrifft dies nur Very-High-Level Funktionen wie Speichern oder die Suche, während das Editieren im Allgemeinen ganz normal vor sich geht. Also keinesfalls so eigenwillig wie z. B. vi oder emacs, für die relativ großer Lernaufwand erforderlich ist um sie zu beherrschen. Vor allem entsteht der Eindruck, dass die Autoren des Programms alle möglichen Spezialfunktionen welche sie selbst benötigten als fixe Bestandteile ins Programm einbauten, anstatt dies wie es naheliegender gewesen wäre als Plugin-Module zu realisieren. Vielleicht liegt es daran dass die Autoren PASCAL-Programmierer sind und mit normalen Scriptsprachen wenig anfangen können. Rechtschreibprüfung wird wahlweise mit hunspell oder aspell ebenfalls vom Programm unterstützt. Eine (lokale) Webseiten-ähnliche Online-Hilfe für den Editor ist verhanden, und kann in einem seiner System-Tabs jederzeit angezeigt (und auch durchsucht) werden. Die Geschwindigkeit mit der diese Hilfe angezeigt wird läßt befürchten, dass der Hilfetext bereits beim Start geladen wird und daher ständig sinnlos im RAM gehalten wird. Mit knapp über 1 MB Größe des Executables ist dies zwar nicht der schlankeste aller Editoren, aber dafür installiert er ansonsten nichts weiter außer den mindesten Dingen (Icon, man-Page, .desktop File). Beim RAM-Verbrauch ist er war nicht gerade sparsam, 330 MB virtuell und 90 MB resident, womit er nur geringfügig weniger RAM als kate verbrät. Allerdings startet er trotzdem schnell und hat dafür auch keine KDE-Abhängigkeiten so dass er in Summe sicherlich sparsamer ist. Gegen Leafpad ist aber auch TEA ein fettes Monster, ohne jedoch genau so viel zu können wie kate. TEA kann auch mehrere MB große Textdateien mit weichen Zeilenumbrüchen schnell öffnen. Der vergleichweise hohe RAM-Bedarf entsteht möglicherweise auch durch die Tendenz von PASCAL, viel mit Datenstrukturen fixer Größe zu arbeiten, etwa für "PASCAL Strings", während dynamische Speicherallokation zwar ebenfalls aber eher zurückhaltend verwendet wird. TEA ist kein neues Programm, sondern wird schon 2000 entwickelt und ist in Borland Delphi geschrieben. Es sollte mittlerweise daher leidlich stabil sein. Alles in allem eine schlankere Alternative zu Kwrite und Kate die aber auch weniger kann. Dafür ist sie unabhängig von einer bestimmten Desktop-Runtime, ist flott und tut ihr Ding. Wenn man kate und kwrite aber ohnehin bereits installiert hat, erkenne ich keinen rechten Mehrwert und in Gegenteil ein paar fehlende Funktionen (wie etwa den Symbol-Browser von kate). Was zu prüfen wäre ist ob er vielleicht weniger Rechenleistung verbrät als kate/kwrite, und daher auch auf langsameren Rechnern funktioniert wo die beiden KDE-Programme zu zäh arbeiten (wie etwa dem Raspberry Pi Modell 1).
tecnoballz-0.92/games-arcade/gentoo {game}: Eine Breakout-Variante mit besonders umständlichen Balleffekten. Stürzt leider andauernd beim Parsen seiner eigenen Konfigurationsdatei ab.
tesseract-ocr-3.03.03-1/graphics/devuan {OCR}: Tesseract ist für allgemeine Fälle die beste OCR, hat jedoch Probleme (insbesondere bei Schriften mit konstanter Zeichenbreite) vor allem mit kaufmännischem Und, Leerzeichen, Minus- und Prozentzeichen abhängig vom Font. "DejaVu Sans" und "Cantarell 12 pt" haben für die Zwecke von Screen OCR gute Ergebnisse gebracht. Weiters ist die Texterkennung von Tesseract sehr kontext-sensitiv, und daher vermutlich weniger für BASE-64 codierte Texte, willkürliche Codes oder Passwörter geeignet.
tetzle-2.0.1-1/games/debian {game}: Ein Puzzle-Programm. Kann offenbar beliebige Bilder in Puzzleteile zerlegen. Baut auf Qt und OpenGL auf und stürzt ab wenn der Rechner keinen OpenGL-Support bietet - wie etwa der Raspberry Pi.
thonny-3.1.2-1/devel/debian {development_environment}: Eine etwas mächtigere, aber grafisch wegen winziger Icons eher mühsam wirkende IDE für Python. Auch diese IDE bietet Direktzugriff auf den Python-Interpreter, Code-Editor und Debugger. Zusätzlich kann sie jedoch auch den abstract Syntax-Tree des Python-Programms, dessen Heap und besitzt einen Object-Inspektor zum Begutachten von Objektvariablen. Der Debugger arbeitet allerdings lahmer als der von mu-editor; teilweise entstehen unerklärliche Verzögerungen während des Debuggens. Insgesamt ist auch diese IDE einzig wegen des integrierten grafischen Debuggers potenziell interessant, bietet jedoch klar mehr Features als das mu-editor Paket. Mit rund 300 kB Download-Größe ist das Paket zudem auch einigermaßen schlank. Allerdings hatte der Debugger zumindest unter i386 in der oben erwähnten Version des Pakets den Nachteil, dass er sich scheinbar unmotiviert aufhängte sobald man in eine Funktion hinein-steppen wollte. Der mu-editor hatte dieses Problem nicht.
thrust-0.89c-3.5/games/debian {game}: Angeblich ein Nachbau des gleichnamigen C64 Spiels. Erfordert allerdings 8 Bit Palette Grafik, wie sie VGA mit 256 Farben bietet. Funktioniert konkret auf keinem RPi mit 24 Bit RGB framebuffer. Schade.
thunar-1.2.1/xfce-base/gentoo {file manager}{GUI}{X11}: Ein simpler "Explorer"-artiger Dateimanager, welcher der Standard-Dateimanager von Xfce4 ist. Implementiert den freedesktop.org-Papierkorb und erlaubt dessen gezielte Umgehung. Er erinnert frappant an pcmanfm, genauer gesagt muss man erst zweimal hinsehen um überhaupt irgendwelche Unterschiede erkennen zu können; beide Programme benutzen standardmäßig sogar größtenteils dieselben Icons und Fonts. Leider eint die beiden Programme dabei auch das gemeingefährliche Verhalten, die Dateierweiterung von bestimmten Dateitypen (zumindest von ".desktop-Dateien") zu verstecken, und dies lässt sich auch nicht abschalten. Thunar hat 3 Ansichten: Die Symbolansicht listet Dateien und Verzeichnisse mehrspaltig auf und scrollt vertikal. Dabei befindet sich unter jedem Icon der Name, der auch mehrzeilig umgebrochen wird um die Spaltenbreite einhalten zu können. Der Text wird dabei linksbündig ausgerichtet (beim pcmanfm ist er zentriert). Die Detailansicht stellt einen Eintrag pro Zeile an. Gerade und ungerade Zeilen werden unterschiedlich gefärbt. Dabei werden Name, Größe, Typ und Änderungsdatum angezeigt. Dies ist dieselbe Anordnung wie beim pcmanfm, nur dass die Spalten "Größe" und "Typ" dort vertauscht sind. Thunar zeigt im Gegensatz zu pcmanfm auch bei Verzeichissen eine Größenangabe an - allerdings nur den Platzbedarf der Directory-Einträge, und nicht etwa die Größe der im Verzeichnis enthaltenen Dateien. In der horizontal scrollenden Listenansicht wird ein kleines Symbol und der Name rechts daneben dargestellt; die Spalten haben variable Breite entsprechend dem längsten Namen in jeder Spalte. Die Icons beim Thunar sind hier in der Voreinstellung ein wenig kleiner, so dass die Ansicht ein wenig kompakter wirkt. (Allerdings kann man dies beim pcmanfm eben so einstellen.) Die Ansicht "Miniatur-Vorschaubilder" des pcmanfm fehlt dem Thunar. Allerdings können beide Programme auch in der Symbolsansicht Miniatur-Vorschaubilder anzeigen. Beide Programme erlauben die Art der Ansicht für neue Fenster einzustellen, aber nur der Thunar bietet dabei die Variante dass die zuletzt verwendete Ansicht dazu genutzt werden soll. Nur der pcmanfm erlaubt es die Icon-Größen für die verschiednen Anzeigemodi und eine Maximalgröße für den Speicherbedarf der Vorschaubilder zu definieren, und er bietet zumindest ein paar Buttons zur Navigation, während der Thunar überhaupt keine Buttons ausserhalb der Listenfenster bietet. Aber das sind nur kleine Details; im größen bleibt der Eindruck zweiter identischer Programme, wobei der Thunar noch geringfügug minimalistischer wirkt als der pcmanfm. Allerdings fiel mir auf dass der pcmanfm bei großen Directories flüssiger scrollt wo der Thunar ein wenig "eiert", er scheint ein wenig performanter programmiert zu sein. Aber die Unterschiede sind nicht groß und man bemerkt sie nur im direkten Vergleich. Dafür ist der Thunar bei der Anzeige selektierter Dateien intelligenter: Er zeigt in diesem Fall nicht nur die Anzahl sondern auch die kombinierte Größe der Dateien an. Ohne Selektion zeigt er den gesamten belegten und freien Platz im Dateisystem an. Der pcmanfm zeigt letzte Angabe immer an, bei selektieren Dateien jedoch nur deren Anzahl doch nicht ihre kumulative Größe. Nur der Thunar erlaubt es, die eingestellten Schriftarten dynamisch mit Strg + und - zu zoomen oder die Möglichkeit Dateien mit einem simplen "*"/"?"-Suchausdruck zu selektieren. Nur der pcmanfm hat Karteireiter oder bietet die Möglichkeit, beim Löschen den "Papierkorb" zu umgehen. Nur der Thunar bietet einen Dialog zum Definieren beliebiger Menü-Kommandos, denen auch Details der selektieren Namen übergeben werden können. Beiden Programmen fehlt gegenüber dem XFE die Möglichkeit, die angezeigten Namen filtern zu können, zwei Directory-Panels nebeneinander anzuzeigen, sowie mit Total-Commander-ähnlichen Tastenkombinationen zu arbeiten, sowie Verzeichnisse wahlweise auch genau so wie Dateien zu sortieren und nicht immer an den Anfang der Liste stellen zu müssen. Fazit: pcmanfm wirkt ein wenig (aber nicht deutlich) mächtiger als Thunar (vor allem durch seine Karteireiter) und ist auch etwas schneller. Dafür muss man beim Thunar weniger konfigurieren; er tut bereits in der Grundeinsteller meist das "richtige" bzw. (zumindest von mir) gewünschte. Wenn man dem aber den Installationumfang des pcmanfm mit 0,5 MB dem des Thunar mit ca. 6,5 MB gegenüber stellt, wirkt der pcmanfm deutlich beeindruckender. Abseits dessen sind die Programme weitgehend identisch. Wer Xfce4 verwendet sollte daher Thunar verwenden da dieser dort ohnehin dabei ist. Alle anderen bekommen mit pcmanfm dasselbe und noch ein wenig mehr für einen etwas geringeren Installationsumfanfg.
tiemu-3.03/sci-calculators/gentoo {symbolic calculation}: Ein Emulator für TI-89, TI-92, TI-92+ und TI Voyager 200 PLT. Zum Betrieb braucht man aber Kopien der Original-ROMs. Oder man nimmt die mitgelieferten freien ROMs; mit diesen ist das Gerät aber nur zum Ausführen eigens entwickelter nativer Programme zu gebrauchen die keinerlei Bezug zu den Taschenrechner-Funktionen des kommerziellen Geräts haben. Freilich lassen sich die Original-ROMs durchaus im bösen Internet finden... allerdings macht der Gebrauch des Emulators irgendwie dennoch keinen rechten Spaß. Erstens ist die grafische Darstellung der Tasten eine Bitmap mit fixer (geringer) Auflösung, die auf einem hochauflösenden Monitor grässlich aussieht. Mag sein dass man hier eine neue installieren könnte. Weiters passt die Tastenbelegung nicht mit der PC-Tastaturbelegung zusammen. Auch das dürfte man in Konfigurationsfiles korrigieren können. Schlimmer jedoch das Problem dass es kein Copy/Paste von/zu anderen GUI-Programmen außerhalb des Emulators gibt. Man muss daher ständig alles neu eintippen oder abtippen. Das nervt! Daher ist dieser Emulator, obwohl er im Grunde hervorragend funktioniert, unpraktisch und nervig für reale Arbeit. Eher ein lustiges Ding zum Herumspielen. Aber natürlich mag das Ding nützlich für Leute sein welche den realen Taschenrechner besitzen, um dann auch ohne diesen die von diesem abgespeicherten Daten, Formeln und Programme am PC verwenden zu können ohne sie irgendwie konvertieren zu müssen. Für andere Anwender aber nur eine sinnlose Spielerei.
tigervnc-1.0.1_p20100914/net-misc/gentoo {KVM sharing}{GUI}{X11}: Ein Fork von tightvnc mit höherer Geschwindigkeit, optionaler Verschlüsselungserweiterung (unterstützt auch X.509 Zertifikate - aber leider nur im Viewer; derzeit noch nicht im Server) und auch etlichen Optionen welche man von laufenden Viewer aus dynamisch übers Popup-Menü konfigurieren kann ohne diesen zuvor beenden zu müssen. Kann neben der optionalen JPEG-Komprimierung auch OpenGL-Beschleunigung für die Ausgabe verwenden und beherrscht Clipboard-Transfer. Im Paket ist auch ein dynamisch nachladbares Erweiterungsmodul für den xorg-Server enthalten, mit dem dieser durch den x0vncserver von TigerVNC direkt kontrolliert werden kann - ohne den bisher erforderlichen Umweg über x11vnc. Auch tigervnc hat seine Probleme mit Drag & Drop, aber zumindest funktioniert es *überhaupt* in den Fällen wo tightvnc kläglich versagt. Das ärgerlichste verbleibende Problem ist dass oft dass bei Drag & Drop oft der "Mouse Grab" hängen bleibt - dann kann man nur noch manuell den X-Server killen. Allerdings kann man dies meist vermeiden in dem man *höllisch* aufpasst bei Drag & Drop nur "sauber zu klicken" und dabei immer innerhalb der richtigen Fenster zu bleiben.
tightvnc-1.3.10-r1/net-misc/gentoo {KVM sharing}{GUI}{X11}: VNC Server und Viewer, der nicht nur das normale VNC-Protokoll versteht, sondern auch die "tight"-Erweiterung mittels welcher Bildänderungen als JPEG komprimiert verlustbehaftet übertragen werden können. Das kann gegenüber den normalen verlustlosen VNC-Protokollen fantastische Geschwindigkeitserhöhungen bei geringer verfügbarer Netzwerk-Bandbreite bringen. Das Paket enthält auch ein optionalens JAVA-Applet für Web-Browser, welches alternativ als Viewer eingesetzt werden kann. So braucht man den nativen Viewer gar nicht installieren; jeder Web-Browser mit JAVA-Plugin reicht ebenfalls. Der in diesem Paket enthaltene VNC-Viewer funktioniert zwar bestens, ist aber extrem hässlich (uralte total hirnrissig zu bedienende Scrollbalken) und hat keinerlei Zusatzfeatures wie Dateiübertragung oder Konfiguration der Einstellungen im laufenden Betrieb. Leider hat die Server-Komponente das Problem, dass Drag & Drop extrem problematisch ist und in einigen Fällen auch überhaupt nicht funktioniert. Etwa wenn man beim Firefox die Toolbars anpassen will in dem man neue Elemente hinein zieht. Das funktioniert einfach nicht.
timidity++-2.14.0-r2/media-sound/gentoo {audio}{music}: Ziemlich dasselbe wie fluidsynth, nur dass es älter und angeblich sparsamer im Resourcenverbrauch ist. Konkret lädt FluidSynth einen Soundfont offenbar immer komplett in dem RAM, während Timidity nur die tatsächlich benötigten Instrumente lädt. Das ist zugleich der Nachteil von Timidity, denn es verwendet ein eigenes Sound-Font-Format, wo die einzelnen Instrumente als "Patches" gespeichert sind, statt alles in einer einzelnen Datei. Ein Vorteil jedoch ist dass zumindest 2 SoundFonts unter Portage zur sofortigen Installation zur Verfügung stehen; man muss also nicht manuell etwas dazu installieren. Eine Behauptung welche ich las ist dass Timidity Probleme bzw. Beschränkungen hat, wie lange zuvor gespielte Töne nachklingen. So soll bei fluidsynth ein aussetzendes Percussion-Instrument noch Sekunden später im Nachklang zu vernehmen sein, während es bei Timidity viel schneller verstummt. Es ist unklar ob dieses Problem immer noch besteht.
tinc 1.0.26-1/community/archlinux: Eine VPN-Lösung ähnlich wie OpenVPN, allerdings nur mit 1/3 von dessen Installationsumfang. Tinc basiert komplett auf OpenSSL und unterstützt daher alle und nur die symmetrischen Verfahren und MACs die OpenSSL bietet. Zum Schlüsseltausch wird immer nur RSA verwendet. Einen pre-shared key mode gibt es nicht. Tinc läuft auf Linux, BSD und Windows. Es unterstützt IPv4 und IPv6 und kann als Router, Switch oder Hub konfiguriert werden. Ebenso kann es SOCKS4, SOCKS5 oder HTTP-Proxies verwenden. Tinc kann die getunnelten Daten wahlweise mittels TCP oder UDP transportieren. Alles in allem wirkt Tinc wie ein Subset von OpenVPN, bei dem das Fehlen eines pre-shared-key Modus am deutlichsten ins Auge sticht. Dafür ist es aber auch kleiner, man muss weniger Optionen auswählen, und sich durch eine weniger lange man-Page quälen.
tint2-0.11/x11-misc/gentoo {desktop panel}: Ein themable und autohide-fähiges Desktop-Panel, welches Taskbar, System Tray, Batterieanzeige und Uhr zur Verfügung stellt. Es bietet kein eigenes Startmenü, Application-Launch-Buttons oder einen Workspace-Pager. Aber Maus-Events in einem freien Bereich des Panels können optional an den Fenstermanagers durchgereicht werden. Das ist hilfreich etwa für Openbox, welches ein Startmenü bietet und Umschaltmöglichkeiten für Workspaces via Kontextmenüs und Mausrad. Das Panel kann horizontal oder vertikal angeordnet werden und wieviel % der Bildschirmkanten-Länge einnimmt ist konfigurierbar. Ein in Python verfasstes GUI-Programm zur Konfiguration kann optional installiert werden (unter 300 KB). Ein GUI-Selector zur Theme-Auswahl (unter 70 KiB Größe) kann optional installiert werden, erfordert dann aber GTK+ als Abhängigkeit. Das eigentliche Exectable von tint2 ist unter 130 KiB groß. Die ganze Installation des Panels unfasst weniger als 500 KiB (ohne den Konfigurations-Wizard). tint2 selbst hat nahezu dieselben Abhängigkeiten wie Openbox: Es selbst benötigt nicht direkt GTK+, hängt aber von einigen dessen Basis-Libraries ab. Die Uhr erlaubt auch zweizeilige Anzeige von Datum und Zeit. Der Taskbar kann optional Ballon-Hilfen mit den vollen Namen der Applikationen anzeigen. Etwas eigenartig ist das defaultmäßige Schließen einer Anwendung, wenn man mit dem rechten Mausknopf auf den Eintrag in der Taskleiste klickt. Dies ist aber konfigurierbar. Lustig hingegen die Idee, dass man mit dem Mausrad abwärts eine Anwendung minimiert und mit Mausrad aufwärts wiederherstellt. Alles in allem eine gute und schlanke Ergänzung zu Openbox; einzig das Fehlen von Applikations-Startbuttons ist zu Bemängeln. Doch eventuell kann man diese mit einer externen Traybar-Applikation nachrüsten.
tinyproxy-1.8.3-r3/net-proxy/gentoo: Ein angeblich winziger Proxy, der allerdings mit 350 KB Installationsumfang nicht wirklich aufregend klein ist. Er kann auch für Reverse Proxying und kann als Transparent Proxy konfiguriert werden. Probleme: Ließ sich nicht als normaler User starten und faselte irgendwas von wegen einem Thread-Pool (Problem im Internet bekannt; bei einigen geht's und bei anderen nicht). Weitere Probleme: Er kann nicht nach stderr loggen und man muss unbedingt einen Pfad zu einer PID-Datei angeben.
tinyscheme-1.41.svn.2016.03.21-1/lisp/debian {programming language}: Eine winzige Scheme-Implemenentation, ca. 150 kB. Beherrscht "fast" den gesamten R5RS Standard, allerdings nur die Kernsprache und nicht die Libraries. Die allerwichtigsten Library-Funktionen beherrscht es zwar, ebenso Ports, (Byte-) Strings, Vektoren, Integers, Reals. Aber beliebig genaue Integers oder Rationals werden einfach durch Fließkommazahlen "implementiert", und auf UNICODE- oder gar Locale-Support muss man natürlich ebenso verzichten. Auch ein Library-Konzept scheint nicht wirklich vorgesehen zu sein. Bzw. muss man es sich selber implementieren. Grundsätzlich sollte das möglich sein, da unter den verfügbaren Features durchaus auch sehr mächtige wie try/throw, call-with-current-continuation, force/delay und eval dabei sind. Die eingebauten Bibliotheksfunktionen werfen standardmäßig keine Exceptions, jedoch gibt es einen zentralen Hook für diesen Zweck und eine einfache Zuweisung an diesen ändert das Verhalten so dass dann im Fehlerfall automatisch Exceptions aufgeworfen werden. Wenn man die Scheme-Quelltexte der beliebten "slib"-Quelltextsammlung mit Bibliotheksfunktionen installiert haben sollte, können "einige" davon möglicherweise auch unter TinyScheme funktionieren. Für die geringe Größe ist TinyScheme insgesamt zwar recht beeindruckend, durch die schwache Abdeckung der Scheme-Standardbibliothek muss man aber vieles selbst implementieren oder dazu kopieren. Andererseits, wenn man es nur als nächste Eskalationsstufe nach AWK sieht um eine mächtigere Programmiersprache zur Verfügung zu haben bevor man zu den wirklich großen Scriptsprachen wie Perl, Python oder Ruby greift, könnte es durchaus nützlich sein. Ein weiteres Argument ist der Umstand, dass die aktuelle Version (Stand 2021) des gesamten Quelltextarchivs inklusive Handbuch gerade mal 61 kB beträgt. Zum Bauen wird nur ein C-Compiler benötigt. Es stellt daher anders als bei vielen anderen Sprachen kein Problem dar, wenn dieses Paket nicht von der Distribution bereit gestellt wird, da man es bei Bedarf jederzeit einfachst selbst bauen und installieren kann. Ein Nachteil ist dass es nur ein Interpreter ist - einen Compiler darf man bei dieser Größe auch nicht erwarten. TinyScheme lässt sich auch als Erweiterungssprache in eigene Anwendungen einbauen und bietet entsprechende APIs dafür an. Umgekehrt gibt es auch einen bereits integrierten Scheme-Befehl zum Laden von Erweiterungs-DLLs/.so-Dateien in den laufenden Interpreter. Dies sollte man auch dringend benutzen, um den fehlenden Support für folgendes Essenzielles zu implementieren: stderr, EXIT_FAILURE sowie fflush(). Sowie bei Bedarf auch: bitwise- und shift-Operatoren, fork/exec/wait, popen. Leider gehört auch TinyScheme zu den vielen C-Programmen, deren Autoren sich kaum je dazu herab lassen die Status-Rückgabecodes von I/O-Funktionen zu prüfen. Insbesondere beim Schreiben auf die Standardausgabe gibt es keinerlei solcher Prüfungen, und daher auch keine Exceptions in solch einem Fall. Vermutlich wäre es kein großer Aufwand die entsprechenden Checks dem Source-Code selbst hinzu zu fügen - allerdings hilft das *diesem* bereits fertig gebauten Binärpaket für eine Installation natürlich nichts.
tkcvs-8.2.3-1.2/vcs/raspbian {text-diff}{character-diff}{dir-diff}{no-soft-line-wrap}{text-merge}: Ein in "Tk" verfasstes grafisches Programm zum 2- oder 3-Way-Mergen (und natürlich auch -Vergleich). Es unterstützt auch mehrere Versionskontrollsysteme nativ, die relevantesten davon sind Git, Mercurial, CVS und RCS. Unter Debian wird es als Ersatz für "tkdiff" verwendet, welches dort nicht zur Verfügung steht. Eine Besonderheit ist, dass es mit Konfliktmarkern (etwa vom Programm "merge", aber auch Git kann solche Marker erzeugen) versehene Textdateien öffnen kann, um die Konflikte dann visuell zu beheben. Die vollständige Offline-Hilfe ist im GUI anzeigbar. Die Vergleichsanzeige ist intuitiv und nicht überladen. Der Vergleich erfolgt zeilenweise und neben einander. Optional können innerhalb der Zeilen die Unterschiede auf Zeichen-Ebene angezeigt werden. Das Programm beherrscht dabei zwar keinen weichen Wortumbruch wie kdiff3, kann aber die Zeilen zumindest am letzten Zeichen für die Anzeige umbrechen, wodurch man - wenn auch weniger hübsch - dennoch auch in überlangen Zeilen alle Änderungen sehen kann. Es handelt sich um eine vergleichsweise kleine Installation mit nur rund 350 kB Download - allerdings vorausgesehen, dass Tcl/Tk bereits installiert ist auf dem es aufbaut. Auf der Ebene einzelner Dateien ist das Programm durchaus mit kdiff3 vergleichbar, allerdings tkcvs die Fähigkeit zum Vergleich ganzer Dateibäume. Dafür kann man aber das Programm "dirdiff" installieren, welches "tkvcs" als externes Diff/Merge-Programm unterstützt. Kombiniert können die beiden Programme kdiff3 dann nahezu vollständig ersetzen. Update 2025: Tatsächlich scheint tkcvs eine geringfügig ältere Version von "dirdiff" mitzuliefern. Die Unterschiede sind sehr gering. Auf der anderen Seite ist "dirdiff" eine derart kleine Installation, dass einem die (bislang einzige) zusätzliche Funktion "Show files that aren't in some dirs" vielleicht die weniger als 200 kB einer zusätzlichen Installation wert sein könnten. Diese Option bezieht den Inhalt fehlender Unterverzeichnisse in die Anzeige ein; andernfalls wird nur das Verzeichnis selbst als fehlend dargestellt. Eine eher entbehrliche Option.
tkremind-03.01.15-1+b1/utils/devuan {PIM}{reminder}: A Tk-based GUI für "remind".
tmux-2.1/app-misc/gentoo {KVM sharing}{text-terminal IO}: Terminal multiplexer. Does mostly the same as "GNU screen". It has some advantages over GNU screen such as a permanently visible status line (which can be disabled) showing the existing windows, and being able to split windows into panes horizontally as well as vertically. By default, tmux uses quite different key bindings than GNU screen, but the package includes an alternative configuration file that binds most of tmux' keys to the same functions GNU screen does. Tmux can generally be customized with some effort to use the same key bindings as GNU screen, acting mostly as a "screen" substitute then. It is also possible to run multiple nested tmux servers, each one using a different command key. However, this is more complicated than in "screen" where a simple -e option is available for that purpose. In tmux, a script should be used to re-map the command key after the nested server has been started. Also, different windows can be split using a different layout. In contrast, GNU screen allows only vertical splitting of the terminal area, and the different windows can be placed into the panes which are global to the session. However, besides of that GNU screen has many special-purpose features tmux has not. A problem is that tmux somehow consumes the key bindings for ctrl+cursor-keys which some applications (read: the joe editor) use within X11 terminal emulators for extending their current block selection. Setting "set-window-option -g xterm-keys on" is needed to fix this. An advantage of tmux is that it has multiple named paste buffers, where GNU screen only has numbered "registers". And even better, tmux can (supposedly) have multiple instances of the same scrollback buffer displayed in different panes, where every instance retains its individual scroll position within the buffer. However, I also noticed the disadvantage that tmux' internal buffers such as when displaying the key bindings in a pane disable most normal key bindings. Maybe this is an issue just needing more configuration, but it certainly sucks for a newbie. A problem tmux shares with "screen" is that fullscreen programs only represent a single screen-height section in the scrollback buffer, and older contents are replaced by newer contents in the buffer while the program runs and continuously updates its textscreen image. So generally, only the last screen-full displayed remains in the scrollback buffer once the program exits. And even worse, programs like Midnight Commander which save the screen contents when starting and restore it on exit, leave no trace at all in the scrollback buffer. It is only possible to copy/paste data via the scrollback buffer while the fullscreen program is still running. Tmux has a smaller memory footprint than GNU screen. But it lacks the multiuser features of GNU screen, its serial terminal capabilities or window transcripts, and nesting tmux instances is more work. On the upside, it is easier to send commands to a tmux session from the outside, i. e. via a script. This allows to populate sessions via scripts, instead of just manually. Also, only a tmux server-instance can manage multiple "sessions" (similar to workspaces in a GUI), also allowing selected windows to be shared between sessions. GNU screen uses a strict one server per session policy. tmux has also a command to send text as input to a window/pane. This could be used to remotely control interactive terminal applications in simple cases. tmux depends on a UTF-8 locale. As a minimum, LANG=C.UTF-8 or LANG=POSIX.UTF-8 needs to be set. LANG=POSIX does not suffice for tmux. Like GNU screen, the tmux front-end command uses temporary UNIX domain sockets in order to communicate with its background process. But other than GNU screen, tmux is able to recreate those sockets if they got accidentally deleted by sending a signal to the background process. On the other hand, the contents of a logical tmux window are more susceptible for getting stuck because of random byte values being sent to the console, which frequently happens when binary data is output by mistake. Also, the window title gets frequently messed up for the same reason. Those things GNU screen does better. One small advantage of tmux is that it ships as part of the base installation of NetBSD, but GNU screen doesn't.
tok64-1.4/app-emulation/gentoo: Kann tokenisierte Commodore-64 BASIC Programme in Reintext-Listings umwandeln, und auch wieder zurück. Spezielle Steuerzeichen werden durch Spezialausdrücke wie "{right}" ersetzt. Im Prinzip eine tolle Sache, jedoch hat das Programm einen Haken: Es ist ziemlich zimperlich und weigert sich "unsaubere" BASIC-Zeilen, wie etwa wenn das abschließende doppelte Anführungszeichen einer String-Konstante am Ende einer Zeile fehlt, in Klartext zu übersetzen. Dann druckt es eine Warnung und lässt die entsprechenden Zeilen aus. Das Programm ist daher nur bedingt brauchbar! Wenn es rein um Ausgabe geht, ist es zielführender im x64-Emulator die Drucker-Funktion zu aktivieren und das Listing mit BASIC-Bordmitteln in die x64-Capture-Datei auszudrucken. Die Steuerzeichen muss man dann zwar selbst konvertieren, aber zumindest fehlt nichts. Auf der anderen Seite enthalten natürlich nicht alle BASIC-Programme "unsaubere" Zeilen. Mit *meiner* damaligen Methode BASIC mit allen Tricks zu programmieren kam ich mit tok64 aber jedenfalls nicht sehr weit.
tokyocabinet-1.4.47/dev-db/gentoo {key/value store}: Ein Key/Value-Store in der Tradition von dbm. LGPL. Obsolet geworden durch dev-db/kyotocabinet. Allerdings gibt es von tokyocabinet schon "stable" Versionen in Portage, während kyotocabinet noch "testing only" ist.
tomboy-ng-0.36a-2/x11/raspbian: Eine in FreePASCAL implementierte Notiz-Anwendung. Es handelt sich offenbar um den Versuch, das in C# geschriebene Original durch eine linux-freundlichere Alternative zu ersetzen. tomboy-ng speichert seine Notizen in einem privaten Verzeichnis als Textdateien in einem XML-Format mit UUIDs als Dateinamen. Händisches Bearbeiten ist daher theoretisch möglich, praktisch sollte man besser die Finger davon lassen. Normalerweise kommt man mit diesen Dateien auch nie in Berührung, sondern sie stehen innerhalb des Programms einfach zur Verfügung, ähnlich wie in einem Mailprogramm. Allerdings gibt es eine Export-Funktion, welche sich Notizen als RTF, Reintext, Markdown oder PDF exportieren lassen. Import-Funktion für die Gegenrichtung fand ich allerdings keine. Der Editor ist grundsätzlich ein Rich-Text-Editor mit WYSIWYG; es kommt keine Wiki-artige Markup-Sprache zum Einsatz. Für Neulinge ist dies vermutlich einfacher zu benutzen. Richtige interne Hyperlinks wie in gnote scheint das Programm aber nicht zu beherrschen (oder ich fand sie lediglich nicht). Aber es gibt zumindest eine Funktion wo man einen Text selektiert, und damit eine neue Notiz mit dem markierten Text als Vorgabe für seinen Titel zu erzeugen. Grundsätzlich erstellt man mit dem Programm neue Notizen oder sieht sich bestende an. Das Programm zeigt normalerweise kein eigenes Fenster an, sondern wird über sein Symbol im Traybar bedient. Dort kann man die letzten Notizen auch direkt auswählen, ohne ein Auswahl-Menü bemühen zu müssen. Neue Notizen haben automatisch eine Überschrift welche Datum und Zeit enthält, und diese Überschrift wird dann auch im Kontextmenü des Traybar-Icons als Menüpunkt zum Öffnen der Notiz angezeigt. Man kann die Überschrift allerdings beliebig verändern. Man kann seine Notizen in "Notebooks" organisieren, damit keines davon zu viele Einträge bekommt. Weiters man man alle Notizen durchsuchen lassen. Ein Nachteil gegen über gnote ist dass das Programm nur mit einer englischen Bedienungsoberfläche ausgestattet ist. Bei gnote kann man zwischen mehreren Sprachen auswählen, darunter auch Deutsch. Eine der Gründe für die Popularität des ansonsten eher unspektakulären Programms dürften seine Synchronisierungs-Features sein. Denn es kann die XML-Dateien mit einem Server synchronisieren, wobei verschiedene Möglichkeiten geboten werden: Mittels git (setzt einen GitHub-Account voraus) oder über einen Ordner im lokalen Dateisystem. Dieser Ordner kann aber auch ein gemountetes Netzwerk-Dateisystem wie sshfs sein oder durch DropBox oder Syncthing und ähnliche Programme automatisch synchronisiert werden. Indirekt ist das ganze daher auch netzwerktauglich, und die Konfiguration in tomboy ist simpel da man nicht viel mehr tun muss als einen Ordner anzugeben. Zufällige Namenskollisionen beim Synchronisieren sind durch die UUID-basierten Dateinamen praktisch unmöglich, so dass auf der Ebene von drobox/ssh keine Konflikte zu erwarten sind. Allerdings kann es sehr wohl innerhalb derselben Notiz zu einem Konflikt kommen, wenn diese auf unterschiedlichen Geräten bearbeitet und jeweils mit dem Server synchronisiert wurde. Dabei bietet das Programm exakt 3 sehr simple Strategien für eine Konfliktbewältigung an: 1.) Die lokale Notiz überschreibt immer die am Server falls beide verändert wurden. 2.) Die Kopie vom Server wird genommen, jedoch eine umbenannte Kopie der lokalen Notiz angelegt. 3.) Man wird bei jedem Konflikt gefragt welche der Strategien verwendet werden soll (Dies ist die Voreinstellung.) Die eigentliche Synchronisation kann dann wahlweise per Hand ausgelöst oder automatisch (einmal pro Stunde) vorgenommen werden. Die Synchronisation von Notizen zwischen tomboy und gnotes funktioniert "out of the box" ohne spezielle Vorbereitungen. Es gibt keinerlei Verschlüsselung bei der Synchronisation. Diese muss das verwendete Netzwerkdateisystem oder das zugrundeliegende Dateiübertragungs-Tool bereit stellen. Download 1,5 MB, 90 MB RAM-Verbrauch, 52 MB PSS, 346 MB virtuell. Fazit: Obwohl das Programm grundsätzlich tut was es soll, ist es in den meisten Detailfeatures dennoch dem Programm gnote unterlegen. Sehr groß ist der Unterschied aber nicht; die Kernfunktionalitäten und das Datenformat sind identisch.
torcs-1.3.0/games-sports/gentoo {game}: Nett gemachtes 3D Autorennen; die Grafik erreicht durchaus 1/2 bis 2/3 der Qualität eines kommerziellen Rennspiels. Mit rund 300 MB Installationsgröße allerdings auch nicht gerade speicherplatzschonend.
torque-4.1.5.1-r1/sys-cluster/gentoo {service manager}: Eine Implementation von OpenPBS, einem portablen Batch-Job System. Man kann Jobs zur späteren Ausführung in verschiedene Warteschlangen einreihen, zwischen diesen verschieben usw. Das funktioniert auch über Rechner-Grenzen hinweg, so dass man Jobs in einem Cluster organisieren kann. Für Jobs können Ressourcen bzw. Abhängigkeiten definiert werden so dass der Job erst startet nachdem diese erfüllt wurden. So eine Abhängigkeit können nicht nur andere Jobs sein, sondern auch Zeitpunkte. Sprich, PBS kann auch den "at"-Dienst ersetzen, jedoch leider nicht kompatibel mit dem at-Kommando. Das Problem dieses sicherlich sehr tollen Systems mit unzähligen Features ist dass es einen permanent laufenden Server zu benötigen scheint um die Jobs abzuarbeiten und zu verwalten, auch wenn man keine zeitgetriggerten Jobs benötigt. Für simple pro-User Jobs die einfach nur gequeued werden sollen ist es daher ein Overkill, und mit 7 MiB Installationsumfang auch nicht besonders schlank.
torus-trooper-0.22.dfsg1-11+b1/games/devuan {game}: Ein rasend schnelles Drahtgitter-Ballerspiel. Man rast durch einen Vektorgrafiktunnel (farbiges Drahtgitter, nicht gefüllt), dreht sich dabei wie wild an dessen Wänden herum, ballert mit Drahtgitter-Projektilen auf Drahtgitter Feinde und weicht deren Schüssen aus. Alles grundsätzlich nett, aber für meinen Geschmack fliegt zu viel Zeug in der Gegend herum - ich werde andauernd getroffen. Echte Vektorgrafik (anders als "Vectoroids") - skaliert problemlos auf jede Bildschirmauflösung. Ca. 8 MB Installationsumfang.
trac/www-apps/gentoo {wiki}{text-formatting}: Small, Python-written project management Wiki. Optionally supports Subversion for online source code browsing. Actually, trac is one of the most prominent Web-Interfaces for Subversion. Can be run as CGI or FastCGI from a web server, or as stand-alone. Really quick and easy to setup! The managed data will be stored in PostgreSQL, SQLite or MySQL databases. As usual, SQLite requires no separate server and zero-administration effort.
trackballs/debian: Does not support OpenGL ES, so does not work on RasPi.
trackballs/games-action/gentoo {game}: Marble-Madness ähnliches, nett gemachtes Spiel. Die Kugel muss innerhalb des Zeitlimits um alle möglichen Gefahren herum zum Ziel in der Landschaft gerollt werden, ohne in den Abgrund zu stürzen.
tracker 1.6.1-3/extra/archlinux {audio}{music}: Ein Front End für "libtracker-sparql", das leider von nicht weniger als 32 anderen Paketen abhängt, darunter der bei mir "geliebte" NetworkManager. Das Problem dieses Pakets ist es, dass es sich als komplette Indizierungs- und Such-Lösung für Desktop-Metadaten aller Art versteht, und nicht nur als anwendungsneutrales Datenbank-Abfrageinterface wie ich es gerne hätte. Ich habe das Paket nie installiert, da ich am N900 schon eine (wesentlich ältere) "tracker"-Version erlebt habe, die mich mit ihrem ständigen Indizierungswahn der sich nicht gezielt einschränken ließ halb in den Irrsinn getrieben hat.
trailblazer/games-arcade/gentoo {game}: Ball rollt auf 3D-Weg entlang gerade aus in Richtung den Bildschirm herein, kann dabei nur links und rechts ausweichen oder hüpfen. Der Weg ist dabei in Streifen und Abschnitte verschiedener Farbe unterteilt welche Effekte wie Bremsen oder Beschleunigen haben, oder er enthält Löcher durch die man in die Tiefe stürzt. Ein alter C-64 Klassiker. Leider extrem schlicht gemacht, und mit einer fix codierten Steuerung die nur für englische Tastaturen sinnvoll ist. Weiters fixe Fensterauflösung und kein Full-Screen Mode. (Wieder mal xrandr.) Nicht direkt schlecht oder häßlich, aber sehr schmucklos und ein Patch für die Tastenbelegung scheint dringend nötig. Dafür ist das Programm mit 100 KB Installationsumfang lächerlich kurz für heutige Verhältnisse.
trayer-1.0/x11-misc/gentoo {desktop panel}: Der aus fbpanel extrahierte Traybar-Support für Leute die den Rest von fbpanel nicht brauchen. Funktional durchaus brauchbar, jedoch leider (genau wie fbpanel) abhängig von den GTK+ Libraries. Dadurch hat das Executable selbst zwar nur 60 KiB und das gesamte Paket keine 350 KiB, jedoch kommt das fette GTK+ als Abhängigkeit dazu. Daher scheint mir x11-misc/stalonetray sinnvoller als diese Applikation zu sein, außer man hat ohnehin GTK+ installiert.
tre-agrep-0.8.0-6/text/devuan: Das ist eine erweiterte Methode von "agrep" zur Ähnlichkeitssuche, die mehr Möglichkeiten bietet, linear skaliert, und UNICODE voll unterstützt. Wie "agrep" unterstützt es ebenfalls nicht die -R Option von grep, dafür aber zusätzliche Optionen für Fuzzy-Search. Obwohl das Programm sehr mächtig bezüglich der Suche mit Fehlern ist, zeigt sich dennoch dass es völlig unfähig ist etwa bei Directory-Listings vom umbenannten Filmdateien. Es findet keinen Zusammenhang im Namen zwischen Original und umbenanntem Titel, obwohl ein großer Namensteil völlig identisch ist. recoll findet etwa deutlich mehr.
treewm-0.4.5/x11-wm/gentoo {window manager}{GUI}{X11}: Could not start up due to some font not found
trimage-1.0.5-1/graphics/debian: Ein sehr simples im Python/Qt implementiertes Tool für verlustlose Bild-Optimierung. "Optimierung" soll dabei bedeuten: Kleinere Dateigrößen. Das wird durch Optimierung der Huffman-Codierung und ähnlicher Tricks erreicht. Das GUI ist Qt-hübsch, aber extrem minimalistisch: Ein Fenster in welches man JPEG sowie PNG-Dateien ziehen kann, und ein Button um diese dann zu optimieren. Immerhin wird noch die vorher-nachher-Größe angezeigt. Das Programm selbst ist nur ein Front-End für die folgenden Kommandozeilen-Programme, welche die Arbeit tatsächlich durchführen: advpng, jpegoptim und optipng.
tsocks/net-proxy/gentoo: Eine DLL und ein zugehöriges Script zum "Socksifizieren" des Socket-APIs der libc. Damit kann man dann durch einen SOCKs Server tunneln. Nachteil: Unterstützt nicht bzw. nur sehr unzureichend DNS-Auflösung durch den SOCKs-Server. Daher vor allem nur für solche externen Adressen verwendbar, die einen /etc/hosts-Eintrag haben.
ttmkfdir/x11-apps/gentoo: Creates fonts.scale files for TrueType fonts, just as mkfontscale does. However, it has better recognition of the original font names (it honors upper case characters in font names).
tumbler-0.1.23/xfce-extra/gentoo: Ein "Thumbnailer" für Thunar. Wenn dieses Paket installiert ist, kann Thunar von wesentlich mehr Dateitypen Vorschaubilder anzeigen als wenn dies nicht der Fall ist. So kann es etwa ein Bild vom Anfangsbereich der meisten Videodateien als Vorschaubild extrahieren. Ohne tumbler wird nur eine Filmspule angezeigt.
tuxcmd-0.6.70+dfsg-1/utils/debian {file manager}{GUI}{X11}: Wäre eigentlich ein ganz passabler TotalCommander-Klon, wären da nicht ein paar Kleinigkeiten die seine Benutzung unkomfortabel machen. Erstens ignoriert er die opendesktop.org-Standard zur Verknüpfung von Dateitypen mit Aktionen mehr oder weniger komplett - er hat zwar einen Ersatz dafür nachprogrammiert, jedoch muss man hier manuell nachbilden was andere Dateimanager einfach aus den installierten Desktop-Infodateien extrahieren. Zweitens treibt er das Konzept der Tastaturbedienbarkeit zu weit - man kann beispielsweise nicht einmal mit Drag und Drop Dateien kopieren, sondern muss dazu allen ernstes auf den F5 Button in der Symbolleiste klicken. Obwohl das Programm schlank ist und aufgeräumt wirkt, ist es darüber hinaus ärgerlich dass es nicht das Feature der meisten Konkurrenten beherrscht, Zeilen abwechselnd einzufärben so dass man leicht erkennen kann welche Angaben in den Spalten zur selben Zeile gehören. Alles zusammen ein Programm das es zwar fast geschafft hat eine brauchbare leichtgewichtige Alternative für den Krusader zu sein, aber eben nicht wirklich. Das Programm ist in PASCAL geschrieben, wie so viele "Commander"-Versionen. Allerdings ist die FreePASCAL-Runtime schlank.
tuxcmd-0.6.70/app-misc/sabayon/gentoo {file manager}{GTK+}: A two-panel file manager obviously trying to imitate the TotalCommander (TC) tool for Microsoft Windows just like krusader does. Tuxcmd is written in PASCAL and only replicates the most basic features of TC, while krusader is written in C++ and much more feature-complete. Tuxcmd is way leaner than krusader (more than a factor of 3 including dependencies) and depends only on GTK+ libraries rather than the KDE libraries like krusader does. Tuxcmd also starts much more quicker than krusader. Tux provides the same function-key commands as TC, but the mouse can only be used to select files (but not multiple files) and optionally rename them, but not for any other operations. For those, the function keys need to be used. Selecting multiple files also requires the keyboard. Multipe tabs are supported for both window panes. There is no support for alternating the background color of odd and even entry lines in the file list panes. There is only a single tabular display mode with one entry per line. The attributes to be displayed in columns can be selected and reordered freely from a fixed list of available attributes. The name extension can be displayed as part of the entry name or as a separate column. Permissions can be shown in text form or octal. Date/time formats can be defined freely. For file size formatting a few alternatives are available, one of them being dynamically chosen base units (Kb, MB, GB etc.). Bookmarks for frequently-used directories are supported. Separate buttons for each window pane are available for the following functions: Set other panel to same directory, go to filesystem root, go to parent directory, go to home directory, display bookmarks. A command line is visible and a "create terminal here" button is available. There are specific commands for copying the base name or the whole path of the selected file into the clipboard. This also works if multiple files or directories are selected, and copies actual (path) names and not just file:// URLs. Showing hidden files is can be enabled. The cumulative size of files in a subdirectory tree can be calculated. Sort order can be changed by clicking on column headers, and it is selectable whether directories sort like files or always alphabetically. However, directories are always displayed before files. A "mount bar" can be displayed for easily mounting and unmounting devices, but it is pretty useless if many devices are available because it tries to display then all as buttons in a single horizontal line. A few more specialized commands are available: Split files into chunks or recombine them, create or verify checksums (SFV or MD5). Owner and permissions can be edited and optionally recursively applied. In the case case, replacing the permissions can be restricted to files only, directories only or both. There is no way of "blending" permissions - they are either replaced or not modified at all. Group selections require use of the keys on the numeric pad which might be a problem on notebook keyboards - in this case then menu has to be used. A medium-powerful search dialog is available which can find files based on file name, size range, date range and contents. Tuxcmd features an optional internal viewer, but it is very primitive and configuring an external viewer might be a good idea. The editor must always be an external tool. There is a powerful feature to create relative as well as absolute symlinks, and symlinks can even be edited. Tuxcmd supported plugins, and plugins for accessing archive files (unrar and as supported by libarchive - read-only support so far) and GVFS virtual filesystem URIs are included. GUI dialogs for configuring and storing GVFS connections are also included. GVFS-support allows TuxCmd to access at least SSH, FTP, SAMBA and Bluetooth devices seamlessly; see a description of gnome-base/gvfs for a complete list of protocols. TuxCmd does not support freedesktop.org standards for associating file types with applications but rather provides its own mappings. However, creating associations is easy as a GUI dialog is available for this. Summing up, TuxCmd ist not particularly powerful as a whole, but the things it can do it can do well. It is clearly targetted for keyboard operation and well suited for this. It mostly uses the same keyboard combinations as TC and TC users can work with it right away for most operations. TuxCmd excels at creating and editing symlinks.
tuxmath/games-kids/gentoo {game}: So ähnlich wie "Missile Command" - nur schießt man als Pinguin nicht auf die angreifenden Raketen, sondern wird von Grundrechenaufgaben angegriffen! Deren Lösung man eintippen muss bevor man getroffen wird, was dann einen Vernichtungsschuß auf die Rakete auslöst. Gar nicht so schlecht.
tuxpaint-0.9.21/media-gfx/gentoo {bitmap image editor}: Ein sehr einfach zu bedienendes Zeichenprogramm, das zwar sehr bedienungsfreundlich ist, aber absolut nichts nützliches kann. Zumindest nichts was man für die Bildnachbearbeitung gebrauchen könnte. Es kann weder zoomen noch drehen - nicht einmal in 90 Grad Schritten. Ausschneiden und Kopieren - ebenfalls Fehlanzeige. Man kann das Fenster nicht einmal auf Vollbildgröße vergrößern oder sich die Größe der "Leinwand" aussuchen. Dafür macht es aber "ulkige Geräusche" während man etwas mit den diversen eigenartigen Grafiktools ("Tornado", "Pinguine zeichnen", "Regen", "Schnee" etc) vor sich hin zeichnet. Ganz offensichtlich ist das ein Spaßprogramm für Volksschulkinder, da es mit deren Malanforderungen wohl gut korrespondieren dürfte. Es ist somit ein für jüngere Kids sicher geeignetes Programm, aber für Erwachsene (vor dem Erreichen der Senilität) völlig unbrauchbar. Ausser vielleicht zur Entspannung, wenn man dem Hirn mal eine "Auszeit" gönnen will.
twm-1.0.4/x11-wm/gentoo {window manager}{GUI}{X11}: This is the only X11 window manager which is actually a little bit smaller than jwm. However, it is really ridiculously restricted and can do nearly nothing. Its default settings are completely nuts; with a lot of changes in the configuration files it is possible to tame that beast to a degree where painful working is at least possible. If jwm is recompiled to exclude its various image formats and optional components, however, then jwm is only nearly half as large as twm! Therefore, just forget twm: If memory footprint is a concern, a minimal jwm is smaller and still much more comfortable to use.
txt2man-1.6.0-1/text/devuan {text-formatting}: Erzeugt aus speziell formatierten ASCII-Dateien nroff/troff-Quelltextdateien für "man"-Pages. Die Eingabedateien sehen dabei bereits sehr ähnlich wie die späteren Ausgabedateien aus, inklusive der üblichen Abschnitts-Überschriften. Die Syntax ist stark Einrückungs-basiert, eigentlich fast schon Tabellen. Mir kommt das sehr unbequem zum Editieren in einem Editor vor. Wie soll man etwa in einer Tabellenspalte Text neu umbrechen falls dies erforderlich wird? (Der "joe" kann es mit Mühe im kombinierten "Column"+"Picture"-Mode, aber damit dürfte er eine Minderheit darstellen.) Im Grunde fragt man sich was das Programm überhaupt noch machen soll außer den Text neu umbrechen und die Section-Titel einfärben. Meiner Ansicht nach ist dieses Programm ziemlich überflüssig denn es gibt bequemere Methoden "man"-Pages zu generieren, wie etwa mittels asciidoc.
txt2tags-3.9-1/text/raspbian {text-formatting}: Txt2tags is a document generator written in Python. It reads a text file with minimal markup such as "**bold**" and "//italic//" and converts it to the following formats: AsciiDoc, Creole 1.0, DocBook, DokuWiki, Google Wiki, HTML, LaTeX, Lout, MagicPoint, Markdown, MoinMoin, PmWiki, Plain Text, SGML, UNIX Manpage, Wikipedia/MediaWiki. 
txtreader-0.6.5-1/text/raspbian: Ein schlankes und schlichtes GUI-Programm zum Anzeigen vom Textdateien. Per Default sind alle Menütexte in chinesisch, aber das lässt sich gottlob einfach auf Englisch umstellen. Er kennt Bookmarks und hat einen Full-Screen-Modus. Leider kann er Texte nur am Fensterrand umbrechen und nicht an Wortgrenzen - bei Chinesen vermutlich keine Erfordernis. Wäre daher vielleicht grundsätzlich nett, ist aber für westliche Belange wohl eher zum Vergessen.
udevil-0.4.4-2/utils/debian: Erlaubt normalen Benutzern ohne Passworteingabe beliebige Dateisysteme zu mounten. Ein direkter Konkurrent von pmount. udevil ist ein SUID/GUID-Programm und bietet weitaus mehr Konfigurations-Optionen als pmount. Konkret unterstützt es beliebige Dateisysteme und ist auch nicht auf Wechseldatenträger beschränkt. Der Nachteil ist dass man diese zahlreichen Konfigurationsoptionen daher auch studieren muss. Der Zugriff auf udevil ist zum einen dadurch eingeschränkt, dass die Benutzer Mitglieder der Gruppe "plugdev" sein müssen. Allerdings ist das Debian-spezifisch. Zum anderen gibt es viele Regeln die man in den Konfigurationsdateien dazu benutzen kann um zu regeln, welche User und Gruppen auf was für Dateigeräte auf welchen Geräten mounten dürfen. Anders als pmount unterstützt udevil kein LUKS bzw. cryptsetup. Eben so wenig gibt es eine Funktion zum Sperren des Datenträgers. Die 2025-Version unter Debian des Programms kann "Out Of The Box" kein ExFAT mounten, da es veraltete FUSE-Optionen verwendet.
udhcpd-1: 1.22.0-9+deb8u1/net/devuan: A lightweight DHCP server, using the BusyBox implementation of a DHCP server. This implementation has one big problem, though: As of 2017, the Busybox implementation has an annoying bug, making it listen on all interfaces for DHCP requests - not just on the specified interface. This makes it inappropriate for boxes which are connected to more than a single network, such boxes connected to a LAN and to the Internet, because it would serve DHCP requests from the Internet too, and not just from the LAN. I hope this will eventually be fixed, because udhcpd works fine otherwise.
uim-1.8.6-r1/app-i18n/gentoo: Ein "Input-Method"-Framework, das komplett in C und Scheme geschrieben ist und keine Client-/Server-Architektur aufweist für die man irgendwelche Dienste starten müsste. Das Framework stellt Möglichkeiten zur Verfügung, weitaus mehr Zeichen eingeben zu können als die aktuelle Tastaturbelegung unterstützt. Bei asiatischen Sprachen ist es ein "Muss", aber auch bei der Eingabe westlicher Sonderzeichen die nicht auf jeder Tastaturbelegung verfügbar sind kann uim Verwendet werden. Der intern verwendete Scheme-Interpreter (oder Compiler?) ist im "C"-Executable enthalten und erfordert keine zusätzlichen Laufzeit-Bibliotheken. Im Gegensatz zu anderen ähnlichen Frameworks wie IBUS benötigt uim auch keine zusätzlichen Scriptsprachen wie Python. User-Interfaces werden für Qt, GTK+, Native X11 (via "XIM") und die Konsole zur Verfügung gestellt.
ultracopier-0.2.0.15/sys-apps/gentoo: Eine Cross-Platform Traybar-Applikation, welche es erlaubt zu kopierende oder verschiebende Dateien und Verzeichnisse zu einer Jobliste hinzu zu fügen, welche dann abgearbeitet wird. Dabei kann man zahlreiche Optionen einstellen wie Multithreading, Preallokation, Priorität, Durchsatz-Drosselung, ob Datum und Rechte mitkopiert werden sollen usw. Im wesentlichen für Command-Line unerfahrene Benutzer gedacht, denen überdies keine anderen Dateimanager zur Vefügung stehen welche Joblisten abarbeiten können, die aber ein beträchtliches Kopiervolumen zu erledigen haben. Während des Kopiervorganges können angeblich auch Statistiken angezeigt werden. Ich für meinen Teil begriff einfach nicht wie man das Ding bedient und konnte keine einzige Datei damit kopieren. Oder vielleicht funktionierte es auch nur nicht. Aber trotz toller GUI-Dialoge tat sich nie etwas, so dass ich es schließlich aufgab und das Ding wieder deinstallierte.
umbrello-3.5.5/kde-base/gentoo: Netter UML-Modeller, kann C++ importieren/exportieren, leider völlig sinnlos wie das ganze UML an sich.
unac-1.8.0/app-text/gentoo: Kann Azente von Zeichen entfernen, und Ligaturen in Einzelzeichen umwandeln. Arbeitet auf der Basis von UNICODE-Text. Hilfreich als optionaler Präprozessing-Schritt bei der Textsuche.
unionfs-fuse-1.0-1+b1/misc/debian {FUSE}: Ein nettes Overlay-Dateisystem wie aufs oder unionfs, aber es benötigt keinerlei Kernel-Support dafür und läuft daher auf nahezu jedem Linux. Man kann beliebig viele lesbare und beschreibbare sowie nur-lesbare beim Mounten angeben, und all diese Verzeichnisse werden dann virtuell zu einem einzelnen zusammen kombiniert in dem man arbeiten kann. Man kann beim Mounten auch eigentlich schreibbare Verzeichnisse als nur-lesbar deklarieren, womit sich dieses Dateisystem auch zum Erzeugen von nur-lesbar-Sichten des Dateisystems missbrauchen lässt. In welches Verzeichnis dabei tatsächlich geschrieben wird, bestimmt normalerweise das Unterverzeichnis in dem man sich gerade befindet. Wenn dieses als read-only definiert wurde, kann man aber mit einer 2. Option bestimmen, dass Schreibzugriffe in einen anderen der Verzeichnisbäume ungelenkt werden (d. h. die Datei wird dorthin kopiert). Ähnlich wie "aufs" legt unionfs "whiteout"-Dateien an um Löschungen in nur-lesbaren Verzeichnissen zu simulieren, diese werden in .unionfs-Unterverzeichnissen angelegt. Es gibt jedoch eine Mount-Option, um all jene unsichtbaren Datenen auch tatsächlich zu verstecken, statt ihnen nur normalerweise nicht angezeigte Dateinamen zu geben. Trotz aller Beschränkungen kann dieses Dateisystem sehr nützlich sein, insbesondere wenn der Benutzer über keine Rechte verfügt das mächtigere kernelbasierte "aufs" zu mounten, oder das verwendete Kernel kein "aufs" (oder "overlayfs") anbietet.
unionfs/sys-fs/gentoo: Overlay von mehreren gemounteten Dateisystemen zu einem kombinierten virtuellen. Kernel-spezifische Patches vonnöten. Auch nicht sonderlich stabil.
unison-2.52+1/utils/raspbian {dirtree sync}: Das wahrscheinlich beste Programm zum bidirektionalen Synchronisieren von Verzeichnissen unter Linux. Kann sowohl zwei lokale Verzeichnisbäume synchronisieren, oder einen lokalen Baum via SSH mit dem auf einem anderen Rechner. Insbesondere können im Gegensatz zu vielen anderen Programme auch die Zugriffsrechte verglichen und synchronisiert werden. Besonders mächtig ist die Unterstützung von Symlinks, denen individuell festlegbar wahlweise gefolgt oder direkt als Symlinks synchronisiert werden kann. In der Anleitung nicht erwähnt (und daher vermutlich auch nicht vorhanden) ist die Unterstützung der Synchronisierung von Hardlinks, Extended Attributes, ACLs, Sparse Files sowie Dateisystem-basierte Kompression bzw. Verschlüsselung. Normalerweise legt man für jede Synchronisations-Quelle/-Ziel eine eine Profildatei an, welche alle Einstellungen und Angaben für dieses Quelle/Ziel enthält. Wenn es bei der Synchronisation Konflikte gibt, werden diese interaktiv aufgelöst. Es können sogar Text-"diffs" zur Entscheidungsfindung angezeigt werden. Grundsätzlich funktioniert Unison sehr gut. Allerdings hat dieses in OCaml geschriebene Programm ein sehr großes Problem: Es existieren unverschiedliche Revisionen davon, die nicht mit einander kompatibel sind. Man muss daher sicher stellen, dass auf allen beteiligten Remote-Rechnern Unison-Versionen installiert sind, welche exakt dieselbe Protokoll-Version verwenden. Sonst versagt die Synchronisierung. Daher stehen oft mehrere Versionen dieses Programms zur Installation zur Verfügung, in der Hoffnung dass zumindest eine der Versionen auf allen verwendeten Rechnern installierbar ist. Möglicherweise lassen sich diese Versionsprobleme aber dadurch vermeiden, indem man ein Remote-Dateisystem mit NFS, sshfs oder einem anderen Netzwerkdateisystem verwendet und dann nur die Funktion zur lokalen Verzeichnis-Synchronisierung verwendet. Allerdings dürfte dies ineffizient bezüglich der Bandbreiten-Nutzung sein.
units-2.02/sci-calculators/gentoo {calculator}{text-terminal IO}: Umrechnungsprogramm für Einheiten mit idiotischem Ausgabeformat. Denn es zeigt das Ergebnis nicht einfach an, sondern schreibt davor ein "*" als würde es sich um eine Multiplikation mit einem Faktor handeln, und in der Zeile danach ein "/" als sollte man das Ergebnis der Multiplikation dann auch noch dividieren. Das ist völlig unintuitiv und verwirrend, auch wenn man das Ausgabeformat natürlich zur Kenntnis nehmen und auswendig lernen kann, wie alles auf der Welt das für sich betrachtet keinen Sinn ergibt.
unknown-0.0/unknown/gentoo: some sort of keymap editor or something similar. With 2 Megs installation size its also not too big.
unknown-horizons-2011.1a/games-strategy/gentoo {game}: Ein nett gemachter "Anno-1602" (oder welche Jahreszahl auch immer) Klon. Man kommt mit einem Segelschiff bei einer Insel an, ankert dort, besiedelt die Insel, beginnt zu handeln und sich mit den Nachbarn auseinander zu setzen. Primär eine Echtzeit-Wirtschafts-Simulation. Ich finde es saufad, aber die Hintergrundmusik ist gut. Grafik ist soweit auch OK wennglich natürlich nicht ganz auf dem Niveau kommerzieller derartiger Spiele. Wem solche Spiele gefallen, könnte von Unknown Horizons aber vielleicht durchaus angetan sein.
unpaper-5.1/app-text/gentoo {bitmap image editor}: Ein mächtiges Kommandozeilentool zum Nachbearbeiten von in erster Linie eingescannten Buchseiten. Es kann aber auch zum Preprocessing von Scans vor einer nachfolgenden OCR-Erkennung eingesetzt werden. Es beherrscht die folgenden Funktionen: Fixe Rotation oder Spiegelung als Vorverarbeitungsschritt. Identifizieren von Inhaltsrahmen (auch im Fall von mehreren Seiten pro Blatt) durch überstreichen des Blattes mit einem virtuellen Balken, wobei das Verhältnis von hellen und dunklen Pixeln verfolgt wird. Suchrichtung, Schrittweite und Schwellwert können frei festgelegt werden. Der Bereich außerhalb der Inhaltsrahmen wird dann typischerweise auf weiß gesetzt. Mit einer ähnlichen Methode werden schwarze Ränder am Blatt identifiziert und entfernt. Es ist auch möglich gezielt Bereiche zu löschen, etwa wenn unerwünschte Logos dort zu sehen sind. Weiters können optional große schwarze Rechtecke auf der Seite gefunden und entfernt werden, etwa zu dunkel eingescannte Illustrationen. Es ist möglich die verbleibenden Inhaltsrahmen zu zentrieren oder neu bzw. an einander anzuordnen. Ein Rauschfilter erlaubt es Pixel-Cluster unterhalb einer bestimmten Fläche als Stör-Sprenkel zu entfernen. Ein Weichzeichenfilter erlaubt es größere Pixel-Cluster zu entfernen, die isoliert von anderen Pixelbereichen sind. Das könnten etwa Lochränder oder Heftklammern sein. Ein Graufilter färbt graue Bereiche in weiß um. Dann kann der Inhalt der erkannten Inhaltsrahmen gerade-gerichtet werden, indem der Inhalt rotiert wird. Die Suchparameter wie Schrittweite und Schwellwerte können auch hier exakt festgelegt werden. Alle Verarbeitungsschritte können deaktiviert werden. Das Programm kann auch zwischen verschiedenen Seiten-Layouts konvertieren, wie beispielsweise zwei Seiten pro Blatt in eine Seite pro Blatt konvertieren. Die Layouts basieren auf den oben genannten Inhaltsrahmen, und können (angesehen von vordefinierten Layouts wie 2 Seiten pro Blatt) entweder durch absolute Bereiche oder Suchparameter für Rahmenerkennung angegeben werden. Ein- und Ausgabe erfolgt ausschließlich über PNM-Bildformate, was typischerweise externe Konvertierung erfordert und dann typischerweise in PDF-Dateien mündet. Was auffällt, ist das Fehlen von Funktionen um aus Farb- oder Grauwert-Scans S/W-Scans zu machen, Halbtonrasterung zu entfernen, Moire-Muster oder Kompressions-Artefakte zu entfernen. Dies sollte man bereits vor der Benutzung des Programms getan haben; es kann mit jedem Typ von Scan (Farbe, Grau, S/W) arbeiten, ändert dabei aber den Typ nicht. Die meisten Funktionen des Programms machen aber nur mit S/W- oder Graustufenbildern Sinn. Mehrere Dateien für die Stapelverarbeitung werden über relativ frei definierbare Zähler und Platzhalter adressiert. Das Tool hat viele Parameter und Optionen, und es ist mühsam sich mit allen auseinander zu setzen. Allerdings ist eine sehr gute Offline-Dokumentation im HTML-Format mitgeliefert, welche die Konzepte und Parameter leidlich gut erklärt und auch illustriert. Für "sofortiges Arbeiten" entsprechend schlecht geeignet, doch potenziell wertvoll für Stapelverarbeitungsjobs. Eine gewisse Überschneidung mit ImageMagick ist erkennbar, doch dieses Tool ist wesentlich schneller da in C oder C++ geschrieben. Es gibt auch Überschneidungen mit Scan Tailor, aber letzterer ist ein interaktives Tool und hat somit ein anderes Zielpublikum.
unzip-6.0-23+deb10u2/utils/debian {compression}: Kommandozeilenprogramme zum Entpacken des bekannten Archiv-Formats der ".zip"-Dateien. Diese Paket enthält das Utility "unzip" zum Extrahieren, Auflisten und Konsistenz-Testen von Zip-Dateien. Für verschlüsselte Zip-Dateien unterstützt es dabei nur den ältesten und völlig unsicheren Verschlüsselungs-Algorithmus. Sollte Zip-Verschlüsselung benötigt werden sollte man besser zum Programm 7z/7zip greifen welches ebenfalls Zip-Dateien entschlüsseln (sowie auch erzeugen und verschlüsseln) kann, dabei aber den wesentlich sichereren AES-Algorithmus unterstützt. Neben "unzip" enthält dieses Paket auch das Utility "funzip" welches die erste Datei aus einem Zip-Archiv auf die Standardausgabe schreiben kann; das kann nützlich sein um unkomprimierte Zwischendateien zu vermeiden. "unzipsfx" erlaubt es Zip-Archive in selbst-extrahierende ausführbare Dateien zu konvertieren; wegen der offensichtlichen Malware-Gefahr sollte man von solchen Möglichkeiten aber nur in besonderen Situationen Gebrauch machen. "zipgrep" erlaubt es die Dateien in Zip-Archiven ähnlich wie mit dem bekannten "grep"-Utility zu durchsuchen, ohne sie davor tatsächlich extrahieren zu müssen. "zipinfo" zeigt detaillierte technische Informationen über ein Zip-Archiv an. Tatsächlich ist dieses Utility aber nur ein Link zu "unzip" welches dieses mit entsprechenden Optionen aufruft, sprich man kann mit "unzip" dasselbe erreichen wenn man einige Optionen angibt.
upstart-1.11-5/admin/debian {service manager}: Ein Event-basiertes (und daher grundsätzlich parallel arbeitendes wo keine Abhängigkeiten existieren) init-System und Drop-in-Replacement für sysvinit. War lange Zeit einer der beiden heißen Kandidaten für eine Ablöse von sysvinit, die mittlerweile jedoch von den meisten Entscheidern (leider) zugunsten von systemd entschieden wurde. Auch wenn upstart derzeit noch in Debian 8 vorhanden ist, soll es angeblich für spätere Versionen bereits aus dem Paketbaum entfernt werden, wie ich las. Ein Problem von Upstart das ich erkenne ist dass es mit der "libnih" implementiert wurde, gegen die ich einige (aber keine unüberwindbaren) Vorbehalte habe. Obwohl Upstart event-basiert arbeitet und damit vollkommen anders als die klassischen insserv-basierten sysvinit-Scripte, habe die Upstart-Autoren es durch ein Framework am Helper-Scripten geschafft, dass Upstart klassische sysvinit-Scripte verwenden kann und deren Abhängigkeiten irgendwie in Signale umwandelt. Ich für meinen Teil stehe (derzeit) auf dem Standpunkt, dass das Event-basierte Konzept dem deklarativen von sysvinit/openrc/systemd sowie dem vorwiegend impliziten Konzept von daemontools/runit überlegen ist, da sich damit vor allem Details wie "wie sollen abhängige Dienste reagieren wenn ein Service den sie verwenden plötzlich abstürzt" besser modellieren lassen. Das Event-Modell kann auch helfen die sonst üblichen pfuschhaften "sleep"-Aufrufe in Scripts zu vermeiden um Race-Conditions zu verhindern. Das Event-Modell definiert auch exakt eine gutes Dutzent an möglichen benannten Zuständen, die ein Dienst bzw. allgemeiner ein "Job" gerade haben kann. Dabei gibt es auch Support für das Policy-Laden vom Jobs in "hardened" Linux-Distributionen. Upstart kann neben von anderen Jobs erzeugten Events auch auf udev- und D-Bus-Events reagieren sowie auf Session-basierte Events. Ein Nachteil von Upstart ist dass die Anzahl der benannten Signale und Zustände relativ groß ist, deren Bedeutungen (vor allem die Reihenfolge der Übergangszustände des Automaten welchen upstart effektiv darstellt) man kennen muss um Job-Definitionen zu verstehen welche sie benutzen. Solange man allerdings nur eigene Jobs verfasst welche meist nur simple Abhängigkeiten haben, ist der Aufwand nicht größer als für syvinit-Scripts. Und damit es so richtig kompliziert wird, können Signalen neben ihrem Namen auch noch beliebige Parameter mit übergeben werden, die von den Empfängern ausgewertet werden. Upstart-Jobs können nicht nur für Systemdienste benutzt werden, sondern auch für benutzerspezifische Aufgaben. Allerdings scheint der Support hierfür noch nicht umfassend fertig implementiert zu sein, und es gibt Einschränkungen. Upstart ist daher zwar sehr toll, aber es erfordert mehr Lern-Aufwand als andere init-systeme (Nur noch durch systemd übertroffen, das einen mit Dokumentation geradezu ersäuft). Fairerweise muss man allerdings sagen, dass vieles von der Komplexität upstarts daher kommt dass das System den init-Scripts Arbeit abnimmt (vor allen zur Synchronisation von Abhängigkeiten), welche diese in primitiveren init-Systemen selbst erledigen müssen.
usbredir 0.7-1/community/archlinux: Ein Server zum Umleiten einzelner USB-Geräte über TCP-Verbindungen. Als Client kann derzeit nur eine QEMU-VM verwendet werden, obgleich das Protokoll grundsätzlich beliebige Clients ermöglichen würde. Usbredir ist daher derzeit nicht in der Lage, USB-Geräte direkt an nicht-virtualisierte Linux-Maschinen weiter zu leiten.
usemod-wiki-1.2.1-2/web/debian usemod-wiki-1.0.6-1/web/devuan {wiki}: Noch ein in Perl geschriebenes Wiki. Ist eine CGI-Anwendung - benötigt einen zusätzlich installierten CGI-fähigen Webserver. Winzig: 232 kB installiert. Benutzt CamelCase für alle Wikilinks - man kann aber auch doppelte eckige Klammern verwenden wenn man dies nicht will. Speichert alle Inhalte als flache Dateien in einem eigenen Binärformat das jedoch hauptsächlich aus dem Wiki-Text besteht. Unterstützt keine Datenbanksysteme. Ansonsten scheint es ganz OK zu sein. Insbesondere sind die Wikiseiten nicht Grafik/HTML5-überladen, sehen schlicht aus und funktionieren auch ohne JavaScript. Bietet auch Historie, Diffs und Volltextsuche. Ein Problem ist die schlechte Dokumentation. Weder wird erklärt wie man es einrichtet, noch wie man es benutzen soll. Es gibt nicht einmal eine Offline-Hilfe - selbst für die Formatierungs-Regeln muss man auf die Homepage des Projekts gehen. Immerhin kann man sie dann von dort holen und ins eigene Wiki kopieren. Die Regeln sind recht umfangreich und chaotisch. Nicht gerade minimalistisch oder einfach zu merken. Zumindest die komplizierteren Dinge. Die einfachen funktionieren recht gut. Ich fand keine Möglichkeit eine nicht mehr benötigte Wiki-Seite wieder zu löschen. Aber vielleicht ist dies Absicht damit die Änderungs-Historie erhalten bleibt. Man kann nicht mehr benötigte Seiten zumindest leer machen, dann brauchen sie nur noch wenig Platz. War mir weiters nicht gelang: Den Wiki-Text einer Seite anzeigen, die fürs Bearbeten gesperrt ist.
util-linux-2.33.1-0.1/utils/debian: Enthält eine größere Anzahl Standard-Kommandos von Linux. "addpart" (teilt dem Kernel die Existenz einer neuen Partition mit, selbst wenn es keine zugehörige Partition-Table gibt), "agetty" (eine "getty"-Implementierung welche zusätzliche Optionen wie etwa für Auto-Logins und Hardware-Flow-Control kennt sowie in der Lage ist, die Baudrate automatisiert aus der "CONNECT"-Meldung eines Modems abzuleiten sowie sie im Falle von virtuellen Linux-Konsolen grundsätzlich ignoriert; außerdem kann "agetty" Terminal-Settings wie Parity und Newline-Sequenz aus der Login-Eingabe ableiten), "choom" (OOM-Killer anpassen), "chrt" (Scheduling-Klasse eines Prozesses konfigurieren), "delpart" (teilt dem Kernel mit dass es eine Partition nicht mehr gibt, auch wenn die zugehörige Partition Table etwas anderes sagt), "dmesg" (Kernel-internen Ringpuffer für Log-Einträge anzeigen oder konfigurieren), "fallocate" (Sparse Files und Löcher in diesen verwalten), "fincore" (Informationen über das aktuelle Ausmaß des RAM-Cachings von Dateien anzeigen), "findmnt" (finde einen Mountpoint anhand von Angaben wie Partition Label oder UUID), "flock" (die Sperrung einer Datei anfordern oder aufheben, für die Nutzung in Shell-Scripts), "getopt" (bietet Shell-Scripten die Möglichkeit, die nicht-portablen Möglichkeiten von GNU getopt inklusive langer Optionsnamen zu nutzen), "i386" (ändert die Ausgabe von "uname -m"), "ionice" (konfiguriert die Priorität eines Prozesses für den I/O-Scheduler), "ipcmk" (erzeugt diverse SHM-Objekte: Shared Memory, Message Queue, Semaphore Arrays), "ipcrm" (kann existierende SHM-Objekte wieder löschen), "ipcs" (auflisten existierender SHM-Objekte), "last" (zeigt den Zeitpunkt der letzten An- und Abmeldung eines bestimmten Users oder aller User), "lastb" (zeigt den Zeitpunkt des letzten fehlgeschlagenenen Anmeldungs-Zeitpunkts eines bestimmten oder aller User), "linux32" (setzt was "uname -m" anzeigen soll auf das 32-Bit ABI), "linux64" (setzt was "uname -m" anzeigen soll auf das 64-Bit ABI), "lsblk" (listet alle oder bestimmte Blockgeräte auf, ähnlich wie "blkid" aber in einem hübschen Baumdiagramm), "lscpu" (gibt ähnliche Angaben wie /proc/cpuid aus, jedoch kummulativ für alle Kerne), "lsipc" (gibt allgemeine Statistiken über das SHM-Subsystem auf, konkret Anzahl, Umfang und Limit der einzelnen SHM-Ressourcen-Kategorien), "lslocks" (zeigt die aktuell aktiven Dateisperren im System an inklusive der einzelnen Byte-Bereiche jeder Sperre), "lslogins" (zeigt an wer gerade im System angemeldet ist, ähnlich wie "whois", allerdings ohne Mehrfachnennungen und hübscher formatiert), "lsmem" (scheint nur für irgendwelche Cluster-Setups gedacht zu sein, wo es RAM-Bereiche anzeigt die online oder offline sein können), "lsns" (listet die Namespaces des Linux Kernels auf welche gerade in Verwendung sind), "mcookie" (erzeugt neue Cookies für "xauth"), "mesg" (setzt/löscht das "world-writeable" bit von /dev/tty, so dass jeder andere User einem mit "write" etwas aufs Terminal schreiben kann oder eben nicht), "more" (der Vorläufer von "less", hat aber den Vorteil dass er nur begrenzten RAM verbrauchen kann), "mountpoint" (testen ob ein Directory ein Mount-Point ist), "namei" (die Komponenten eines Pfadnamens mitsamt ihren einzelnen Zugriffsrechten auflisten), "nsenter" (einen neuen Prozess in einem oder mehreren bereits existierenden Linux-Namespaces starten), "partx" (kann eine nicht in Verwendung befindliche Partition Table parsen und anzeigen, sowie darüber hinaus auch noch dasselbe wie "addpart" und "delpart" tun), "prlimit" (Ressourcen-Limits von Prozessen konfigurieren, ähnlich wie "ulimit" aber unabhängig von der Shell und kann auch die Limits bereits laufender Prozesse benutzen), "rename.ul" (Umbenennung durch simple Substring-Ersetzung in den angegebenen Dateinamen), "resizepart" (dem Kernel eine neue Größe für eine existierende Partition mitteilen, selbst wenn die Partition Table etwas anderes sagt), "rev" (wie "cat" nur werden die Zeichen in jeder Zeile von rechts nach links ausgegeben statt umgekehrt), "setarch" (setzt was "uname -m" anzeigen soll), "setpriv" (führt einen Prozess mit geänderten Linux-"Capabilities"-Settings aus), "setsid" (startet einen Prozess als neue Sitzung in welcher er "Session Leader" ist - wichtig für Job Control), "setterm" (ändert verschiedene Terminal-Atrribute wie Schriftfarbe, Cursor-Blinken, Tab-Settings, Fettschrift etc., konsultiert dazu entweder die TERMINFO-Datenbank oder führt direkt ioctrl-Aufrufe durch), "su" (ein Kommando als anderer Benutzer oder Gruppe ausführen, in der Regel nur für den Superuser zu gebrauchen), "taskset" (CPU-Affinity verwalten, kann Prozesse an bestimmte CPU-Cores binden), "unshare" (einen Prozess in einem oder mehreren neuen Namespaces starten), "utmpdump" (Kopien von binären UTMP/WTMP Datenbanken decodieren und als Text ausgeben), "wdctl" (Hardware-Watchdog-Timer administrieren), "whereis" (zeigt den Pfadnamen der ausführbaren Datei eines Kommandos sowie den Pfadnamen der zugehörigen "man"-Datei an).
uucp-1.07-24/comm/debian: Das "klassische" UNIX-to-UNIX-copy Programm. Es besteht im wesentlichen aus den Hauptkommandos "uucp" und "uux". Ersteres kann Dateien zwischen uucp-unterstützenden UNIX-Installationen hin- und her kopieren, und letzteres Kommandos dort ausführen. Praktisch meist sehr eingeschränkt welche Kommandos auszuführen erlaubt ist, so dass auf vielen Systemen die einzigen erlaubten Befehle solche zum Austausch von e-Mail oder USENET-News sind. Die diversen Quell- und Zielsysteme die bei uucp und uux angegeben werden können, müssen sämtlich explizit in Konfigurationsdateien deponiert sein. uucp hat gewisse Ähnlichkeiten mit ssh, nur dass es keinerlei Verschlüsselung gibt. Der größte Unterschied ist aber der Batch-Charakter von uucp: Zwar wird dort in der Regel ein Remote-System sehr ähnlich wie bei SSH aufgerufen. Jedoch häufig zeitgesteuert nur innerhalb bestimmter Intervalle und Zeitpunkte - häufig als cron-Job. Die entsprechenden Befehle bzw. zu kopierenden Dateien sind zu diesem Zeitpunkt schon längst bekannt und werden dann während der tatsächlichen Verbindung komplett automatisch ausgetauscht bzw. ausgeführt. Dem Anschein nach verwendet uupc sogar ganz normale interaktive Terminal-Logins um den Datenaustausch zu initiieren; tatsächlich implementiert wird dies dann aber doch durch andere Programme aus der uucp-Suite, welche als Empfangs-Teil nach dem Einloggen gestartet werden. Es gibt auch Routing, aber nur extrem primitives: Die Routen werden exakt als Teil der verwendeten Pfadangaben explizit angeführt. Die eigentliche Verbindungsaufnahme geschieht normalerweise über Modem-Einwahl, dazu gibt es auch das Programm "cu" (für "call up") welches auch "chat"-Scripte zur Automatisierung des Einwahlvorgangs unterstützt (mit der weitgehend selben Syntax wie das "chat"-Utility des "ppp"-Pakets). Aktuelle Versionen von uucp wurden jedoch in der Regel um TCP-Funktionalität erweitert; hierbei wird das Server-Gegenstück des Protokolls in der Regel über einen Internet-Superserver wie "inetd" gestartet. Alles in allem scheint uucp nichts zu können was man mit "ssh" und einem cron-job nicht genau so und dabei viel sicherer umsetzen könnte. uucp hat lediglich den Vorteil dass bereits eine klar definierte Infrastruktur vorhanden ist wie die Befehle zusammenwirken, die man sich im Falle von ssh erst selbst schreiben müsste. Andererseits ist diese Infrastruktur so altbacken und unsicher, dass es vermutlich ohnehin besser ist sie erst gar nicht zu benutzen.
uudeview/app-text/gentoo: Implementiert die restlichen der bekannten Texte-Encodings welche app-arch/sharutils nicht beherrscht. (Letzteres beherrscht nur uuencode/uudecode.) Das wären: Base64, xxencode, yenc und MIME-Quoted-Printable. Standard-kompatibles uencode/uudecode beherrscht es ebenfalls, aber unter anderem Befehlsnamen mit anderen Argumenten.
vde2-2.3.2+r586-1/net/debian: Ein virtueller Ethernet-Switch. Implementiert in Software, was ein teurer VLAN-fähiger Multiport-Switch in Hardware leistet. Qemu hat Support für VDE2, und kann solch einen Switch direkt an die VM anschließen. VDE2 funktioniert aber auch unabhängig von Qemu, und kann verschiedene TUN/TAP-Interfaces mit einander verbinden als wären es echte Netzwerk-Karten. Das Paket behinhaltet verschiedene "Kabel"-Utilities, die sich auf der einen Seite des "Kabels" mit dem virtuellen Switch verbinden können, und auf der anderen Seite mit unverschiedlichen Dingen. Darunter die simple Möglichkeit, den Netzwerk-Verkehr einfach durch eine Pipe an einen benutzerdefinierten Prozess zu schicken. Oder mittels eines "Crypto-Kabels" ein verschlüsseltes VPN zu realisieren. Der Switch unterstützt sowohlo VLAN 801.1q als auch "fast spanning tree"-Protokoll (optional zuschaltbar). Weiters stellt der Switch eine Monitor-Konsole zur Verfügung, die man über einen UNIX Domain Socket aufrufen kann um den Switch auch zur Laufzeit rekonfigurieren zu können. Das Paket enthält weiters Utilities für das Verbinden von Prozessen zu bi-direktionalen Pipes, sowie ein simples Terminal-Programm für UNIX-Domain Sockets. Letzteres ist hilfreich zur Benutzung der Switch-Monitor-Konsole, leistet aber eben so gute Dienste für die Monitor-Konsole von Qemu, falls man diese konfiguriert UNIX Domain Sockets zu benutzen.
vde2-cryptcab-2.3.2+r586-1/net/debian {security}: Ein "Crypto-Kabel" für den virtuellen VDE2 Ethernet-Switch. Theoretisch eine gute Sache. Leider ist die Dokumentation sehr spärlich und man erfährt nicht mehr als dass Blowfish-Verschlüsselung benutzt wird. Weder wird die Schlüsselstärke verraten noch ob die Verbindung gegen Replay-Attacken abgesichert ist. Dies macht einen schlechten Eindruck und ich befürchte, dass die Verschlüsselung unsicher implementiert ist und weder die Integrität der übertragenen Daten noch vor Replay-Attacken schützt. Da man bei VDE2 ohnehin relativ einfach einen eigenen Prozess mittels Pipes als Filter in die Netzwerkverbindung einklinken kann, sollte es kein Problem darstellen später einmal selbst ein besseres "Crypto-Kabel" zu implementieren. Auf *dieses* Paket sollte man hingegen besser verzichten, und OpenVPN nehmen bis das eigene Crypto-Kabel zur Verfügung steht.
vdmfec-1.0-2/misc/raspbian {FEC}: Fügt einem Datenstrom aus Datenblöcken einer Länge B von mindestens 26 Bytes Fehlerkorrekturinformation basierend auf Vandermonde-Matrizen hinzu. Dabei werden jeder Gruppe aus 2 <= N <= 256 Eingabeblöcken K zusätzliche Blöcke (wobei 0 < K < N) hinzu gefügt und die Originaldaten sowie die Fehlerkorrektur-Information über alle N + K Ausgabeblöcke verteilt. Beim späteren Decodieren der Ausgabe können von jeder Gruppe aus N + K Blöcken bis zu K Blöcke beschädigt sein, aber die N Ausgabeblöcke können dennoch rekonstruiert werden. Der Encoder kann die Daten in eine Pipe schreiben und der Decoder aus einer lesen. Ein Nachteil des Programms ist das die Fehlerkorrekturinformation nicht in separaten periodischen Blocks in die Originaldaten eingefügt wird, sondern mitten in die geschützten Daten eingestreut ist. Man muss die Daten daher immer decodieren bevor man sie benutzen kann. Außerdem können nur in-place Fehler repariert werden. Fehler durch entfernte oder eingefügte Datenblöck können nicht korrigiert werden. Der typische Anwendungsfall dieses Programms ist es daher, sequentielle Archivdateien vor dem Schreiben auf ein Blockgerät (Disk ohne Dateisystem oder Tape) zu schützen.
vectoroids-1.1.0-13+b1/games/devuan {game}: Ein "Asteroids"-Klon in Pseudo-Vektorgrafik mit irgendwie unpassendem Foto-Hintergrundbild vom Jupiter. "Pseudo" weil es keine Vektoren sondern relativ dicke Striche sind, die noch dazu mehrere Farben benutzen und zu allem Überfluss auch noch mit geringer Auflösung und daher pixelig gerendert werden. Vom Spielgefühl her ist es OK, aber die fixe geringe Bildschirmauflösung auf welche das Spiel offenbar umschaltet ärgert einen dann doch immer wieder. Ca. 500 kB Installationsumfang.
vfu-4.10-1.1/utils/raspbian {file manager}{text-terminal IO}: Ein im Grunde ganz netter "konventioneller"-Dateimanager für den Text-Modus, d. h. *kein* Midnight-Commander-Klon. (Ist auch viel schlanker als dieser.) Das Programm hat sogar ein eigenes "Clipboard", welches eine Liste von Dateien enthält die man zwischen den verschiedenen Verzeichnissen hin- und herkopieren, verschieben oder verlinken will. Nutzt den Bildschirm vor allem in der Breite besser aus als der mc, da keine idiotischen Rahmen oder ähnliches verwendet werden. Bis auf Farben verwendet er überhaupt keine gesonderten GUI-Elemente, und auch die Farben nur optional da Markierungen immer zusätzlich durch normale Zeichen gekennzeichnet sind. Weiters kann man mit einem einzelnen Tastendruck zwischen einem Modus umschalten wo Datum, Dateigröße etc angezeigt werden, und einem Modus wo bis auf den grundlegenden Typ (Directory, Symlink, normale Datei, etc) die ganze Bildschirmbreite für den Namen verwendet wird. Den mc muss man erst mühsam umkonfigurieren bis er ähnliches leistet, und das Umschalten zwischen den Modi ist dann nur umständlich möglich. Zwar gibt es keine Tabs oder gar ein 2. Fenster zum Umschalten per Tabulator-Taste, aber dafür gibt es eine recht intelligente History der zuletzt besuchten Verzeichnisse welche einem automatisch das zuletzt besuchte als erste Auswahl anbietet. So erfordert der mehrfache Wechsel zwischen zwei Verzeichnissen nur jeweils 2 Tastendrücke. Es gibt ein "Tools"-Menü mit vermutlich fix definierten zusätzlichen Funktionen und ein "User"-Menü dessen Einträge man (obgleich vordefinierte vorhanden sind) wohl selbst gestalten kann. Es gibt eine Suchfunktion die allerdings nur nach Namen suchen kann, und die gefundenen Dateien können dann entweder sofort benutzt werden oder als ein virtuelles Dateiverzeichnis mit den üblichen Möglichkeiten dargestellt werden. A pro pos, mit den gebräuchlichsten Archiv-Formaten scheint das Programm auch als virtuelle Dateisysteme umgehen zu können. (Zumindest lesend - ich weiß nicht ob auch Änderungen so möglich sind). Man kann auch eine Kommandozeile aufrufen, die jedoch nicht permanent verfügbar ist sondern durch einen Tastenbefehl geöffnet werden muss. Er hat einen eingebauten Hex-Editor und Text-Viewer. Letzterer kann auch Textumbrüche, aber leider nur am Zeilenrand und nicht nach Worten. Außerdem fehlt ein Gegenstück zur Quick-View des mc - man muss den Viewer jedesmal explizit schließen und für die nächste Datei öffnen, um mehrere Datei-Inhalte anzusehen. Der Support für UTF-8 ist inkonsistent. Bei der Anzeige der Dateiliste gibt es keine Probleme damit, aber sehr wohl wenn man eine Datei mit non-ASCII-Zeichen dann umbenennen will. Besonders geistesgestört gefährlich scheint mir das "Directory-Tree"-Anzeige-Feature zu sein, wo das Programm zumindest beim ersten Aufruf dieser Funktion eine komplette Dateiliste des gesamten Wurzeldateisystems einzulesen versucht - und dabei auch nicht vor /proc und ähnlichen Verzeichnissen halt macht. Zudem scheint man die Funktion nicht abbrechen zu können - außer durch ein "kill" von einer anderen Shell/Taskmanager. Die Dokumentation ist auch lausig - obwohl die Online-Hilfe alle Tasten erklärt, ist unklar wie die Funktionen dann zu benutzen sind - insbesondere wie man sie wieder abbrechen kann oder bestätigen muss. Experimentieren ist angesagt. Weiters ist das Programm auch etwas gemeingefährlich, da auch gefährliche Operationen wie das Löschen von Dateien ohne Sicherheitsabfrage kommentar los sofort durchgeführt werden. Pech wenn man mal im Dunkeln die falsche Befehlstaste erwischt hat! An die meisten dieser Probleme kann man sich aber vermutlich gewöhnen oder sie umgehen. Doch das UTF-8 Problem ist gravierend und verbietet eigentlich den Einsatz des Programms, zumindest wenn einem die Dateien lieb sind deren Namen sonst verstümmelt und falsch umbenannt werden.
vice 2.4-8/extra/archlinux: Der Commodore 64 Emulator. Er ist unter Raspberry Pi 1 zwar schnell genug dass er Spiele in 1:1-Aufösung mit Originalgeschwindigkeit wiedergeben kann. Doch dann läuft das Spiel nur in einem winzigen Fenster. Aktiviert man hingegen die Optionen zur Skalierung der Ausgabe auf etwas Größeres, bricht die Wiederholrate so stark ein dass die Spiele nur noch herumeiern. Die einzige Lösung wäre das temporäre Umschalten der Videoauflösung des Hardware-Displays auf eine geringere und später wieder zurück. Das ist mir am Raspberry aber bislang leider noch nicht ohne Neustart des Rechners gelungen. Bis dahin bleibt vice daher unbrauchbar. Am Raspberry Pi 2 hingegen wäre es trotz Software-Skalierung vielleicht schnell genug - das ist noch zu prüfen.
viking-1.8-4+b1/utils/debian {GIS}: GPS-Datenauswertung und Bearbeitung. Kann GPS Tracks im GPX, TCX und KML importieren, editieren und visualisieren. Es kann auch JPEG Bilder mit GPS-Koordinaten importieren und über die Kartenansicht erreichbar machen. Die Daten können in verschiedenen Layern organisiert werden. Es kann kachelbasierte Karten herunterladen (Bing Aerial Maps, Mapbox Outdoors, OSM, NASA BlueMarble) oder offline importieren (OSM, MBTiles). Zur Ergänzung der Kacheldaten kann es auch DEM-Daten (Höheninformationen) von NASA-Projekt SRTM importieren. Es wird jedoch auch ein Mapnik Layer unterstützt, in welchem mittels der Mapnik-Library fehlende Kacheln auch lokal gerendert werden können. Layer können auch Daten anderer Layer zusammenfassen und filtern, etwa zum Wandern, Radfahren und ähnlichen Zwecken. Routen können geplant werden, jedoch nur mittels externe Internet-Dienste. Tracks können optimiert werden, indem doppelte und unnötige Wegpunkte entfernt werden. Die Editiermöglichkeiten beschränken sich im wesentlichen auf das Bearbeiten und Hinzufügen von Wegpunkten. Die Analysefunktionen können die Geschwindigkeit der Bewegung verschiedenen Abschnitten anzeigen oder zusammenfassen, und auch vergessene Ruhepausen erkennen und einfügen. Ebenso kann errechnet werden wie nahe man sich während eines Trips einem bestimmten Ziel abseits der Route angenähert hat.
vim-2 {text-editor}: 8.0.0197-4+deb9u3/editors/devuan: Die Vollversion des populären "vi"-clones ViM, die mit vollständiger Hilfe und allen möglichen Erweiterungsmodulen daher kommt. Für vi-Liebhaber sicherlich der Himmel. Leute die einfach nur mit vi Textdateien bearbeiten wollen, dürften mit dem vim-tiny Paket genau so glücklich werden.
vim-scripts-20130814/editors/debian: Optionale Support-Scripte für den ViM-Editor. Beispielsweise Integration von Versionskontrollsystemen, Doxygen, GnuPG, GNU info usw. Alles wohl nur für Hardcore-ViM-Liebhaber interessant; jeder andere macht das in einer separaten Shell. Allerdings gibt es ein Highlight dieses Pakets: Es sind auch mehrere Spiele integriert, darunter Tetris und Sokoban. Und von letzterem liegen alle Levels als simple Text-Files vor. Wenn man also ein eigenes Sokoban programmieren will, kann man sich dort billig "bedienen".
vim-tiny-2 {text-editor}{text-terminal IO}: 8.0.0197-4+deb9u3/editors/devuan: Eine abgespeckte Version des vollwertigen vim-Pakets, wo aber immer noch der eigentliche vi Editor für den Textmodus verfügbar bleibt. Völlig ausreichend, außer man ist ein ViM Power-User der alle möglichen Erweiterungsmodule nutzen will welche hier genau wie das Tutorial fehlen.
virtualbox-ose/app-emulation/gentoo: Pseudo-Emulator a la VMware, allerdings OpenSource und frei. Die Gasterweiterungen unterstützen allerdings kein Windows XP. Ebenso fehlt bei der freien Version die Möglichkeit, den Bildschirminhalt remote anzeigen zu lassen. Hardware-Virtualisierung wird zwar optional unterstützt, bringt aber nahezu keinen Geschwindigkeitsvorteil.
w3m-0.5.3-37/web/debian {www-browser}{text-terminal IO}: Unterstützt UNICODE und SSL. Kann optional auch das USENET Newsgroup Protokoll verstehen. Legt besonderen Wert auf Unterstützung der japanischen Sprache (aber beim Bauen abwählbar). Außer einer Hilfeseite welche die Tastaturkommandos anzeigt scheint alles weitere nur über Konfigurationsdateien einstellbar zu sein. Wirkt weniger komfortabler als Lynx, hat aber auch nur 2/3 von dessen Größe. Kann ebenfalls als Dateisystem-Browser (sogar mit Baumansicht) verwendet werden. Außerdem ist ein Download-Manager integriert, der im Hintergrund begonnene Downloads fortsetzt wenn man die Download-Ansicht einfach nur schließt ohne den Download abzubrechen. Das mit Abstand wichtigste Feature von w3m ist es jedoch, HTML-Dateien in reinen Text umwandeln zu können. Und zwar in Text, der für eine vorgegebene Spaltenanzahl formatiert wurde, mitsamt der dazu nötigen Wortumbrüche. Auch Tabellen werden dabei in entsprechende Ersatzzeichen für die Linien konvertiert, wobei das Programm sowohl UNICODE-Liniengrafikzeichen als auch ASCII-Ersatzzeichen in die Ausgabe einbauen kann. w3m wird daher auch vom a2x.pl-Backend des Hilfsprogramms "asciidoc" benutzt (falls es installiert ist), so dass die damit erzeugten formatierten Textdateien auch hübsch formatierte Tabellen enthalten können. Damit ist w3m ein wichtiger Bestandteil der Formatierungskette vom Dokumenten mit Tabellen zu Reintextdokumenten mit "gerenderten" Tabellen. Weiters glänzt w3m mit der Fähigkeit Grafikbilder (ja - mitten im Xterm!) in die Textausgabe einbauen zu können! Zumindest unter X11 und ansonsten wohl auch nur bei Framebuffer-Devices. (Unter Debian wurde dieses Feature in ein separates Paket "w3m-img" ausgelagert, welches man zusätzlich installieren muss.) Dabei bedient er sich der imglib und kann daher deren Bildformate darstellen.
w_scan-20130331/media-tv/gentoo: Benutzt einen angeschlossenen DVB-Empfänger wie etwa einen DVB-USB-Stick, um ohne jedes vorherige Wissen um Sendernamen und Frequenzen eine Liste der verfügbaren Sender zu erzeugen. Der Aufruf "w_scan -ft -L > dvt.xspf" erzeugt eine Playlist-Datei, die man direkt mit dem VLC Player öffnen kann, und jeder Titel ist ein TV-Stream von einem der gefundenen Sender. w_scan ermittelt dabei automatisch alle erforderlichen Parameter wie Sendernamen und Frequenz. Dieses Tool und VLC Player sowie die erforderlichen Kernel-Treiber sind alles, was man benötigt um TV mittels DVB zu sehen. Ein weiterer Vorteil ist, dass man w_scan wieder deinstallieren kann, nachdem man die XML-Datei erzeugt hat. Zumindest solange sich an der Sender-Landschaft nichts ändert.
warzone2100-2.3.9/games-strategy/gentoo {game}: Ein grafisch wirklich nett gemachtes Aufbau-Strategiespiel. Man baut und steuert Panzer, Raketenwerfer, Konstruktionsfahrzeuge etc, um seine Basis auszubauen und zu vergrößern während man dabei von Computergegnern angegriffen wird welche dasselbe machen. Man steuert dabei in der Regel nicht direkt die Einheiten sondern erteilt diesen nur Befehle welche sie dann selbsttägig ausführen. Man muss auch Erkundungsfahrten unternehmen um unbekanntes Gelände auf der Karte aufzudecken oder zu sondieren, Bodenschätze zum Abbau zu entdecken und Artefakte zu finden welche einem bessere Technologien ermöglichen. Dieses Spiel war früher einmal ein kommerzielles Spiel, welches ge-open-sourced wurde.
wavpack-4.50.1-r1/media-sound/gentoo {audio}: Lossless audio compression utility. Packs slightly better than FLAC, but only if the very slowest high-performance options are enabled. A nice feature is the option to create two output files instead of a single one: A much smaller lossy file plus a correction file which is needed to reconstruct the exact original file. With the tightest compression setting, the lossy file has a size comparable to that of a very high-quality MP3 file. This allows only keeping the lossy files for daily use and archiving the correction file on an external harddisk in case the original file has to be reconstructed.
wayv-0.3-r2/x11-misc/gentoo {input without physical keyboard}: WayV ist ähnlich wie XStroke ein Gestenerkennungs-Programm. Auch hier können neben Tastendrücken und Maus-Events und beliebige Programme durch Gesten ausgelöst werden. Doch während XStroke mit einem 3 x 3 Raster arbeitet, basiert WayV auf einem 8 x 8 Raster, was komplexere Gesten erlaubt. Dennoch bringt das Programm vorinstalliert noch weniger Gesten mit als XStroke; soweit ich das sehe sind nicht einmal die Dezimalziffern vordefiniert! Und auch die normalen Buchstaben starten in der Default-Konfiguration meiste eher Programme, als dass sie Tasten einfügen. WayV ist daher offenbar primär zum Auslösen von Kommandos gedacht, und nicht als Texteingabeprogramm - auch wenn man es wohl entsprechend konfigurieren könnte. Um die Gestenerkennung einzuleiten, muss immer irgend eine Taste festgelegt werden; in der Default-Konfiguration die mittlere Maustaste. Genau wie XStroke zeichnet WayV die Gesten temporär auf den Bildschirm während man sie eingibt. Danach verschwinden sie wieder und die Aktion erfolgt. Es gibt mehr Wahlmöglichkeiten als bei XStroke ob das ganze Bildschirm zur Gesteneingabe dienen soll, oder ob das Programm ein dezidiertes Eingabefenster angezeigen soll. Ebenso wie XStroke scheint WayV nicht sonderlich intensiv weiter entwickelt zu werden. Ein weiterer Eindruck ist dass WayV primär ein klassisches PC User-Interface mit Maus unt Tastatur durch zusätzliche Gesten erweitern soll, während XStroke als Tastaturersatz zur Texteingabe dienen soll.
wbar-1.3.3/x11-misc/gentoo {desktop panel}: Ein nett aussehender Stand-Alone Toolbar für X11. Denkbar einfach: Man trägt Icon, Name und Command in eine Konfigurationsdatei ein, und dann kann man diese Commands aus dem Toolbar starten. Der Toolbar befindet sich immer an einem der Bildschirmränder (per Default zentriert unten); der Fenster-Manager darf dort nicht ebenfalls etwas hinlegen. Es gibt keinen Support für Scrolling oder dergleichen; die Einträge des Toolbars müssen am unteren Rand Platz finden. Dafür ist wbar grafisch nett gemacht: Die Icons sind normalerweise kleiner, aber wenn man mit der Maus drüber fährt werden sie größer und bewegen sich wie eine Welle unter der Maus. wbar ist sinnvoll für Fenstermanager die selbst keinen Toolbar haben. wbar hat allerdings ein praktisches Problem: Er beherrscht kein "Autohide", und man muss daher Platz für ihn an seinem Rand frei halten, sonst wird er entweder von anderen Fenstern verdeckt oder verdeckt seinerseits diese. Überdies hat er in dem Fall dass er andere Fenster verdeckt Probleme seinen Hintergrund zu restaurieren sobald man eine Auswahl getroffen hat, so dass dann Teile des ehemaligen Fensters als Teil des wbar-Hintergrunds angezeigt werden. Praktisch bedeutet dies dass man wbar nicht sinnvoll verwenden kann, außer man ist gewillt permanent einen Teil der Bildschirmfläche nur für wbar zu reservieren. Wirklich schade, denn er ist ein echtes Eye-Candy.
wcalc-2.4-3/math/debian {calculator}{text-terminal IO}: Ein weiterer Kommandozeilen-Taschenrechner mit frei konfigurierbarer Genauigkeit. Im Gegensatz zu bc rechnet dieser immer mit Fließkommazahlen, jedoch kann man deren Wortbreite beliebig definieren. Wegen dieser ungewöhnlichen Arbeitsweise kann man in wcalc auch die Genauigkeit in Bits einstellen, während man die Anzahl der Nachkommastellen unabhängig davon einstellen kann. Ein weiteres Alleinstellungemerkmal ist der "konservative" Rundungsmodus, wo versucht wird Underflows zu erkennen und intelligent zu behandeln. Wcalc beherrscht auch die üblichen mathematischen und transzendenten Funktionen, jedoch weniger als "calc". Er beherrscht Dezimale, binäre, oktale und Hexadezimale Arithmetik und erlaubt es Variablen zu definieren. Da diese jedoch wiederum Referenzen zu anderen Variablen enthalten können, handelt es sich dabei eher um simple Benutzerdefinierte Funktionen. Im Gegensatz zu bc und calc kann wcalc nur Ausdrücke evaluieren und Variablen definieren, beherrscht aber keine Kontrollstrukturen bzw. Schleifenkonstrukte. Es gibt aber Vergleichsoperatoren die zu 0 oder 1 evaluieren, durch deren Verknüpfung man zumindest simple "if"-Bedingungen emulieren kann. Rekursive Funktionen lassen sich so aber nicht emulieren. Das Programm nimmt seine Eingaben entweder als Kommandozeilenargumente zu sich, oder es arbeitet als interaktive Shell mit History-Funktion. Es verfügt über Online-Hilfe, und der Liste aller Befehle samit allgemeiner Hinweise passt auf eine Bildschirmseite. Zusätzlich kann für jede einzelne Funktion noch genauere Hilfe angefordert werden. Alles in allem ein klarer Herausforderer für "calc", das vor allem durch seinen geringeren Installationsumfang glänzt: 300 KB vs. 4 MB. Wenn man daher "nur" einen Commandline-Taschenrechner braucht scheint wcalc die bessere Wahl zu sein. Will man jedoch eine kleine Programmiersprache die auch Schleifenkonstrukte und dergleichen kennt, ist calc die bessere Wahl. Allerdings könnte in letzterem Fall yacas eine noch bessere Wahl sein, da dies ein vollwertiges kleines CAS und funktionale Programmiersprache ist und trotzdem nur den halben Installationsumfang von calc hat.
wdfs-1.4.2/net-fs/gentoo {FUSE}: Ein weiteres FUSE-basiertes Netzwerkdateisystem, das es erlaubt den Inhalt von WebDAV-Servern lokal und ohne Administratorrechte zu mounten.
whiptail-0.52.23-1+b1/utils/raspbian {cmdline-dialog}{text-terminal IO}: Eine abgemagerte und weniger Funktionalität bietender Klon von "dialog", welche dafür aber den Vorteil hat UTF-8 zu unterstützen. Unter Debian wird whiptail für die Anzeige von Konfigurations-Dialogen im Terminal verwendet, wie etwa bei "dpkg-reconfigure". Außerdem steht dort "dialog" gar nicht zur Verfügung, so dass man ohnehin nur whiptail nehmen kann wenn man etwas "dialog"-ähnliches verwenden möchte.
wifi-radar-2.0.s08+dfsg-1.1/net/debian: Ein angeblich nützliches Tool zum WLAN-Cracken. Leider startet es nicht einmal sondern verreckt sofort mit eine Python-Core-Dump und jammert dass irgend ein Ereignis nicht auftreten würde. So weit so nützlich. Braucht wohl mehr Dienste als es in den Paket-Abhängigkeiten angibt. Hmmm. Ich sollte vielleicht erst einmal die WLAN-Karte ohne Network-Manager in Betrieb zu nehmen versuchen?
wifite-2.0r85-1/net/debian: Ein von wifi-radar empfohlenes Front-End fürs WLAN-cracken, das auch genau so "gut" funktioniert wie ersteres Tool. Konkret findet es keinen WLAN-Adapter. Hmmm. Ich sollte vielleicht erst einmal die WLAN-Karte ohne Network-Manager in Betrieb zu nehmen versuchen?
wiggle-0.8-r1/dev-util/gentoo {text-merge}{word-diff}{word-merge}{rej-conflict-resolver}{text-diff}: Ein kommandozeilenbasiertes diff/merge-Tool, welches primär zu drei Zwecken konzipiert wurde. Erstens um .rej-Files von fehlgeschlagenen "patch"-Versuchen mit etwas mehr Heuristik doch noch anwenden zu können. Zweitens um Texte nicht nur zeilenweise, sondern innerhalb von Zeilen auch wortweise vergleichen zu können. Und drittens um Patches anzuwenden, von denen einem das Original fehlt, aber man mit einer bereits anderweitig geänderten Version der Originaldatei arbeitet. Wiggle kann als diff-, patch- und merge-Tool eingesetzt werden. Außerdem kann es aus mit Konfliktmarkern versehenen 3-Wege-Merge-Files die drei Textvarianten extrahieren.
wikitrans-1.3-2/text/raspbian: Mann MediaWiki-Markup welches z. B. von der Wikipedia benutzt wird in andere Formate umwandeln. Konkret in "html", "texi", "text" und "dump" (JSON mit proprietärem Layout). Keine der Optionen funktionierte zufriedenstellend als ich es teste. Insbesondere die erzeugten Tabellen waren umbrauchbar (transponiert oder unselig mit verschachtelten Untertabellen verschmolzen).
windowlab-1.40-3/x11/raspbian {window manager}{GUI}{X11}: Ein sehr schlanker Fenster-Manager für X11. Bei einen kleinen Test mit ca. 8 offenen Fenstern belegte er 6 MB RAM und nur 2 MB mehr an virtuellen Speicher. Stellt am oberen Fensterrand einen Taskbar zur Auswahl bereits laufender Applikationen dar, wobei in der Standard-Einstellung sowohl der Titelbalken des aktuellen Fensters als auch der zugehörige Eintrag im Taskbar besonders knallig (schwarze Schrift auf gelbem anstatt grauem Hintergrund) und daher sehr gut sichtbar hervor gehoben werden. Je mehr Einträge der Taskbar bekommt, desto schmaler werden sie, bis man schließlich überhaupt nichts mehr erkennen kann. Immerhin kann man mit dem Mausrad über der Taskleiste die einzelnen Fenster durchscrollen und dabei aktivieren, was in solchen Fällen ein Notanker sein mag. Weitere Panels als den Taskbar (den man weder ausblenden noch verstecken kann) gibt es nicht, und damit auch keine Möglichkeit zur Uhrzeitanzeige - zumindest nicht aus eigener Kraft dieses Fenstermanagers. Resizen von Fenstern geht nur unter Zuhilfenahme der Tastatur und ist einigermaßen originell: Man muss bei gedrückter [Alt]-Taste zuerst außerhalb des Fensters (beim Verkleinern) oder innerhalb des Fensters (beim Vergrößern) irgendo hin klicken, und dann bei weiterhin niedergehaltenen Tasten gegen diejenige Kante des Fensters "drücken" die man dadurch verschieben will. Am Titelbalken der Fenster (deren einzige "Verzierung") gibt es nur rechts 3 Symbole: Minimieren, Z-Reihenfolge ändern (ganz nach oben falls es dies noch nicht ist, andernfalls ganz nach unten), Schließen. Fenster erhalten durch Anklicken den Eingabefokus, kommen aber deswegen nicht nach oben. Dazu muss man entweder das oben erläuterte Icon auf dem Titelbalken anklicken, oder einen Doppelklick auf den Titelbalken machen wodurch das Fenster direkt nach oben gebracht wird. Es *gibt* auch ein Menü, welches man dadurch anzeigt dass man außerhalb jedes Anwendungsfensters auf den rechten Mausknopf drückt. Allerdings ist dieses extrem primitiv: Es kann nur eine einzelne Zeile von Einträgen (nicht etwa mehrere Menüs zum Aufklappen!) anzeigen, die dann ein beliebiges Shell-Kommando starten können, das man in einer Konfigurationsdatei hinterlegt hat. In Kombination mit "dmenu_run" und "dmenu" aus dem "suckless-tools"-Paket kann man aber auch aus diesem primitiven Menü noch brauchbare Funktionalität herausholen. Eigene Tastenkürzel für zu startende Programme oder Funktionen des Fenstermanagers kann man nicht festlegen. [Alt]+[Tab] wird unterstützt; für die Gegenrichtung wird interessanter Weise aber nicht [Umschalt]+[Alt]+[Tab] verwendet wie üblich, sondern [Alt]+[q]. Eigentlich ist das sogar bequemer, zumindest mit einer deutschen oder englischen Tastaturbelegung weil [Tab] und [q] dann direkt neben einander liegen. Ansonsten gibt es nur noch [Alt]+[F11] zum Maximieren (wofür es kein Icon gibt) und [Alt]+[F12] was dasselbe tut wie das Icon für die Z-Anordnung. Der zu verwendende Font und Farben lassen sich mit Kommandozeilenoptionen festlegen, aber offenbar nicht über Konfigurationsdateien. Es gibt auch keinerlei Unterstützung des WM beim Anordnern der Fenster, wie etwa Snapping oder Kantenwiderstand. Man kann bzw. muss das pixelgenau mit der Hand machen. Dock Apps werden *nicht* unterstützt. "Enhanced Windows-Manager Hints" werden vermutlich ebenfalls nicht unterstützt. Mit anderen Worten: Sehr primitiv. Ein Vorteil ist dass man wegen der wenigen Tastenkombinationen und Funktionen auch kaum etwas falsch machen kann, es bis auf die Menüeinträge nichts zu konfigurieren gibt, und die Lernkurve entsprechend flach ist. Ein vielleicht halbwegs guter WM für komplette DAUs, denen man dabei nicht viel erklären muss.
wine-1.8.7-2/otherosfs/raspbian: Wenn man es unter Raspbian startet, kommt nur eine lapidare Fehlermeldung dass das Kernel anders kompiliert sein muss um WINE ausführen zu können, und das war es dann. *Schwach*. Angeblich gibt es irgendwo einen inoffiziellen WINE-Build zum Downloaden der auch mit dem normalen Raspbian Kernel funktionieren soll, aber davon hat jemand der *dieses* Paket installierte natürlich nichts.
wing-0.7-27.1/games/debian {game}: Ein von-oben-nach-unten scollendes Weltraumballerspiel. Im Gegensatz zu Galaga kann man sich nicht nur links/rechts, sondern auch rauf/runter bewegen. So kann man ballernde Feinde auch überfliegen und ihren Schüssen entgehen, obgleich man selbst normalerweise nur nach oben schließen kann. Die Feinde sind relativ groß; das Vermeiden von Kollisionen ist teils schwieriger als das Ausweichen von Schüssen. Funktioniert am Raspberry Pi Model 1 passabel, obgleich nur rund 1/4 des Bildschirms ausgenutzt wird. Das Spielfeld ist von einem entsprechend großen schwarzen Rahmen umgeben. Jedoch hat dieses Spiel ein riesiges Problem: Es läuft offenbar immer proportional zur CPU-Geschwindigkeit. Dadurch ist es bereits auf eine Raspberry Pi 3 unspielbar schnell, und es gibt auf keine Möglickeit eine Verzögerung oder dergleichen einzustellen. Man sollte zwar meinen dass dieses Problem leicht gepatched werden könnte, aber in der ausgelieferten Form ist wing leider auf schnelleren Rechnern unbrauchbar.
wireless_tools 30.pre9-1/core/archlinux: Ein Legacy-Paket welches das "iwconfig"-Tool enthält. Dieses tut dasselbe tut wie "iw", allerdings mittels eines veralteten APIs namens "wext" und auf mehrere Kommandos aufgeteilt. iwconfig setzt die Betriebsparameter der WLAN-Karte, iwlist zeigt diese an, iwspy analysiert beobachtete Parameter aus dem Funkverkehr fremder WLAN-Sender, iwpriv erlaubt den Zugriff auf treiberspezifische Features, und iwevent erlaubt es WLAN-Netzwerk-Ereignisse zu "monitoren". "iw" implementiert all diese Kommandos weitgehend äquivalent über ein anderes API in einem einzelnen Executable. Die einzelnen Tools von wireless_tools sind kleiner als besagtes Executable, doch das gesamte Paket hat den doppelten Installationsunfang (370 statt 150 KB).
wmaker-0.95.7-8/x11/raspbian {window manager}{GUI}{X11}{WM Dock}: Der "Window Maker"-Fenstermanager, früher als "WindowMaker" bezeichnet. Auch die Kurzbezeichnung "WM" ist für ihn verbreitet, allerdings nur im Kontext von Dock Apps. Ich habe Window Maker nie benutzt bzw. fand ihn gräßlich und habe hier nur deshalb einen Eintrag für ihn gemacht, da er für seine "Dock-Apps" berühmt ist. Eine solche Dock-App, oft als "WM Dock App" bezeichnet, ist ein 64 x 64 Pixel großes animiertes Icon bzw. winziges Fenster, das irgendwelche Informationen wie CPU-Auslastung und dergleichen anzeigt. Alle Dock Apps werden von der Anwendung welche die Docks bereit stellt (meist dem Fenstermanager selbst, aber es könnte auch eine "Panel"-Anwendung sein) automatisch in einem speziell dafür vorgesehenen Bereich des Desktops angezeigt, üblicherweise entlang eines der Bildschirmränder. wmaker hat dabei den Standard etabliert wie solche Dock Apps funktionieren sollen, und es gibt dutzende Dock Apps welche nach diesem Prinzip arbeiten. Sie lassen sich aber nicht nur mit wmaker einsetzen, sondern auch mit jedem anderen Fenstermanager welche den WM Dock "Standard" beherrscht bzw. nachbildet. Ein solcher Fenstermanager ist fluxbox. Generell wurden alle solchen Fenster-Manager sowie alle Dock Apps hier im Kontext dieser Software-Aufstellung mit der Kennzeichnung {WM Dock} markiert. Ohne eine Anwendung oder Fenstermanager der ein Dock bereit stellen, lassen sich WM Dock Anwendungen in der Regel nicht sinnvoll verwenden. wmaker bringt ein Utility "wmsetbg" mit, welches den Desktop-Hintergrund setzen kann. Es scheint zumindest JPEG-Dateien laden zu können.
wmclockmon-0.8.1-3/x11/raspbian {WM Dock}{reminder}: Eine optisch recht hübsch gemachte Digitaluhr mit Datum- und Sekundenanzeige. Durch Mausklick wechselt sie zwischen normaler und hintergrundbeleuchteter LCD-Optik. Das Programm ist eine sogenannte "Dock App" für den "Window Maker"-Fenstermanager. Weiters wird ein grafisches Konfigurationsprogramm mitgeliefert wo man auch beliebig viele Alarme einstellen kann, zu einer beliebigen Uhrzeit und mit einer Textnachricht. Jeder Alarm kann selektiv aktiviert oder deaktiviert werden, und entweder an einem bestimmten Wochentag (ulkig: nur als Zahl 1-7 auswählbar, man darf raten on "1" Montag oder Sonntag sein soll) oder täglich ausgelöst werden. Es gibt 3 Modi: Normal, "Internet-Zeit" (vermutlich UTC) oder "Binär" (lustig aber völlig sinnlos). Es gibt noch ein zweites mitgeliefertes GUI-Programm, das einen einfachen Kalender darstellt in den man immerhin pro Tag einen Eintrag (beliebiger mehrzeiliger Text; für alle Termine dieses Tages) eingeben kann, und auch Einträge die monatlich oder jährlich wiederholt werden können. Es ist stark zu vermuten, dass man sowohl die Alarme als auch den Kalender irgendwie über das Uhr-Fenster aufrufen können sollte, aber das gelang mir nicht. Möglicherweise fehlt irgend eine Dienst-Komponente des "Windows Maker"-Frameworks, die ich nicht installiert habe. Auf jeden Fall war das Programm leider weitgehend unbrauchbar aufgrund dieser Mängel.
wmcpuload-1.0.1-6/x11/raspbian {WM Dock}: Eine "Window Maker" Dock-App, welche in hübsch gemachter LCD-Optik offenbar die CPU-Auslastung anzeigen sollte. Man kann auch einen "Alarm"-Wert konfigurieren, bei dessen überschreiten die "passive" LCD-Anzeige "beleuchtet" wird. Leider tut diese App nicht sinnvolles, bzw. springt ständig zwischen 0 und 100 % herum, ohne die echte CPU-Belastung anzuzeigen. Offensichtlich fehlerhaft und daher unbrauchbar. Möglicherweise kommt sie nicht mit MultiCore-Systemen zurecht.
wmhdplop-0.9.10-1/x11/raspbian {WM Dock}: Eine "Window Maker" Dock-App, welche eigentlich die Hard-Disk-Aktivität grafisch darstellen sollte. Es könnte darüber hinaus sogar die Temperaturen darstellen. Aber leider jammert es immer dass es keine Festplatten gefunden habe, selbst dann wenn man ihm den Pfad direkt angibt. Vielleicht liegt es auch daran dass es nur mit echten Festplatten arbeitet, während mein Testsystem von einer SDXC-Karte lief. Wie auch immer, es funktionierte zumindest unter diesen Umständen nicht und war dann unbrauchbar.
wmifs-1.8-1/x11/raspbian {WM Dock}: Eine "Window Maker" Dock-App, welche ein simples Verlaufsdiagramm (monochrome Pixelbalken) der Netzwerk-Aktivität anzeigen kann. Neben dem Verlauf werden noch "Lämpchen" angezeigt, die bei Upload- und Download-Aktivität flackern. Ein weiteres Lämpchen signalisiert den Zustand der Schnittstelle, ob sie aktiv ist ("up") oder nicht. Die App kann zwar nur eine einzelne Netzwerkschnittstelle anzeigen, jedoch lassen sich mehrere Instanzen der App für unterschiedliche Schnittstellen starten.
wmmemload-0.1.6/x11-plugins/gentoo: Zeigt eine hübsche Digitalanzeige an welche den Prozentsatz von genutztem RAM und Swap-Space anzeigt. Ähnlich wie xload primär dazu gedacht, in die Traybars diverser WMs integriert zu werden. Man kann auch Alarme setzen falls die beiden Werte einen bestimmte Prozentpunkte überschreiten. Doch nun die Nachteile: Grafik zwar schön, aber Bitmap und nicht skalierbar. Die Werte sind überdies *über* einander dargestellt, was schlecht für horizontale Panele geeignet ist. Am schlimmsten ist aber dass der Cache im genutzten RAM eingerechnet wird. Das macht diesen Wert nahezu sinnlos, da praktisch immer der meiste freie RAM als Cache verwendet wird statt gänzlich ungenutzt zu bleiben.
wmmon-1.1+20131205-1.1/x11/raspbian {WM Dock}: Eine "Window Maker" Dock-App, welche die (per Mausklick umschaltbar) die folgenden Informationen anzeigen kann: CPU Auslastung Balken- sowie Verlaufsdiagramm, Disk I/O Balken- sowie Verlaufsdiagramm, RAM- und Swap-Auslastung Balkendiagramme (zusammen mit der "Uptime" in Days und HH:MM:SS). Man kann auch 3 Programme konfigurieren, welche beim Klick mit einem der 3 Mausbuttons auf das Dock-Icon der App gestartet werden. Alternativ zum Umschalten zwischen den einzelnen Modi mit der Maus kann man auch nur einen einzigen davo anzeigen lassen, und dafür mehrere Instanzen der App in unterschiedlichen Modi starten. Das Balkendiagramm der CPU-Auslastung zeigt für jede CPU einen horizontalen Balken an, die ohne jeden Abstand direkt über einander angeordnet sind. Es gibt allerdings einen alternativen Modus, der nur noch einen Balken anzeigt, allerdings ist unklar *was* dies dann anzeigen soll: Maximum aller CPUs? Durchschnitt? Der Modus kann nämlich angeblich beides anzeigen. Und was zeigt dann das Verlaufsdiagramm an? Dassselbe? Etwas anderes? Völlig unklar ist woher das Programm seine "Disk I/O" bezieht; auf meinem System (von einer SD-Karte laufend) zeigte es jedenfalls gar nichts an. Bei der Speicherauslastung lässt sich immerhin festlegen, ob man Buffer- und Page-Cache als benutzten oder freien Speicher anzeigen möchte. Insgesamt leidet die App darunter dass man keine Ahnung hat was die angezeigten Werte bedeuten, und teilweise erscheinen sie auch nicht sehr glaubwürdig sondern springen ständig wie wild herum. Auch das Intervall für die Wert-Erfassung oder Display-Updates lässt sich nicht einstellen. Aus diesen Gründen eher unbrauchbar.
wmnd-0.4.17-2/net/raspbian {WM Dock}: Eine "Window Maker" Dock-App, welche den Datenverkehr einer Netzwerkschnittstelle anzeigt. im Vergleich zu wmifs ist die Anzeige etwas ausführlicher, da die aktuelle Up- und Downloadrate auch numerisch angezeigt wird. Dafür fehlt wmnd allerdings der "up"/"down"-Indikator für den Zustand der Schnittstelle. Insgesamt wirkt wmnd "nervöser" als wmifs. Dafür hat es aber verschiedene umschaltbare Diagrammformen für das Verlaufsdiagramm, und mehr Optionen. Beide Apps sind recht schlank, wmnd verbraucht etwas weniger RAM, alloziert dafür allerdings etwas mehr virtuellen Speicher. Außerdem erlaubt es wmnd, ein benutzerdefiniertes Kommando zu starten wenn man auf dem unteren Bereich des Diagramms klickt.
wmpuzzle-0.5.2-2/games/raspbian {WM Dock}{game}: Eine "Window Maker" Dock-App, die ...
wmsun-1.05-1/x11/raspbian {WM Dock}: Eine "Window Maker" Dock-App, die ...
wmsysmon-0.7.7+git20150808-1/x11/raspbian {WM Dock}: Eine "Window Maker" Dock-App, die ...
wmtime-1.4-1/x11/raspbian {WM Dock}: Eine "Window Maker" Dock-App, die ...
wordpress/www-apps/gentoo: CMS in PHP geschrieben. Danke. Nächster, bitte.
worker-3.8.5-2/x11/raspbian {file manager}{GUI}{X11}: Ein in extrem hässlicher Optik gehaltener X11-Dateimnager, die fast schon an die grausigen "Athena Widgets" erinnert. Allerdings wäre dies nicht das Problem, da das Programm schlank und auch angenehm über die Tastatur zu bedienen ist. Das Problem ist vielmehr, dass auch dieses Programm leider einer jener unseligen Dateimanager ist, der ständig die CPU belastet auch wenn es absolut nichts zu tun hat. Zwar nur wenig, aber doch: Rund alle 500 Sekunden Echtzeit wird 1 CPU-Sekunde verschwendet. Dennoch läppert sich dies wenn man das Programm wochen- und monatelang laufen ließe. Teilweise liegt das Problem an der Default-Konfiguration, wo etwa die Uhrzeit auf Sekunden genau angezeigt wird und entsprechend jede Sekunde neu angezeigt werden muss. Diese und andere Dinge welche periodisch Zeit verbrauchen lassen sich in der Konfiguration zwar abschalten und damit die CPU-Verschwendung noch deutlich weiter senken. Ganz auf 0 geht sie deswegen aber nicht herab. Daher ist dieses Programm für mich indisktutabel. Obwohl es schade ist, da es ansonsten sehr nett wäre und man vor allen nahezu jeden Aspekt anpassen kann. So kann man die Buttons beliebig in umschaltbaren "Banks" erweitern, und dabei sowohl auf eingebaute als auch externe Kommandos zurück greifen. Tabs, Verlauf und Kommandozeile werden ebenfalls unterstützt. Es gibt eine zwar hässliche aber doch vorhandene ausführliche GUI-Konfiguration für alle Einstellungen. Das Programm ist ressourcenschonend und startet rasch. Wenn nur die Sache mit der permanenten CPU-Belastung nicht wäre, so gering sie auch sein möge.
worldofpadman/games-fps/gentoo {game}: Comichafte Batman-Verarschung. Lustig, nett, etc., aber leider nur für Multiplayer mit ausreichender Ping-Rate.
wrap-0-1330-g120af10/https%3A%2F%2Fgithub.com%2Fpaul-j-lucas%2Fwrap.git/git {text-formatting}: Sehr schlanker, in C geschriebener Text Re-Formatter, der auch mit UTF-8 problemlos zurecht kommt. Verwendet Autotools mit vielen configure-Tests, daher vermutlich sehr portabel. Ein typischer UNIX Filter. Kann auch Quelltext-Kommentare reformattieren. Spezieller Support für das Reformatieren von MarkDown-Quelltext inklusive Tabellen. Leider wegen sehr vieler Optionen die teilweise zwingend erforderlich sind umständlich zu bedienen; man sollte das Utility daher besser über ein Script aufrufen welches die korrekten Optionen setzt, anstatt direkt.
wvdial/debian: Just a wrapper around pppd, replacing "chat" by heuristics how to connect. If you get pppd working directly using pppconfig, there is no reason to use wvdial.
wxGTK-2.8.10.1-r5/x11-libs/gentoo: GTK+ version of wxWidgets, a cross-platform C++ GUI toolkit. Pro: Uses native controls on each platform, available on many platforms (including Windows, Apple and Linux), provides solution to most common portability issues (threads, standard dialogs, filename abstraction, graphics, ODBC, printing) and also provides a high-level model for document-centric applications (document templates, views), conversion from existing MFC-based apps is easy. Con: Very bloated, large DLLs, based on old-style C++ with no C++ templates, RTTI oder even exceptions, heavy usage of C macros, very similar to Microsoft's MFC, poor error handling, UTF-16 based strings.
wxhexeditor-0.22/app-editors/gentoo {hex-editing}{GUI}{X11}: Ein sehr komfortabler mit wxWidgets implementierter Hex-Editor. Der beste bisher. Ist für das Editieren riesiger Dateien und Block-Devices geeignet, und versucht nicht vorher alles in den RAM zu laden wie so manch anderer Hex-Editor. Der Hauptbereich des Fensters besteht aus drei Spalten für Offset, Hex-Dump und Character-Dump. Man kann die Gruppierung der Hex-Ziffern in der Zeile frei konfigurieren, voreingestellt sind Gruppen aus je 2 Ziffern. Beim Encoding für den Character-Dump kann aus verschiedenen Zeichensätzen gewählt werden, auch alle UTF-Varianten (außer UTF-7) sind darunter. Die Zeilen sind alternierend eingefärbt, um auch breitere Zeilen im Blick halten zu können. Per Default passt sich die Zeilenbreite an die Fensterbreite an; man kann kann aber auch eine fixe Limitierung einstellen (16 Bytes bieten sich häufig an). Schriftgröße und Farben lassen sich anpassen. Man kann zwischen Read- und ReWrite-Mode umschalten, das verhindert irrtümliche Änderungen. Zudem gibt es noch einen DirectWrite-Mode zum direkten Schreiben auf den Datenträger ohne Verzögerung aufgrund von Delayed Writeback des OS oder Dateisystems. Man kann mehrere Dateien gleichzeitig in Tabs öffnen und auch mittels Pulldown-Menü zwischen ihnen umschalten. Ebenso merkt sich das Programm die zuletzt bearbeiteten Dateien zum schnellen Öffnen. Das Menü bietet einige Spezialfunktionen, wie das Berechnen von vielen Hash-Funktionen über den Dateiinhalt. (Es gibt auch mehrere CRC-Varianten, doch seltsamerweise kein CRC-64.) Ungewöhnlich ist die XOR-Ansicht, wo man einen Text oder Hex-String eingibt, und dieser wird dann - nur für die Anzeige - zyklisch mit dem Dateiinhalt bitweise ge-XOR-ed. Vielleicht hilfreich bei besonders dümmlichen "Verschlüsselungen". Des weiteren gibt es eine Vergleichsfunktion für zwei Dateien. Dabei kann man wählen ob Unterschiede oder gleiche Bytes markiert werden sollen. Die maximale Anzahl der Suchergebnisse kann beschränkt werden. Ebenso kann man einen Toleranzwert angeben, wo Trefferbereiche die nahe genug bei einander liegen als ein Trefferbereich angezeigt werden. Das Vergleichergebnis erscheint als neue virtuelle Sicht mit eingefärbten Treffer-Bereichen. Neben Dateien lassen sich auch direkt aus dem Menü Block-Geräte und sogar das Speicherabbild laufender Prozesse auswählen (entsprechende Berechtigungen natürlich vorausgesetzt). Neben dem Hauptbereich des Fensters gibt es noch mehrere Werkzeugfenster, die sich bei Bedarf links und rechts von Hauptfenster andocken lassen. Eines davon zeigt die Bytes ab der aktuellen Stelle in unterschiedlichen Repräsentationen gleichzeitig an: Als 8-, 16-, 32- und 64-bit Integer, sowie als 32- und 64-Bit Fließkommazahl. Für die Integers kann man dabei zwischen Signed- und Unsigned-Darstellung umschalten, bei allen Darstellungsvarianten kann man zwischen Big- und Little Endian umschalten. Ein anderes Fenster ist das Disassembler-Fenster, welches die Bytes ab der aktuellen Position als Maschinen-Instruktionen interpretiert und in Assembler-Syntax anzeigt. Unterstützt werden offenbar 16-, 32- und 64-Bit Befehlssätze der x86-Architektur, wahlweise in INTEL oder AT&T Syntax. Leider werden nur ein paar wenige Instruktionen angezeigt, so dass es kein Ersatz für ein richtiges Disassembler-Listing ist. Aber fürs schnelle Finden von Stellen zum Patchen reicht es wenn man die ungefähre Position kennt. Alles in allem ein großartiges Programm. Sein einziger Nachteil ist dass es relativ groß und fett ist, und durch seine Abhängigkeit von den noch viel fetteren wxWidget-Runtime-Libraries wenig für eine Installation auf minimalistische Rettungs-Systeme taugt bei denen ein möglichst geringer Installationsumfang wichtig ist. Andererseits, wenn man andere wxWidgets-Programme wie Audacity ohnehin bereits installiert hat, ist der Zusatz-Platzbedarf gering.
wyrd-1.4.4-1/utils/debian {PIM}{reminder}{text-terminal IO}: A ncurses-based "graphical" text-mode user interface for "remind".
x-tile-2.5-3/x11/raspbian: Ein lustiges in Python geschriebenes GUI-Programm zum Kante-an-Kante-Anordnen von Fenstern. Unterstützt dabei alle möglichen Fenster-Konfigurationen, wie vertikal, horizontal, quadratisch und noch einige mehr. Welche Fenster betroffen sein sollen, kann man vorher in einer Liste ankreuzen (oder es nimmt alle Fenster). Das Programm könnte nützlich in Kombination mit besonders unfähigen/primitiven Fenstermanagern sein, die keine entsprechenden Optionen von sich aus anbieten. Andererseits könnte man sich bei einem Installationsumfang von 1,3 MB auch fragen, ob man diese nicht vielleicht besser gleich in einen fähigeren Fenstermanager investiert hätte.
x11-apps/x11/debian {calculator}{bitmap image editor}: Multiple small but useful X11 utilties. The most useful ones are described in the following. atobm, bitmap, and bmtoa: Edit or manipulate bitmap images. oclock and xclock: Graphical clocks. xcalc: Scientific calculator (RAM usage: 4,6 MB). xclipboard: Manage cut-and-pasted text selections. xconsole: Show system console messages. xcursorgen: Create X cursor files from PNGs. xedit: Simple text editor. xeyes: Pair of eyes tracking the cursor. xload: Show system load average. xmag: Magnifies parts of the X screen. xman: man page browser. xmore: text pager. xwd: Save screenshots (whole screen or window selected by user) in a custom format which can be converted into any file format by ImageMagick. Regarding xcalc, this program can either emulate a TI-30 (normal algebraic input) or a HP-10C (stack-based RPN input). All buttons can be swapped/repositioned by modifying a configuration file. It is also possible to define colors for the buttons by editing another configuration file. Clicking on the displayed number will make it into the current X11 selection, allowing the results to be pasted elsewhere. Unfortunately, there seems to be no way to paste an externally selected number into xalc.
x11vnc-0.9.9/x11-misc/gentoo {KVM sharing}: Ein TightVNC-Server, der die Daten nicht von einem virtuellen Bildschirmspeicher abgreift den er selbst verwaltet, sondern von der tatsächlich am PC laufenden X11-Session. Funktioniert auch via SSH: Einfach ssh mit "-L5900:localhost:5901" aufrufen, in der SSH-Session x11vnc starten, und schon kann man am Rechner wo der Benutzer sitzt mit einem TightVNC-Viewer von Port 5900 durch den Tunnel den entfernten X11-Bildschirminhalt fernwarten.
x2vnc/x11-misc/gentoo {KVM sharing}: Imagine one has two computers, both with linux installed, but one often has to run Windows when working, and one just got tired of switching between the two keyboards. While running this program one can move the mouse pointer beyond the right edge of the X display, and then the pointer will appear on the screen on the other computer.
xapian-1.2.14/dev-libs/gentoo: A full-text database and search engine library for embedding into applications. Uses B+ trees for data storage and is limited to 2^32 documents. Each document is made of "document data" (a single blob such as a filename, database key or whatever is used to locate the original document), "terms" (typically the words of a text with information about their position in the original document) and "values" which are key-value datasets where key is a 32 bit identifier ans the value is a blob. Xapian also supports stemmers which "normalize" different variation of a term in a common base form of that term. Furthermore, it supports stop words which are terms deemed to occur too frequently in the documents, so they are left out and are simply ignored when creating the database (or when searching). Although terms are typically words in a text, they can actually represent anything and are treated as blobs with a size up to 254 bytes. Document maximum size varies with database configuration such as block size, but is typically somewhere around 100 MB. Values could theoretically be as large as documents, but for performance reasons they should not be longer than a dozen of bytes or so. Values are intended to store numbers or identifiers, not complete sub-documents. The B+ Tree uses 32 bit block numbers, which means with the default block size of 8 KiB a database cannot be larger than 32 TiB. However, the block size can be up to 64 KiB, allowing for a maximum DB size of 256 TiB. Queries can find documents which match logical expressions containig terms, value ranges and operators. Logical operators are AND, OR, AND_NOT, AND_MAYBE. Term operators are NEAR, PHRASE and HAS_PREFIX. Value operators are LESS_OR_EQUAL, GREATER_OR_EQUAL and VALUE_RANGE. A parser is available which creates query expression objects from a Google-like search expression in text form. Those can also include parenthesized subexpressions and define a default operator (AND or OR) to be used to combine words in the query expression text. The result of a query can be filtered again using AND and OR operators. Xapian automatically sorts results by relevance ("rank"), and several ranking algorithms are built in and can be selected. It is also possible to define one's own algorithm.
xarchiver-1 {compression}: 0.5.4-1+deb8u2/x11/devuan: Der native Archiv-Manager der LXDE-Oberfläche, hat aber keine speziellen Abhängigkeiten von LXDE. Unterstützt alle wichtigen Formate für gepackte Archive. Beherrscht alle Funktionen welche man von einem Archiv-Manager erwartet. Hat eine auf GTK+ 2 basierende grafische Oberfläche.
xautolock-1: 2.2-4/x11/debian: Ruft nach einer gewissen Weile des Ausbleibens von X11 Eingabe-Events einen externen Befehl auf, der den Bildschirm sperren oder sonstwas tun kann. Problem: Kümmert sich nicht um die üblichen Maßnahmen von Video-Playern, mit denen diese Verhindert dass ein "richtiger" Bildschirmschoner wie xscreensaver sich aktiviert.
xbindkeys-1.8.4/x11-misc/gentoo: Ein mit 300 KiB wirklich nicht großes Programm, welches beliebige Kommandos als Reaktion von X-Input-Events wie Tastatur, Maus oder Multimedia-Tasten starten kann. Die meisten größeren Desktop Environments und Fenstermanager haben diese Funktionalität bereits eingebaut so dass die Erfordernis für dieses Programm dort nicht besteht. Aber für minimalistische Fenstermanager kann das Programm eine nützliche Ergänzung um diese Funktionalität darstellen. Zusammen mit "xev" (zum Ermitteln der Tastencodes) und "xmodmap" (zum Zuordnen der ermittelten Tastencodes zu symbolischen Namen welche xbindkeys einer Aktion zuordnet) lässt sich so eine komplette Lösung für die Abfrage und Funktionalität von Multimedia-Tasten implementieren. xbindkey kann optional Scheme (guile) als Scriptsprache benutzen sowie ebenfalls optional ein Tk-basiertes Anzeigeprogramm für die Tastaturzuordnungen bereit stellen. Die Konfigurationsdatei selbst ist eine simple Textdatei. Trotz der grundsätzlichen Nützlichkeit des Programms besteht das Problem, dass selbst kleinste Fenstermanager wie twm inzwischen selbst Tasten irgendwelchen Befehlen zuordnen kann, so dass kaum noch Bedarf an diesem Programm besteht, wenn man nicht gerade einen besonders absonderlich minimalen Fenstermanager benutzt.
xbmc-11.0/media-tv/gentoo {audio}{music}: Eine Multimedia-Komplettlösung, die nicht in einem Fenster läuft sondern das Display komplett übernimmt. Sieht optisch sehr ansprechend aus, unterstützt auch so ziemlich alle relevanten Audio-, Video- und Bildformate, sowie Internet-Radio und Streaming. Auch TV-Karten, Wetterprognose usw. sind via einem reichhaltigen Plug-In-Angebot verfügbar. Nur Videorecorder-Funktion zur Aufzeichnung von TV-Wiedergabe hat das Ding noch nicht. Metadaten für wiedergegebene Medien (Künstlerinfo, Albumcover usw) können automatisch übers Internet geholt werden. Ebenso kann das Ding als Web-Server agieren um sich fernsteuern zu lassen. Und das beste: Es funktioniert perfekt out-of-the-box mit der IR-Fernbedienung, die ich jüngst erworben habe (offensichtlich irgend eine unter Windows übliche Standard-Tastenbelegung). Jedoch, Zitat Wikipedia: "But because of its origins from the Xbox game-console, XBMC's graphics renderer runs in a game-loop environment rather than using event-driven and on-demand rendering,meaning that it is constantly re-drawing the GUI even when nothing is changing on-screen. This results in very high CPU and high GPU usage, which can be observed on embedded systems and low-end machines, and hence high temperatures, fan activity, and high power consumption." Ganz so schlimm wie es hier steht ist es zwar nicht, meine Grafikkarte war wärmer als im Normalbetrieb (ohne OpenGL-Aktivität), aber auch nicht sonderlich heiß. Was mich an dem Programm mehr stört, ist dass es das Display komplett übernimmt, und man daher nicht einfach mal zwischendurch zu einer anderen Anwendung wechseln kann. Das Programm ist sicher interessant wenn man sich eine kleine dezidierte Media-Player-Box fürs Wohnzimmer installieren will, aber meiner Meinung nach wenig zielführend auf einem normalen Desktop-System. Auch wenn es klaglos funktioniert.
xbmc/media-tv/gentoo: Media-Center und alles ganz toll, aber: Angeblich pollt das Ding statt auf Events zu warten und zeichnet andauernd den Bildschirm neu auch wenn sich nichts ändert. Entsprechend ein Stromverschwender erster Güte. Kommt angeblich daher, dass es sich ursprünglich um eine XBOX-Anwendung handelt wo im Hintergrund ein Spiel läuft und deshalb ohnehin ständig refreshed werden muss. (Stand 2009-12.)
xcas-1.9.0.35+dfsg2-1.1/science/raspbian {symbolic calculation}{programming language}: Ein in FLTK verfasstes grafisches Front-End für die in C++ verfasstge CAS-Bibliothek "Giac". Ca. 11 MB Download-Umfang, welcher sich jedoch verdoppelt wenn man auch die Giac-Dokumentation dazu installiert. Es handelt sich um eine französische Entwicklung, und das Programm wird angeblich auch häufig im Unterricht verwendet. Aufgrund einer Bibliotheksabhängigkeit und dem Namen des Autors besteht ein Verdacht, dass es gewisse Zusammenhänge mit einem anderen CAS namens "pari" geben könnte (welches allerdings ein Spezial-CAS und kein allgemeines CAS wie xcas ist). Das Programm unterstützt verschiedene Emulations-Modi für die Eingabe und Anzeige von Ausdrücken. Darunter auch die Syntax von Python, MuPAD, Maple, TI-89 und TI-92. Ergebnisse können hochwertig als LaTeX formatiert exportiert werden. Es gibt auch eine Spreadsheet-Anzeige, wo man Eingaben als 2-dimensionale Matrix ähnlich einem Tabellenblatt vornehmen kann. Insbesondere kann man solche Spreadsheets auch aus CSV-Dateien laden oder speichern. Neben dem FLTK GUI bietet xcas auch eine Kommandozeilenschnittstelle mittels dem Utility "icas" (mit readline Support). Es lässt sich auch non-interaktiv nutzen. xcas bietet auch eine eingebaute Programmiersprache welche ähnlich der von maxima und yacas ist; jedenfalls imperativ und kein LISP. Nur ASCII-Strings scheinen von er Sprache verarbeitet werden zu können. Die Sprache wird zudem interpretiert; es ist kein Compiler. Geschwindigkeitsrekorde sollte man sich keine erwarten. Etwas ärgerlich fand ich dass viele xcas-Befehle abhängig von den aktuellen Settings der Session funktionieren. Dort stellt man auch Dinge wie numerische Genauigkeit oder Winkel-Einheiten ein. xcas rechnet dabei immer mit Fließkommarithmetik wenn man Fließkommaliterale in einem Ausdruck verwendet, ansonsten exakt. Die Dokumentation ist im Großen und Ganzen gut, aber in einigen Überschriften gibt es verstümmelte Zeichen (möglicherweise Konvertierungsfehler nach HTML von Symbol-Zeichen).
xclip-0.13-1/x11/debian {clipboard manager}: Eine Kommandozeilen-Anwwendung zum Setzen und Auslesen der X11 Selections. Ist unter den meisten Distributionen als Paket verfügbar. Sehr hilfreich, wenn man etwa aus einem Script heraus Text oder Dateinamen dem X11 Clipboard entnehmen möchte, damit der Benutzer sie nicht direkt als Script-Argumente angeben muss.
xdelta3-3.0.11-dfsg-1+b1/utils/debian xdelta-3.0.4/dev-util/gentoo {binary-diff}{deduplication}: The xdelta3 utility implements the VCDIFF algorithm as defined in RFC 3284 ("Generic Differencing and Compression Data Format"), which is intended to create a portable, machine-independent binary delta file from two input files. It therefore creates binary diffs and applies binary patches. However, the results are usually inferior in size reduction compared to "diff -U0 | bzip2", even if the xdelta diff is compressed using bzip2 rather than the (rather ineffective) builtin zip compression. But this is only true when diff'ing source archives. The more binary data is included within a diff, the better xdelta gets away compared to the diff method. Nevertheless, xdelta performance is not too impressive. On the other hand, it adds checksum information to the patches which makes xdelta patches more secure than context diffs. bdelta is a more efficient binary deltification tool, but it is not as standardized and as portable and as mature as xdelta is. The sizes of 4 different kinds of compression windows/buffers used by the VCDIFF algorithm can be overridden for enhanced tuning. xdelta3 provides multiple internal compressors which can be automatically applied to the VCDIFF deltified data before output (lzma, djw, gfk, none) with selectable compression level. Checksum inclusion and even writing of the data format header can be disabled to make the output file smaller. xdelta3 can also be used as a mere compression program, by only providing a single input file. xdelta3 can also merge multiple existing binary patches into a single combined patch. Furthermore, there is an option to re-code existing deltas with new settings.
xdm-1.1.11-r1/x11-apps/gentoo: Der Standard-Displaymanager von X11. Schmucklos, primitiv - und man könnte vergleichsweise durchaus sagen: häßlich. Er bietet genau zwei Felder an, eines zum Eingeben des User-Namens und eines zum Eingeben des Passwords. Weder gibt es einen Button um die Anmeldung auszulösen (dies erfolgt durch das Drücken der Eingabetaste nach dem Eingeben des Passworts) noch Buttons um eine bestimmte Art der Sitzung auszuwählen, noch Buttons um das System herunterzufahren oder neu zu starten. Alle fehlenden Buttons kann man allerdings selbst realisieren, indem man in der Konfiguration von XDM angibt dass er weitere Programme im Hintergrund starten soll sobald er das Login anzeigt. Diese Programme können dann am X-Display des xdm die entsprechenden Buttons oder Eingabefelder in darüber gelegten Fenstern anzeigen und entsprechend die vermissten Funktionen implementieren. Man kann dies etwa einfach mittels Tcl/Tk realisieren - an der "Schönheit" des ganzen verbessert dies freilich nichts. Xdm bietet ferner Tastenkombinationen (die man zum Teil erst in der Konfiguration freischalten muss) für grundlegende Operationen wie den X-Server (von xdm selbst) neu zu starten, oder xdm zu terminieren so dass man in die Textkonsole zurück fällt (es sei denn der init Daemon wurde angewiesen xdm in diesem Fall automatisch neu zu starten). Im Rahmen seiner erbärmlich wenigen Funktionen kann man den xdm relativ frei konfigurieren; die wenigen angezeigten Texte, Bitmaps und verwendeten Fonts lassen sich frei redefinieren. Allerdings werden nur die häßlichen Bitmap-Fonts des "klassischen" X11 APIs unterstützt. Also keine TrueType Fonts. Ebensowenig wird Anti-Aliasing oder gar Subpixel-Rendering unterstützt. Daher sieht der xdm egal was man tut immer häßlich aus, gemessen an modernen Vorstellungen wie ein Login-Manager auszusehen hat. Das größte Plus von xdm ist sein wirklich geringer Installationsumfang und seine minimalen Abhängigkeiten und geringer Ressourcenverbrauch. Außerdem ist er ein vollwertiger Display-Manager, der alle entsprechenden Vorgaben des Standards erfüllt (etwa die Unterstützung von primitiven und unsicheren Remote-Logins wenn man dies aktiviert). Er kann wahlweise mit Support für PAM, ConsoleKit oder sogar IPv6 (für Remote Logins) gebaut werden. Das vergrößert dem Umfang der Abhängigkeiten dann aber natürlich entsprechend.
xdotool-1: 2.20100701.2961-3+rvt+deb7u3/x11/debian: Ein kleines Tool um Tastendrücke und Mausereignisse an ein X11-Fenster zu senden. Erfordert allerdings die XTEST-Erweiterung im X-Server. Die solchermaßen erzeugten Keyboard-Events sind des weiteren mit einem speziellen Flag gekennzeichnet, das viele Programme erkennen und dann als Input-Events ignorieren. Andere Programme wie Xterm muss man erst speziell konfigurieren dass sie derartige Tasten-Events anerkennen. Neben dem Senden von Mausbewegungen, einzelnen Tasten oder Zeichenketten bietet es auch Kommandos zum Suchen von Fenster anhand diverser Merkmale, kann ermitteln zu welchem Prozess ein Fenster gehört, welches Fenster aktuell den Eingabefokus besitzt, kann Fenster resizen, verschieben und den Eingabefokus ändern, Fenster verstecken (unmap), sie nach oben oder unten bringen, kann einige Eigenschaften wie Icon oder Fensterklasse eines Fensters ändern, kann die Anzahl der Desktops ermitteln und ändern, den aktuellen Desktop ermitteln und setzen, den Desktop eines Fensters ermitteln.
xfce4-dict-0.6.0/xfce-extra/gentoo: Ein netter grafischer Client für das 'dict'-Protokoll, der sich ins die Xfce4-Panel integrieren lässt. Allerdings entsteht dadurch kein erkennbarer Mehrwert gegenüber einer beliebigen X11-Applikation welche man aus dem Panel startet. Der Client sollte sich auch ohne Xfce4 starten lassen, wenngleich er auch einige dessen Libraries als Abhängigkeiten mitschleppt. Nichts desto trotz ist der Client untadelig gemacht und nützlich. Er kann auch so konfiguriert werden dass er nur auf einen lokal installierten "dict"-Dienst zugreift (typischer Weise app-text/dictd).
xfce4-panel-4.12.1-2/xfce/debian {desktop panel}: Ein sehr komfortables Desktop-Panel mit vielen Features. Es ist ein zentraler Bestandteil des Xfce Desktop Environments, lässt sich aber auch unabhängig von diesem zusammen mit einem anderen Fenstermanager (wie etwa marco) betreiben, der selbst keine Panel-Funktionalität bietet. xfce4-panel erlaubt es beliebige viele Panel-Leisten (Minimum: eine) zu erzeugen und an verschiedenen Bildschirmrändern oder auch frei schwebend anzuordnen. Alle Einstellungen können mit eingebauten Menüs vorgenommen werden, es ist kein Bearbeiten von Konfigurationsdateien vonnöten. Panel-Einträge können mit Drag und Drop verschoben oder für Veränderungen geperrt werden. Jedes angelegte Panel kann mit Plug-Ins bestückt werden, welche die eigentlichen Bedienungselemente enthalten. Obgleich es noch zusätzliche Pakete für zahlreiche weitere Plugins gibt, sind in xfce4-panel selbst folgende Plugins enthalten: Anwendungs-Starter (stellt einen Button zum Starten eines Programms dar, es konnen auch mehrere Programme auf einen Button gelegt werden der dann für das zweite und weitere zugewiesene Programme wie ein Menü ausgeklappt werden kann), Aktionsknöpfe (eine feste Auswahl bestimmter Funktionen, wie Abmelden, Neustarten, von denen aber beschränkt werden kann welche Aktionen im Panel sichtbar sein sollen), Anwendungsmenü (komfortables freedesktop.org-konformes "Startmenü", das automatisch aufgebaut wird und zusätzlich gemäß dem Standard mit XML- und INI-Dateien anpassbar ist; sieht von allen separat installierbaren Paneln noch am besten aus und hat auch den größten Funktionsumfang), Arbeitsflächenumschalter (wechseln zwischen den verschiedenen virtuellen Arbeitsflächen, optional mit Miniatur-Ansicht), Fensterknöpfe (die Taskleiste, welche alle gerade laufenden GUI-Programme anzeigt und deren Fenster aktiviert, kann optional auch gruppieren jedoch muss man eine Gruppe dann mit einem separaten Mausklick aufklappen), Benachrichtigungsfläche (ausgegraut - möglicherweise nur mit weiteren Xfce-Komponenten benutzbar), Fenstermenü (ähnlich wie die Taskleiste, nur vertikal und aus einem kleinen Button heraus aufklappbar - hat den Vorteil dass mehr Einträge Platz finden als in der Taskleiste und auch die Fenstertitel komplett lesbar sind), Schreibtisch anzeigen (versteckt alle Fenster so dass man den Desktophintergrund sehen kann, oder stellt sie wieder her), Trennelement (verschiedene Stile: Durchsichtig, Strich, Punktiert, "Griff"-Optik - kann wie eine Feder optional den restlichen Panel-Platz einnehmen; proportional zu anderen Trennelementen), Uhr (mit eingebautem navigierbaren Kalender, Datum als Tool-Tip, benutzerdefinierbare Schriftart, Zeitzone und Datums/Zeit-Format, mehrere Stile: analog, digital, LCD, binär, in Worten mit verschiedenen Präzisions-Stufen der Formulierung), Verzeichnismenü (stellt einen Dateibaum beginnend mit einem definierten Startverzeichnis als Menüstruktur dar, optional mit simpel gefiltert, und erlaubt einem dann entweder ein Terminal oder einen Dateimanager im gewählten Verzeichnis zu starten). Alles in allem ist xfce4-panel das wahrscheinlich komfortabelste Panel, das ohne überwältigend viele Abhängigkeiten von anderen Komponenten "stand alone" installiert werden kann. Ganz ohne ein paar Xfce-Abhängigkeiten geht es allerdings nicht: 8 Pakete, zusammen mit xfce4-panel selbst 2 MB an Downloads und danach 9 MB Installationsumfang. Doch Xfce selbst (ca. 23 MB Kern-Anwendungen, 73 MB mit allen Optionen) wäre doch noch um einiges umfangreicher. Zur Laufzeit ist der Hilfsprozess xfconfd (4 MB RAM-Bedarf) nötig, während xfce4-panel 30 MB RAM verschlingt, sowie noch durchschnittlich 15 MB RAM pro benutztem Plug-In als separatem Prozess. Wenigstens scheinen dabei die wichtigsten Plug-Ins wie Taskleiste, Startmenü, Uhr und Applikations-Buttons bereits direkt im Hauptprozess enthalten zu sein, und nur eher seltener genutzte Plug-Ins laufen als separate Prozesse. Dennoch - RAM-sparend kann man dieses Panel wohl kaum nennen. Wenn man jedoch genug RAM hat aber einen anderen Fenstermanager als den von Xfce selbst verwenden möchte (etwa marco von Mate), ist xfce4-panel eine schlankere Lösung als Mate oder Xfce komplett zu installieren, und dies immer noch mit gutem Komfort.
xfce4-taskmanager-1.0.0/xfce-extra/gentoo {resource monitor}: Ein Task-Manager der ebenfalls alles bietet was man braucht, der mir persönlich aber weniger gut gefällt als lxtask oder gnome-system-monitor. Obwohl er schlank aussieht, frisst er im Betrieb trotzdem 38 MB RAM. Mit 650 kB Installationsumfang und 100 kB Download-Größe ist er zwar in der Tat der schlankeste der "größeren" Ressourcen-Monitore, aber der gnome-system-monitor ist nicht all zu weit davon entfernt. Oben im Fenster gibt es ein Panel mit ein paar etwas sinnlos wirkenden Buttons wie "Info" (ist aber nur ein "About") und "Beenden" oder zum Starten eines Terminal-Managers oder beliebiger Programme. Der einzig sinnvolle Button ist der zum Öffnen der Einstellungen, aber da hätte es ein schlichtes Pull-Down-Menü auch getan. Ansonsten befinden sich noch zwei Diagramme im oberen Panel, welche CPU- und Speicherauslastung anzeigen. Allerdings zeigen diese Diagramme den zeitlichen Verlauf an, und nicht den Momentanzustand wie bei lxtask. Ich finde das wenig praktisch wenn man den Task-Manager nur ad hoc bei Bedarf startet, denn die Diagramme sind erst aussagekräftig wenn das Programm bereits einige Zeit lang gelaufen ist. Sonst sind die Grafiken zu schmal um etwas gleich zu schauen. Zwar verkleinert sich der xfce4-taskmanager nur in den Traybar und läuft daher weiter wenn man das Fenster nur schließt statt auf den Button "Beenden" zu klicken, und daher läuft die Diagrammerfassung währenddessen weiter. (Genauer gesagt gibt es eine defaultmäßig aktive Option zum Aktivieren dieser Funktionalität.) Ich bevorzuge es jedoch den Taskmanager komplett zu schließen wenn ich ihn nicht brauche, und daher sind diese Verlaufsdiagramme bei mir weniger sinnvoll. Der Rest des Fensters wird auch bei xfce4-taskmanager von der eigentlichen Prozessliste eingenommen. Die Default-Spalten sind Befehl, PID, Status, RSS und CPU %. Und somit fast gleich zu lxtask, nur dass lxtask "User" anzeigt statt "Status" (meiner Ansicht nach sinnvoller). Aber xfce4-taskmanager erlaubt es dafür, nicht nur nach jeder dieser Spalten zu sortieren (auch in diesem Fall wird genau wie bei lxtask die Sortierspalte hervorgehoben), sondern auch die Reihenfolge der Spalten per Drag & Drop beliebig zu ändern. Ferner kann man die Anzeige jeder der verfügbaren Spalten außer die für den Befehl individuell an- oder abschalten, und es gibt auch etwas mehr zum Auswählen als in der Default-Konfiguration verwendet werden. Konkret sind vorhanden: PID, PPID, Status, Virtual Bytes (Virtual Memory), Private Bytes (RSS), UID (Owner), CPU (Percent), Priorität. In der Spalte für den Befehl wird übrigens auch das Fenster-Icon des Prozesses angezeigt, falls der Prozess eines hat. In der Hinsicht auf die Spalten-Konfigurationsmöglichkeiten übertrifft xfce4-taskmanager den lxde daher deutlich - allerdings verwendet letzerer ohnehin bereits von Haus aus eine sinnvolle Auswahl. Bei der Aktualisierungsgeschwindigkeit kann man zwischen den folgenden fixen Werten wählen: 0,5, 0,75, 1, 2, 5 oder 10 Sekunden. Das ist zwar weniger flexibel als bei lxtask wo man einen beliebigen Wert eingeben kann, allerdings kann man dort nur ganze Sekunden eingeben und somit weder 0,5 noch 0,75 Sekunden. Weniger flexibler als lxtask ist der xfce4-taskmanager allerdings bei der Auswahl welche Prozesse überhaupt angzeigt werden sollen: Hier gibt es nur die Wahl zwischen allen Prozessen und denen des aktuellen Benutzers. Ansonsten mangelt es an einer Dokumentation des Programms. So werden etwa gelegentlich (und immer nur kurzfristig) Zeilen in der Prozessliste farblich in rot, organge oder grün eingefärbt was offensichtlich irgend etwas anzeigen soll, aber es ist nirgends erklärt *was*. Außerdem kann man wählen ob bei der Anzeige der der Befehle die volle Kommandozeile angzeigt werden soll oder nicht - aber entweder funktioniert diese Option nicht richtig oder anders als man meinen sollte. Denn zwar erscheinen dann bei einigen der Befehle deren Pfadnamen und nicht nur deren Basenames, aber nicht bei allen Befehlen ist dies so. Außerdem werden nach den Befehlen und deren Argumenten noch geheimnissvolle zusätzliche Zahlen angezeigt von denen unklar ist was sie bedeuten sollen. Und schließlich scheinen noch Infos aus den .desktop-Dateien der Befehle angezeigt zu werden (so es welche gibt), wie etwa der Kommentar. Aber all diese Angaben sind nirgends erklärt und man muss sich zusammenraten was sie bedeuten. Was xfce4-taskmanager hingegen genau wie lxtask fehlt ist eine alternierende Färbung benachbarter Zeilen in der Prozessliste und eine hierarchische Darstellung der Vater-Sohn-Beziehungen. Zwar ist auch der xfce4-taskmanager genau wie lxtask deutlich schlanker als der gnome-system-monitor, aber letzterer bietet jene fehlenden Features. Insgesamt ist der xfce4-taskmanager zwar sicher nicht viel fetter als lxtask, aber beim täglichen Arbeiten bevorzuge ich dennoch lxtask wenn beides installiert ist. Und gnome-system-monitor ist noch besser als beide zusammen.
xfce4-taskmanager-1.1.0-1/xfce/raspbian {resource monitor}{GTK+}: Seit lxtask unbrauchbar geworden ist, hat dieser Prozess-Manager die Rolle meines Lieblingsprogramms zu diesem Zweck übernommen. Im Gegensatz zu lxtask merkt er sich die eingestellten Spaltenpositionen, besitzt ansonsten fast die identische Funktionalität von lxtask, stellt darüber hinaus aber auch noch Verlaufsdiagramme dar. Anders als erwartet hängt dieser Taskmanager auch von keiner einzigen XFCE-Bibliothek ab, sondern nur von den GTK+ Libraries. Für die Anzeige-Auffrischung können mehrere Intervalle aus dem Bereich zwischen 0,5 und 10 Sekunden eingestellt werden. Ein Nachteil gegenüber lxtask ist der hohe CPU-Verbrauch (etwa 5 % auf einem Raspberry Pi 4), der vermutlich den Ressourcen-Verlaufsdiagrammen zu "verdanken" ist. Leider ändert aber weder das Minimieren der Verlaufsdiagramme noch das Vergrößern des Auffrischungs-Intervalls etwas am hohen CPU-Verbrauch, wenngleich er dadurch schon ein wenig beeinflusst wird. Man muss das Programm komplett schließen, damit es nicht mehr permanent CPU-Leistung verschwendet.
xfe-1.45-2/x11/raspbian xfe-1.32.1/x11-misc/gentoo {file manager}{GUI}{X11}: Sehr brauchbarer Dateimanager für X11. Basiert auf dem FOX-Toolkit; keine besonderen weiteren Abhängigkeiten. Implementiert den freedesktop.org-Papierkorb und erlaubt dessen gezielte Umgehung; was davon Vorgabe ist kann definiert werden. Xfe unterstützt vier Fenster-Layouts: Nur Verzeichnisfenster, Verzeichnisbaum und -fenster, zwei Verzeichnisfenster, Verzeichnisbaum und zwei Verzeichnisfenster. Bei den Layouts mit zwei Verzeichnisfenstern welchselt die Tabulator-Taste zwischen diesen hin- und her. Zusammen mit redefinierbaren Tastaturkommandos erlaubt einem dies, eine dem Total Commander sehr ähnliche Tastaturbedienung für die wichtigsten Funktionen festzulegen. Jedes der vier Layouts kann unabhängig in drei verschiedenen Ansichtsmodi betrieben werden. "Große Icons" stellt ein Icon und darunter zentriert und einzeilig den Namen an. Da diese nie umgebrochen werden, ist dies bei langen Dateinamen platzverschwendend im Falle spaltenweiser Darstellung, sofern man das Kürzen langer Namen nicht erlaubt. "Kleine Symbole" stellt ein kleines Icon und rechts daneben linksbündig und nicht umgebrochen den Namen an. Diese Anzeige ist meist die übersichtlichste. In der "langen Dateiliste" wird Name, Größe, Endung, Datum, Benutzer, Gruppe und Berechtigungen immer zeilenweise angezeigt; die Hintergrundfarbe sind für gerade und ungerade Zeilen unterschiedlich. Die beiden erstgenannten Anzeigemodi erlauben es zwischen Spalten- und zeilenweiser Darstellung zu wählen. Dies beeinflusst auch ob horizontal oder vertikal gescrollt wird. Und man kann sich aussuchen ob lange Namen mit "..." abgekürzt werden sollen oder nicht. Leider lassen sich dies Einstellungskombinationen nicht speichern; man muss sie nach dem Wechsel des Modus immer wieder neu einstellen. In allen Modi ist wählbar ob Directories (wobei Symlinks auf Directories gleich behandelt werden) immer am Anfang oder genau wie Dateien gereiht werden sollen, ob bei der Sortierung Groß-/Kleinschreibung beachtet werden soll. Karteireiter gibt es keine, aber wenigstens Lesezeichen für Ordner. Allerdings werden diese Lesezeichen einfach nur als Pfad angezeigt und sortiert. Man kann sie weder umbenennen noch ihre Reihenfolge anpassen. Es gibt direkte Buttons für jede Pane um versteckte Einträge ein- oder auszublenden. Ein "Trichter"-Button erlaubt es mit simplen "*"/"?"-Filterausdrücken einzuschränken welche Dateien angezeigt werden. Bei aktivem Anzeigefilter wird der Filterausdruck in roter Farbe in der Statuszeile angezeigt. Dies lässt sich auch dazu verwenden um Dateien per Filter auszuwählen, da auch der "Alles auswählen"-Befehl die Filterung beachtet. Einen expliziten Befehl zur Selektion per Filteraudruck ohne den Anzeigefilter zu verwenden besitzt XFE dafür nicht. Die Directory-Panels haben ferner einen Button um Thumbnail-Previews zu aktivieren bzw. zu deaktivieren. Im Falle zweier Directory-Panels besitzt jedes Panel ein eigene eigene Version dieser drei Buttons und des Filterausdrucks. Es gibt Befehle zum Hinüberkopieren oder Vertauschen der Verzeichnispfade in beiden Panels. Es gibt ein einziges editierbares Textfeld für die Anzeige des aktuellen Verzeichnispfades, das beim Wechsel des Directory-Panes umgeschaltet wird. Diese Feld enthält auch einen Lösch-Button für den Inhalt sowie einen "Go To"-Button was praktisch fürs Einfügen von Text rein mit der Maus ist. Eine Ballonhilfe zeigt alle Eigenschaften einer Datei oder Directory. Ein Button startet ein Terminal im Directory der aktiven Sicht; ein zweiter führt einen einzelnen Befehl dort aus (auch Wunsch auch mit Anzeige der umgeleiteten Ausgabe). Wenn mehrere Dateien ausgewählt sind, zeigt XFE sowohl sie Anzahl als auch Gesamtgröße der Dateien; selektierte Verzeichnisse werden bei der Größenberechnung allerdings ignoriert. Wenn nichts speziell selektiert ist, gilt immer die aktiv die Datei welche den Fokus hat als aktiv, und ihre Eigenschaften werden in der Statuszeile angezeigt. Was XFE komplett fehlt ist eine Anzeige des gesamten oder noch freien Platzes im aktuellen Dateisystem. XFE verwendet vier dockbare Toolbars und eine Statuszeile für seine Buttons und Statusinformationen; alle davon lassen sich separat abschalten um Platz zu sparen. Ein Riesenvorteil: XFE scheint weder unerwünschte Auto-Mounts durchzuführen, noch irgend einen schwachsinnigen Directory-Überwachungs-Daemon zu starten. Er kann allerdings selbst Mountpoints überwachen und die automatisch zu mounten versuchen - doch gottlob ist das deaktivierbar. Er besitzt einen eigenen simplen Textbetrachter (xfv) wie auch Texteditor (xfw) und Bildbetrachter (xfi); alle auch als separate Programme ausführbar. Der Betrachter beherrscht keinen Zeilenumbruch und nur simple String-Suche. Der Editor hingegen beherrscht auch Soft Line-Wrapping und das Einblenden von Zeilennummern. Bei aktiviertem weichem Zeilenumbruch werden dabei leider auch die Fortsetzungszeilen wie normale Zeilen gezählt. Das ist ein idiotisch. Er ist auch bei MB-großen Textdateien vernünftig schnell. Konvertierung in Groß- oder Kleinschreibung. Search/Replace beherrscht auch Regular Expressions. Konfigurierbare Fonts, mehrere Farbschemas (oder benutzerdefinierbar), per Dialogfeld redefinierbare Tastenkombinationen; man kann damit eine relativ Total-Commander-ähnliche Tastenbelegung realisieren. XFE kann allgemein ganz gut mit der Tastatur gesteuert werden. Konfigurierbare Features wie ob Fensterpositionen oder Layout gespeichert werden sollen, ob Directories immer am Anfang der Dateiliste angeordnet werden sollen, ob Groß-/Kleinschrift beim Sortieren unterschieden werden soll. Voller UTF-8 und Locale-Support. Im Gegensatz zu anderen Dateimanagern wie thunar oder pcmanfm unterschlägt xfe niemals die Dateierweiterung der Dateien; auch nicht von "*.desktop"-Dateien.
xfig-1 {2D}{CAD}{X11}: 3.2.8-3/graphics/debian: Ein auf den ersten Blick sehr übersichtliches 2D Vektorzeichenprogramm, welches vor allen durch seine aussagekräftigen Icons auffällt. Allerdings hat es auch einen sehr primitiven "Original X11"-Look ohne Anti-Aliasing, so dass alles sehr pixelig wirkt. Auch der Umstand dass es Dithering in einigen Icons verwendet anstatt zusätzlicher Farben verstärkt diesen Eindruck. Das GUI verwendet nur 3 Farben (Schwarz, Weiß und Grau) prominent, obgleich zusätzliche Farben (wie Rot) bei einigen Kleinigkeiten zum Einsatz kommen. Für die erzeugten Grafiken können durchaus mehr Farben verwendet werden, wobei eine vordefinierte Palette aus 32 benannten Farben zur Verfügung steht. Diese kann um weitere benutzerdefinierte RGB-Farben erweitert werden, was aber relativ umständlich funktioniert. Grundsätzlich bietet das Programm alles was man von einem 2D-CAD-Programm erwarten würde, inklusive Schraffuren und Bauteilbibliothek. Primärprimitiven sind Kreise, Ellipsen, Polygone (inklusive Linien), Rechtecke, Splines welche sich Kontrollpunkten nur annähern, Splines welche alle Kontrollpunkte berühren, Kreis-Segmente, Text und Bitmap-Grafiken. Kreis-Segmente, Splines und Polygone können dabei offen oder geschlossen sein; nur Kurven oder aber gefüllt. Bemaßungslinien und Pfeilspitzen sind verfügbar. Winkel, Längen und Flächeninhalte können gemessen bzw. berechnet und angezeigt werden. Editierfunktionen: Gruppieren/Aufbrechen, Linien/Splines verbinden/trennen, Beschneiden, Endpunkte verschieben, Objekte kopieren, löschen oder verschieben, Einzelpunkte zu Objekten hinzu fügen oder entfernen, rotieren, skalieren, spiegeln, Tangente hinzu fügen, Eigenschaften übertragen oder editieren, Objekte anordnen oder verteilen. Es können Höhenebenen definiert und Objekten zugeordnet werden, die entweder die Verdeckung von Objekten regeln oder aber ausgegraut oder unsichtbar geschaltet werden können. Einheiten sind cm oder Zoll, ein Maßstab kann dabei jedoch festgelegt werden. Ein Gitter kann angezeigt werden. Positionen können auch auf ein zweites unsichtbares Raster beschränkt werden. Die aktuelle Belegung aller 3 Maustasten wird an zentraler Stelle im Toolbar angezeigt, so dass man nie rätseln muss was welche Maustaste im aktuellen Zustand gerade bewirkt. Es einige Einschränkungen die befremdlich wirken. So lassen sich manche Objekte nur in 90-Grad-Schritten drehen anstatt beliebig. Die Befehle zur Rotation wiederum lassen sich nur in fixen Grad-Schritten rotieren und nicht beliebig frei. Zwar kann man diese Grad-Schritte beliebig genau (Nachkommastellen) einstellen, jedoch kann kann man das Objekt dadurch nicht einfach durch Bewegen der Maus drehen sondern nur um exakt einen Rotationsschritt per Mausklick. Andere Operationen wie das Verschieben von Endpunkten wiederum sind zwar vorhanden, jedoch kann man kein Outline des Objekts ziehen sondern man wählt z. B. den Anfangspunkt durch Anklicken und danach auf den gewünschten Endpunkt. Bei komplexen Objekten kann es schwer sein dabei abzuschätzen wo die anderen Punkte des Objekts dann zu liegen kommen werden und das Objekt überhaupt aussieht. Weiters können nicht alle Operationen rückgängig gemacht werden; in so einem Fall hilft nur zwischendurch Speichern. Ungewohnt ist auch dass man mehrere Objekte nicht einfach mit der Maus gemeinsam selektieren kann. Statt dessen muss man erst mit einer separaten Funktion ein Verbundobjekt, quasi eine Gruppe, erzeugen, und nur dann kann man die Objekte gemeinsam verschieben oder sonstwie manipulieren. Auch das Zoomen und Verschieben der Ansicht ist untypisch gelöst. Ein Vorteil des Programms sind sicherlich sehr geringe Ansprüche an Speicher und CPU; es wirkt jedoch auch sehr antiquiert und teils sehr umständlich zu bedienen. Es verwendet sein eigenes *.fig Speicherformat welches ein Reintextformat mit beschränkter Zeilenlänge und Fortsetzungszeilen ist. Dadurch ist es platzsparender und für Menschen übersichtlicher sowie in einem Texteditor einfacher zu bearbeiten. Allerdings ist es auch kryptischer. Überdies kann es mit gzip komprimiert werden, was allerdings nur beim Öffnen direkt unterstützt wird. Eine ausführliche HTML-Hilfe lässt sich lokal als Zusatzpaket installieren, die auch das Speicherformat exakt erklärt. Mit Zusatzprogrammen kann zwischen *.fig-Dateien in Postscript und auch SVG umgewandelt werden, allerdings ist unklar wie verlustlos dies ist. Der Programm-Download ist keine 700 kB groß, wenn man die Dokumentation benötigt kommen allerdings nur 4 MB dafür hinzu. Wenn man dies alles und zusätzlich noch Bauteilbibliothek und Konvertierungsprogramme installiert, summiert sich dies zu 6,2 MB an Downloads. Ich wurde irgendwie nicht so richtig warm mit dem Programm, vor allem simple Funktionen wie Verschieben sollten einfacher funktionieren.
xfm-1.4.3/x11-misc/gentoo {file manager}{GUI}{X11}: Minimalistic file manager with a look similar to Amiga's Workbench 2.0. About 1.2 MB installed. Unfortunately it does not work due to several compilation flaws.
xfwm4-4.10.0/xfce-base/gentoo {window manager}{GUI}{X11}: Der Standardfenstermanager von Xfce4. Grundsätzlich sehr nett und auch mächtig, allerdings nur bedingt brauchbar für eine sehr große Anzahl an Fenstern. Denn zwar kann man durch die Gruppierungsfunktion der Taskleiste verhindern dass einem diese überläuft sobald man ein paar hundert Instanzen einer Applikation startet, und die Menüs welche die verfügbaren Fenster auflisten enthalten eine Scrollmöglichkeit so dass grundsätzlich unbeschränkt viele Fenster verwaltet werden können. Jedoch erlaubt es diese Scrollmöglichkeit immer nur um eine Zeile zu scrollen; es gibt weder einen Scrollbalken noch eine mehrspaltige Ansicht. Obwohl man das Scrollen auch per Mausrad oder Wiederholungsfunktion beschleunigen kann, wird es bei hunderten Fenstern doch recht reichlich mühsam das gewünschte anzusteuern. In dieser Hinsicht sind Blackbox, Openbox und Fluxbox mit ihren mehrspaltigen Fensterauswahlmenüs besser, auch wenn xfwm4 sie theoretisch übertrifft da die mehrspaltigen Menüs nur Platz für ein paar hundert Fenster bieten, xfwm4 kann aber mittels Scrollen eine unbeschränkte Anzahl an Fenstern grundsätzlich verwalten. Praktisch wird man sich in xfwm4 aber schon lange zu Tode gescrollt haben, bevor man in Fluxbox das Limit des verfügnaren Anzeigeplatzes für das mehrspaltige Menü erreicht.
xgalaga-2.1.1.0-5+b1/games/debian xgalaga/games-arcade/gentoo {game}: Das klassische Galaga-Spiel. Gut gemacht, und läuft auch auf unbeschleunigten X-Servern leidlich gut. Die Gentoo-Version hatte den Nachteil nur eine fixe Fenstergröße zu unterstützen; dieser Nachteil ist bei der Debian Version nicht mehr vorhanden wo das Fenster beliebig groß sein kann. Die Raumschiffe werden dadurch allerdings nicht größer und sind dann entsprechend winzig. Allerdings stört das beim Spielen interessanter Weise überhaupt nicht, sondern kann sogar vorteilhaft sein weil so mehr Platz ist den Schüssen auszuweichen (was allerdings auch entsprechend raschere Reaktionen erfordert). Nachteil: Sound nur mit OSS-Unterstützung. Doch trotz dieses Mangels ist es von der Spielbarkeit und irgendwie auch von Feeling her immer noch die beste Galaga-Adaption für Linux die ich kenne. Die Debian-Version liefert zusätzlich eine 2. Version des Spiels mit, "Xgalaga Hyperspace" genannt. Das ist beinahe dasselbe Spiel, nur das man nach links oder rechts aus dem Bildschirm heraus fahren darf und dann auf der anderen Seite wieder herein kommt. Das kann sehr hilfreich sein um Schüssen zu entgehen wenn man bereits ganz bis zum Rand gedrängt war. Doch beide Spielvarianten haben ihren Reiz und bieten auch eine Langzeit-Motivation (im Sinne von "immer wieder spielen", nicht von "alles in einem Aufwasch durchspielen"). Das Spiel scheint 15 Levels zu haben, danach wiederholen sie sich vermutlich nur schwieriger. Ich kam aber noch nie so weit alle zu sehen zu bekommen.
xine-ui-0.99.6/media-video/gentoo {media-player}: Das offizielle Front-End für die xine-lib. In TCL/Tk geschrieben. Wirkt eher schwach im Vergleich zu den Möglichkeiten welche mplayer oder VLC Player bieten. Dennoch funktioniert Drag/Drop problemloser als bei beim VLC GUI wenn man es als GUI Music Player verwenden will. Mit 2,5 MB Installationsumfang (ohne die xine-lib die aber ohnehin immer von irgendwelchen anderen Paketen als Abhängigkeit erfordert wird) ist dieser Player trotz einiger mitgelieferter Skins auch wahrlich nicht sehr umfangreich im Platzbedarf. Leider hat die Tk-Basis auch einige Nachteile was die Bedienung angeht: Die Textfelder lassen sich teilweise nicht normal bedienen; etwa kein Copy/Paste-Support. Das Hauptfenster des Players lässt sich nicht verstecken oder minimieren solange es das einzige offene Fenster des Programms ist. Nur wenn man das Visualisierungsfenster öffnet kann man das Hauptfenster verstecken, und danach das Visualisierungsfenster minimieren. Aber schlimmer noch: Das Hauptfenster bietet nicht nur kein Fenstermenü oder Button zum Minimieren. Sondern das Programm stellt auch kein Icon dar, welches der Panel-Manager im Taskbar anzeigen könnte. Folglich kann man auch keine der entsprechenden Funktionen des Taskbar-Panels durchführen. Einige der Menüpunkte im Einstellungsdialog bringen das Programm zum Einfrieren wenn man sie auswählt (konkret: Das Auswahlmenü für die Netzwerkbandbreite). Weitere "kleine Probleme": Bei der Videowiedergabe gab es keinen Ton, weil der mkv-Decoder gepackte Frame-Headers nicht versteht. Alles in allem daher ein ziemlicher Müll als Video-Player - aber als Audio-Player weniger buggy als das VLC GUI.
xinv3d-1.3.6-6+b2/games/debian {game}: Ein Space-Invaders Klon in 8-farbiger 3D Drahtgitter-Vektorgrafik. Sieht zwar vielversprechend aus, ist aber leider so langsam dass man es nicht sinnvoll spielen kann. Und das obwohl es sich um einen MS-DOS Port handelt der nur 640 x 480 Auflösung unterstützt. Vielleicht läuft es auf irgend einer teuren High-End Grafikkarte flüssig, aber zumindest mit einer Standard INTEL-Onboard-Grafik ist es schlicht unbenutzbar.
xjump/games-arcade/gentoo {game}: Simpel gestricktes "Hüpf"-Geschicklichkeitsspiel mit schlichter Grafik in wenigen Farben. Auch für den umbeschleunigten X-Server geeignet. Politisch korrekt und für kleine Kinder von Helikoptereltern geeignet.
xkbd-0.8.15-r1/x11-misc/gentoo: A graphical keyboard, but very small (in functionality as well as on the display) and minimalistic. Did not work very well with UNICODE locale. US-Keyboard layout only. Forget it except perhaps on embedded devices.
xkeycaps-2.46/x11-misc/gentoo {input without physical keyboard}: A graphical virtual on-screen keyboard for X11. Supports different keyboard layouts, including German. Oh, by the way, and its also a GUI front-end to xmodmap. The best OSD keyboard I have found so for now which does not require half GNOME or KDE installed as dependencies. Unfortunately, xkeycaps does not work out-of-the box with every type of Window. Specifically, xterm needs to be started with the special arguments "-xrm XTerm.vt100.allowSendEvents:true" or it cannot accept input from xkeycaps.
xli-1.17.0+20061110-8/graphics/raspbian {graphics image viewer}: Scheint ein Fork von "xloadimage" zu sein und kann annähernd dieselben Grafikformate wie dieses laden. Also ebenfalls alle relevanten klassischen und jede Menge Exoten. Einzig TIFF unterstützte es scheinbar nur in der Fax Group 3 Variante. Ein deutlicher Unterschied gegenüber dem Vorfahr dürfte sein, dass dieser Fork die Dateien (auch?) in einem Fenster anzeigen kann und nicht nur als Hintergrundbild setzen. Es handelt sich daher um einen sehr simplen Bildbetrachter. Mit 123 kB Download-Bedarf (2023-12, raspbios) ist es nur minimal größer als sein Vorfahr.
xload/x11-apps/gentoo: Very minimalistic, just B/W (dual-color) plots the CPU load over time. However, its widgets are designed in a way which makes it easy to be integrated into other programs. For instance, jwm can use xload in order to display a CPU load diagram in its toolbar.
xloadimage-4.1-25/graphics/debian {graphics image viewer}{X11}: Ein Bildbetrachter der neben einigen exotischen/veralteten Bildformaten die folgenden verbreiteten anzeigen kann: png, jpeg, gif, tiff, xpm (X11 pixmap) und xbm (X11 bitmap). Kann auch ein paar Tranformationen durchführen: clipping, dithern, Farbreduktion, Zoom, aufhellen/abdunkeln, Gamma-Korrektur, rotieren, glätten, normalisieren und noch einige mehr. Ein ImageMagick für Arme. Dafür allerdings auch wesentlich kleiner. Dieser Image-Viewer ist allerdings nur dafür ausgerichtet aus der Kommandozeile oder Scripten heraus aufgerufen zu werden - er verfügt über keinerlei grafische Bedienungselemente (nicht einmal die üblichen Fensterverzierungen). Neben den namensgebenden eigentlichen Bildbetrachter sind noch die folgenden weiteren Utilities enthalten: xsetbg (setzt ein Bild als Desktop-Hintergrund - unterstützt zu diesem Zweck problemlos z. B. den Fluxbox WM), xview (dasselbe wie xloadimage nur mit Fensterverzierungen) and uufilter (ein "smartes" weil etwas mehr fehlertolerantes "uudecode"). 126 kB Download-Größe, 291 kB Installationsumfang.
xmag-1.0.5/x11-apps/gentoo: Eine sehr minimalistische (40 kB Executable) Bildschirm-Lupe die primitiv aussieht, aber ihren Job tut. Wegen den deutlich geringeren Ressourcen-Verbrauch (4,1 MB RAM) scheint es mir für gelegentliche Vergrößerungsaktionen die bessere Wahl zu sein, und es ist auch einfacher zu benutzen weil es kaum etwas einzustellen gibt. Man zieht mit der mittleren Maustaste ein Rechteck auf, und dieses wird dann vergrößert. Der Ausschnitt verändert sich auch nicht mehr und wird auch nicht "refreshed" wenn sich etwas am Original ändert. Man kann aber mit "Replace" jederzeit die ganze Aktion wiederholen und dann einen neuen oder aktuelleren Ausschnitt anzeigen. Dadurch verbraucht das Programm aber auch keine weitere Rechenzeit während es den Schnappschuss des Ausschnittes vergrößert anzeigt. Das kann ein Vorteil gegenüber anderen Lupen-Programmen sein welche ständig die Ausschnitt aktualisieren, und dafür viel Rechenzeit verbrauchen wenn sie länger laufen. xmag eignet sich gut um in "dummen Browsern" wie Dillo, welche Bilder nicht vergrößern können, diese Funktion extern nachzubilden.
xmahjongg/debian: Garbled display in window; unusable.
xmessage-1.0.3/x11-apps/gentoo {cmdline-dialog}: Zeigt einen Dialog mit Text und Buttons an (der Default nur der "OK" Button). Der Text kommt entweder aus der Kommandozeile oder aus einer Datei. Für jeden Button kann ein der Text und ein Return-Code definiert werden der beim Drücken retour geliefert wird. Ein Default-Button kann ebenfalls definiert werden. Der Dialog kann irgendwo erscheinen, zentriert oder in der Nähe des Mauscursors. Optional kann xmessage auch den Text des gedrückten Buttons ausdrucken statt nur den Return-Code zu liefern. Es hat keine weitere Funktionalität, wie etwa Icons oder Texteingabemöglichkeit. Ebensowenig reagiert es auf Esc oder Tab oder die Enter-Taste. Einzig die Return-Taste kann als Alternative zur Maus den Default-Button auswählen. Da xmessage von xterm benötigt wird ist es meist installiert; allerdings sieht es wirklich unglaublich kotzig aus (Athena Widgets). Als Fallback wenn man sonst nichts hat ist es gut geeignet um irgendwelche Meldungen auszugeben.
xml2-0.5-4/utils/raspbian {stream-filter}: Convert between flat formats and the XML, HTML and CSV formats. The flat formats convert every item into a single line and converts structure into path prefixes for those lines. The flat formats are easier to process by standard UNIX command line utilities. The flat format for CSV decomposes CSV lines into key=value pairs and includes metadata such as the running record number. It removes quoting and converts embedded control characters into C-like escapes such as "\n". UTF-8 input is not a problem. There is some overlap between the "xmlstarlet" utility and its "pyx" and "p2x" commands. However, the "pyx" format is still hierarchical, although it can be transformed with some effort using an AWK script into a format similar to "xml2" which is easier to process by line-oriented utilities.
xmlcopyeditor-1.3.0.0-1.1+b1/devel/raspbian xmlcopyeditor-1.2.0.6/app-editors/gentoo: Ein XML Editor, welcher die editierten Dokumente zugleich auch auf Well-Formedness und Validität überprüfen kann. Syntax-Highlighting, Folding, Autocompletion... nett. Er kann auch XPath-Ausdrücke Evaluieren und Manipulationen mittels XSLT durchführen. Per Default verwendet er kein Pretty-Printing (keine automatische Einrückung zur Struktur passend), jedoch lässt sich das Dokument über einen Menübefehl entsprechend reformatieren. Leider wird der Editor bei der Anzeige großer CDATA-Abschnitte sehr langsam welche nur "in einer Wurst" dargestellt werden, falls der weiche Zeilenumbruch dabei eingeschaltet ist. Durch Zuklappen solcher Abschnitte kann das Problem aber unterdrückt werden. Der Editor kann zwar den XPath der aktuellen Cursorposition im Dokument in die Zwischenablage kopieren, jedoch scheint es keinen gegenteilige Funktion zu geben um anhand eines gegebenen Xpaths zur entsprechenden Stelle um Dokument zu navigieren.
xmms2-0.8-r2/media-sound/gentoo xmms2 0.8DrO_o-35/community/archlinux {audio}{music}: Ein großartiges und als Nachfolger des beliebten XMMS Music Player betiteltes Programm. Doch während letzterer tatsächlich vor allem wegen seinem GUI beliebt war, bringt XMMS2 überhaupt keinen GUI-Client mit, sondern lediglich einen Commandline-Client! Tatsächlich besteht das Paket aus einem Server-Backend, das ähnlich wie der bekanntere Music Player Daemon (MPD) alle möglichen Typen von Audio-Dateien abspielen kann, sowie dem angesprochenen Commandline-Client welche den Backend-Dienst steuert. Verschiedene Ausgabe-Backends werden unterstützt, darunter ALSA, PulseAudio, JackAudio, DiskWriter.  Viele Plugins für Spezialfunktionen sind verfügbar, darunter auch Replaygain. Es gibt zwar auch grafische Clients für XMMS2, etwa LXMusic, aber diese befinden sich entweder immer noch in der Entwicklung, oder werden im Gegenteil nicht mehr weiter entwickelt. Es drängt sich angesichts der Tatsache dass das XMMS2-Projekt schon etliche Jahre alt die Befürchtung auf, dass niemand mehr Interesse daran hat die bestehenden Clients fertig zu implementieren, und dieses Projekt daher, obgleich das Backend eigentlich fertig ist, von niemandem mehr verwendet werden wird, da andere Projekte wie MPD oder mplayer genau so gut als Backends für Music Player Front-Ends dienen können, aber bekannter sind und ständig aktiv weiter entwickelt werden. Davon abgesehen war gerade das GUI von XMMS der Grund warum dieses so beliebt war, doch genau das GUI haben sie bei XMMS2 ins Nirvana "outgesourced". Derzeit ist XMMS2 jedenfalls keine sinnvolle Alternative zu Amarok, Clementine, Strawberry, Totem oder anderen populären Music Playern. Auch die 6 MB Installationsumfang sind für das Gebotene (nur ein CLI) eigentlich ziemlich happig. Ein grundsätzlicher Vorteil vom XMMS2 (den es allerdings mit MPD teilt) ist der mögliche nahtlose Wechsel zwischen Commandline- und GUI-Clients, um auf dieselbe Music-Library, Playlists und laufende Musikwiedergabe zuzugreifen. Leider integriert sich das ganze per Default auch via ZeroConf und startet dadurch den avahi-daemon, der dann gemeingefährlich an öffentlichen Ports lauscht. Besonders unverschämt ist der per Default aktive xmms2-et-Dienst, der bei jedem Song-Wechsel angeblich "anonyme" Informationen an die Entwickler sendet! Es ist keine triviale Aufgabe, diese ganzen Spitzeldienste und -plugins zu deaktivieren, auch wenn es vermutlich irgendwie möglich ist. Überhaupt stinkt das ganze Projekt leider sehr nach den systemd-Machern. Man sollte sich das Ganze besser nicht antun!
xmoto-0.5.11/games-sports/gentoo {game}: Ein 2D-Motorradspiel. Man sieht es von der Seite und muss schwierige Kurse absolvieren. Es bietet auch einen Level-Editor.
xmove 2.0beta2-6/community/archlinux: Ein Protocol-Proxy für X11, welcher erlaubt, bereits laufende X11-Applikationen (Clients) auf unterschiedliche Displays oder X-server zu verschieben. Derzeit (2016) offenbar noch ziemlich Beta. Außerdem wird anders als bei "xpra" zumindest in der man-Page nirgends darauf hin gewiesen, dass xmove auch in der Lage wäre den X-Server komplett zu ersetzen, so dass die Applikation im Falle eines Verbindungsabbruchs weiter laufen kann. Mag allerdings sein, dass man dies lediglich nicht der Erwähnung wert fand.
xmpsolve-3.2.1-2+b1/science/debian {math}: Die grafische Version von mpsolve. Enthält den Lösungsalgorithmus; es ist kein Front-End der Kommandozeilenversion und kann unabhängig von dieser installiert werden. Man gibt das Polynom in Formelschreibweise in ein Feld ein, wählt die Genauigkeit der Lösung, und die Nullstellen werden in einer Liste angezeigt. Zusätzlich wird noch ein Funktionsplot in einem Fensterabschnitt angezeigt.
xnc/x11-misc/gentoo: X11 Norton Commander clone. Unusable due to bad UTF-8 support.
xnee 3.19-1/community/archlinux: Kann die Eingabe-Events einer X11-Session (Maus und Tastatur) in eine Datei aufzeichnen, und später wiederholen. Das mag zwar zum Testen von GUI-Programmen nützlich sein, aber da es die Eingaben *wirklich* wiederholt ist es auch potenziell gefährlich, und *nicht* dasselbe wie die Aufzeichnung des Bildschirminhalts im Sinne eines Tutorials für andere.
xonix-1.4-32/games/debian {game}: Im Prinzip der 100. Klon von "Quix" wo man feindliche Bälle in Flächen einsperren muss welche man durch das Ziehen einer Spur immer mehr abteilt bis die verbleibende Fläche eine gewisse Größe unterschritten hat wobei man das Level gewinnt. Der Unterschied zum Original ist im wesentlichen dass es hier feindliche Bälle anstatt Linienbündel sind. Die Grafik ist etwas primitiv, aber das wäre noch nicht das Problem. Sondern die Steuerung ist nervig: Man muss mit der Tatatur steuern obwohl das Spiel nur in einem relativ kleinen Fenster läuft. Das Fenster lässt sich dabei zwar verschieben, jedoch nicht in der Größe ändern. Und sobald man eine Taste drückt schießt die Spielfigur bzw. das Linien-Ziehende Was-auch-immer viel zu schnell los, wo es dann oft mit dem feindlichen Ball kollidiert wodurch man ein Leben verliert. Und als wäre das noch nicht nervig genug, gibt es zudem einen zusätzlichen Feind der sich nicht in der Fläche bewegt sondern einen direkt auf dem Bereich außerhalb der Fläche verfolgen und bei Berührung töten kann. Während man im Originalspiel an den Spielfeldrändern immer sicher war. Jedenfalls, gefällt mir nicht sehr - zu schwer und auch zu nervig.
xosd 2.2.14-8/community/archlinux: Kann Overlays über dem X11-Display anzeigen, die nach einigers Zeit wieder verschwinden. Diese Overlay können reine Texte sein, oder auch Prozentanzeigen bzw. Schieberegler welche optional mit einem Titel ergänzt werden können. Im Grunde also optimal um Lautstärkeregler etc. anzuzeigen. Jedoch, leider: Es unterstützt nur die alten X11 Fonts ohne Anti-Aliasing, und das Ergebnis sieht daher selbst bei großen Font-Größen immer noch pixelig und somit gräßlich aus.
xosview/x11-misc/gentoo: Plain but useful bar charts of cpu, memory, i/o, interrupts. But not network activity.
xournal-0.4.2.1-r1/app-text/gentoo: Ein liniertes Papier welches ein Schulheft darstellt und diverse Tools um darauf zu "schreiben". Vektorbasiert. Anti-Aliased. Mehrere Seiten. Mehrere Layer pro Seite. Tools sind gerade Linie (Lineal), Freihandlinie (Stift) und (editierbarer) Text. Ein "Shape Recognizer" kann Kreise und gerade Linien erkennen. Highlighter und Radiergummi sind auch vorhanden. 9 Stiftfarben und 3 Stiftgrößen wählbar. Objekte können über eine Rechteck-Auswahl markiert und dann verschoben werden. Gzip-komprimiertes XML-Speicherformat. Zoom. Undo. Redo. Export to PDF. Ansicht seitenweise oder mit gleitendem Seitenübergang. Kommentar-Funktion für PDF-Dokumente: Dies speichert ein Xournal-Dokument zusätzlich zum PDF-Dokument ab. Selber Name aber zusätzliche Erweiterung. Beim Öffnen des Xournal-Dokuments wird dann das originale PDF-Dokument ebenfalls geladen um die Kommentare darzustellen. Was hingegen nicht möglich ist, ist die Kommentare als PDF-Kommentare in die PDF-Datei zu speichern. Wohl aber kann man eine neue PDF-Datei erzeugen, welche die Kommentare als zusätzlichen normalen Inhalt hat. Ein Sicherheitsproblem: Der absolute Pfad zu kommentierten PDF-Dokumenten wird im Xournal-Dokument gespeichert. Zwar sucht er falls das Dokument dort nicht gefunden wird auch im selben Verzeichnis die das Xournal-Dokument selbst danach oder fragt den Benutzer, so dass ein Verschieben oder Umbenennen des PDF kein Problem für die Benutzung ist. Jedoch könnten die Namen der Pfadkomponenten vertrauliche Informationen enthalten, was dann ein Problem wäre. Fazit: Wesentlich simpler als ein normales Vektorzeichenprogramm, aber gut geeignet für alle Arten von "handschriftlichen" Skizzen.
xpaint-2.9.10.2/media-gfx/gentoo {bitmap image editor}: Ein simples Bildbearbeitungsprogramm mit klassischen Werkzeugen wie Bleistift, Pinsel, Linie, Rechteck, Kreis, Freihand, Sprühdose, Füll-Kübel, Bezier-Splines, Kreisbogen, Text usw. Im Gegensatz zu "The GIMP" kommt man hier recht rasch und ohne stundenlanges Suchen in der Anleitung zu Ergebnissen. Das Programm beherrscht auch alle wichtigen Bildformate, und bietet sogar ein paar einfache Filter sowie Zoom-Stufen. Grundsätzlich wäre es sehr nett, aber leider hat es eine Eigenart die - je nach Situation - abschreckend wirkt: Beim Laden von Bildern werden diese in native Bitmaps des Displays geladen. Das ist kein Problem wenn man eine Grafikkarte mit 24 Bit TrueColor hat. Falls man jedoch auf einem High-Color-System mit nur 16 Bit Farben oder gar auf eine 8-Bit Farbdisplay arbeitet, geht dabei ein Teil der originalen Bilddaten unwiderbringlich verloren! Sehr wahrscheinlich ist das bei modernen Rechnern zwar nicht, aber trotzdem. Außerdem ignoriert xpaint alle Metadaten des ursprünglichen Bildformats beim Laden, wie JPEG-Kommentare, EXIF-Informationen etc. Sprich, diese Informationen sind verloren sobald man das bearbeitete Bild beim Speichern über das Original schreibt. Beide Gefahren zusammen sind mir persönlich zu riskant um xpaint zu verwenden, auch wenn sie je nach Situation nicht immer ein praktisches Problem darstellen.
xpdf-3.04-13/text/debian {document viewer}{PDF}: Ein schlanker, aber extrem hässlich nach "UNIX-GUI-Urgestein" aussehender PDF-Betrachter. Wer okular unter KDE oder evince unter GNOME verwendet, wird darauf gerne verzichten. Überdies kann man PDF-Dateien zur Not ja auch noch mit GhostView/gv ansehen, das ähnlich häßlich ist aber zum Ansehen von PostScript-Dateien meist ohnehin installiert ist.
xpenguins/games-misc/gentoo {game}: Pinguine laufen am Desktop herum. Kann man auch mit Fenstern zerquetschen! Angeblich. Leider aber nicht unter KDE! Unter twm etc. sieht es aber sehr nett aus!
xplanet/x11-misc/gentoo: Celestia für Arme. Rendert einzeln und mit zig Optionen Planeten, was Celestia in Echtzeit schafft.
xplore/x11-misc/gentoo {file manager}{GUI}{X11}: A small and simple file manager for small installations similar to xfm, but in contrary to xfm it justs works. About 1.7 MB installed.
xpra-0.17.6+dfsg-1/x11/devuan {KVM sharing}{GUI}{X11}: Ein "GNU screen"-ähnlicher modifizierter X11-Server (oder vielleicht nur eine Zusatz-Schicht zu einem vorhandenen?), welcher es erlaubt Verbindungen zwischen X11-Clients und Servern zu unterbrechen und später wieder wiederherzustellen, ohne dass die logische Verbindung unterbrochen wird obwohl die physische Verbindung dies sehr wohl wurde. Grundsätzlich wird damit eine ähnliche Funktionalität wie bei VNC geboten, nur auf "intelligenterem" Protokoll-Niveau was eine höhere Grafikqualität und eventuell eingesparte Datenübertragungen erhoffen lässt. Allerdings kann man XPRA anders als x11vnc nicht ad hoc "dazu schalten" wenn man es braucht, sondern muss den X11-Server und -Clients bereits von vorn herein unter der Kontrolle von XPRA starten. Dies lässt auch Overhead für den Fall befürchten dass man die XPRA-Funktionalität vielleicht gar nicht benötigt. Das Setup schien mir auch recht kompliziert, obgleich das vielleicht unfair ist sondern nur die Anleitung ausführlich.
xracer-0.96.9.1-9/games/debian {game}: Does not support OpenGL ES, so does not work on RasPi. Works with OpenGL, however. The game is intended to become a clone of the well-known action racing game "Wipeout". The current version, however, seems to be still in its early stages. You can race along a track, but completely alone, and nothing ever happens. Rather pointless to play so far.
xrick/games-arcade/gentoo {game}: Im Prinzip ganz nett gemachtes Jump'n Run wie in den 80ern - aber leider auch mit der Auflösung von damals. Zwar ist Vollbildmodus dank Vergrößerung mit Anti-Aliasing möglich, doch wirkt das ganze Bild dann störend unscharf. Als Spiel OK, aber die miese Auflösung nervt.
xscreensaver-5.15-3/x11/debian {screen locker}{GUI}{X11}: A nice screen saver and screen locking application which is independent of a specific desktop environment. Unfortunately, this version has a bug and denies to unlock the screen, even if the correct password was provided. Must be some PAM-related issue. Anyway, not usable until this gets fixed.
xscreensaver/x11-misc/gentoo: Sehr hübsche mit einigen faden Screen-Savern kombiniert. Generisch für X11, unabhängig von bestimmten Desktop Environments. Darunter auch sehr eindrucksvolle OpenGL-Versionen. Allerdings, wer seinen Bildschirm wirklich schonen will, nimmt am besten den guten alten "Black Screen" Bildschirmschoner. Ausserdem bringen die meisten Desktop-Environments ihre eigenen Bildschirmschoner mit. Zusammen mit dem Programm "xv" lässt sich xscreensaver aber auf "billige Weise" in einen Slideshow-Screensaver umwandeln, und zwar auch ganz ohne OpenGL-Support oder ohne GPU-Belastung durch Hardwarebeschleunigung.
xsel-1.2.0+git9bfc13d.20180109-1/x11/debian {clipboard manager}: Eine Kommandozeilen-Anwendung zum Setzen und Auslesen der X11 Selections. Anders als xclip welches im Grunde dasselbe tut, benötigt dieses Programm in den am häufigst benötigten Fällen keinerlei Argumente oder Optionen. Zumindest bei Scripten die in einem Terminal ablaufen. Dann unterscheidet es aufgrund des Umstandes ob stdin oder stdout mit einem Terminal verbunden ist ob es den aktuellen Inhalt des X11 clipboards zurückliefern oder diesen Setzen soll. Wenn das Script ohne Terminal läuft, reicht eine simple Option um die beiden Fälle zu unterscheiden. Darüber hinaus scheint das Programm aber auch alles zu können was xclip bietet. Der größte Unterschied zwischen xsel und xclip scheint es aber zu sein, dass xsel per Default das Clipboard benutzt während xclip per Default die primäre X11-Selection benutzt. Angesichts der Namen der beiden Programme ist das erstaunlich; man hätte eher das exakte Gegenteil erwartet. Allgemein kommt mir xsel einfacher zu benutzen und auch mächtiger aus xclip vor. Andererseits bietet xclip ein paar exotische Optionen welche wiederum xsel fehlen.
xsfcave/games-arcade/gentoo {game}: Das muss ein Wahnsinniger programmiert haben: Sieht unter 1280 x 1024 kleiner aus als eine Briefmarke! VC-20-Auflösung? Diese war vermutlich größer... OK, dank xrandr ist es unter 320 x 200 spielbar - dann nutzt die Höhe des Fensters den Bildschirm aus. Doch selbst dann füllt es nicht einmal die Hälfte der Breite! Das Spiel selbst wäre nett und OK umgesetzt wenn auch grafisch sehr simpel gemacht. Der Bildinhalt scrollt nach rechts und Hindernisse scrollen mit. Man steuert einen Punkt, der eine Kurvenspur hinter sich lassend an den Hindernissen vorbei fliegen muss. Der Punkt wird durch Schwerkraft nach untern gezogen und man kann durch Halten der Maustaste gegensteuern. Simpel doch unterhaltsam. Jedoch nicht mit dieser (fixen) Auflösung - außer vielleicht als Lachnummer.
xsnow-1.42/x11-misc/gentoo: Santa flies around in his sleigh, snow is falling on the screen contents. Nice. Unfortunately does not work with KDE/Nvidia.
xstroke-0.6-r1/x11-misc/gentoo {input without physical keyboard}: Ein gestenbasiertes Handschrift-Eingabeprogramm, das sowohl mit einem eigenen Fenster arbeiten kann, oder einfach die aktuelle Zeigerposition überall am Bildschirm für die Gestenerkennung verwendet. Im Gegensatz zu richtiger Handschrifterkennung müssen die einzelnen Zeichen hier mit vorbestimmten Gesten eingegeben werden, die sich allerdings anpassen lassen. Xstroke hingegen basiert auf einem 3 x 3 Gitterraster, wo die Übergänge zwischen den 9 Zellen registriert werden. Es ist somit eine ähnliche Eingabemethode die die Stift-Eingabe auf den alten PALM-Geräten. Die Gesten sind in verschiedene Klassen aufgeteilt, wie Buchstaben, Ziffern und Sonderzeichen. Daneben gibt es globale Gesten, welche zwischen den Klassen umschalten sowie Cursortasten und andere besonders häufig gebrauchte Tastendrücke generieren. Ein simpler Klick ohne Mausbewegung wird als "Geste" für einen Mausklick interpretiert. Das Programm wird komplett über Textkonfigurationsdateien gesteuert. Es gibt eine Möglichkeit sich die definierten Strokes aus den Konfiguration über den Umweg über Scripte grafisch darstellen zu lassen. Grundsätzlich kann jede Geste eines der folgenden Dinge tun: Einen Tastendruck generieren, ein Mausbutton-Eingabeevent erzeugen, ein beliebiges Programm ausführen, permanent oder nur für die nächste Geste auf einen anderen "Modus" umzuschalten. Jede Geste wird dabei nur in dem Modus erkannt für den sie definiert wurde - außer globale Gesten deren Erkennung immer aktiv ist. Ein Nachteil von xstroke ist dass es ziemlich viele Gesten auswendig zu lernen gilt, und nicht alle sind "logisch" sondern wegen der Unterscheidbarkeit zwischen den Gesten nötig. Xstroke scheint nicht gerade aktiv weiter entwickelt zu werden, und einen sonderlich ausgereiften Eindruck hinterlässt sie auch nicht. Leider scheint XStroke nicht mit allen Fenstern zu funktionieren - bei einem Terminal-Fenster etwa markiert man damit nur, statt Zeichen einzugeben. Immerhin installiert das Programm ein Symbol im Systembereich der Taskleiste, mit der man die Erkennung an- und abschalten kann.
xstroke/x11-misc/gentoo: Recognize characters drawn at the X display using your current pointer device. Extensible, but the shipped configuration does not have support for german umlauts or combining characters.
xterm-262/x11-terms/gentoo {terminal emulator}{GUI}{X11}: Das Standard-Terminal Programm von xorg-server. Unterstützt so ziemlich alle Standards, Fonts und Eingabemethoden für asiatische Zeichen; kein Problem mit UNICODE. Auch keine Abhängigkeiten von umfangreichen Fremdbibliotheken. Freetype-Support. Was leider fehlt ist ein komfortabler Einstellungs-Dialog; alles muss mühselig über X Ressourcen oder Kommandozeilenargumente konfiguriert werden. Außerdem gibt es keine einfache Art die Farben zu redefinieren; das dünklere Blau ist auch hier zu dunkel um auf schwarzem Hintergrund noch gut lesbar zu sein. Es gibt zwar möglicherweise eine Anpassungsmöglichkeit für die Farbpalette, aber wenn dann nicht über RGB-Werte, sondern nur durch Auswahl aus einer begrenzten Liste vordefinierter Farbnamen. Tabs sucht man ebenfalls vergeblich. Alles in allem ein mächtiges und sehr standardkonformes Programm mit sehr geringem Komfort, das aber wegen seiner geringen Paketabhängigkeiten in minimalen Umgebungen durchaus Sinn machen kann. Doch auch in umfangreicheren Umgebungen empfiehlt es sich wegen seines guten Standard-Supports zumindest als Zweit-Terminal-Emulator für besonders anspruchsvolle Anwendungen.
xtris/games-puzzle/gentoo {game}: Netzwerkfähige TETRIS-Version. Schmucklos aber funktional und von der Tastenbelegung her bestens spielbar. Leider auch nur in einem ziemlich kleinen Fenster. Davon abgesehen aber die beste Adaption des Spiels für Linux.
xtrlock-2.2/x11/debian {screen locker}{GUI}{X11}: Another very minimal X11 screen locker that did not work on the Raspberry Pi. It always complained about the account having no password set, which is just not true. I assume this utility just does not work with PAM. It is therefore unusable on must Linux installations, which do use PAM.
xtux/games-arcade/gentoo {game}: 2D-Multiplayer Ballerspiel mit Pinguinen die auf lustigen Level-Hintergründen in schwacher isometrischer Pseudo-3D-Darstellung herumlatschen. Allerdings lustige Level - eines sieht etwa aus wie ein Desktop wo man sich zwischen den Fenstern herumtreiben kann. Leider keine Singleplayer-Missionen, obgleich lokaler Server startbar. Maximalauflösung 896 x 768 und kein Fullscreen-Mode - da muss wohl wieder mal xrandr ran! ;-)
xv-3.10a-r15/media-gfx/gentoo {bitmap image editor}{graphics image viewer}: Ein Programm zum Anzeigen und interaktiven Bearbeiten von Bildern. Es ähnelt in dieser Hinsicht sehr dem "display"-Programm von ImageMagick, bietet aber um Welten weniger Filter und Bearbeitungsmöglichkeiten. Allerdings hat es dennoch einen Vorteil gegenüber "display": Erstens scheint es schneller und ressourcenschonender zu arbeiten (keine Kunst), vor allem aber kann man es verwenden um in einer einzigen Shell-Kommandozeile eine automatisierte Slideshow mit Zufallsauswahl an Bildern zu implementieren, die sich überdies noch als ressourcenschonenden Bildschirmschoner für das Programm "xscreensaver" einsetzen lässt.
xvideoservicethief-2.4.1-r1/media-video/gentoo: Eine grafisch nett gemachte Qt-Script Anwendung, die ähnlich wie youtube-dl Videostreams als Datei abspeichern kann. Im Gegensatz zum ersteren Programm beherrscht es aber eine "Vielzahl" von Video-Websites, und nicht nur Youtube. Ich habe allerdings noch nie eine andere benutzt, da es sich bei den restlichen unterstützten Sites um irgendwelche komischen US-Sites handelt die nur dort jemanden interessieren und wenig internationalen Bezug haben. Allerdings gab es Zeiten in denen die aktuelle Version von youtube-dl nicht funktionierte; hier diente xvideoservicethief als nützliche Überbrückungshilfe.
xvkbd/x11-misc/gentoo: A better looking and working graphical keyboard. On-screen resizeable. But also US-Keyboard layout. However, many foreign language characters can be composed using its composing capabilities.
xwelltris-1.0.1-16+b2/games/devuan {game}: Tetris in 3D: Die Formen fallen in eine Art Grube mit quadratischem Querschnitt, und man muss die Steine auf irgendwelchen der 5 sichtbaren Wände irgendie irgendwo ablagern. Ich blicke derzeit nicht durch. Jedenfalls ist mir schon das normale Tetris schwer genug, eine Verkomplizierung durch 3D kann mir gestohlen bleiben. Davon abgesehen funktioniert es wie es soll und ist mit etwas unter 500 kB Installationsumfang auch verleichsweise schlank.
xwpe-1.5.30a-3/editors/debian {text-editor}{development_environment}{text-terminal IO}: Eine Nachahmung des klassischen Borlands "Turbo-C" im Textterminal. Anders als das Original ist jedoch kein Compiler integriert, sondern das Programm ist im wesentlichen ein via Maus, Menüs und Buttons bedienbarer Mehrfenster-Texteditor (bis zu 35 Dateien gleichzeitig geöffnet) der mit verschiedenen Compilern und Linkern zusammen arbeiten kann. Neben dem rein terminal-basierten "xwpe"-Executable bringt es auch eine angebliche "X11"-Version namens "xwe" mit, welche jedoch tatsächlich genau so im Terminal läuft. Das Programm selbst bezeichnet sich lediglich als "Windows Editor" ("we") im Hilfe-Menü. Vermutlich kann diese Version lediglich von irgendwelchen Zusatz-Features einer X11-Umgebung gebrauch machen, darunter jedoch leider nicht deren Zwischenablage (das Programm implementiert statt dessen seine eigene interne Zwischenablage). xwpe funktioniert nur vernünftig wenn man es ohne gesetztes "$LANG" aufruft. Denn benutzt er - zumindest in einer UTF-8 Umgebung - automatisch Liniengrafikzeichen für seine Menüs. Nur für die Scrollbalken werden dann unverständlicher Weise trotzdem ASCII-Zeichen zur Darstellung verwendet. Umlaut-Support oder sonstige Non-ASCII-Zeichen im editierten Text darf man sich ohne $LANG freilich keine erwarten. Eine reine ASCII-IDE daher. Ein Ärgernis ist dass das Programm die Terminal-Einstellungen versaut wenn es sich beendet - man muss manuell (und blind) "reset" eintippen, damit das Terminal wieder normal funktioniert. Der Texteditor unterstützt 2 alternative Mengen an Tasteneinstellungen. Voreingestellt sind die klassischen Turbo-C Tastenkombinationen. Jedoch kann man auch einen "CUA"-Modus wählen, deren Tastenkombinationen jenen moderner grafischer Programme ähnlicher sind (insbesondere [Strg]+[c], [Strg]+[x]. [Strg]+[v] für die interne Zwischenablage). Die Umschalt-Tasten zum Markieren einer Textauswahl werden aber nicht unterstützt; dazu dienen andere Tastenkombinationen. Dies ist jedoch nicht die Schuld des Programms sondern grundlegenden Beschränkungen des Text-Terminals geschuldet unter denen auch andere Terminal-Editoren leiden. Suchen/Ersetzen ist mit und ohne RegExes möglich. Ein "Grep"-Menübefehl erlaubt eine optional rekurive Suche mit und ohne RegExes in einem Dateiverzeichnis. Ebenso ist eine optional rekursive Suche nach Dateinamen möglich, die gefundene Datei kann dann geöffnet werden. In diesem Fall werden allerdings nur normale Shell-Joker unterstützt und keine RegExes. Undo- und Redo-Support ist vorhanden. Markierte Blöcke lassen sich auf die übliche Weise benutzen (ausschneiden, verschieben usw.), Ein-/Ausrücken sowie Groß-/Kleinschreibung darin umkehren. Auch eine dubiose Option "Hide" gibt es welche den markierten Text versteckt - unklar bleibt wie man ihn wieder sichtbar machen kann. Man kann einen Block auch in eine Datei schreiben oder von dort lesen. Was leider fehlt ist die Möglichkeit einen Block durch ein externes Kommando zu filtern. Man kann das nur über Temporärdateien nachbilden in welche der Block gespeichert und danach modifiziert geladen wird, wobei die Modifikationen in einer Shell durchgeführt werden welche wxe temporär gestartet hat (zumindest dies wird unterstützt). Ein komplettes Hilfesystem ist im Programm integriert. Ebenso ein "man"-Seiten-Browser, der die ausgwählte man-Seite dann in einem neuen Editor-Fenster darstellt. Was ich in der Bedienung angangs verwirrend fand ist dass das Programm nicht mit einem leeren Text startet wenn man keine Argumente angibt. Ich versuchte immer Text in den Desktop-Hintergrund des Programms einzutippen was nicht möglich ist. Man muss erst mit "New" ein neues leeres Textfenster anlegen bevor Text eingegeben werden kann. Die Textdarstellung ist farbig und per Vorgabe weißer Text auf blauem Hintergrund. Alle Farbkombinationen lassen sich allerdings über einen Menüpunkt anpassen. Ein aufgebohrter "Öffnen"-Dialog für Dateien dient als integrierter "File-Manager". Er kann das aktuelle Verzeichnis wechseln, neue Verzeichnisse anlegen, Dateien verschieben, lösche, verlinken, kopieren, Permission-Bits ändern sowie zum Bearbeiten öffnen. Angeblich kann man in diesem Editor nun diverse Compiler und Projektdateien konfigurieren. Auch eine Debugger-Integration für den gdb inklusive Breakpoints und Watch-Window sei vorhanden. Nur finde ich all diese angepriesenen Menüpunkte nirgends! Entweder sind sie noch nicht implementiert, oder wirklich gut versteckt! Derzeit (2022) daher nichts weiter als ein Texteditor ohne UTF-8 Support welcher zudem das Terminal nach jedem Aufruf versaut zurück lässt. Laut README ist dieses Software-Projekt die Neuauflage eines existierenden älteren Projekts und derzeit im Alpha-Modus wo eine Reorganisation des Original-Quelltextes ansteht. Daher sind viele Features die im Original bereits vorhanden waren wohl noch nicht verfügbar. Grundsätzlich aber interessant. In Zukunft erneut prüfen.
xxdiff/dev-util/gentoo {text-diff}{text-merge}: Ein nettes grafisches Comparison & Merge Tool. Obwohl es Verzeichnisse als Argumente akzeptiert, muss man in diesen dann erst recht wieder die einzelnen zu vergleichenden Dateien selektieren. Daher ein nettes Tool, aber kein Konkurrent für bessere wie kdiff3. Dafür braucht es kein KDE. xxdiff ist dafür allerdings in Python geschrieben.
xxkb-1.11-r1/x11-misc/gentoo: Angeblich eine verbesserte Version von xkdb. Mag stimmen, es installiert zumindest eine Datei die nach Support für eine deutsche Tastatur aussieht. Jedoch ein kleines Problem mit dem Programm: Immer wenn man es startet kommt eine Fehlermeldung: "XXkb.mainwindow.type". Man scheint dieses Programm erst umständlich über XResources konfigurieren müssen. Da pfeife ich doch drauf und verwende statt dessen xkeycaps. So nötig braucht man dieses Programm ja auch wieder nicht.
xye-0.12.1+dfsg-4/games/debian {game}: Supposed to be some sort of puzzle game, similar in spirit to Sokoban. However, even the tutorial does not work - the game hangs, eating 100 % CPU until killed with -9. This version does not work; maybe try to check it out a new version after some time.
xz-utils-5.2.4-1/utils/debian {compression}: Dies ist eine modernisierte Version bzw. nachfolger von "lzma". Es bietet grundsätzlich eine ähnlich starke Komprimierung an und deutlich mehr Komfort, hat gegenüber dem Vorgänger aber den Nachteil dass es mehr Metadaten in die komprimierte Datei schreibt. Dies führt dann dazu dass vor allem sehr kleine Dateien mit lzma komprimiert kleiner sind als mit xz komprimiert, da der Metadaten-Overhead dann den Unterschied ausmacht. Bei größeren Dateien wird der Unterschied immer kleiner obwohl er nie ganz verschwindet. Ein Vorteil von xz gegenüber lzma ist dass ersteres eine Prüfsummen in die erzeugte Datei aufnimmt, wodurch man ermitteln kann ob die Datei beschädigt wurde. lzma hat so etwas nicht und kann korrupte Dateien nur dann erkennen wenn die Korruption zu illegalen Zuständen beim Dekomprimieren führt. Dies ist zwar meist so, aber nicht immer. xz ist daher zuverlässiger um die Integrität einer komprimierten Datei zu erkennen. Ähnlich wie "gzip" bringt auch "xz" einige Wrapper mit, welche die xz-Funktionaliät auf diverse Standard-Kommandos übertragen welche vom Wrapper mit temporär entpackten Kopien der komprimierten Dateien intern aufgerufen werden. Es gibt: "unxz", "xzcat", "unlzma", "lzcat". Die letzteren beiden Wrapper erlauben es lzma-Dateien zu dekomprimieren ohne dass man ein "lzma"-Kommando installiert haben muss. Denn xz ist rückwärtskompatibel zu seinem Vorgänger lzma, und kann dessen komprimiertes Dateiformat daher auch lesen und schreiben. Mit Ausnahme der Verwendung dieser Wrapper muss man bei xz allerdings spezielle Optionen angeben um das lzma-Format zu verarbeiten, so dass die meisten Benutzer diesen Mehraufwand scheuen dürften und statt dessen lieber das originale lzma-Utility zusätzlich installieren dürften.
xzoom-0.3-26/x11/debian: Ein weiteres minimalistisches (24 kB Executable) ressourcensparendes Bildschirm-Lupenwerkzeug für X11. Belegt ca. 5,5 MB RAM wenn es läuft. Es ist komfortabler zu benutzen als xmag und hat nur minimal höheren Ressourcenverbrauch. Das Executable ist sogar deutlich kleiner. Der größte Unterschied zu xmag ist dass xzoom permanent den gewählten Ausschnitt aktualisiert. Man kann also damit zusehen was sich an einer anderen Stelle des Bildschirms tut, ohne dazu irgendwelche Refresh-Buttons drücken zu müssen. Der Nachteil ist allerdings, dass das Programm daher ständig und auch relativ viel Rechenzeit verbraucht, da es andauernd seinen Bildschirmausschnitt aktualisiert selbst wenn sich dort gar nichts verändert. Im Gegenzug ist es jedoch viel einfacher einen neuen Ausschnitt zur Anzeige festzulegen: Dazu muss man nur einfach mit ins Lupenfenster klicken und den Mausknopf gedrückt lassen während man den Cursor wieder aus dem Fenster bewegt während seine Umgebung dabei als Ausschnitt zu sehen ist. Sobald man den Mausknopf wieder los lässt, ist der neue Ausschnitt damit fixiert. Allerdings kann man die Größe des Ausschnitts anders als bei xmag nicht mit der Maus ändern; statt dessen ändert man den Zoom-Faktor mit den [+]- oder [-] Tasten. xzoom ist für Anfänger einfacher zu benutzen als xmag, da es keine Bedienungsbuttons gibt über deren Funktion man rätseln könnte. Beide Programme haben daher ihren Nutzen. Wegen der leichteren Benutzbarkeit empfehle ich xzoom zuerst, aber xmag ist wegen der geringeren CPU-Belastung besser wenn der Ausschnitt lange am Bildschirm angezeigt werden soll.
yabasic-1 {programming language}: 2.78.0-1/interpreters/devuan: Download 230,8 kB. Ein ebenfalls ziemlich schlankes BASIC; der Interpreter ist 251 kB groß und damit um gute 50 % größer als bwbasic. Auch hier wird in der man-Page die ganze Sprache erklärt, jedoch ausführlicher als in der von bwbasic. Vor allem aber mit Beispielen. Außerdem gibt es neben das man-Page die annähernd selbe Information noch einmal in Form einer einzigen HTML-Seite, die Hyperlinks für weitaus komfortableres Nachschlagen von Verweisen nutzt. Anders als bwbasic hat yabasic einige grundlegende Grafikbefehle. Es kann (richtige) Fenster erzeugen, Kreis, Ellipse, Punkte, Linien, Polygonzug Rechtecke und Dreiecke zeichnen. Kreise, Rechtecke und Dreiecke kann es auch (solid) füllen oder löschen. Dann noch Texte an einer Koordinate ausgeben, sogar mit optionalem Alignment horizontal und vertikal. Man kann (optional) einen Font für das ganze Fenster festlegen, aber auch optional für jeden "text"-Befehl übersteuern. Allerdings kann man nur 6 vordefinierte Worte für den Font wählen, sowie optional noch eine Größe, und nicht etwa einen echten Fontnamen. Man kann nur die Vordergrundfarbe setzen (nur 1-Bit RGB, bzw. die 8 sich daraus ergebenden Farben, und zwar per Name). Es gibt kein Flood-Fill, keine Patterns, kein Ändern der Hintergrundfarbe (immer weiß, das kann aber beim Start mittels Kommandozeilenoptionen geändert werden). Tastatur und Maus lassen sich abfragen, so dass man einfache Spiele problemlos realisieren können sollte. Sound-Support beschränkt sich auf einen Befehl zum Piepsen. Witziger Weise gibt es sogar PEEK und POKE. Diese setzen aber interne Variablen anstatt Speicherzellen, und verwenden Strings anstatt Adressen zur Angabe der handvoll vordefinierte Konfigurations- und Info-Variablen. Man kann damit beispielsweise die aktuelle Fenstergröße abfragen. Weiters kann man Grafiken auch ausdrucken, was unter UNIX in Form von PostScript geschieht; das externe "lpr"-Kommando wird dazu aufgerufen. Schließlich gibt es noch einen Befehl, der einen rechteckigen Ausschnitt aus der Grafik in eine Stringvariable speichern und wieder daraus woanders hin kopieren kann. Damit kann man erstaunlich viel machen, bis hin zu flüssig bewegten Animationen. Ziemlich minimalistische Grafikbefehle daher zwar, sie wirken aber durchdacht ausgewählt, und dadurch bleibt auch alles angenehm simpel und der Einlernaufwand ist gering. yabasic kann sowohl als Kommando ihm als Argument übergebene BASIC-Dateien ausführen, als auch mittels Shebang BASIC-Programme als Scripte ausführen. yabasic ist wegen seinen Grafikfähigkeiten gegen diverse X11-libraries gelinked, allerdings nur gegen sehr grundlegende. Ein chroot-Jail der alles benötigten libraries inklusive C-Runtime enthält, ist mit 4,5 MB immer noch relativ klein. Ein X-Server wird dabei nicht benötigt, wenn das Programm keinen Gebrauch von den Grafikbefehlen macht. Wenn allerdings ein X-Server mittels X11-Forwardings erreicht werden kann, kann man mit diesem geringen Installationsumfang vollen Gebrauch von den Grafikfähigkeiten machen. Dafür fehlt aber eine interaktive BASIC-Shell. Als Ausgleich dafür kann das Programm aber ein Standalone-Executable erstellen, welches BASIC-Programm und Interpreter vereint. Das funktioniert zumindest jeweils unter Linux (von mir auch getestet) und Windows. Settings für yabasic können neben der Kommandozeile auch über X11 Ressourcen (xrdb) gesetzt werden. Ähnlich wie bwbasic bietet es auch alle relevanten klassischen BASIC-Befehle und zusätzlich noch die strukturierten Varianten, jedoch nicht immer mit klassischer Syntax. So hat es etwa statt dem "select" ein C-ähnliches "switch", inklusive fall-through-Schwachsinn. Es gibt auch andere Abweichungen, etwa dass "break" anstatt "exit" zum Abbruch von Schleifen dient, SQRT anstatt SQR, RAN statt RND und mehr. Eine sympathische Eigenheit ist, dass es short-circuit-Auswertunge bei AND und OR durchführt (so wie in C). Am eigenwilligsten ist wohl der Unterschied dass IF ohne THEN die einzeilige Form darstellt, mit THEN hingegen die strukturierte mehrzeilige. Mit anderen Worten, es ist weniger VB-kompatibel als bwbasic, bietet allerdings auch mehr Befehle und Funktionen. Weiters erweckt die Anleitung den Eindruck, dass man sinnlose runde Klammern um alle Bedingungen machen müsste, ähnlich wie in C. Nur stimmt das gar nicht; es geht auch ohne. Es gibt ein spezielles Dokumentations-Kommentar, deren Inhalte man mit einer Kommandozeilenoption extrahieren kann, die aber auch dem Programm selbst als Array zur Verfügung steht. Auch dieses BASIC erlaubt Labels anstatt von optionalen Zeilennummern, doch mit LABEL Schlüsselwort. Doppelpunkte separieren mehrere Statements pro Zeile. Es gibt (neben GOSUB) nur noch SUB - kein FUNCTION oder DEF FN. Allerdings vereinigt SUB beide Funktionalitäten in sich. Es ist mächtiger als in bwbasic, kann auch lokale und statische Variablen definieren, variable Argumentlisten verarbeiten und beherrscht Rekursion. Ein Rückgabewert kann mit RETURN angegeben werden; es gibt keine Zuweisung an eine Variable desselben Namens wie das SUB. Mit IMPORT kann man auch SUBs aus anderen Quelltexten als Bibliotheken laden. Man kann SUBs auch indirekt ausführen, indem man den Namen als Stringausdruck bereit stellt. Weiters gibt es einen COMPILE-Befehl, der neuen BASIC-Code zur Laufzeit kompiliert - scheinbar ist yabasic ein Bytecode-Compiler und kein reiner Interpreter. Es werden DIM und auch DEDIM unterstützt, und man kann auch die Größe aller Array-Dimensionen abfragen. Arrays lassen sich per Reference an SUBs übergeben. Weiters ist ncurses-Support enthalten, so dass man Kontrolle über die Cursorposition hat, sowie rechteckige Ausschnitte des Terminals in eine Stringvariable kopieren kann, sowie anderswo zurück ins Terminal. Damit sollten sich auch simple Text-UIs implementieren lassen. Die OPEN Funktion weicht stark von der BASIC-üblichen Syntax ab und entspricht mehr oder weniger dem fopen() von C. Auch SEEK ähnelt stark fseek(). PRINT USING wird unterstützt, ähnelt einen printf() aber stärker als dem klassischen. Immerhin unterstützt es zumindest die "#"-Platzhalter auch konventionell. Es scheint nur Fließkomma-Zahlen und Strings zu geben, keinen eigenen Integer-Datentyp. Es gibt kein ON ERROR sondern Fehler terminieren normalerweise immer das Programm. Allerdings gibt es eine Ausnahme für OPEN: Man kann dieses auch als Funktion statt als Statement ausführen, und dann kann man einen Fehlercode erhalten anstatt dass die Anwendung terminiert. Das ist allerdings die einzige Möglichkeit zur Fehlerbehandlung. Allerdings: Braucht man überhaupt mehr? Mir fällt nichts ein. Fazit: Etwas eigenwillig was die Abweichungen einiger Befehle angeht, aber nicht zu übertrieben. Um einiges mächtiger als bwbasic, und weitaus besser für interaktive Anwendungen geeignet. Der größte Nachteil sind die umfangreicheren Library-Abhängigkeiten, so dass es für ein Minimalsystem eine weniger gute Wahl ist. Bei einem Desktopsystem ist es aber bwbasic klar vorzuziehen - außer wenn Quelltext-Kompatibilität mit klassischen BASICs ein Kriterium ist. Da beide BASICs wenig Platz belegen, kann man sie aber ruhig beide installiert lassen.
yacas-1.9.1+dfsg-1/math/raspbian/2025-12-07 yacas-1.3.2/sci-mathematics/gentoo {symbolic calculation}{programming language}: Ein sehr platzsparendes CAS (0,6 MB Download bzw. 3 MB installiert plus optional 1,4 weitere MB Download sowie installiert für die Dokumentation), welches vom Funktionsumfang her durchaus mit dem bekannten kommerziellen "Derive!" vergleichbar ist. Allerdings hat es kein GUI, sondern arbeitet konsolenorientiert (aber wenigstens hat es readline-Support). Im Gegensatz zu vielen anderen CAS benötigt Yacas auch kein zusätzlich installiertes LISP oder eine andere Programmiersprache, sondern ist in einer eigenen Programmiersprache implementiert deren Implementation (in C++) bereits im oben genannten Installationsumfang enthalten ist. Diese Sprache sieht weitgehend wie "funktionales C" aus, also sehr viel "normaler" als LISP. Da diese Sprache offenbar eine Scriptsprache ist, liegen die Quelltexte der höheren yacas-Funktionen daher im Quelltext bei und werden bei jedem Start neu eingelesen. Das ist aber so schnell dass es keine merkliche Verzögerung beim Start gibt. Außerdem kann man sich die Quelltexte so ansehen und bei Bedarf auch kopieren und ändern. Yacas scheint mir etwas leistungsfähiger als das vergleichbare "qalc" aus dem "libqalculate"-Paket zu sein, da es etwa kubische Gleichungen lösen kann was "Qalculate!" nicht schaffte. Ob es genau so leistungsfähig wie Derive! ist würde genauere Vergleiche erfordern, aber auf den ersten Blick scheint es in etwa auf derselben Augenhöhe zu sein. Da es mehrfachgenaue Arithmetik beherrscht und seine eigene Programmiersprache mitbringt, kann man es durchaus als Konkurrent von "bc" betrachten: yacas ist zwar (ohne Dokumentationspaket) rund 16 x länger, aber es kann auch deutlich mehr als 16 x so viel. Auf jeden Fall ist yacas kürzer als alle anderen vergleichbaren OpenSource-CAS die ich kenne und hat keine externen Abhängigkeiten (außer der C++ Standardbibliothek). Meiner Ansicht nach ist es das derzeit beste CAS für ressourcenbeschränkte Systeme, und auch seine integrierte Programmiersprache dürfte wesentlich ressourcenschonender sein als die üblicherweise installierbaren LISP-Pakete. Sicherlich reicht es nicht an Maxima heran, aber es kann das meiste was man täglich braucht. Und es ist wesentlich schneller erlernbar, einfach weil es deutlich kleiner ist und daher um Welten weniger Dokumentation durchzuackern ist. Leider ist im Speziellen die Funktion NextPrime() sehr lahm; nur bis 2**128 ist sie annehmbar schnell, bei 2**256 braucht sie schon fast eine Minute, und für Kryptografie erforderliche Bitlängen kann man damit komplett vergessen. Möglicherweise liegt das aber auch daran dass Yacas den Miller-Rabin Test zu häufig anwendet, und nur für alle 8-Bit Primzahlen Trial-Divisionen vorzunehmen scheint. Sprich, man kann dies möglicherweise durch eigenen Yacas-Code mit mehr Trial-Divisionen beschleunigen. Ich habe allerdings Zweifel. "Out of the box" ist NextPrime() auf jeden unbrauchbar langsam für kryptografische Anwendungen. Maxima hat keine solchen Probleme und ist hierbei viel schneller. Frühere Versionen enthielten die Dokumentation im HTML-Format, akuelle Versionen nur noch im PDF-Format und sind (zumindest unter Debian) in ein separates Paket ausgelagert. Diese Dokumentation enthält dabei aber sogar deutlich mehr als nur eine Erklärung der interaktiven yacas-Shell und verfügbarer yacas-Befehle. Sondern es gibt auch ein sehr lesenswertes Dokument welches ausgewählte besonders interessante Algorithmen erklärt die yacas intern verwendet. Etwa über mehrfach-genaue Arithmetik und wie man Pi auf beliebig viele Stellen damit berechnen kann. Auch ohne konkreten Bezug zu yacas lesenswert!
yad-0.40.0-1/utils/raspbian {cmdline-dialog}: Ein GTK+-basiertes Tool, mit dem man simple grafische Dialoge aus der Kommandozeile und aus Shell-Scripts heraus erzeugen kann. Sehr ähnlich wie zenity (tatsächlich ist es sogar ein Fork von zenity), bietet aber zusätzliche Features und Optionen. Konkret bietet es die folgenden Dialoge zusätzlich zu simplen Buttons: calendar, color selection, drag-and-drop box (Dialogfeld in welches via Drag & Drop Dateien gezogen werden können), text entry, box with shortcut icons, file selection, font selection, display form, display HTML, list, multi progress bars, notebook (umschaltbare Karteireiter), notification icon, print, progress indication, text information, scale (Schieberegler um einen Wert einzustellen). In Texteingabefeldern kann optional eine Rechtschreibprüfung aktiviert werden. Obwohl yad deutlich mächtiger als zenity ist und insgesamt die meisten Features aller "dialog"-artigen Programme bietet, ist es kaum je vorinstalliert anzutreffen da zenity viel verbreiteter ist.
yagf 0.9.5-3/community/archlinux {PDF}: Ein auf den ersten Blick OK aussehendes GUI für irgendwelche zweifelsohne nützlichen PDF/OCR-Operationen. Integriert auch die Tesseract OCR (alternativ auch die Cueform OCR). Jedoch frisst das Ding 200+ MB RAM wenn man auch nur ein einziges Bild konvertieren will. Daher zumindest am RPi 1 praktisch unbrauchbar.
yamagi-quake2-7.40+ctf1.06~dfsg-1/contrib/games/debian {game}: Ein Client für Quake 2 Netzwerk-Spiele. Es handelt sich dabei um eine der Abhängigkeiten von quake2, welche allerdings ein eigenes Icon im Menü installiert.
yamagi-quake2-core-7.40+ctf1.06~dfsg-1/contrib/games/debian {game}: Ein Server für Quake 2 Netzwerk-Spiele. Es handelt sich dabei um eine der Abhängigkeiten von quake2, welche allerdings ein eigenes Icon im Menü installiert.
yarsync-0.1.1+deb-2/utils/raspbian: Ein Backup-Programm mit git-ähnlichem Command line interface. Lokal benutzt es Hardlinks um für jedes Backup einen weiteren Snapshot des Verzeichnisbaums zu erstellen. Es erkennt auch Umbenennungen und Verschiebungen. Im Fall einer Änderung werden neue und alte Version der Datei vollständig gespeichert - kein Versuch einer Deltifizierung oder teilweisen Deduplizierung wird unternommen. Weiters kann man zusätzliche Pfade als "Remotes" definieren (sowohl lokal als auch auf anderen Rechern), und das lokale Repository (mit all seinen Hardlinks) dorthin zu synchronisieren, wobei rsync hinter den Kulissen diese Arbeit erledigt. Leider arbeitet das Programm dabei sehr ineffizient da es sehr lange dauert ein "yarsync push" zu machen nachdem man nur eine einzige kleine Datei beim letzten "yarsync commit" hinzu gefügt hat. Ob es vielleicht rsync für jede einzelne Datei im Baum aufruft? Wie auch immer, unbrauchbar für große Directory Trees. Zudem kann man die Kernfunktion des Programm einfach nachbilden, indem man selbst mit "cp -rl" Snapshots erzeugt und dann "rsync" für eine Remote-Replikation aufruft.
yash-2.43-1/shells/debian: Eine "größtenteils" POSIX-kompatible Shell, die in der Leistungsfähigkeit zwischen Bash und Dash zu liegen scheint. Was das "größtenteils" angeht, lieferte bereits eine erste Kommandosequenz zum Setzen von PS1 andere Ergebnisse als auf jeder anderen *tatsächlich* POSIX-kompatiblen Shell. Aus diesem Grund für mich unbrauchbar, obgleich die Shell ansonsten einen recht passablen Eindruck macht. Sie bringt weniger Erweiterungen mit als die Bash, ist aber im Gegensatz zur Dash durchaus fürs Interaktive Arbeiten geeignet (Command Line Editing, History, Job Control, Tab Completion, "disown", "hash", "pushd"). Allerdings ist Yash nicht wirklich deutlich schlanker als die Bash, und auch nicht auf alle entbehrlichen Erweiterungen wurde verzichtet. So gibt es etwa Arrays und zusätzliche Operatoren für arithmetische Expansion und Parameter-Substitution. Außerdem liest yash auch nie ~/.profile, obwohl es dies laut POSIX zumindest als Login-Shell müsste. Das einzig möglicherweise sinnvolle Zusatz-Feature ist Pipeline-Redirection, womit man sich - vielleicht - in manchen Scripts das Anlegen temporärer FIFOs sparen könnte. Alles in allem ziemlich OK als Shell, aber verbraucht nur marginal weniger Ressourcen als die Bash und hat immer noch etliche Erweiterungen gegenüber Dash. Irgendwie scheint es daher keinen besonderen Grund zu geben, sie zu verwenden. Allerdings habe ich einen Verdacht: Der Autor ist Japaner, und die Shell hat zusätzliche Prompt-Strings wo der Promit *hinter* dem Cursor steht. Offensichtlich ist dies vorteilhaft für Benutzer mit Sprachen, wo von rechts nach links geschrieben wird. Das dürfte daher wohl auch die Zielgruppe der Shell sein. Für westliche Benutzer ist sie OK, bietet aber keine überzeugenden Vorteile da sie weder mehr kann als bash oder zsh noch ressourcenschonender als die Dash oder ash ist. Verglichen mit der Korn Shell (ksh) ist die yash aber deutlich fetter.
yasm-1.1.0-r1/dev-lang/gentoo yasm-1.3.0-2.1/devel/debian: Yasm ist ein auf neue Architekturen erweiterbarer, portabler Macro-Assembler. Die derzeitige Version unterstützt aber genau wie nasm ebenfalls nur x86 und amd64-Instruction Sets. Als Targets werden derzeit binary, ELF32, ELF64, COFF, Win32, und Win64 Object-Formate unterstützt. Source Debugging Informationen können dabei im STABS, DWARF 2, und CodeView 8 Format erzeugt werden. Yasm versteht bei Quelltexten sowohl die nasm-Syntax, als auch the GAS-Syntax (die etwa der GCC intern verwendet). MASM beherrscht er allerdings genau so wenig. Alles in allem scheint mir dieses Tool mehr eine großartige Vision als eine großartige Realität zu sein: In der Theorie ist er großartig portabel und erweiterbar, in der Praxis kann die derzeitige Version aber dasselbe bzw. sogar weniger als der nasm welcher viele Spezialoptionen und zusätzliche Output-Formate kennt. Der einzige Vorteil den ich gegenüber den aktuellen nasm entdecken kann ist das yasm auch das GAS-Format kennt. Doch dann kann man eigentlich gleich den GAS nehmen, und sowohl auf nasm als auch yasm verzichten - der GAS ist schließlich fixer Bestandteil jeder GCC-Installation. Und was die leichte Erweiterbarkeit für neue Instruction-Sets und Zielplattformen angeht: Das ist wohl eher ein Vorteil für Implementoren neuer Assembler-Versionen als für Anwender. Denn ein neues Instruction-Set wäre ohnehin komplett inkompatibel zu anderen, weswegen das Weiterverwenden von Quelltexten keine realistische Option ist. Daher ist es dem Anwender dann auch einerlei ob er nun den yasm oder sonst einen Assembler für jene neuen Quelltexte verwendet. Weiters ist die Kompatibilität von yasm zu nasm nicht komplett, sondern nur "nearly" 100 %-ig. Fazit: Nett gedacht, doch ich bleibe beim nasm weil der mehr kann und der yasm derzeit einfach keinen Mehrwert gegenüber letzterem bietet.
youtube-dl-2012.02.27/net-misc/gentoo: Eine sehr nützliche Kommandozeilenanwendung, die Youtube-Videostreams in verschiedenen Formaten und Auflösungen herunterladen und als lokale Videodatei abspeichern kann. Mit dem -t Parameter kann auch der Dateiname automatisch aus der Beschreibung und YouTube-ID erzeugt werden. Der -f Parameter wählt Format und Auflösung; -f5 beispielsweise eine besonders geringe und entsprechend kleinstmögliche Downloads.
yq-3.1.0-3/utils/raspbian: In Python verfasste Filter-Wrapper um das JSON-Verarbeitungs-Utility "jq" herum, die mit YAML (*.yml), XML (*.xml) und TOML (*.toml) nach JSON konvertieren können und dies dann an das "jq"-Kommando als Eingabe übergibt. "yq" liest YAM-Dateien, "xq-python" (vermutlich wegen eines Namenskonflikt mit einem anderen Debian-Paket umbenannt, es nennt sich selbst nur "xq") liest XML-Dateien, tomlq liest TOML-Dateien. Tatsächlich wird dies alles durch das "yq"-Script implementiert, welches dazu aber im Fall von TOML mit undokumentierten Optionen aufgerufen werden müsste.
ytalk/net-misc/gentoo: Dies ist nur ein hübscherer Client für einen bereits installierten "talk"-Daemon wie netkit-nettalk. Die Sicherheitsprobleme bestehen hier daher genau so. Der wesentliche Unterschied zum dem mitgelieferten client von netkit-nettalk ist lediglich die Multiuser-Chat-Fähigkeit von ytalk.
ytree-1.94-1.1/utils/devuan {file manager}{text-terminal IO}: Ein mit 100 kB Download-Umfang (250 kB installiert) sehr schlanker ncurses- und libreadline-basierter Textmodus-Dateimanager. Anders als "mc" stellt dieser Manager die Dateien immer nur in einem Fenster-Abschnitt dar; ein zweiter zeigt den Dateibaum und ein dritter Informationen zur Datei. Dateien können markiert werden, und dann aufgrund der Markierung woanders hin verschoben, kopiert, etc. werden. Etwas seltsam ist dass man zum Markieren und Demarkieren separate Tasten verwenden muss. A pro pos - normale Menüs gibt es keine. Statt dessen steuert man alles mit Tastendrücken. Die verfügbaren Tastenbefehle werden allerdings auch am Bildschirm angezeigt.
yudit-3.1.0-1/editors/raspbian {text-editor}{GUI}{X11}: Ein in C++ verfasster Texteditor für das Bearbeiten von UNICODE-Dateien mit (scheinbar) allen Extras wie bidirektionalem Text. Er läuft zwar in einem X11-Fenster, spiegelt dabei aber den optischen Charme eines Terminal-Fensters wider. Der Cursor ist ein dünnes rotes "Größer"-Zeichen, das den vorhandenen Text beinhart überlappt. Er hat auch keine Menüs. Allerdings hat er am oberen Fensterrand einen Buttonbar, und am unteren Fensterrand eine Kommandozeile. Seine Bearbeitungsfunktionen erfüllen das Minimum dessen was man von jedem Text-Editor erwartet, inklusive simplem Suchen-Ersetzen. Gottlob unterstützt er zumindest die X11 Selection, nicht jedoch die X11 Zwischenablage. Markiert wird mit der [Alt]- anstatt mit der [Umschalt]-Taste. Dafür implementiert er selbst programmintern eine Zwischenablage. Erstaunlicher Weise beherrscht er Multi-Level Undo und Redo. Eine Stärke sind seine Eingabemethoden, neben Tastatur und den IMEs des OS unterstützt er auch Zeicheneingabe durch Malen mit der Maus in ein internes Fenster! Mit "Esc" schaltet man zwischen Textbereich und Kommandozeile hin und her. Trotz seines, gelinde gesagt ärmlichen, Aussehens rühmt er sich, UNICODE besonders toll zu unterstützen, inklusive rechts-nach-links Sprachen, und alle 31 Bit von UNICODE. Das mag alles stimmen, jedoch ist dieses Wunderwerk in der Default-Konfiguration nicht einmal in der Lage, auch nur deutsche Umlaute anders darzustellen als in Form kleiner Hex-Codes. (Ich gehe einmal davon aus dass man dies irgendwie beheben könnte.) Etwas nervig ist auch dass der Text in einem Proportionalfont dargestellt wird. Dafür rendert er TrueType-Fonts aber selbst und ist nur von den X11- und Standard-C-Bibliotheken abhängig. Er erfordert nicht einmal eine UNICODE-taugliche Locale! Weiters unterstützt er von Haus aus überlange Zeilen mit weichem Zeilenumbruch; dazu muss man nichts Spezielles einstellen. Angeblich ist er auch sehr portabel und auf viele Plattformen portiert worden. Fazit: Wenn man nichts anderes hat um UNICODE-Dateien zu editieren, ist er vermutlich eine gute Wahl. Vor allem auf Betriebssystemen, da selbst keinen speziellen UNICODE-Support oder Locales bieten. Denn yudit scheint alles selbst zu machen. Allerdings wird dies dadurch konterkariert, dass er zumindest unter Linux auf X11 angewiesen ist. Vermutlich kann dieser Editor auch nicht mehr als jeder Texteditor der mit GTK+ oder Qt implementiert ist. Vermutlich kommt er aber mit deutlich weniger Ressourcen aus. Möglicherweise eine interessante Wahl für sehr ressourcenbeschnittene Rechner-Hardware, wie etwa einen RPi 1b.
zbackup-1.4.4-2/admin/devuan {backup}{deduplication}: Ein in C++ geschriebenes Backup-Programm welches, da nicht "statisch" gelinkt, etwas mehr Abhängigkeiten von externen Bibliotheken hat als das ansonsten recht ähnliche "restic". Für die Benutzung in einer initramfs (wo BorgBackup wegen seiner Python-Abhängigkeit Probleme bekommen dürfte) sollte es jedenfalls immer noch geeignet sein. Featuremäßig scheint zbackup ein Zwischending aus restic und BorgBackup zu sein. zbackup scheint ebenfalls Komprimierung und Deduplikation zu beherrschen, allerdings wiederum nur auf Basis des rsync-Algorithmus. Andererseits muss rsync ja nicht notwendiger Weise nur innerhalb einer einzelnen Datei deduplizieren auch wenn alle Tools die ich bisher sah dies immer getan haben. Die unselige von NSA empfohlene AES-Verschlüsselung kann es auch, fragt sich nur ob man diese ausschalten kann. Weiters verwendet es genau wie restic und BorgBackup auch SHA-256 für seine Prüfsummen. Weiters beherrscht es auch ähnlich wie BorgBackup noch Komprimierung, allerdings mit weniger Wahlmöglichkeiten bezüglich des Algorithmus. Ein großer praktischer Nachteil von zbackup ist es, dass es einen Index aller Deduplikations-Blöcke im RAM hält. Ich befürchte, damit wird einem früher oder später der RAM ausgehen, wenn man riesige Backup-Archive anlegt. Allerdings kann man den Platzbedarf für die Deduplikation indirekt dadurch steuern, indem man die Option für die Blockgröße für die Deduplikation entsprechend auswählt. Offensichtlich gibt es nur die Wahl zwischen 64 KiB und 2 MiB. Ersteres ist auf jeden Fall schon einmal interessanter (im Sinne effizienterer Deduplikation) als die 500 MB von restic. Obwohl schon besser, erscheint mir das immer noch zu groß. Viele Dateien, insbesondere Textdateien, sind deutlich kleiner als 64 KiB. Andererseits wird man wegen den oben erwähnten RAM-Speicherbedarf die Deduplikation ohnehin nur auf relativ Größe Datenblöcke beschränken wollen. Trotz eigentlich sehr interessanter Ansätze dürfte sich dieses Programm daher in der Praxis wegen seiner Limits nur für kleinere Backups eignen. Aber es wird wahrscheinlich ausreichend sein, ein Backup für einen einzelnen User von dessen Bürorechner (viele Office-Dokumente, kaum große Image- oder Multimedia-Dateien) zu erstellen. zbackup hat zudem den Nachteil, dass Backup-Archive immer nur wachsen können - es ist nicht möglich alte Daten daraus zu löschen. Daher wird einem irgendwann der Platz ausgehen, und dann muss man ähnlich wie bei einem "Full Backup" anderer Backup-Programme wieder ganz von vorne anfangen (so dass die früher bereits vorhandene Deduplikation verloren geht bzw. wieder aufs Neue ermittelt werden muss). Außerdem kann man nicht nur Teile des Backups restoren, man muss immer das gesamte Backup restoren (freilich kann man es in ein Temporärverzeichnis restoren und dann löschen was man nicht braucht - doch dies kann viel temporären Platz belegen).
zbar 0.10-5/community/archlinux: Zwei Kommandozeilenprogramme zum Decoderen diverser Barcodes. Eines unterstützt das Extrahieren aus einzelnen Bilddateien, das zweite Programm das Extrahieren aus Video4Linux-Livestreams. Die folgenden 1D bzw. 2D-Barcodes werden unterstützt: EAN-13 (inklusive dessen Untermengen ISBN-13, ISBN-10, UPC-A und UPC-E), EAN-8, Code 128, Code 39, Interleaved 2 of 5 und QR Code. Das Paket enthält auch eine Bibliothek um die Decoder-Engine in eigene Programme einbauen zu können. Bindings für C und Python-2 liegen bei.
zchunk-1.2.3+ds1-2+rpi1/utils/raspbian: zck ist ein Archivprogramm mit ZSTD-Komprimierung und erzeugt *.zck Dateien. Genau wie gzip kann jedes Archiv nur eine einzige komprimierte Datei enthalten. Die Besonderheit des Formats ist dass es noch stärker als "gzip --rsyncable" auf rsync-freundlichkeit ausgelegt ist. Es speichert Daten innerhalb der Archivatei als Chunks variabler Länge zerhackt und einzeln komprimiert. Die Chunk-Grenzen werden durch den Inhalt der Daten selbst festgelegt. Die Autoren von zchunk waren mit zsync nicht zufrieden, vor allem weil dieses einen HTTP-Request pro Chunk durchführt was viel Netzwerkoverhead mit sich bringt. Der Download-Client der zchunk-Suite, zckdl, versucht mehrere hinter einander liegende Chunks mit einem HTTP-Request downzuloaden. Serverseitig ist dabei nichts anderes als ein normaler Web-Server mit Support für HTTP Range-Requests notwendig. Ein Nachteil gegenüber zsync ist, dass zchunk keine zusätzliche Indexdatei zu einer bestehenden Originaldatei verwendet, sondern die Originaldatei in ein exotisches Archivformat verpackt. Der Client benötigt daher unbedingt unzck um das Archiv wieder zu entpacken, egal ob er es in einem Stück oder delta-basiert (via zckdl oder rsync) herunter geladen hat. Bei zsync kann der Client auch nur das Original herunterladen und benötigt dann keinen speziellen Download-Client oder Unpacker dafür. Vorteilhaft ist zchunk hingegen für den Server, da dort ein normaler Webserver für den Download reicht, und die Clients "ermuntert" werden Delta-Downloads zu verwenden die den Server bei Updates entlasten. Ein Nachteil der per-Chunk Komprimierung von zchunk ist geringe Kompression. Daher kann ein "compression dictionary" erzeugt werden, das die Kompression effizienter macht, jedoch den Nachteil hat dass man es nachträglich nie mehr wieder ändern kann, oder die Archive verlören ihre Delta-Kompatibilität mit älteren Revisionen desselben Archivs. Angeblich zahlt es sich aber stark aus solch ein Dictionary zu benutzen, in einem Test wurde das Archiv dadurch um 40 % kleiner. Um das Dictionary zu erzeugen komprimiert man zuerst eine Datei die "möglichst typische" Daten enthält in ein zck-Archiv, und generiert daraus dann eine Dictionary-Datei. Diese muss man fortan bei jedem Komprimierungs-Aufruf als Argument angeben, sonst geht die Delta-Kompatibilität verloren. Zum Glück muss man die Dictionary-Datei aber nicht separat aufbewahren, da sie in jedem damit komprimierten zck-Archiv enthalten ist und daraus wieder extrahiert werden kann. Ich verglich die Effektivität von zck mit anderen Verfahren: 916 bdelta, 1684 rdiff, 2684 gzrs+rdiff, 2744 zck+rdiff, 3712 xz, 4680 gz+rdiff, 5952 zck, 7160 gz, 7192 gzrs, 48908 raw. Die Zahlen sind die Summe der Dateigrößen in KiB. "raw" enthält unkomprimierte Quelltextarchive, welche auf einander folgende Revisionen eines Quelltextbaums darstellen. Die Dateien innerhalb dieser Archive sind nach dem Pfadnamen sortiert. Alle anderen Namen repräsentieren dieselben Archive, welche entweder nur mit einem bestimmten Verfahren gepackt wurden, oder mittels rdiff (oder bdelta) nur als Unterschiede von der Vorgänger-Version gespeichert sind. In allen Fällen wurden nur jene Dateien behalten, die dazu nötig wären um alle Dateiversionen von einem Rechner zu einem anderen zu übertragen. Im Fall der Delta-Methode wurde daher nur die erste Version der Datei im Original übertragen, alle restlichen nur als Delta. Dafür wurde im Fall von rdiff die erste Signatur nicht übertragen, da man diese aus dem Original extrahieren kann. Im Fall von zck wurde ein Dictionary verwendet, das aus der 1. Datei extrahiert wurde. "gzrs" ist "gzip" mit der Option "--rsyncable" aktiviert. In allen Fällen wo rdiff oder bdelta zum Einsatz kam, wurden die Deltas dann noch mit der effektivsten Methode gepackt (gzip, xz oder gar nicht) was die kleinste Ausgabedatei ergab. Die obigen Vergleiche sind aber insofern unfair, da dazu die Deltas vor dem Herunterladen komprimiert werden müssen was weder zsync noch rsync im Live-betrieb beherrschen. Entfernt man die zusätzliche Komprimierung der Deltas und verlangt dass Originaldateien und rekonstruierte Dateien mit derselben delta-freundlichen Methode komprimiert sind sowie dass die Deltas ad hoc gebildet werden müssen anstatt vorab berechnet am Server zu liegen, ergibt sich hingegen folgendes Bild: 3184 zck+rdiff, 3384 gzrs+rdiff, 15268 rdiff. Sowohl zchunk als auch gzip --rsyncable schlagen rdiff mit unkomprimierten Datei also deutlich, wobei der Vorteil von zchunk gegenüber gzip --rsyncable aber nicht gerade berauschend ist. Vor allem wenn man bedenkt dass zchunk hierzu noch ein Dictionary benutzen musste um auf diese Werte zu kommen. Diese Ergebnisse mittels rdiff sollten ähnlich jenen sein, welche rsync bzw. zckdl bei Downloads an Datenverkehr erzeugen würden. rsync hat hier allerdings den Nachteil das dafür ein rsync-Server laufen müss, während für zckdl ein statischer Webserver welcher Byte-Ranges ausliefern kann völlig ausreichend ist. Ich denke, zchunk hat Vorteile für den Server-Betreiber, ist jedoch als Exotenformat eine Zumutung für die Clients. Es wird daher wohl nie populär werden, und macht eher bei Organisations-internern Nutzung Sinn.
zenity-2.32.1/gnome-extra/gentoo {cmdline-dialog}: Ein GTK+-basiertes Tool, mit dem man simple grafische Dialoge aus der Kommandozeile und aus Shell-Scripts heraus erzeugen kann. Das GTK+-Gegenstück zu kdialog. Sozusagen eine verbesserte bzw. hübschere Version von xdialog. Genauer gesagt bietet es eine fixe Menge an vorgefertigten Dialogen für unterschiedliche Zwecke an, unter denen man wählen und deren Parameter anpassen kann: Datumsauswahl mittels Kalender, Texteingabe, Informationsanzeige, Benachrichtigung mittels Symbol und Hilfstext im Nachrichtenbereich des DTE-Panels, mehrspaltige Listen (optional auch bearbeitbar und Mehrfachselektion), Auswahl mehrerer Werte mittels Check-Boxen, Auswahl eines einzelnen Wertes mittels Radio-Box, Dateiauswahl (auch Directories oder Mehrfachauswahl möglich), Fortschrittsanzeige, Auswahlfrage, Werteingabe mit Schieberegler, Farbauswahl, Textanzeige von umgeleiteter Eingabe. Was auffällt ist das Fehlen eines Schriftart-Auswahldialogs. Mit Ausnahme der Textanzeige muss man den Text immer über Kommandozeilenargumente angeben und kann ihn nicht etwa direkt aus einer Datei lesen. Daher ist es schwierig z. B. den Fehlerdialog anzuzeigen wenn man stderr in eine Datei umgeleitet hat und diese groß wurde. Eben so wenig kann man einen komplexen Dialog aus einzelnen Elementen zusammen bauen wie "gtkdialog" oder das klassische "dialog" aus der Kommandozeile. Dafür ist die Benutzung simpler. Leider funktioniert Zenity nur unter einer grafischen Oberfläche und nicht auch im Text-Modus. Ein Vorteil von Zenity gegenüber mächtigeren Dialog-Tools ist seine relativ hohe  distributionsübergreifende Verfügbarkeit. Das gilt zwar auch für xdialog, jedoch ist dieses aufgrund eines Herkunft aus der Frühzeit von X11 optisch fürchterlich häßlich.
zfs-fuse-0.7.0-19/otherosfs/debian {FUSE}: Das berühmte ZFS-Dateisystem welche alle so rühmen, als FUSE-Dateisystem so dass man es unabhängig von Kernel-Support mounten und benutzen kann. Das echte ZFS (also nicht die FUSE-Version) zeichnet sich dadurch aus bedienungsfreundlich zu sein, großartige Dinge tun zu können (Pool/Volume Management, Subvolumes, Snapshots und Rollback, Quotas, SMB/NFS-Support, Replication, Data Integrity Checksumming, Block-Level Deduplication, Compression, Mirroring, Striping, eine verbesserte Variante von RAID-5, Support für Flash-Caches) und dabei unglaublich viel RAM zu verbrauchen. Die FUSE-Variante wird da vermutlich nicht besser sein, dafür aber deutlich langsamer. Dieses FUSE-Dateisystem ist *nicht* dafür gedacht von nicht-privilegierten Benutzern verwendet zu werden, da es verschiedene absolute Pfade benutzt auf die normale Nutzer keinen Zugriffe haben. Der Sinn ist es statt dessen, bestehende ZFS-Datenträger auch auf Systemen ohne Kernel-Support für ZFS mounten zu können. Mit rund 4 MB Installationsumfang ist dieses Paket nicht einmal besonders groß, bedenkt man die gebotene Leistung. Gleichwohl wird es nicht für den Produktionsbetrieb empfohlen; es ist wohl wirklich nur für dem temporären Zugriff auf vorhandene ZFS-Volumes gedacht.
zile-2.4.9/app-editors/gentoo {text-editor}{text-terminal IO}: Ein kleiner Textmodus-Editor, der Emacs zu imitieren versucht. Dabei bringt der die meisten normalen Editier-Funktionen von Emacs mit, unterstützt aber kein LISP. Leider unterstützt Zile auch kein UTF-8/UNICODE, was ihn in den meisten nicht-englischprachigen Ländern als Editor disqualifiziert. "joe" und "nano" können das. Obwohl das Executable von Zile nur halb so groß wie das von "joe" und nur um 50 KB größer als der sehr minimale nano, ist er mit allen DLL-Abhängigkeiten (ohne Standard C-Runtime) zusammen der größte der 3 Editoren. Das liegt vor allem daran, dass er unbedingt den Boehm-GC verwenden will, was nur die wenigsten anderen Programme tun. Fairerweise muss man sagen dass er aber nur um 100 KB größer als nano ist; alle drei Editoren liegen im Bereich 900 KB bis 1 MB was die Excutable + DLL Abhängigkeiten angeht.
zim-0.68-1/x11/debian {wiki}: Ein in Python implementiertes Personal/Desktop Wiki mit hübschem GTK+ basiertem UI. Dieses Wiki benötigt weder einen Web-Server noch andere laufende Dienste und speichert die einzelnen Wiki-Seiten als Textdateien mit Markup. Zusätzlich generiert es einen Cache in einer SQLite3-Datenbank, welcher für die Suchfunktionen sowie das Link-Management verwendet wird. Mit rund 50 MB RAM-Verbrauch ist es zwar nicht die schlankeste Lösung, aber zumindest eine der schlankeren. Das UI präsentiert sich auf den ersten Blick ähnlich wie eine Notiz-Zettel-Anwendung mit 2 Panes: Links eine hierarchische Liste der verfügbaren Wiki-Seiten, rechts der Inhalt der ausgewählten Wiki-Seite dargestellt. Die Darstellung dient zugleich als Editor-Ansicht. Grundsätzlich handelt es sich dabei um WYSIWYG-Editierung mit Schaltflächen für Attribute; tatsächlich wird dabei aber Markup-Text erzeugt und man kann diesen alternativ auch direkt eintippen. Neue Wiki-Seiten können zwar auch explizit erzeugt werden, doch normalerweise entstehen sie dadurch dass man erst einen Text als Wiki-Hyperlink markiert und dann anklickt wodurch die neue Seite erzeugt wird. Das Speichern von Änderungen erfolgt allgemein automatisch; man muss sich nicht darum kümmern. Eben so wenig muss man sich um die Dateinamen oder Directory-Struktur des Wikis kümmern, dieses folgt automatisch den Änderungen welche man im Editor vornimmt (umbenennen oder löschen von Wiki-Seiten). Die Wiki-Seiten haben eine simple Hierarchie, welche durch ":" in den Seitennamen vorgegeben ist. Man kann allerdings Seitenverweise relativ zur eigenen Position der verweisenden Seite in der Hierarchie erstellen. Externe Hyperlinks sind ebenfalls möglich. Weiters können beliebige Dateien als Attachments ins Wiki aufgenommen werden; diese werden dann innerhalb des Wikis in speziellen Unterordnern direkt abgespeichert. Bilder hingegen können direkt ins Wiki aufgenommen werden, so dass sie auch "inline" als Teil der Seite erscheinen. Dabei wird allerdings keine automatische Skalierung unterstützt - man muss entweder das Bild vor dem Importieren selbst auf die gewünschte Größe bringen, oder nachträglich die exakte numerische Pixelbreite und -höhe für die Darstellung/Zoom angeben. Alternativ können eingebundene Bilder zudem auch als externe Verknüpfungen im Wiki deklariert werden. Es gibt eine Funktion zum Anzeigen aller Links welche von anderen Seiten her auf die aktuelle Seite verweisen. Wiki-Seiten können mit Markierungen ("Tags") versehen werden (etwa Themen-Bezeichnungen), und auch anhand dieser gesucht. Ein Webserver ist eingebaut der optional gestartet werden kann; in diesem Fall kann man den Wiki-Inhalt auch mittels eines Web-Browsers (nur-lesend und ohne jede Sicherheit) betrachten. Des weiteren wird eine umfangreiche Anzahl von Plug-ins standardmäßig mitgeliefert. Eine davon dient dazu das Wiki automatisiert unter Versionskontrolle zu stellen. Derzeit unterstützt werden dabei Git, Bazaar-NG, Fossil und Mercurial. Neue Revisionen werden konfigurierbar entweder manuell erstellt, oder in periodischen Abständen, oder beim Beenden des Wikis. Und dies jeweils nur dann wenn es auch tatsächlich Änderungen gab. Weitere Plug-Ins existieren für das Erstellen von Tagebuch-Einträgen (wahlweise eine Wiki-Seite pro Tag, Woche, Monat oder Jahr), Rechtschreibprüfung, Tabellen-Erstellung, Tag-Cloud, Lesezeichen, automatisches Inhaltsverzeichnis (innerhalb von Wiki-Seiten basierend auf der enthaltenen Überschriften-Hierarchie), To-Do-Liste, berechnete Ausdrücke, Formelsatz, Diagramme (Gnuplot, dot, R, ditaa, Sequenzdiagramme), Notensatz (lilypond), Quelltextansicht (mit Syntax-Highlighting), "Zeitgeist"-Integration für Activity Monitoring, Schnell-Erstellung von Notizen aus der Zwischenablage und noch etliche weitere.
zip-3.0-11+b1/utils/debian {compression}: Kommandozeilenprogramme zum Erzeugen des bekannten Archiv-Formats der ".zip"-Dateien. Zip-Dateien haben den Vorteil über die meisten Plattform- und Betriebssystemgrenzen hinweg austauschbar und kompatibel zu sein. Weiters kann man gezielt einzelne Dateien in Zip-Archiven extrahieren oder austauschen, ohne dass deswegen die gesamte Archivdatei neu komprimiert oder zur Gänze dekomprimiert werden muss. Entsprechend gut geeignet sind Zip-Dateien auch für virtuelle Dateisysteme wie viele Dateimanager sie zur Verfügung stellen, zumindest bei Nur-lesender Nutzung. Ein Nachteil des Dateiformats ist eine relativ geringe Kompression im Vergleich zu anderen Kompressionsprogrammen. Das Dateiformat beherrscht auch Verschlüsselung, allerdings werden dabei nur die Dateiinhalte und nicht auch die Dateinamen verschlüsselt. Man kann dies aber umgehen indem man zunächst ein unverschlüsseltes Zip erstellt, und dieses dann als einzige und verschlüsselte Datei in eine unkomprimierte 2. Zip-Datei archiviert. Der Vorteil nur einzelne Dateien entpacken zu können geht dabei allerdings verloren. Das Zip-Format kennt mehrere Verschlüsselungs-Modi, von diesem Paket und dem davon bereit gestellten "zip"-Utility wird leider nur die unbrauchbar unsichere Original-Methode unterstützt, welche bestenfalls Amateure von einer Entschlüsselung abhalten kann. Das 7z/7zip-Utility kann ebenfalls Zip-Dateien erzeugen und extrahieren, unterstützt aber die deutlich sicherere AES-Verschlüsselung. Man sollte verschlüsselte Zip-Dateien daher besser mit 7zip als mit "zip" erzeugen. Eine Zip-Datei kann überdies Kommentare enthalten, sowohl für das Archiv im Ganzen als auch für jede einzelne Datei darin. Das Utility "zipnote" erlaubt das Erstellen und Editieren solcher Kommentare. Ein weiteres beiliegendes Utility "zipsplit" zerteilt eine große Zip-Datei in mehrere kleine einer wählbaren Maximalgröße. Dieses Utility ist dafür gedacht, große Zip-Archive auf mehrere kleine Datenträger aufteilen zu können. Die so erzeugten automatisch nummerierten Teil-Archive sind jeweils vollständige Archive, nur enthält jedes einen anderen Teil der insgesamt zu archivierenden Dateien. Optional kann auch eine Index-Datei erzeugt werden, welche eine vollständige Liste aller Dateien enthält, sowie einen Hinweis in welchem Teilarchiv man welche Datei finden kann. Beim Erzeugen der Teilarchive wartet das Programm optional auch auf einen Tastendruck bevor das nächste Archiv geschrieben wird. Das erlaubt es, in der Zwischenzeit den Datenträger zu wechseln.
zsh/app-shells/gentoo: Extremely powerful shell, incorporating almost all the features of other shells. Fully POSIX compatible. However, it has the same problems like ksh regarding ash/dash/bash compatibility, and UTF-8 support is weak.
zsync-0.6.2-3/net/debian {compression}: Ein nützliches Utility um "dummen" Downloadservern welche nur http-basierten Download anbieten eine Möglichkeit zu verleihen, dass Dowloader im Falle von Updates nicht die gesamte Datei herunter laden müssen, sondern nur jene Teile welche sich gegenüber der alten Version geändert haben welche die Downloader bereits besitzen. Dies kann das Übertragungsvolumen deutlich reduzieren, vor allem beim Download von multigigabyte-großen Dateisystem-Abbildern. Grundsätzlich erlaubt zsync eine "rsync"-ähnliche Download-Effizienz, ohne dass jedoch ein "rsync"-Dienst am Download-Server laufen müsste, sowie ohne dass man einen SSH-Zugang dorthin benötigt. Statt dessen erstellt derjenige welcher auch die Downloads selbst zur Verfügung gestellt hat mit dem "syncmake"-Utility eine *.zsync-Datei für jede (große wo es sich auch auszahlt) Download-Datei, welche die Anwender dann herunter laden können. Mit einem beim Anwender installierten "zsync"-Utility können dann anhand der Informationen in der *.zync-Datei jene Bereiche der downzuloadenden Datei identifiziert werden welche der Anwender bereits als Teil einer lokal vorhandenen älteren Datei besitzt, und so beim Download übersprungen werden indem statt dessen die entsprechenden Datenabschnitte aus der lokal vorhandenen älteren Version entnommen werden. Eine Einschränkung ist dass zsync derzeit ausschließlich von "http://"-URLs herunterladen kann, weder "file://" noch "https://" werden unterstützt. Allerdings befindet sich das Programm noch in einem relativ frühen Entwicklungsstadium (Stand: 2021), so dass zu hoffen ist dass spätere Versionen hier mehr Flexibilität bieten werden. Eine besonders interessante Kombination ist es, eine Dateisystem-Abbild-Datei mit "gzip --rsyncable" zu komprimieren auch wenn dies nicht eine gerade starke Kompression bewirkt. Der Vorteil ist jedoch dass die solchermaßen komprimierte Datei "rsync"-freundlich wird, und damit auch "zsync"-freundlich welches denselben zugrundeliegenden Algorithmus zur Identifikation von lokalen Übereinstimmungen verwendet. Es ist daher empfehlenswert zwei unterschiedlich komprimierte Versionen derselben Abbild-Datei am Download-Server anzubieten: Eine wie oben beschriebene zwar nur mit gzip komprimierte Version die zwar größer ist aber rsync-freundlich ist, und eine besser komprimierte Version für Komplett-Downloads. Die *.gz Version soll dann nur zum Download mit zsync verwendet werden wo sie trotz ihres größeren Gesamtumfangs zu weniger Datenübertragung führt, da zsync die Erneute Übertragung von lokal bereits vorhandenen identischen Abschnitten in den Dateien unterdrücken wird um statt dessen diese Daten aus den lokal vorhandenen älteren Versionen in die downloadende Zieldatei zu kopieren.
ztex-bmp-20120314-2/science/raspbian: The "Babel Macro Processor" provides the "bmp" utility, which is very similar to the C standard macro processor "cpp". The program is written in FreePASCAL and statically linked. It has a size of around 150 kB (armhf). It supports 2 input modes, "PACAL" (default) and "C". Only the utility options are covered in the man page, no local documentation about the macro language itself is installed. Only a reference to an online Wiki is given. Reviewing the Wiki revealed that this is basically a remake of the the C macro processor for PASCAL. It even has similar syntax as "cpp", but there are also some differences. It is nowhere as powerful as "m4". Seems to be a rather pointless utility if a real "cpp" is already available as part of a C compiler installation.
zynaddsubfx-2.2.1-r2/media-sound/gentoo {audio}{music}: Ein polyphoner und mikrotonaler Realtime Software-MIDI-Synthesizer mit ALSA und OSS Support. Wenn man das Hauptprogramm startet, erzeugt es einen virtuellen MIDI-Output-Port, wohin dann jedes ALSA/OSS MIDI-fähige Programm MIDI-Events schicken kann, welcher der Software-Synthesizer dann ausgibt. JACK-Support ist optional möglich wenn man die Ausgabe weiter mischen will. Ein GUI zum Editieren aller Settings sowie Bearbeiten von Patches und Banks samt virtuellem Keyboard ist vorhanden; braucht aber nicht gestartet zu werden wenn man das Ding nur als reines MIDI-Output-Device verwenden will. Das GUI sieht auch sehr nette aus, hat nur einen Haken: Es basiert auf dem veralteten FLTK-1, die meisten Fenster haben eine fixe Größe und passen nicht mit den verwendeten Default-Fonts zusammen. Weiters ließ sich das Ding nicht ohne JACK-Server starten, obwohl ich extra einen Command-Line-Switch angegeben hatte dass ich den JACK-Support nicht aktivieren will. Irgendwie ein sehr toll wirkendes Programm, das leider an der praktischen Umsetzung des GUI scheitert. Die unpassenden Fonts kann man vielleicht mit irgendwelchen config-Settings beheben, doch die nicht anpassbaren Fenstergrößen sind ein echtes Ärgernis welche den Spaß am Programm verleiden. Als reines virtuelles Ausgabegerät ist es vielleicht brauchbar da es laut eigener Aussage weniger fetten Code haben soll als andere Software-Synthesizer.
