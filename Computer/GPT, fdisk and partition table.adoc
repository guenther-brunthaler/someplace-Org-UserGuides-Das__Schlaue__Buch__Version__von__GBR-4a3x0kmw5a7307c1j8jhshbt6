GPT (GUID Partition Table)
==========================
v2025.234


Partition-Typen
---------------

----
024DEE41-33E7-11D3-9D69-0008C781F39F "MBR partition scheme" (MBR disk image für VMs)
07041C10-2471-11EB-80C5-001999FDCDD9 stand-alone dm-integrity (privater non-Standard)
0FC63DAF-8483-4772-8E79-3D69D8477DE4 Linux filesystem (z. B. "ext4")
21686148-6449-6E6F-744E-656564454649 "BIOS boot" für z. B. Stage 1.5 Loader von GRUB
420B95EE-246D-11EB-90DA-001999FDCDD9 Protective MBR Backup (manually)
7FFEC5C9-2D00-49B7-8941-3EA10A5586B7 "dm-crypt", etwa für encrypted swap
80A29844-F5E3-11E3-B1C1-B827EB896DB5 TrivialFS (textbasiert)
97FD874C-2471-11EB-BF72-001999FDCDD9 Partition-Kommentare (privater non-Standard)
BC13C2FF-59E6-4262-A352-B275FD6F7172 "Linux extended boot" für /boot
C12A7328-F81F-11D2-BA4B-00A0C93EC93B "EFI System" Partition (ESP)
CA7D7CCB-63ED-4C53-861C-1742536059CC LUKS, etwa für encrypted LVM PV
E6D6D379-F507-44C2-A23C-238F2A3DF928 "Linux LVM" (LVM2 "Physical Volume")
E7927CBA-E311-11EE-88CE-DCA632491A1D Anti-Forensic Information Splitter (privater non-Standard)
E9E0D43A-E311-11EE-B11F-DCA632491A1D Anti-Forensic Information Splitter Backup (privater non-Standard)
----


GPT-Eintragszahl
----------------

Per Default hat eine GPT immer 128 Einträge. Das ist im Normalfall viel zu viel.

Empfehlung: Die GPT nach dem Anlegen auf eine Größe von 24 GPT-Einträge reduzieren (mit "`l`" in Expertenmodus von `fdisk`) so auf diese Anzahl festlegen.)

4 GPT-Einträge passen in einen 512-Byte-Sektor, d. h. dies belegt 6 Sektoren. Zusammen mit dem Boot Sector und dem GPT Header Sektor sind dies daher 8 Sektoren, oder exakt die 4 KiB welche ein physischer Sektor bei modernen Disks groß ist.

Am Ende der Disk wird ebenfalls ein solcher Sektor fürs GPT-Backup eingerichtet. Diese GPT kostet daher nur 2 physische Sektoren, einen am Anfang und eine am Ende. Das erlaubt optimales Alignment aller Partitons (an 4 KiB-Grenzen ausgerichtet).

Hinweis: Das GPT-Backup ist nur 7 Stück 512-Byte-Sektoren groß, da der Boot Sektor nicht eigentlicher Bestandteil der GPT ist, und daher auch nicht gebackupt wird. Der letzte 512-Byte Sektor im partionierbaren Bereich beginnt daher zwar an einer 4096-Byte Grenze, ist jedoch nur 512 Bytes groß. Man sollte diesen Sektor daher am besten unbenutzt lassen. Oder man richtet eine Mini-Partition dort ein, welche ein (manuelle erstelltes) Backup des Boot-Sektors aufnehmen soll.


GPT Header
---------

Der GPT Header beginnt auf LBA # 1. Er folgt dem Protective MBR auf LBA # 0 nach.

Interessante Felder (unvollständige Auflistung) sind:

[options="header,autowidth"]
|===
| Offset | Länge | Bedeutung
|   0x00 |  0x08 | Signature ("EFI PART")
|   0x28 |  0x08 | First usable LBA (first PT LBA + 1)
|   0x30 |  0x08 | Last usable LBA (second PT LBA - 1)
|   0x38 |  0x10 | Disk GUID
|   0x48 |  0x08 | Starting LBA of array of partition entries (usually 2) 
|   0x50 |  0x04 | Number of partition entries in array
|   0x54 |  0x04 | Size of a single partition entry (usually 80h or 128) 
|===

Alle Werte verwenden Little Endian Byte Order.


GPT Entry
---------

Jeder GPT Eintrat ist 128 Bytes lang. Der erste Eintrag der GPT beginnt auf LBA # 2.

[options="header,autowidth"]
|===
| Offset | Länge | Bedeutung
| 0x00   | 0x10  | Type GUID
| 0x10   | 0x10  | GUID
| 0x20   | 0x08  | First LBA
| 0x28   | 0x08  | Last LBA
| 0x30   | 0x08  | Attribute flags
| 0x38   | 0x48  | Name (36 Zeichen)
|===

Alle Werte verwenden Little Endian Byte Order. Die Zeichen im Namensfeld sind als UTF-16LE codiert.


GPT-Attribute Flags
-------------------

[options="header,autowidth"]
|===
|     Bit | Name | Bedeutung
|       0 | Required Partition   | Für die Plattform erforderlich, z. B. OEM Partition
|       1 | No Block IO Protocol | EFI soll diese Partition komplett ignorieren und nicht einmal lesen/proben
|       2 | Legacy BIOS bootable | MBR soll auf dieser Partition weiter booten
|  3 - 47 | Reserviert
| 48 - 63 | Bedeutung vom Partition-Typ abhängig
|===


Bootloader
----------


GRUB2
~~~~~

GRUB2 installiert seine Stage 1.5 normalerweise automatisch in die ESP (auf UEFI-Systemen) oder in die "BIOS Boot" Partition (non-UEFI Systeme). Sie wird anhand ihrer Typ-UUID als solche erkannt.

Angeblich ignoriert `grub-install` diese "BIOS Boot" Partition jedoch wenn die GRUB2 Stage 1 bereits in den MBR installiert wurde. (Möglicherweise kann `grub-install --recheck` hier helfen. Außerdem gibt es neuerdings ein `grub-bios-setup` utility von GRUB2.)

Seinen Stage-1 Loader installiert er normalerweise in den GPT Boot Sector. Jedoch kann dieser auch in den Bootsektor einer anderen Partition installiert werden (etwa auf /boot wenn dies eine normale Partition ist). In diesem Fall muss die Partition wo die Stage-1 installiert wurde entweder mit dem `LegacyBIOSBootable` Flag markiert sein (im Falle einer GPT), oder als "aktiv" markiert sein (im Falle einr MBR-PT). In allen Fällen außer dem ersten muss im GPT Boot Sector dann ein generischer Bootsektor-Code (wie +<<extlinux,gptmbr.bin>>+) installiert werden, welche dem MBR-Bootvorgang von dort auf den Stage-1 Loader weiterleitet.

Sein Stage-2 Loader kann dann die restlichen GRUB2-Module bereits aus einem regulären Dateisystem loaden.

Es sei darauf hingewiesen, dass das Markieren als "aktiv" bzw. `LegacyBIOSBootable` nicht erforderlich ist wenn die Stage-1 im MBR oder GPT-Bootsektor installiert wurde.

Es ist auch nicht möglich, die Stage-1 zusammen mit der Stage 1.5 in die BIOS Boot Partition (oder in die Lücke zwischen MBR und 1. Partition) zu installieren. Nur die Stage 1.5 kann dort hin installiert werden. Die Stage-1 muss wo anders hin installiert werden.

Am Raspberry Pi ist das "aktiv"-Markieren ebenfalls unnötig. Dieser bootet *immer* von der ersten MBR-Partition. Wenn man einen anderen PT-Eintrag als den 1. booten möchte, muss man manuell die Einträge in der MBR-PT vertauschen so dass die gewünschte Boot-Partition im 1. der 4 PT-Slots zu liegen kommt.


"BIOS Boot" Partition
~~~~~~~~~~~~~~~~~~~~~

Diese Partition in einer GPT wird nur dann verwendet wenn vom MBR anstatt via ESP gebootet wird. Sie ersetzt für GPT-Disks jenen Speicherbereich welcher bei MBR-Disks von der "Lücke" zwischen MBR und 1. Partition gebildet wird.

Angeblich kann man diese BIOS Boot Partition auf 3 Arten als solche kennzeichnen:

* fdisk: `BIOS boot` als Partition-Typ festlegen.
* gisk: Code `ef02` als Partition-Typ festlegen.
* parted: Das Flag `bios_grub` für die Partition setzen/aktivieren.

Dieses angebliche `bios_grub`-Flag ist jedoch eine reine Erfindung von `parted`. Es gibt kein GPT Entry Attribute Flag dafür. Statt dessen setzt `parted` dabei einfach die Typ GUID auf `{21686148-6449-6E6F-744E-656564454649}`.


[[extlinux]]
Extlinux
~~~~~~~~

Hier gibt man als Installationsziel ein Verzeichnis an, welches beim Booten als Defaultverzeichnis für alle Pfadangaben in den Konfigurationsdateien dient.

Extlinux installiert seinen Stage-1 Loader allerdings nicht direkt in den GPT Boot Sector, sondern auf den ersten Sektor der Partition in der sich das Installations-Zielverzeichnis befindet.

In diesem Fall muss man den von extlinux mitgelieferten Boot-Code `gptmbr.bin` an den Anfang der Disk schreiben, und danach mit fdisk die Partition auf welche extlinux installiert wurde editieren um dort die Markierung "LegacyBIOSBootable" zu setzen.

Anhand dieser Markierung erkennt der Code aus gptmbr.bin auf welcher Partition der eigentliche Boot-Code liegt, und lädt diesen dann sowie springt ihn danach an.


Empfohlenes Disk-Layout
-----------------------


Allgemein
~~~~~~~~~

. Anti-Forensic Information splitter (AFIS) area for master key storage, around 9 MiB in size.
. LVM2 Volume Group (includes /boot, Swap, Main System)
. EFI System Partition (optional)
. BIOS boot Partition (optional), 1 MiB, Partition-UUID gemäß diesem Typ, Attribut `LegacyBIOSBootable`
. Backup of AFIS area, around same size as original.


Für GPT-Disks
~~~~~~~~~~~~~

. GPT Boot Sector: GRUB2 Stage 1
. Anti-Forensic Information Splitter (optional)
. `vg_n0myhost` (includes `/boot`)
. EFI System (ESP)
. BIOS boot (1 MiB, GRUB2 Stage 1.5), Attribut `LegacyBIOSBootable`
. Backup AFI Splitter (optional)

Im 'Protective MBR' bzw. GPT Boot Sector sollte der GRUB2 installiert werden. Das installiert seine Stage 1 dorthin. Die Stage 1.5 wird automatisch in die BIOS Boot Partition installiert.

Die BIOS Boot Partition sollte die zugehörige Typ-UUID gesetzt haben. Das Attribut `LegacyBIOSBootable` sollte hingegen *nicht* gesetzt sein.


Für MBR-Disks
~~~~~~~~~~~~~

. MBR Sector: GRUB2 Stage 1
. Gap between MBR and first partition: GRUB2 Stage 1.5, Minimum 1000 MiB
. Anti-Forensic Information Splitter (optional)
. `vg_n0myhost` (includes `/boot`)
. Backup AFI Splitter (optional)


Spezialfall Raspberry Pi
~~~~~~~~~~~~~~~~~~~~~~~~

. Anti-Forensic Information Splitter (optional)
. `vg_n0myhost` (LVM2 PV + VG, MBR Partition Type ID `0x8e`)
. `/boot/firmware` (MBR Partition Type ID `0x0e`, marked "active")
. Backup AFI Splitter (optional)

"`vg_n0myhost`" enthält auch ein LV namens "`swap-enc`" mit 8 oder 16 GiB Größe am Ende.

"`/boot/firmware`" ist als VFAT mit einer 16-Bit FAT formatiert.

"`/boot`" ist Teil von "`/`" und kein separates LV.

"`/`" existiert typischerweise als LV in einer verschachtelten VG "`vg_myhost`" in einem verschlüsselten PV "`/dev/mapper/pv-myhost-level0-dec`" welches innerhalb von "`vg_n0myhost`" als LV "`pv_e0myhost-enc`" enthalten ist.

Nach dem Partitionieren mit

----
$ d=/dev/disk/by-id/... # SD/SDXC Card to be partitioned.
$ fdisk -u "${d:?}"
----

muss die Partition Table manuell im Hex-Editor bearbeitet werden

----
$ hexedit -s "${d:?}"
----

und die Einträge der 1. und 2. Partition müssen vertauscht werden. (Es gibt 4 Einträge, jeder ist 0x10 Bytes lang, der letzte Eintrag endet genau vor den letzten beiden Bytes im Sektor welche 0x55 und 0xAA sein müssen. `hexedit` hat zwar keinen Befehl zum Vertauschen von Bereichen. Aber man kann mit dem Kopieren in einen ungenutzten Bereich des Sektors welcher nur Nullen enthält eine Temporärkopie eines Bereichs anlegen und den Rest durch Kopieren erledigen. Die Temporärkopie kann danach wieder mit Nullen gefüllt werden. Fürs Überschreiben eines Bereichs mit einem Bytewert besitzt der `hexedit` einen Befehl.)

Denn der ROM-Bootloader das RPi erfordert dass die Firmware Boot Partition die 1. Partition sein muss. Nach dem obigen Layout wäre es allerdings die 2. Partition. Durch das Vertauschen der Partition-Table Einträge wird dies behoben. Nach dem Speichern der Änderungen muss

----
$ blockdev --rereadpt "${d:?}"
----

aufgerufen werden, 

Sollte die Partition Table später jemals wieder mit `fdisk` editiert werden, gibt es in den "Expert Commands" eine Option um die Reihenfolge der Partition Table wieder der Reihenfolge am Blockgerät anzupassen, bevor die eigentlichen Bearbeitungen durchgeführt werden. Nach dem Speichern dieser Änderungen müssen dann erneut die zuvor beschriebenen Schritte durchgeführt werden, um sicher zu stellen dass die "`/boot/firmware`" Partition den ersten Eintrag der Partition-Table darstellt.


Anmerkungen
~~~~~~~~~~~

* Die anti-forensischen Partitionen kann man sich ersparen, wenn man das alte LUKS-1 Format anstatt dem neuen LUKS-2 Format verwendet. LUKS-1 hatte noch einen Anti-forensischen Information Splitter eingebaut.

* Alle Strukturen (LBA Sektornummern) zumindest an 8 KiB Grenzen ausrichten. Ausgenommen davon ist eine Partition deren Ende exakt an das GPT Backup grenzt. Deren Ende (nicht aber deren Anfang) kann beliebig ausgerichtet sein. Oder man lässt eine ungenutzte Lücke minimaler Größe für den Bereich dessen Ende nicht exakt ausgerichtet werden kann.

* Performance-kritische strukturen (LBA Sektornummern) am 1 MiB Grenzen ausrichten.

* Die AFIS Area und ihr Backup sind normale Linux Dateisysteme. Empfohlen ist ext4 ohne Journal und mit einer 4 KiB block size (`mkfs.ext4 -O '^has_journal' -b 4k`).


Beispiel
~~~~~~~~

----
$ fdisk -lo Device,Start,Size,Attrs,Name /dev/sda
...
Device          Start  Size Attrs              Name
/dev/sda1           8    9M                    Anti-Forensic Information Splitter
/dev/sda2       18432  2,7T                    vg_n0myhost
/dev/sda3  5859284992  600M LegacyBIOSBootable /boot (host myhost)
/dev/sda4  5860513792  9,5M                    Backup AFI Splitter
----

Die Namen der Partitions können bis zu 36 UTF-16LE Zeichen lang sein. (Die Disk selbst als Ganzes hat keinen Namen sondern nur eine UUID.)

Die `vg_n0myhost`-Partition im obigen Beispiel dient als LVM2 physical volume. Das "`n`" im Namen steht dabei für "Nesting-Level". In dieser VG befindet sich der eigentliche Disk-Inhalt als Logical Volumes, mit etwaigen Swap-Volumes (typischer LV-Name "swap") als letztes.

Der "eigentliche Inhalt" kann entweder ein unverschlüsseltes LVM PV sein (`vg_n1myhost`).

Oder es ist ein "dmintegrity"-Layer (typischer LV-Name "integrity") mit unverschlüsseltem LVM PV (`vg_n1myhost`) darin.

IMPORTANT: "dmintegrity" unterstützt kein SATA TRIM bzw "discard". Es ist daher ungünstig auf SSDs und sollte nur bei Festplatten verwendet werden.

In beiden Fällen gibt ist das unverschlüsselte `vg_n1myhost` eine VG für die verschiedenen verschlüsselten (FDE-Äquivalent) oder unverschlüsselten Bereiche der Festplatte (etwa für Recovery Images und dergleichen).

Typische LVs innerhalb von `vg_n1myhost` sind: `level0-enc`, `level1-enc`, `level2-enc`.

Verschlüsselte Bereiche enthalten ebenfalls LVM2 PVs mit VGs darin, die dann Namen wie `vg_e1myhost` für Level-1 Encryption tragen. Das "`e`" steht für "Encryption-Level".

So könnte z. B. das entschlüsselte Blockgerät `level0-enc` die LVM2 Volume Group `vg_myhost` enthalten, das entschlüsselte `level1-enc` könnte `vg_e1myhost` enthalten, und das entschlüsselte `level2-enc` könnte `vg_e2myhost` enthalten.

Level-0 Encryption ist der Default. Der größte Teil des Systems wie `/usr` und `/var` und meist auch `/home` befinden sich in diesem Level.

Level-1 ist stärker verschlüsselt als Level-0, und Level-2 ist noch stärker als Level-1 verschlüsselt. Ob zusätzliche Levels zu Level-0 überhaupt erforderlich sind, ist Ermessens-Sache.

Der FDE-Hauptbereich (also Level-0) würde dem zufolge eigentlich `vg_e0myhost` heißen, wird aber tatsächlich einfach nur `vg_myhost` genannt da er am meisten benutzt wird und das "normale System" darstellen soll.

Beispiele:

....
/dev/vg_n0myhost/pv_e1myhost-enc 15g (contains vg_e1myhost)
/dev/vg_n0myhost/pv_e2myhost-enc 240m (contains vg_e2myhost)
/dev/vg_n0myhost/pv_e0myhost-enc 215g (contains vg_myhost)
/dev/vg_n0myhost/swap-enc 8g (level-5 encrypted with random keys)
/dev/vg_myhost/main-fsroot 1g
/dev/vg_myhost/main-usr_local 1g
/dev/vg_myhost/main-srv 1g
/dev/vg_myhost/main-var 14g
/dev/vg_myhost/main-usr 32g
/dev/vg_myhost/ai_models 25g
/dev/vg_myhost/home 40g
/dev/vg_myhost/multimedia 100g
/dev/vg_e1myhost/level1 16g (contains level-1 encrypted files)
/dev/vg_e2myhost/level2 240m (contains level-2 encrypted files)
....

Ausrichtung an Hardware-Sektorgrenzen
-------------------------------------

Siehe link:mbr.html#alignment[Alignment]
